<Type Name="Type" FullName="System.Type">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c9d0cd38262ec08b9e5f4fb5d5b18c32257a7b1a" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55320417" /></Metadata><TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje typ deklaracji: klasy, typy, typy interfejsów, typy tablicowe, typy wartości, Typy wyliczeniowe, parametry typu, definicji typu ogólnego i otwarte lub zamknięte typy rodzajowe utworzone.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Type` jest katalogiem głównym <xref:System.Reflection> funkcji i jest to podstawowy sposób dostępu do metadanych. Użyj elementów członkowskich <xref:System.Type> Aby uzyskać informacje na temat deklaracji typu, na temat elementów członkowskich typu (na przykład konstruktorów, metody, pola, właściwości i zdarzenia w klasie), a także moduł i zestawu, w której jest wdrażany klasy.  
  
 Nie uprawnienia są wymagane dla kodu używać odbicia, aby uzyskać informacje na temat typów i ich członków, niezależnie od ich poziomy dostępu. Nie uprawnienia są wymagane dla kodu dostępu publiczne elementy Członkowskie lub innych członków, w których poziomy dostępu będzie stały się widoczne podczas normalnej kompilacji przy użyciu odbicia. Jednak aby używać odbicia do dostępu do elementów członkowskich, które zwykle będzie niedostępny, takie jak metody prywatne lub wewnętrzne lub objęte ochroną pól typu kodu, klasa nie dziedziczy, kod musi mieć <xref:System.Security.Permissions.ReflectionPermission>. Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).  
  
 `Type` jest abstrakcyjna klasa bazowa, która zezwala na wiele implementacji. System będzie zawsze podawać klasy pochodnej `RuntimeType`. W odbiciu wszystkie klasy, począwszy od programu word środowiska uruchomieniowego są tworzone tylko raz dla każdego obiektu w operacjach porównania systemu i pomocy technicznej.  
  
> [!NOTE]
>  W scenariuszach wielowątkowość nie blokuj <xref:System.Type> obiektów w celu synchronizowania dostępu do `static` danych. Inny kod, nad którym masz żadnej kontroli, może również zablokować typu klasy. Może to spowodować zakleszczenia. Zamiast tego należy zsynchronizować dostęp do danych statycznych blokując prywatnej `static` obiektu.  
  
> [!NOTE]
>  Klasa pochodna mają dostęp do chronionych składowych klas bazowych kodu wywołującego. Ponadto jest dozwolony dostęp do zestawu elementów członkowskich zestawu kodu wywołującego. Zgodnie z zasadą Jeśli możesz uzyskać dostęp w kodzie z wczesnym wiązaniem, następnie również możesz dostęp w kodzie z późnym wiązaniem.  
  
> [!NOTE]
>  Interfejsy, które rozszerzają inne interfejsy nie dziedziczą metody zdefiniowane w rozszerzonych interfejsów.  
  
 W tej sekcji:  
  
 [Jakie typy reprezentuje obiekt typu?](#WhatTypes)   
 [Pobieranie obiektu typu](#Retrieve)   
 [Porównywanie obiektów typu pod kątem równości](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>Jakie typy reprezentuje obiekt typu?  
 Ta klasa jest bezpieczny wątkowo; wiele wątków jednocześnie może odczytywać dane z wystąpienia tego typu. Wystąpienie <xref:System.Type> klasa może reprezentować dowolny z następujących typów:  
  
-   Klasy  
  
-   Typy wartości  
  
-   Tablice  
  
-   Interfejsy  
  
-   Wyliczenia  
  
-   Delegaty  
  
-   Zbudowany typy ogólne i definicji typu ogólnego  
  
-   Argumenty typu, a następnie wpisz parametry typów ogólnych skonstruowany, definicji typu ogólnego i definicji metody ogólnej  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>Pobieranie obiektu typu  
 <xref:System.Type> Obiekt skojarzony z określonym typem można uzyskać w następujący sposób:  
  
-   Wystąpienie <xref:System.Object.GetType%2A?displayProperty=nameWithType> metoda zwraca <xref:System.Type> obiekt, który reprezentuje typ wystąpienia. Ponieważ wszystkie zarządzane typy wyprowadzono z klasy <xref:System.Object>, <xref:System.Object.GetType%2A> metoda może być wywołana w wystąpieniu dowolnego typu.  
  
     Poniższy przykład wywołuje <xref:System.Object.GetType%2A?displayProperty=nameWithType> metodę pozwala ustalić typ środowiska uruchomieniowego dla poszczególnych obiektów w tablicy obiektu.  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   Statyczne <xref:System.Type.GetType%2A?displayProperty=nameWithType> metody zwracają <xref:System.Type> obiekt, który reprezentuje typ określony przez jego w pełni kwalifikowana nazwa.  
  
-   <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, I <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> metody zwracają `Type` obiektami, które reprezentują typy zdefiniowane w module. Pierwsza metoda może służyć do uzyskiwania tablicę <xref:System.Type> obiektów dla wszystkich typów publicznych i prywatnych zdefiniowany w module. (Można uzyskać wystąpienia `Module` za pośrednictwem <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> metodę, lub za pomocą <xref:System.Type.Module%2A?displayProperty=nameWithType> właściwości.)  
  
-   <xref:System.Reflection.Assembly?displayProperty=nameWithType> Obiekt zawiera wiele metod, które można pobrać klas zdefiniowanych w zestawie, w tym <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, i <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.  
  
-   <xref:System.Type.FindInterfaces%2A> Metoda zwraca filtrowana lista typów interfejsów, obsługiwany przez typ.  
  
-   <xref:System.Type.GetElementType%2A> Metoda zwraca `Type` obiekt, który reprezentuje element.  
  
-   <xref:System.Type.GetInterfaces%2A> i <xref:System.Type.GetInterface%2A> metody zwracają <xref:System.Type> obiektów reprezentujących typy interfejsów, obsługiwany przez typ.  
  
-   <xref:System.Type.GetTypeArray%2A> Metoda zwraca tablicę <xref:System.Type> obiektów reprezentujących typy określone przez dowolny zestaw obiektów. Obiekty są określane za pomocą tablicy typu <xref:System.Object>.  
  
-   <xref:System.Type.GetTypeFromProgID%2A> i <xref:System.Type.GetTypeFromCLSID%2A> metody są dostarczane dla współdziałania COM. Zwracają <xref:System.Type> obiekt, który reprezentuje typ określony przez `ProgID` lub `CLSID`.  
  
-   <xref:System.Type.GetTypeFromHandle%2A> Metoda towarzyszy współdziałania. Zwraca `Type` obiekt, który reprezentuje typu określonego przez dojście do klasy.  
  
-   C# `typeof` operatora C++ `typeid` operator i Visual Basic `GetType` uzyskać operator `Type` obiektu dla typu.  
  
-   <xref:System.Type.MakeGenericType%2A> Metoda zwraca <xref:System.Type> obiekt reprezentuje zbudowany typ ogólny, który jest zbudowany typu otwartego, jeśli jego <xref:System.Type.ContainsGenericParameters%2A> właściwość zwraca `true`, i zamkniętej skonstruowany typ inaczej. Mogą można utworzyć wystąpienia typu ogólnego, tylko wtedy, gdy jest ono zamknięte.  
  
-   <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, I <xref:System.Type.MakeByRefType%2A> metody zwracają <xref:System.Type> obiektami, które reprezentują odpowiednio tablicę określonego typu, wskaźnik do określonego typu, a typem parametru odwołania (`ref` w języku C# `ByRef`w języku Visual Basic).  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>Porównywanie obiektów typu pod kątem równości  
 A <xref:System.Type> obiekt reprezentuje typ to unikatowy, czyli dwa <xref:System.Type> odwołania do obiektu odnoszą się do tego samego obiektu, tylko wtedy, gdy reprezentują tego samego typu. Dzięki temu porównanie <xref:System.Type> obiektów przy użyciu równości odwołań. W poniższym przykładzie porównano <xref:System.Type> obiektami, które reprezentują liczbę liczb całkowitych, aby ustalić, czy są one tego samego typu.  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano kilka funkcji reprezentatywny <xref:System.Type>. C# `typeof` — operator (`GetType` operatora w języku Visual Basic `typeid` operator w programie Visual C++) służy do uzyskiwania <xref:System.Type> obiekt reprezentujący <xref:System.String>. Z tego <xref:System.Type> obiektu <xref:System.Type.GetMethod%2A> metoda jest używana do pobierania <xref:System.Reflection.MethodInfo> reprezentujący <xref:System.String.Substring%2A> przeciążenia przyjmującego lokalizację początkową i długość.  
  
 Aby zidentyfikować sygnatura przeciążenia, przykład kodu tworzy tablicę tymczasową, zawierający dwie <xref:System.Type> obiekty reprezentujące `int` (`Integer` w języku Visual Basic).  
  
> [!NOTE]
>  Ściślej mówiąc, tablica zawiera dwa odwołania do wystąpienia <xref:System.Type> reprezentujący `int` w bieżącej domenie aplikacji. Dla dowolnego typu, jest tylko jedno wystąpienie <xref:System.Type> dla domeny aplikacji.  
  
 Przykład kodu wykorzystuje <xref:System.Reflection.MethodInfo> do wywołania <xref:System.String.Substring%2A> metody na ciąg "Hello, World!" i wyświetla wynik.  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <block subset="none" type="overrides"><para>Przy dziedziczeniu z <see langword="Type" />, konieczne jest przesłonięcie następujących składowych: 
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para></block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="~/docs/framework/reflection-and-codedom/viewing-type-information.md">Wyświetlanie informacji o typie</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Type" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływany przez klasy pochodne podczas konstruowania obiektów typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Reflection.Assembly" /> w którym zadeklarowano typu. Dla typów ogólnych pobiera <see cref="T:System.Reflection.Assembly" /> w jest definicja typu ogólnego.</summary>
        <value><see cref="T:System.Reflection.Assembly" /> Wystąpienia, który opisuje zestawu zawierającego bieżącego typu. Dla typów ogólnych wystąpienia w tym artykule opisano zestaw, który zawiera definicję typu ogólnego, nie zestawu, który tworzy i używa określonego skonstruowanego typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> obiekt reprezentuje zbudowany typ ogólny, właściwość ta zwraca zestaw, który zawiera definicję typu ogólnego. Załóżmy na przykład, możesz utworzyć zestaw o nazwie MyGenerics.dll, który zawiera definicję typu ogólnego `MyGenericStack<T>` (`MyGenericStack(Of T)` w języku Visual Basic `generic<T> ref class MyGenericStack` w języku C++). Jeśli utworzysz wystąpienie `MyGenericStack<int>` (`MyGenericStack(Of Integer)` w języku Visual Basic) w innym zestawie <xref:System.Type.Assembly%2A> zwraca właściwości dla skonstruowanego typu <xref:System.Reflection.Assembly> obiekt, który reprezentuje MyGenerics.dll.  
  
 Podobnie jeśli bieżący <xref:System.Type> obiekt reprezentuje nieprzypisanego parametru ogólnego `T`, właściwość ta zwraca zestaw, który zawiera typ ogólny, który definiuje `T`.  
  
 Jeśli <xref:System.Type.Assembly%2A?displayProperty=nameWithType> właściwość nie jest dostępna na określonej implementacji .NET, takich jak .NET Core i platformy uniwersalnej Windows, należy użyć <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> właściwości zamiast tego.      
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład wyświetla nazwę zestawu, skojarzony z klasą i w pełni kwalifikowaną nazwę typu.  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kwalifikowaną dla zestawu nazwę typu, który zawiera nazwę zestawu, z którego należy to <see cref="T:System.Type" /> obiekt został załadowany.</summary>
        <value>Nazwa kwalifikowanego dla zestawu <see cref="T:System.Type" />, który zawiera nazwę zestawu, z którego <see cref="T:System.Type" /> został załadowany, lub <see langword="null" /> Jeśli bieżące wystąpienie reprezentuje parametr typu ogólnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwa kwalifikowanego dla zestawu typu składa się z nazwą typu, łącznie z jego przestrzeń nazw i przecinek, a następnie według nazwy wyświetlanej zestawu. Nazwa wyświetlana zestawu są uzyskiwane przy użyciu <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> właściwości.  
  
> [!NOTE]
>  W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw. Na przykład "ProcessorArchitecture = msil". Jednak nie są uwzględnione w ciągu zwracanego przez <xref:System.Type.AssemblyQualifiedName%2A> właściwość ze względu na zgodność. Zobacz <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 Wszystkie kompilatory, które obsługują środowiska uruchomieniowego języka wspólnego emitować prostą nazwę klasy zagnieżdżonej, a odbicie zniekształcone nazwy, po otrzymaniu kwerendy, zgodnie z następujących konwencji.  
  
|Ogranicznik|Znaczenie|  
|---------------|-------------|  
|Ukośnik odwrotny (\\)|Znak ucieczki.|  
|Przecinek (,)|Poprzedza nazwę zestawu.|  
|Znak plus (+)|Poprzedza klasę zagnieżdżoną.|  
|Kropka (.)|Wskazuje przestrzeń nazw identyfikatorów.|  
|Nawiasy kwadratowe ([])|Po nazwie typu wskazuje, że tablicy tego typu.<br /><br /> —lub—<br /><br /> Dla typu ogólnego otacza listy argumentów typu rodzajowego.<br /><br /> —lub—<br /><br /> Na liście argumentów typu otacza typu kwalifikowanego zestawu.|  
  
 Na przykład nazwa kwalifikowanego dla zestawu dla klasy może wyglądać następująco:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 Jeśli przestrzeń nazw zawiera znak plus, na przykład TopNamespace.Sub+Namespace, a następnie znak plus (+) może być poprzedzony znakiem ucieczki (\\), aby zapobiec interpretacji jako separator zagnieżdżenia. Ten ciąg będzie emisji odbicia w następujący sposób:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 A "++" staje się "\\+\\+", a "\\"staje się"\\\\".  
  
 Ta nazwa kwalifikowana może utrwalona i później używana do ładowania <xref:System.Type>. Aby wyszukać i załadować <xref:System.Type>, użyj <xref:System.Type.GetType%2A> albo z typem nazwy tylko lub nazwą kwalifikowaną typu zestawu. <xref:System.Type.GetType%2A> z typem nazwy tylko będzie szukać <xref:System.Type> w zestawie wywołującego, a następnie w zestawie systemowym. <xref:System.Type.GetType%2A> z zestawem kwalifikowanej nazwy typu będzie szukać <xref:System.Type> w każdym zestawie.  
  
 Nazwy typów mogą obejmować końcowe znaki, które wyznaczają dodatkowe informacje dotyczące typu, na przykład to, czy typ jest typem odwołania, typem wskaźnika lub typem tablicowym. Aby pobrać, wpisz nazwę bez tych znaków końcowych, należy użyć `t.GetElementType().ToString()`, gdzie `t` jest typem.  
  
 Spacje są istotne we wszystkich składnikach nazwy z wyjątkiem nazwy zestawu. Spacje przed separatorem w nazwie zestawu ',' są istotne, ale spacje po separatorze ',' są ignorowane.  
  
 Argumenty ogólne typów ogólnych są kwalifikowane przez nazwę zestawu. Na przykład w nazwie typu kwalifikowanego zestawu `MyGenericClass<int>` (`MyGenericClass(Of Integer)` w języku Visual Basic), `int` podzielonego na nazwę typu kwalifikowanego zestawu <xref:System.Int32>.  
  
 Jeśli bieżący <xref:System.Type> obiekt reprezentuje parametr ogólny, właściwość ta zwraca `null`.  
  
   
  
## Examples  
 Poniższy przykład wyświetla nazwę zestawu, skojarzony z klasą i w pełni kwalifikowaną nazwę typu.  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 W poniższym przykładzie porównano ciągów zwracanych przez <xref:System.Type.ToString%2A> metody i `Name`, <xref:System.Type.FullName%2A>, i <xref:System.Type.AssemblyQualifiedName%2A> właściwości.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Określanie w pełni kwalifikowanych nazw typów</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera atrybuty skojarzone z <see cref="T:System.Type" />.</summary>
        <value>A <see cref="T:System.Reflection.TypeAttributes" /> obiekt reprezentujący zestaw atrybutów <see cref="T:System.Type" />, chyba że <see cref="T:System.Type" /> reprezentuje parametr typu ogólnego, w której wartość jest nieokreślony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektórzy członkowie <xref:System.Reflection.TypeAttributes> wyliczenia są masek, które reprezentują grupy wartości. Każda grupa zawiera jeden element członkowski, którego podstawową wartość wynosi zero. Na przykład, podstawową wartość <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> elementu członkowskiego w <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> grupy wynosi zero, ponieważ jest <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> elementu członkowskiego w <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> grupy. W związku z tym należy użyć maska przed testowaniem w przypadku tych wartości. Przykład stanowi ilustrację.  
  
> [!TIP]
>  W większości przypadków, właściwości, takie jak <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, i <xref:System.Type.IsSpecialName%2A> są łatwiejsze w obsłudze niż atrybuty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta zwraca atrybuty definicji typu ogólnego. Na przykład, atrybutów, które są zwracane dla `MyGenericClass<int>` (`MyGenericClass(Of Integer)` w języku Visual Basic) są atrybuty `MyGenericClass<T>` (`MyGenericClass(Of T)` w języku Visual Basic).  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego — oznacza to, jeśli <xref:System.Type.IsGenericParameter%2A> właściwość zwraca `true` — <xref:System.Reflection.TypeAttributes> wartość zwracana przez właściwość ta jest nieokreślony.  
  
   
  
## Examples  
 Następujące usesthe przykład <xref:System.Type.Attributes%2A> właściwości.  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ, z którego bieżący <see cref="T:System.Type" /> dziedziczy bezpośrednio.</summary>
        <value><see cref="T:System.Type" /> z którego bieżący <see cref="T:System.Type" /> dziedziczy bezpośrednio, lub <see langword="null" /> Jeśli bieżące <see langword="Type" /> reprezentuje <see cref="T:System.Object" /> klasę lub interfejs.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ podstawowy jest typem, z której dziedziczy bezpośrednio bieżącego typu. <xref:System.Object> jest to jedyny typ, który nie ma typu podstawowego, w związku z tym `null` jest zwracana jako typ bazowy <xref:System.Object>.  
  
 Interfejsy dziedziczyć zero lub więcej podstawowych interfejsów; Ta właściwość zwraca `null` Jeśli `Type` obiekt reprezentuje interfejs. Interfejsy podstawowe można określić za pomocą <xref:System.Type.GetInterfaces%2A> lub <xref:System.Type.FindInterfaces%2A>.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny skonstruowany, typ podstawowy odzwierciedla argumentów rodzajowych. Na przykład należy wziąć pod uwagę następujące deklaracje:  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 Do skonstruowanego typu `C<int>` (`C(Of Integer)` w języku Visual Basic), <xref:System.Type.BaseType%2A> właściwość zwraca `B<int>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego, <xref:System.Type.BaseType%2A> zwraca ograniczenia klasy, oznacza to, że parametr typu musi dziedziczyć klasy. Jeśli nie określono ograniczenia klasy <xref:System.Type.BaseType%2A> zwraca <xref:System.Object?displayProperty=nameWithType>.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie <xref:System.Type.BaseType%2A> właściwości.  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 W poniższym przykładzie użyto rekursji, aby wyświetlić listę hierarchii dziedziczenia pełną każda klasa odnaleźć w zestawie. W przykładzie zdefiniowano klasę o nazwie `C` która jest pochodną klasę o nazwie `B`, która z kolei pochodzi od klasy o nazwie `A`.  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy bieżący <see cref="T:System.Type" /> obiekt ma parametry typu, które nie zostały zastąpione przez określone typy.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> sam parametr typu ogólnego lub obiektu ma parametry typu, dla których określonych typów nie zostały podane; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby można było utworzyć wystąpienia typu, musi być nie definicji typu ogólnego lub Otwórz typy utworzone w argumentach typu sam typ, w dowolnym otaczających typów ogólnych lub w dowolnych elementów tego typu. Innym sposobem powiedzenia, to jest że w przypadku badania cyklicznie, typ musi zawierać żadnych parametrów typu ogólnego.  
  
 Ponieważ typy mogą być dowolnie złożone, dzięki czemu oznaczanie jest trudne. Dla wygody i zmniejszyć prawdopodobieństwo wystąpienia błędu <xref:System.Type.ContainsGenericParameters%2A> właściwość udostępnia standardowy sposób odróżnić zamknięte typy utworzone, które mogą być utworzone, i otwórz zbudowane typy, które nie. Jeśli <xref:System.Type.ContainsGenericParameters%2A> właściwość zwraca `true`, nie można utworzyć wystąpienia typu.  
  
 <xref:System.Type.ContainsGenericParameters%2A> Właściwość przeszukiwane rekursywnie dla parametrów typu. Na przykład zwraca `true` tablicy, której elementy są typu `A<T>` (`A(Of T)` w języku Visual Basic), nawet jeśli tablica nie jest sam ogólny. Natomiast to zachowanie <xref:System.Type.IsGenericType%2A> właściwość, która zwraca `false` dla tablic.  
  
 Zbiór przykład klasy i tabelę przedstawiającą wartości <xref:System.Type.ContainsGenericParameters%2A> właściwości, zobacz <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Poniższy przykład definiuje klasę ogólną z dwoma parametrami typu i następnie definiuje klasę ogólną drugi wywodzi się z pierwszej klasy. Klasa podstawowa dla klasy pochodnej ma dwa argumenty typu: pierwszy to <xref:System.Int32> , a drugim parametrem typu w typie pochodnym. W przykładzie są wyświetlane informacje o tych klasach ogólnych, w tym pozycje raportowane przez <xref:System.Type.GenericParameterPosition%2A> właściwości.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Reflection.MethodBase" /> deklarującego metody reprezentująca Jeśli bieżące <see cref="T:System.Type" /> reprezentuje parametr typu metody ogólnej.</summary>
        <value>Jeśli bieżący <see cref="T:System.Type" /> reprezentuje parametr typu metody ogólnej <see cref="T:System.Reflection.MethodBase" /> reprezentująca deklarowania metody; w przeciwnym razie <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda deklarujący jest definicję metody rodzajowej. Oznacza to jeśli <xref:System.Type.DeclaringMethod%2A> nie zwraca `null`, następnie `DeclaringMethod.IsGenericMethodDefinition` zwraca `true`.  
  
 <xref:System.Type.DeclaringType%2A> i <xref:System.Type.DeclaringMethod%2A> właściwości zidentyfikować definicji typu ogólnego lub definicję metody rodzajowej, w której została pierwotnie zdefiniowana parametru typu generycznego:  
  
-   Jeśli <xref:System.Type.DeclaringMethod%2A> właściwość zwraca <xref:System.Reflection.MethodInfo>, które <xref:System.Reflection.MethodInfo> reprezentuje definicję metody rodzajowej, a bieżący <xref:System.Type> obiekt reprezentuje parametr typu tej definicji metody rodzajowej.  
  
-   Jeśli <xref:System.Type.DeclaringMethod%2A> właściwość zwraca `null`, a następnie <xref:System.Type.DeclaringType%2A> właściwość zawsze zwraca <xref:System.Type> obiekt reprezentujący definicji typu ogólnego i bieżący <xref:System.Type> obiekt reprezentuje parametr typu ogólnego typu Definicja.  
  
-   Wprowadzenie <xref:System.Type.DeclaringMethod%2A> właściwość typu którego <xref:System.Type.IsGenericParameter%2A> właściwość `false` zgłasza <xref:System.InvalidOperationException>.  
  
 <xref:System.Reflection.MethodBase> Zwracanym przez <xref:System.Type.DeclaringMethod%2A> właściwości <xref:System.Reflection.MethodInfo> w przypadku metody rodzajowej, lub <xref:System.Reflection.ConstructorInfo> w przypadku ogólnych konstruktora.  
  
> [!NOTE]
>  Ogólny konstruktory nie są obsługiwane w .NET Framework w wersji 2.0.  
  
 Aby uzyskać listę niezmiennych warunków dla terminów używanych w odbiciu rodzajowym, zobacz <xref:System.Type.IsGenericType%2A> uwagi dotyczące właściwości.  
  
   
  
## Examples  
 Poniższy kod definiuje klasę, która zawiera metody rodzajowej, przypisuje argument typu do metody i wywołuje wynikowego skonstruowanego metody rodzajowej. Wyświetla informacje o definicji metody rodzajowej, a także metoda skonstruowany. Podczas wyświetlania informacji na temat parametrów typu definicji metody ogólnej w `DisplayGenericMethodInfo` metody, przykładowy kod pokazuje wartość <xref:System.Type.DeclaringMethod%2A> właściwość, parametru typu ogólnego metody.  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ, który deklaruje bieżącego typu zagnieżdżonego lub parametr typu ogólnego.</summary>
        <value>A <see cref="T:System.Type" /> obiekt reprezentujący otaczający typ, jeśli bieżącym typem jest typ zagnieżdżony; lub definicji typu ogólnego, jeśli bieżącym typem jest parametr typu ogólnego; lub typ, który deklaruje metody rodzajowej, jeśli bieżącym typem jest parametr typu metody ogólnej; w przeciwnym razie <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> obiekt reprezentuje parametr typu metody rodzajowej, właściwość ta zwraca definicji typu ogólnego.  
  
 Jeśli bieżący <xref:System.Type> obiekt reprezentuje parametr typu metody rodzajowej, właściwość ta zwraca typ, który zawiera definicję metody rodzajowej. W przypadku typu ogólnego, definicja typu ogólnego jest zwracana. Oznacza to, poniższy kod zwraca definicji typu rodzajowego <xref:System.Collections.Generic.List%601> klasy ogólnej, który zawiera <xref:System.Collections.Generic.List%601.ConvertAll%2A> metody ogólnej:  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, <xref:System.Type.DeclaringType%2A> i <xref:System.Type.DeclaringMethod%2A> zidentyfikować właściwości w definicji typu ogólnego lub metody rodzajowej definicji, gdzie parametr typu ogólnego została pierwotnie zdefiniowana:  
  
-   Jeśli <xref:System.Type.DeclaringMethod%2A> właściwość zwraca <xref:System.Reflection.MethodInfo>, które <xref:System.Reflection.MethodInfo> reprezentuje definicję metody rodzajowej, a bieżący <xref:System.Type> obiekt reprezentuje parametr typu tej definicji metody rodzajowej.  
  
-   Jeśli <xref:System.Type.DeclaringMethod%2A> właściwość zwraca `null`, a następnie <xref:System.Type.DeclaringType%2A> właściwość zawsze zwraca <xref:System.Type> obiekt reprezentujący definicji typu ogólnego i bieżący <xref:System.Type> obiekt reprezentuje parametr typu ogólnego typu Definicja.  
  
-   Wprowadzenie <xref:System.Type.DeclaringType%2A> właściwość typu którego <xref:System.Type.IsGenericParameter%2A> właściwość `false` zgłasza <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Ten przykład Wyświetla typ deklarujący metody w klasie pochodnej.  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do domyślnego integratora, który implementuje wewnętrzne zasady dotyczące wybierania odpowiednich elementów członkowskich, które ma zostać wywołana przez <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</summary>
        <value>Odwołanie do domyślnego integratora używaną przez system.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślny integrator dołączonym środowiska uruchomieniowego języka wspólnego jest stosowana we wszystkich oprócz najbardziej wyspecjalizowaną okoliczności. Jeśli potrzebujesz integratora definiują reguły poniżej, które różnią się od skoroszytu domyślną dostarczony typ pochodzący od <xref:System.Reflection.Binder> klasy i przekaż wystąpienie tego typu za pomocą `binder` parametr jednego z <xref:System.Type.InvokeMember%2A> przeciążenia.  
  
 Odbicie modeli reguły ułatwień dostępu wspólny system typów. Na przykład jeśli obiekt wywołujący znajduje się w tym samym zestawie, obiekt wywołujący nie potrzebne żadne specjalne uprawnienia dla wewnętrznych składowych. W przeciwnym razie wywołujący musi mieć <xref:System.Security.Permissions.ReflectionPermission>. Jest to zgodne z wyszukiwania elementów członkowskich, które są chronione, prywatne i tak dalej.  
  
 Ogólną zasadą jest fakt, że <xref:System.Reflection.Binder.ChangeType%2A> należy wykonać tylko do poszerzenia konwersje, które nigdy nie utracą danych. Przykładem konwersję rozszerzającą konwertuje wartość całkowita 32-bitowa wartość całkowita 64-bitowych. Jest to odróżnić od konwersją zawężającą może spowodować utratę danych. Przykład konwersja zawężająca jest konwersja całkowita 64-bitowego na całkowita 32-bitowych.  
  
 W poniższej tabeli wymieniono konwersje obsługiwane przez domyślny integrator.  
  
|Typ źródła|Typ docelowy|  
|-----------------|-----------------|  
|Dowolnego typu|Jego typ podstawowy.|  
|Dowolnego typu|Interfejs, który implementuje.|  
|Char|Unt16, UInt32, Int32, UInt64, Int64, pojedynczy Double|  
|Byte|Char, Unt16 Int16, UInt32, Int32, UInt64, Int64, pojedynczy Double|  
|SByte|Int16, Int32, Int64, pojedynczy Double|  
|UInt16|UInt32, Int32, UInt64, Int64, pojedynczy Double|  
|Int16|Int32, Int64, pojedynczy Double|  
|UInt32|UInt64, Int64, pojedynczy Double|  
|Int32|Int64, jeden dwukrotnie|  
|UInt64|Pojedynczy Double|  
|Int64|Pojedynczy Double|  
|Single|Double|  
|Non-reference|Przez odwołanie.|  
  
   
  
## Examples  
 Poniższy przykład pobiera domyślnego integratora z `DefaultBinder` właściwości i wywołuje członka MyClass przez przekazanie `DefaultBinder` wartość jako parametr do <xref:System.Type.InvokeMember%2A>.  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Oddziela nazwy w przestrzeni nazw <see cref="T:System.Type" />. To pole jest tylko do odczytu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje pustą tablicę typu <see cref="T:System.Type" />. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod przedstawia przykład `EmptyTypes` pole używane w jednym z `GetConstructor` metody w celu uzyskania konstruktora, który nie przyjmuje żadnych parametrów.  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy typ podstawowy system bieżącego <see cref="T:System.Type" /> jest taka sama jak system typem podstawowym określonego <see cref="T:System.Object" /> lub <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Obiektu, którego podstawowym typem systemu jest ma zostać porównane z podstawowym typem systemu bieżącego <see cref="T:System.Type" />. Porównanie zakończyło się sukcesem <paramref name="o" /> musi być w stanie rzutowania lub przekonwertować na obiekt typu <see cref="T:System.Type" />.</param>
        <summary>Określa, czy typ podstawowy system bieżącego <see cref="T:System.Type" /> obiekt jest taki sam jak systemu typem podstawowym określonego <see cref="T:System.Object" />.</summary>
        <returns><see langword="true" /> Jeśli typ podstawowy system <paramref name="o" /> jest taka sama jak podstawowym typem systemu bieżącego <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />. Ta metoda zwraca też wartość <see langword="false" /> przypadku:.  
  
-   <paramref name="o" /> jest <see langword="null" />.  
  
-   <paramref name="o" /> Nie można rzutować lub przekonwertowane na <see cref="T:System.Type" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Rzuca `o` do obiektu typu <xref:System.Type> i wywołuje <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Type.Equals%28System.Object%29> porównywanie różnych <xref:System.Type> obiektu wystąpień z różnymi <xref:System.Object> wystąpień.  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 Dwie rzeczy są szczególnie, warte odnotowania o w przykładzie:  
  
-   Porównanie <xref:System.Type> obiekt, który reprezentuje liczbę całkowitą z <xref:System.Reflection.TypeInfo> obiekt, który reprezentuje liczbę całkowitą zwracany `true` ponieważ <xref:System.Reflection.TypeInfo> jest tworzony na podstawie <xref:System.Type>.  
  
-   Porównanie <xref:System.Type> obiekt, który reprezentuje <xref:System.Collections.Generic.IList%601> obiektu (otwartym typem ogólnym) z `List(Of String)` (zamknięty typ rodzajowy) zwraca `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">Obiektu, którego podstawowym typem systemu jest ma zostać porównane z podstawowym typem systemu bieżącego <see cref="T:System.Type" />.</param>
        <summary>Określa, czy typ podstawowy system bieżącego <see cref="T:System.Type" /> jest taka sama jak system typem podstawowym określonego <see cref="T:System.Type" />.</summary>
        <returns><see langword="true" /> Jeśli typ podstawowy system <paramref name="o" /> jest taka sama jak podstawowym typem systemu bieżącego <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto `Equals` do porównywania dwóch typów.  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje filtr elementu członkowskiego, używane dla atrybutów. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To pole zawiera odwołanie do delegata używany przez <xref:System.Type.FindMembers%2A> metody. Metoda zamknięte przez ten delegat przyjmuje dwa parametry: pierwszy to <xref:System.Reflection.MemberInfo> obiektu, a drugi jest `Object`. Metoda określa, czy `MemberInfo` obiektu spełniający kryteria określone przez `Object`. `Object` Może mieć przypisaną taką wartość jednego pola na klasy <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, lub <xref:System.Reflection.MethodImplAttributes>.  
  
 Na przykład `Object` można przypisać wartości pola z `FieldAttributes` takim jak Public. W takiej sytuacji, gdy `FilterAttribute` obiekt delegowany jest wywoływany, zwróci `true` tylko wtedy, gdy metoda jest reprezentowany przez `MemberInfo` obiektu zostanie nadany atrybut publiczne pole w metadanych.  
  
   
  
## Examples  
 Poniższy przykład pobiera `FilterAttribute` delegować, przekazuje go jako parametr do <xref:System.Type.FindMembers%2A> metodę i wyświetla określonych elementów i ich atrybutów.  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje filtr Członek uwzględniana wielkość liter, używane w nazwach. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To pole zawiera odwołanie do delegata używany przez <xref:System.Type.FindMembers%2A> metody. Metoda zamknięte przez ten delegat przyjmuje dwa parametry: pierwszy to <xref:System.Reflection.MemberInfo> obiektu, a drugi jest `Object`. Metoda określa, czy `MemberInfo` obiektu spełniający kryteria określone przez `Object`. `Object` Jest przypisywana wartość ciągu, które mogą obejmować końcowe "*" znak symbolu wieloznacznego. Tylko koniec ciągu dopasowanie z symbolami wieloznacznymi jest obsługiwany.  
  
 Na przykład `Object` można przypisać wartości "Bajtów *". W takiej sytuacji, gdy `FilterName` obiekt delegowany jest wywoływany, zwróci `true` tylko wtedy, gdy metoda jest reprezentowany przez `MemberInfo` obiekt ma nazwę rozpoczynającą się od "Bajtów".  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera metody skojarzone z zdefiniowany przez użytkownika `Application` typu.  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje filtr Członek bez uwzględniania wielkości liter, używane w nazwach. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To pole zawiera odwołanie do delegata używany przez <xref:System.Type.FindMembers%2A> metody. Metoda zamknięte przez ten delegat przyjmuje dwa parametry: pierwszy to <xref:System.Reflection.MemberInfo> obiektu, a drugi jest `Object`. Metoda określa, czy `MemberInfo` obiektu spełniający kryteria określone przez `Object`. `Object` Jest przypisywana wartość ciągu, które mogą obejmować końcowe "*" znak symbolu wieloznacznego. Tylko koniec ciągu dopasowanie z symbolami wieloznacznymi jest obsługiwany.  
  
 Na przykład `Object` można przypisać wartości "Bajtów *". W takiej sytuacji, gdy `FilterName` obiekt delegowany jest wywoływany, zwróci wartość true, tylko jeśli metoda jest reprezentowany przez `MemberInfo` obiekt ma nazwę rozpoczynającą się od "bajtów", bez uwzględnienia wielkości liter.  
  
   
  
## Examples  
 Poniższy przykład pobiera `MemberFilter` delegować, przekazuje go jako parametr do <xref:System.Type.FindMembers%2A> metodę i wyświetla metod i ich atrybuty `String` klasy, które zaczynają się od litera "c", nie biorąc pod uwagę w przypadku.  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">Delegat, który porównuje interfejsów względem <paramref name="filterCriteria" />.</param>
        <param name="filterCriteria">Kryteria wyszukiwania, które określa, czy interfejs powinny być objęte zwróconej tablicy.</param>
        <summary>Zwraca tablicę <see cref="T:System.Type" /> obiekty reprezentujące filtrowana lista interfejsy implementowane lub jest dziedziczona przez bieżący <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiekty reprezentujące filtrowana lista interfejsy implementowane lub jest dziedziczona przez bieżący <see cref="T:System.Type" />, lub pusta tablica typu <see cref="T:System.Type" /> Jeśli interfejsy nie jest zgodny z filtrem nie są implementowane lub dziedziczone przez bieżącą <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
 <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> i <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegatów dostarczonych przez <xref:System.Reflection.Module?displayProperty=nameWithType> klasy może być również, w miejsce <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegować.  
  
 Wszystkie interfejsy implementowane przez tę klasę są traktowane jako podczas wyszukiwania, czy podana przez klasę bazową lub tej samej klasy.  
  
 Metoda ta wyszukuje w hierarchii klasy bazowej, zwracanie wszystkich zgodnych interfejsów, każda klasa implementuje, a także wszystkie zgodne każdego z tych interfejsów implementuje interfejsy (oznacza to, zwracana jest przechodnia zamknięcia zgodnych interfejsów). Brak interfejsów zduplikowane są zwracane.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, <xref:System.Type.FindInterfaces%2A> wyszukiwanie wszystkich interfejsów zadeklarowanych w ograniczenia dla parametru typu, a wszystkie interfejsy dziedziczone za pośrednictwem interfejsów zadeklarowana w ograniczenia. Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny, argument typu <xref:System.Type.FindInterfaces%2A> wyszukuje wszystkie interfejsy implementowane przez ten typ, czy też nie są zgodne z ograniczeniami.  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A> może zwracać interfejsów ogólnych, nawet w przypadku typów, które nie są rodzajowe. Na przykład nierodzajowymi typ może implementować `IEnumerable<int>` (`IEnumerable(Of Integer)` w języku Visual Basic).  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie określonego interfejsu implementowany lub dziedziczone przez określonego typu, a następnie wyświetla nazwy interfejsu.  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Statycznego inicjatora jest wywoływany i zgłasza wyjątek.</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">Obiekt, który określa typ elementu członkowskiego do wyszukania.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <param name="filter">Delegat, który wykonuje porównania, zwracając <see langword="true" /> elementu członkowskiego aktualnie inspekcji dopasowania <paramref name="filterCriteria" /> i <see langword="false" /> inaczej. Możesz użyć <see langword="FilterAttribute" />, <see langword="FilterName" />, i <see langword="FilterNameIgnoreCase" /> delegatów, dostarczone przez tę klasę. Pierwszy używa pól <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, i <see langword="MethodImplAttributes" /> jako kryteria wyszukiwania, a następnie użyj dwa delegaty <see langword="String" /> obiektów jako kryterium wyszukiwania.</param>
        <param name="filterCriteria">Kryteria wyszukiwania, które określa, czy członek jest zwracany w tablicy <see langword="MemberInfo" /> obiektów.  
  
Pola <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, i <see langword="MethodImplAttributes" /> mogą być używane w połączeniu z <see langword="FilterAttribute" /> delegata dostarczonych przez tę klasę.</param>
        <summary>Zwraca tablicę filtrowane <see cref="T:System.Reflection.MemberInfo" /> obiektów typu określonego elementu członkowskiego.</summary>
        <returns>Filtrowane tablicę <see cref="T:System.Reflection.MemberInfo" /> obiektów typu określonego elementu członkowskiego.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.MemberInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma elementów członkowskich typu <paramref name="memberType" /> pasujących do kryteriów filtrowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
 Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania elementów członkowskich, które można uwzględnić w wyszukiwaniu:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.  
  
-   Określ `BindingFlags.Instance` obejmujący składowych wystąpienia w wyszukiwaniu.  
  
-   Określ `BindingFlags.Static` obejmujący statyczne elementy członkowskie w wyszukiwaniu.  
  
-   Określ `BindingFlags.Public` obejmujący publiczne elementy członkowskie w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący elementów członkowskich niepublicznych (czyli prywatne, wewnętrzne i chronione elementy członkowskie) w wyszukiwaniu.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko do elementów członkowskich zadeklarowanych w <xref:System.Type>, nie elementów członkowskich, które zostały po prostu odziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Prawidłowe wartości dla <xref:System.Type.MemberType%2A> są zdefiniowane w <xref:System.Reflection.MemberInfo>. Jeśli nie zostaną znalezione nie takich członków, zwracany jest pusta tablica.  
  
 Aby uzyskać inicjatora klasy (.cctor), za pomocą tej metody, należy określić <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic). Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego lub metody rodzajowej, <xref:System.Type.FindMembers%2A> przetwarza wszystkie elementy członkowskie zadeklarowana przez ograniczenia klasy i ograniczenia interfejsu, parametru typu.  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie wszystkich elementów członkowskich w klasie, spełniających określone kryteria wyszukiwania, a następnie wyświetla dopasowane elementy członkowskie.  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera w pełni kwalifikowaną nazwę typu, łącznie z jego przestrzeń nazw, ale nie jej zestawu.</summary>
        <value>W pełni kwalifikowaną nazwę typu, łącznie z jego przestrzeń nazw, ale nie jej zestawu; lub <see langword="null" /> Jeśli bieżące wystąpienie reprezentuje parametr typu ogólnego, typ tablicy, typ wskaźnika lub <see langword="byref" /> typu na podstawie parametru typu lub typ ogólny, który nie jest definicja typu ogólnego, ale zawiera nierozpoznany typ parametrów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład w pełni kwalifikowanej nazwy <xref:System.String> typ jest `System.String`. Natomiast to nazwą kwalifikowaną dla zestawu zwrócony przez <xref:System.Type.AssemblyQualifiedName%2A> właściwość, która składa się z pełną nazwę i nazwę pełnego zestawu.  
  
 Jeśli bieżący typ reprezentuje zamknięty typ ogólny, argumentów typu ciąg zwracany przez <xref:System.Type.FullName%2A> właściwości są kwalifikowane według nazwy pełnego zestawu nawet reprezentację ciągu typu ogólnego, sama nie kwalifikuje się przez jego pełnej Nazwa zestawu. Poniższy przykład ilustruje tę różnicę we właściwości FullName dla typu, który reprezentuje definicji typu ogólnego i taki, który reprezentuje typ ogólny, zamknięte.  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 Ta właściwość zwraca `null` jeśli:  
  
-   Bieżący <xref:System.Type> obiekt reprezentuje parametr typu ogólnego.  
  
     Poniższy przykład pobiera parametr typu <xref:System.Nullable%601> typu i próbuje wyświetlić jego <xref:System.Type.FullName%2A> właściwości.  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   Bieżący <xref:System.Type> obiekt reprezentuje typ tablicy, typem wskaźnika lub `byref` typ, który jest oparty na parametr typu ogólnego.  
  
     W poniższym przykładzie zdefiniowano typ ogólny, `Generictype1<T>`, za pomocą trzech metod: `Display(T[])`, która jest przekazywana tablicę typu T; `HandleT(T)`, który jest przekazywany obiekt T; a `ChangeValue(ref T)`, który jest przekazywany obiekt T przez odwołanie. Ponieważ języka C# i Visual Basic nie pozwalają nam T jest definiowana jako wskaźnik w `HandleT` metody, konieczne jest wywołanie <xref:System.Type.MakePointerType%2A> metody <xref:System.Type> obiekt, który reprezentuje typ parametru metody, aby utworzyć wskaźnik do typu ogólnego. Dane wyjściowe z przykładu pokazuje, że we wszystkich trzech przypadkach <xref:System.Type.FullName%2A> właściwość `null`.  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   Bieżący typ zawiera parametry typu ogólnego, które nie zostały zastąpione przez określone typy (oznacza to, <xref:System.Type.ContainsGenericParameters%2A> właściwość zwraca `true`), ale nie jest to typ definicji typu ogólnego (oznacza to, że <xref:System.Type.IsGenericTypeDefinition%2A> zwraca właściwości `false`  
  
     W poniższym przykładzie `Derived<T>` dziedziczy `Base<T>`. <xref:System.Type.BaseType%2A> Uzyskuje właściwość <xref:System.Type> obiekt, który reprezentuje typ podstawowy elementu `Derived<T>`, a jego <xref:System.Type.FullName%2A> właściwość zwraca `null`.  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     Aby uzyskać <xref:System.Type.FullName%2A> , który nie jest `null`, możesz użyć <xref:System.Type.GetGenericTypeDefinition%2A> metodę, aby uzyskać definicji typu ogólnego, tak jak pokazano w przykładzie.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład Wyświetla pełną nazwę określonego typu.  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 W poniższym przykładzie porównano ciągów zwracanych przez <xref:System.Type.ToString%2A> metody i `Name`, <xref:System.Type.FullName%2A>, i <xref:System.Type.AssemblyQualifiedName%2A> właściwości.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Określanie w pełni kwalifikowanych nazw typów</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kombinacji <see cref="T:System.Reflection.GenericParameterAttributes" /> flagi opisujące kowariancji i ograniczeń specjalnych bieżącego parametru typu ogólnego.</summary>
        <value>Bitowa kombinacja <see cref="T:System.Reflection.GenericParameterAttributes" /> wartości, które opisano kowariancji i ograniczeń specjalnych bieżącego parametru typu ogólnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości zawiera flagi, które opisują, czy bieżący parametr typu ogólnego jest kowariantny i flagi opisujące żadnych szczególnych ograniczeń. Użyj <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> wartość, aby wybrać flagi Kowariancja, a następnie użyj <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> wartość, aby wybrać flagi ograniczenia.  
  
 Aby uzyskać listę niezmiennych warunków dla terminów używanych w odbiciu rodzajowym, zobacz <xref:System.Type.IsGenericType%2A> uwagi dotyczące właściwości.  
  
   
  
## Examples  
 Poniższy kod definiuje typ ogólny `Test` z dwoma parametrami typu, które mają z nią związane inne ograniczenia. Gdy program będzie działać, ograniczenia są sprawdzane przy użyciu <xref:System.Type.GenericParameterAttributes%2A> właściwości i <xref:System.Type.GetGenericParameterConstraints%2A> metody.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący <see cref="T:System.Type" /> obiektu nie jest parametrem typu ogólnego. Oznacza to, że <see cref="P:System.Type.IsGenericParameter" /> właściwość zwraca <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pozycję parametr typu na liście parametrów typu ogólnego typu lub metody, który zadeklarowany parametr, gdy <see cref="T:System.Type" /> obiekt reprezentuje parametr typu ogólnego lub metody rodzajowej.</summary>
        <value>Pozycja parametru typu na liście parametrów typu dla typu ogólnego lub metody, która definiuje parametru. Rozpocznij Pozycja cyfry od 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GenericParameterPosition%2A> Właściwość zwraca pozycja parametru typu na liście parametrów w definicji typu ogólnego lub metody rodzajowej definicji gdzie parametr typu została pierwotnie zdefiniowana. <xref:System.Type.DeclaringType%2A> i <xref:System.Type.DeclaringMethod%2A> właściwości określania ogólnego definicji typu lub metody:  
  
-   Jeśli <xref:System.Type.DeclaringMethod%2A> właściwość zwraca <xref:System.Reflection.MethodInfo>, które <xref:System.Reflection.MethodInfo> reprezentuje definicję metody rodzajowej, a bieżący <xref:System.Type> obiekt reprezentuje parametr typu tej definicji metody rodzajowej.  
  
-   Jeśli <xref:System.Type.DeclaringMethod%2A> właściwość zwraca `null`, a następnie <xref:System.Type.DeclaringType%2A> właściwość zawsze zwraca <xref:System.Type> obiekt reprezentujący definicji typu ogólnego i bieżący <xref:System.Type> obiekt reprezentuje parametr typu ogólnego typu Definicja.  
  
 Aby zapewnić poprawny kontekst dla wartości <xref:System.Type.GenericParameterPosition%2A> właściwości jest niezbędne do identyfikowania typu ogólnego lub metody z parametrem typu, o których należy. Rozważmy na przykład wartość zwracaną metody ogólnej `GetSomething` w poniższym kodzie:  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 Typ zwracany przez `GetSomething` zależy od argumentów typu przekazana do klasy `A` i `GetSomething` sam. Możesz uzyskać <xref:System.Reflection.MethodInfo> dla `GetSomething`, i przy jego użyciu można uzyskać typ zwracany. Podczas badania parametrów typu zwracanego typu <xref:System.Type.GenericParameterPosition%2A> zwraca wartość 0 dla obu. Pozycja `V` wynosi 0, ponieważ `V` pierwszego parametru typu na liście parametrów typu dla klasy `A`. Pozycja `X` wynosi 0, ponieważ `X` pierwszego parametru typu na liście parametrów typu dla `GetSomething`.  
  
> [!NOTE]
>  Wywoływanie <xref:System.Type.GenericParameterPosition%2A> właściwości powoduje wyjątek, jeśli bieżący <xref:System.Type> nie reprezentuje parametr typu. Podczas badania argumentów typu otwartego skonstruowanego typu użycia <xref:System.Type.IsGenericParameter%2A> właściwość stwierdzić, którego parametrów typu i typów. <xref:System.Type.IsGenericParameter%2A> Właściwość zwraca `true` dla parametru typu; można następnie użyć <xref:System.Type.GenericParameterPosition%2A> metodę, aby uzyskać jego położenie i użyj <xref:System.Type.DeclaringMethod%2A> i <xref:System.Type.DeclaringType%2A> właściwości, aby określić metodę rodzajową lub definicji, który go definiuje typu .  
  
   
  
## Examples  
 Poniższy przykład definiuje klasę ogólną z dwoma parametrami typu i definiuje klasę ogólną drugi wywodzi się z pierwszej klasy. Klasa podstawowa dla klasy pochodnej ma dwa argumenty typu: pierwszy to <xref:System.Int32>, a drugą jest parametrem typu w typie pochodnym. W przykładzie są wyświetlane informacje o tych klasach ogólnych, w tym pozycje raportowane przez <xref:System.Type.GenericParameterPosition%2A> właściwości.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący typ nie reprezentuje parametr typu. Oznacza to, że <see cref="P:System.Type.IsGenericParameter" /> zwraca <see langword="false" />.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera tablicę argumentów typu ogólnego dla tego typu.</summary>
        <value>Tablica argumenty typu generycznego, dla tego typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej właściwości pobiera tylko argumenty typu generycznego; oznacza to, że typy, które zostały określone dla parametrów typu ogólnego bieżącego typu. Jeśli bieżący typ jest definicja typu ogólnego, właściwość ta zwraca pustą tablicę.  
  
> [!NOTE]
>  Jeśli typ ogólny jest używany w metody ogólnej lub w innym typem ogólnym, niektóre argumenty typu ogólnego może być otaczającej metody lub typu parametrów typu ogólnego.  
  
 Aby uzyskać parametry typu ogólnego typu, który reprezentuje definicję typu ogólnego, użyj <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> właściwości. Aby uzyskać <xref:System.Reflection.TypeInfo> obiektu dla bieżącego <xref:System.Type> obiektu, należy użyć <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> — metoda rozszerzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera liczbę wymiarów w tablicy.</summary>
        <returns>Liczba całkowita, która zawiera liczbę wymiarów w bieżącym typem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wyświetla liczbę wymiarów w tablicy.  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Funkcjonalność ta metoda nie jest obsługiwana w klasie bazowej i muszą być zaimplementowane w klasie pochodnej zamiast tego.</exception>
        <exception cref="T:System.ArgumentException">Bieżący typ nie jest tablicą.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, implementuje <see cref="P:System.Type.Attributes" /> właściwość i pobiera maskę bitów wskazującą atrybuty skojarzone z <see cref="T:System.Type" />.</summary>
        <returns>A <see cref="T:System.Reflection.TypeAttributes" /> obiekt reprezentujący zestaw atrybutów <see cref="T:System.Type" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera konstruktora określonego bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla żądanego konstruktora.  
  
—lub— 
Pusta tablica <see cref="T:System.Type" /> obiektów, można pobrać konstruktora, który nie przyjmuje żadnych parametrów. Pusta tablica jest dostarczany przez <see langword="static" /> pola <see cref="F:System.Type.EmptyTypes" />.</param>
        <summary>Wyszukiwanie konstruktora wystąpienia publicznego, w której parametry pasują do typów w określonej tablicy.</summary>
        <returns>Reprezentuje obiekt konstruktora wystąpienia publicznego, w której parametry pasują do typów w tablicy typu parametru, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tego przeciążenia metody szuka konstruktory publiczne wystąpienia i nie można uzyskać inicjatora klasy (.cctor). Aby uzyskać inicjatora klasy, użyj przeciążenia, które przyjmuje <xref:System.Reflection.BindingFlags>, a następnie określ <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic). Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 Jeśli żądana Konstruktor jest niepublicznych, Metoda ta zwraca `null`.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.ConstructorInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu. Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta zwraca zawsze `null`.  
  
   
  
## Examples  
 W poniższym przykładzie uzyskano typ `MyClass`, pobiera <xref:System.Reflection.ConstructorInfo> obiektu, a następnie wyświetla sygnatury konstruktora.  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> jest <see langword="null" />.  
  
—lub— 
Jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ma charakter wielowymiarowy.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla konstruktora, aby uzyskać.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie konstruktora, który nie przyjmuje żadnych parametrów.  
  
—lub— 
 <see cref="F:System.Type.EmptyTypes" />.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w tablicy typu parametru. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Wyszukiwanie konstruktora, w której parametry odpowiadają określone typy argumentów i modyfikatorów, za pomocą ograniczeń w określonym powiązaniu.</summary>
        <returns>A <see cref="T:System.Reflection.ConstructorInfo" /> obiekt reprezentujący Konstruktor, który spełnia określone wymagania, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie istnieje dokładne dopasowanie, `binder` będzie próbował przekształcić typy parametrów określonych w `types` tablicy w celu wybrania dopasowania. Jeśli `binder` nie może wybrać dopasowania, następnie `null` jest zwracana.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania, które z konstruktorów do uwzględnienia w wyszukiwaniu:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.  
  
-   Określ `BindingFlags.Public` obejmujący konstruktorów publicznych w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący w w wyszukiwaniu konstruktory niepubliczne (czyli prywatne, wewnętrzne i chronione konstruktory).  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Aby uzyskać inicjatora klasy (.cctor), za pomocą tego przeciążenia metody, należy określić <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic). Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.ConstructorInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu. Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta zwraca zawsze `null`.  
  
   
  
## Examples  
 Następujący program uzyskuje typ `MyClass1` klasy pobiera <xref:System.Reflection.ConstructorInfo> obiektu dopasowania flagi określonego powiązania, a następnie wyświetla podpis konstruktora.  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> jest <see langword="null" />.  
  
—lub— 
Jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ma charakter wielowymiarowy.  
  
—lub— 
 <paramref name="modifiers" /> ma charakter wielowymiarowy.  
  
—lub— 
 <paramref name="types" /> i <paramref name="modifiers" /> nie mają tę samą długość.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Obiekt, który określa zestaw reguł dotyczących kolejności i układ argumentów, jak wartość zwracana jest przekazywany, jakie rejestrów są używane dla argumentów i stos jest czyszczony.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla konstruktora, aby uzyskać.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie konstruktora, który nie przyjmuje żadnych parametrów.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <paramref name="types" /> tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Wyszukiwanie konstruktora, w której parametry odpowiadają określone typy argumentów i modyfikatorów, za pomocą ograniczeń w określonym powiązaniu i określonej konwencji wywoływania.</summary>
        <returns>Obiekt reprezentujący Konstruktor, który spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że domyślny integrator nie przetwarza <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `modifiers`. `ParameterModifier` jest używana tylko podczas wywoływania przez współdziałania z modelem COM i są obsługiwane tylko w przypadku parametrów, które są przekazywane przez odwołanie.  
  
 Jeśli nie istnieje dokładne dopasowanie, `binder` będzie próbował przekształcić typy parametrów określonych w `types` tablicy w celu wybrania dopasowania. Jeśli `binder` nie może wybrać dopasowania, następnie `null` jest zwracana.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania, które z konstruktorów do uwzględnienia w wyszukiwaniu:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.  
  
-   Określ `BindingFlags.Public` obejmujący konstruktorów publicznych w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący w w wyszukiwaniu konstruktory niepubliczne (czyli prywatne, wewnętrzne i chronione konstruktory).  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Aby uzyskać inicjatora klasy (.cctor), za pomocą tej metody, należy określić <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic). Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.ConstructorInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu. Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta zwraca zawsze `null`.  
  
   
  
## Examples  
 W poniższym przykładzie uzyskano typ `MyClass1`, pobiera <xref:System.Reflection.ConstructorInfo> obiekt, który odpowiada flagi określonego powiązania, a następnie wyświetla sygnatury konstruktora.  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> jest <see langword="null" />.  
  
—lub— 
Jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ma charakter wielowymiarowy.  
  
—lub— 
 <paramref name="modifiers" /> ma charakter wielowymiarowy.  
  
—lub— 
 <paramref name="types" /> i <paramref name="modifiers" /> nie mają tę samą długość.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Obiekt, który określa zestaw reguł dotyczących kolejności i układ argumentów, jak wartość zwracana jest przekazywany, jakie rejestrów są używane dla argumentów i stos jest czyszczony.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla konstruktora, aby uzyskać.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie konstruktora, który nie przyjmuje żadnych parametrów.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <paramref name="types" /> tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wyszukuje konstruktora, w której parametry odpowiadają określone typy argumentów i modyfikatorów, korzystając z ograniczeń w określonym powiązaniu i określonej konwencji wywoływania.</summary>
        <returns>A <see cref="T:System.Reflection.ConstructorInfo" /> obiekt reprezentujący Konstruktor, który spełnia określone wymagania, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że domyślny integrator nie przetwarza <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `modifiers`. `ParameterModifier` jest używana tylko podczas wywoływania przez współdziałania z modelem COM i są obsługiwane tylko w przypadku parametrów, które są przekazywane przez odwołanie.  
  
 Jeśli nie istnieje dokładne dopasowanie, `binder` będzie próbował przekształcić typy parametrów określonych w `types` tablicy w celu wybrania dopasowania. Jeśli `binder` nie może wybrać dopasowania, następnie `null` jest zwracana.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania, które z konstruktorów do uwzględnienia w wyszukiwaniu:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.  
  
-   Określ `BindingFlags.Public` obejmujący konstruktorów publicznych w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący w w wyszukiwaniu konstruktory niepubliczne (czyli prywatne, wewnętrzne i chronione konstruktory).  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Ta metoda implementuje <xref:System.Type.GetConstructor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> jest <see langword="null" />.  
  
—lub— 
Jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ma charakter wielowymiarowy.  
  
—lub— 
 <paramref name="modifiers" /> ma charakter wielowymiarowy.  
  
—lub— 
 <paramref name="types" /> i <paramref name="modifiers" /> nie mają tę samą długość.</exception>
        <exception cref="T:System.NotSupportedException">Bieżącym typem jest <see cref="T:System.Reflection.Emit.TypeBuilder" /> lub <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera konstruktory bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie publiczne konstruktory zdefiniowane dla bieżącego <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Reflection.ConstructorInfo" /> obiekty reprezentujące wszystkie konstruktory publiczne wystąpienia zdefiniowane dla bieżącego <see cref="T:System.Type" />, z wyjątkiem typu inicjatora (Konstruktor statyczny). Jeśli nie konstruktory publiczne wystąpienia są zdefiniowane dla bieżącego <see cref="T:System.Type" />, lub, jeśli bieżący <see cref="T:System.Type" /> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, pusta tablica typu <see cref="T:System.Reflection.ConstructorInfo" /> jest zwracana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A> Metoda nie zwraca konstruktorów w określonej kolejności, takie jak kolejność zgłoszenia. Twój kod nie może zależeć od kolejności, w której zwracane są konstruktory, ponieważ kolejność się zmienia.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Tego przeciążenia metody wywołuje <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> przeciążenie metody z <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> w języku Visual Basic). Inicjatory klasy (.cctor) nie zostanie odnaleziony. Aby znaleźć klasy inicjatory, użyj przeciążenia, które przyjmuje <xref:System.Reflection.BindingFlags>, a następnie określ <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic). Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.ConstructorInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu. Na przykład jeśli klasa `C<T>` ma Konstruktor `C(T t1)` (`Sub New(ByVal t1 As T)` w języku Visual Basic), wywoływania <xref:System.Type.GetConstructors%2A> na `C<int>` zwraca <xref:System.Reflection.ConstructorInfo> reprezentujący `C(int t1)` w języku C# (`Sub New(ByVal t1 As Integer)` w języku Visual Basic).  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, <xref:System.Type.GetConstructors%2A> metoda zwraca pustą tablicę.  
  
   
  
## Examples  
 Ten przykład przedstawia dane wyjściowe <xref:System.Type.GetConstructors%2A> przeciążenia z klasy, która ma dwa konstruktory wystąpień i jeden konstruktor statyczny.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 Wynik tego kodu jest:  
  
 2  
  
 False  
  
 False  
  
 Ponieważ <xref:System.Type.GetConstructors> przeciążenia używa tylko <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> i <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, statyczny Konstruktor nie jest traktowana przez `for` wyrażeń ani oceniany przez `IsStatic`.  
  
 Aby znaleźć konstruktorów statycznych, użyj <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> przeciążenia i przekazywać połączenie (logiczne `OR`) z <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, jak pokazano w poniższym przykładzie kodu:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Teraz dane wyjściowe to:  
  
 3  
  
 False  
  
 Prawda  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wyszukuje konstruktorów, zdefiniowanych dla bieżącej <see cref="T:System.Type" />, przy użyciu określonego <see langword="BindingFlags" />.</summary>
        <returns>Tablica <see cref="T:System.Reflection.ConstructorInfo" /> obiekty reprezentujące wszystkie konstruktory zdefiniowane dla bieżącego <see cref="T:System.Type" /> zgodnych ograniczeń w określonym powiązaniu, w tym inicjatora typu, jeśli jest on zdefiniowany. Zwraca pustą tablicę typu <see cref="T:System.Reflection.ConstructorInfo" /> Jeśli konstruktory nie są zdefiniowane dla bieżącego <see cref="T:System.Type" />, czy żaden z konstruktorów zdefiniowanych być zgodne z ograniczeniami powiązania, czy bieżący <see cref="T:System.Type" /> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A> Metoda nie zwraca konstruktorów w określonej kolejności, takie jak kolejność zgłoszenia. Twój kod nie może zależeć od kolejności, w której zwracane są konstruktory, ponieważ kolejność się zmienia.  
  
 `bindingAttr` może służyć do określenia, czy należy zwrócić tylko konstruktory publiczne lub konstruktorów publicznych i niepublicznych.  
  
 Jeśli nie istnieje dokładne dopasowanie, `binder` będzie próbował przekształcić typy parametrów określonych w `types` tablicy w celu wybrania dopasowania. Jeśli `binder` nie może wybrać dopasowania, następnie `null` jest zwracana.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania, które z konstruktorów do uwzględnienia w wyszukiwaniu:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.  
  
-   Określ `BindingFlags.Public` obejmujący konstruktorów publicznych w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący w w wyszukiwaniu konstruktory niepubliczne (czyli prywatne, wewnętrzne i chronione konstruktory). Konstruktory klas bazowych nie są zwracane.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Aby uzyskać inicjatora klasy (.cctor), za pomocą tego przeciążenia metody, należy określić <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic). Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.ConstructorInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu. Na przykład jeśli klasa `C<T>` ma Konstruktor `C(T t1)` (`Sub New(ByVal t1 As T)` w języku Visual Basic), wywoływania <xref:System.Type.GetConstructors%2A> na `C<int>` zwraca <xref:System.Reflection.ConstructorInfo> reprezentujący `C(int t1)` w języku C# (`Sub New(ByVal t1 As Integer)` w języku Visual Basic).  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, <xref:System.Type.GetConstructors%2A> metoda zwraca pustą tablicę.  
  
   
  
## Examples  
 Ten przykład przedstawia dane wyjściowe <xref:System.Type.GetConstructors> przeciążenia z klasy, która ma dwa konstruktory wystąpień i jeden konstruktor statyczny.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 Wynik tego kodu jest:  
  
 2  
  
 False  
  
 False  
  
 Ponieważ <xref:System.Type.GetConstructors%2A> przeciążenia używa tylko <xref:System.Reflection.BindingFlags.Public> i <xref:System.Reflection.BindingFlags.Instance>, statyczny Konstruktor nie jest traktowana przez `for` wyrażeń ani oceniany przez `IsStatic`.  
  
 Aby znaleźć konstruktorów statycznych, użyj <xref:System.Type.GetConstructors%2A> przeciążenia i przekazywać je kombinacja (operator logiczny lub) <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, jak pokazano w poniższym przykładzie kodu:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Teraz dane wyjściowe to:  
  
 3  
  
 False  
  
 Prawda  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyszukuje elementy członkowskie zdefiniowane dla bieżącego <see cref="T:System.Type" /> którego <see cref="T:System.Reflection.DefaultMemberAttribute" /> jest ustawiona.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące wszystkie domyślne elementy członkowskie bieżącego <see cref="T:System.Type" />.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.MemberInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma domyślne elementy członkowskie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetDefaultMembers%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji. Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.  
  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
 Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MemberInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu. Na przykład jeśli klasa `C<T>` ma właściwość `P` zwracającego `T`, wywoływania <xref:System.Type.GetDefaultMembers%2A> na `C<int>` zwraca `int P` w języku C# (`Property P As Integer` w języku Visual Basic).  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje składowe ograniczenia klasy lub elementów członkowskich <xref:System.Object> przypadku bez ograniczenia klasy.  
  
   
  
## Examples  
 W poniższym przykładzie uzyskano informacje o członkach domyślne z `MyClass` i wyświetla domyślne elementy członkowskie.  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po przesłonięciu w klasie pochodnej zwraca <see cref="T:System.Type" /> obiektu wchodzących w skład lub określone przez bieżący typ tablicy, wskaźnika lub odwołania.</summary>
        <returns><see cref="T:System.Type" /> Obiektu wchodzących w skład lub odwołuje się bieżącej tablicy, wskaźnika lub typ referencyjny lub <see langword="null" /> Jeśli bieżące <see cref="T:System.Type" /> nie jest tablicą ani wskaźnikiem, nie jest przekazywany przez odwołanie lub reprezentuje typ ogólny lub parametr typu w Definicja typu ogólnego lub metody rodzajowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca `null` dla <xref:System.Array> klasy.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie `GetElementType` metody.  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Wartość, której nazwa to do pobrania.</param>
        <summary>Zwraca nazwę stałą, która ma określoną wartość, dla bieżącego typu wyliczeniowego.</summary>
        <returns>Nazwa elementu członkowskiego bieżący typ wyliczeniowy, który ma określoną wartość lub <see langword="null" /> Jeśli zostanie znaleziony taki stałej.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Bieżący typ nie jest wyliczeniem.  
  
—lub— 
 <paramref name="value" /> nie jest ani bieżącego typu ani nie ma ten sam typ podstawowy jako bieżącego typu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca nazwy elementów członkowskich bieżącego typu wyliczenia.</summary>
        <returns>Tablica, która zawiera nazwy elementów członkowskich wyliczenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy w tablicy zwracanej wartości są sortowane według wartości binarnych (czyli wartości bez znaku) stałych wyliczeniowych. Jeśli tablica zawiera stałych wyliczeniowych z taką samą wartość, kolejność odpowiadających im nazw jest nieokreślona.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżący typ nie jest wyliczeniem.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca typ podstawowy elementu bieżącego typu wyliczenia.</summary>
        <returns>Podstawowy typ bieżącym wyliczeniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie jest podstawowym typem wyliczenia w języku C# i Visual Basic <xref:System.Int32>. Można określić innych typów całkowitych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżący typ nie jest wyliczeniem.  
  
—lub— 
Typ wyliczeniowy nie jest prawidłowy, ponieważ zawiera ona co najmniej jedno pole wystąpienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę wartości stałych do bieżącego typu wyliczenia.</summary>
        <returns>Tablica, która zawiera wartości. Elementy tablicy są sortowane według wartości binarnych (czyli wartości bez znaku) stałe wyliczeń.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Bieżący typ nie jest wyliczeniem.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określone zdarzenie zadeklarowane lub dziedziczone przez bieżącą <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę zdarzenia, które jest zadeklarowany lub jest dziedziczona przez bieżący <see cref="T:System.Type" />.</param>
        <summary>Zwraca <see cref="T:System.Reflection.EventInfo" /> obiekt reprezentujący określonego zdarzenia publiczne.</summary>
        <returns>Obiekt reprezentujący określonego zdarzenia publiczne, zadeklarowany lub dziedziczone przez bieżącą <see cref="T:System.Type" />, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenie jest uważane za publiczne odbicie, jeżeli ma co najmniej jedną metodę lub metodę dostępu, która jest publiczna. W przeciwnym razie zdarzenie jest traktowane jako prywatne i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.  
  
 Wyszukaj `name` jest uwzględniana wielkość liter. Wyszukiwanie uwzględnia publiczne static i public wystąpienia zdarzenia.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.EventInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje zdarzenia ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Reflection.EventInfo> obiektu i pobiera zdarzenia dla klasy przycisku dla określonego zdarzenia.  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę zdarzenia, które jest zadeklarowany lub jest dziedziczona przez bieżący <see cref="T:System.Type" />.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>Po przesłonięciu w klasie pochodnej zwraca <see cref="T:System.Reflection.EventInfo" /> obiekt reprezentujący określonych zdarzeń, za pomocą ograniczeń w określonym powiązaniu.</summary>
        <returns>Obiekt reprezentujący określonego zdarzenia, które jest zadeklarowany lub jest dziedziczona przez bieżący <see cref="T:System.Type" />, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania zdarzeń do uwzględnienia w wyszukiwaniu:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.  
  
-   Określ `BindingFlags.Public` obejmujący publicznych zdarzeń w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący zdarzenia niepubliczne (czyli prywatne, wewnętrzne i chronione zdarzenia) w wyszukiwaniu.  
  
-   Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko zdarzenia, które są zadeklarowane w <xref:System.Type>, nie te zdarzenia, które zostały po prostu odziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Zdarzenie jest uważane za publiczne odbicie, jeżeli ma co najmniej jedną metodę lub metodę dostępu, która jest publiczna. W przeciwnym razie zdarzenie jest traktowane jako prywatne i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.EventInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje zdarzenia ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> metody do wyszukiwania typu publiczne lub niepubliczna zdarzenie o nazwie "Kliknij" który nie jest `static` (`Shared` w języku Visual Basic).  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera zdarzenia, które są zadeklarowane lub dziedziczone przez bieżącą <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie publiczne zdarzenia, które są zadeklarowane lub dziedziczone przez bieżącą <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Reflection.EventInfo" /> obiekty reprezentujące wszystkie zdarzenia publiczne, które są zadeklarowane lub dziedziczone przez bieżącą <see cref="T:System.Type" />.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.EventInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma publicznych zdarzeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenie jest uważane za publiczne odbicie, jeżeli ma co najmniej jedną metodę lub metodę dostępu, która jest publiczna. W przeciwnym razie zdarzenie jest traktowane jako prywatne i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.  
  
 <xref:System.Type.GetEvents%2A> Metoda nie zwraca zdarzeń w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji. Twój kod nie może zależeć od kolejności, w której zwracane są zdarzenia, ponieważ kolejność się zmienia.  
  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.EventInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje zdarzenia ograniczenia klasy.  
  
   
  
## Examples  
 W poniższym przykładzie uzyskano tablicę <xref:System.Reflection.EventInfo> obiektów, pobiera wszystkie zdarzenia dla `Button` klasy, a następnie wyświetla nazwy zdarzenia. Aby skompilować przykład Visual Basic, użyj następującego polecenia:  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wyszukuje zdarzenia, które są zadeklarowane lub dziedziczone przez bieżącą <see cref="T:System.Type" />, za pomocą ograniczeń w określonym powiązaniu.</summary>
        <returns>Tablica <see cref="T:System.Reflection.EventInfo" /> obiekty reprezentujące wszystkie zdarzenia, które są zadeklarowane lub dziedziczone przez bieżącą <see cref="T:System.Type" /> zgodnych ograniczeń w określonym powiązaniu.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.EventInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma zdarzenia, lub jeśli żadna z tych zdarzeń ograniczenia wiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetEvents%2A> Metoda nie zwraca zdarzeń w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji. Twój kod nie może zależeć od kolejności, w której zwracane są zdarzenia, ponieważ kolejność się zmienia.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania zdarzeń do uwzględnienia w wyszukiwaniu:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.  
  
-   Określ `BindingFlags.Public` obejmujący publicznych zdarzeń w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący zdarzenia niepubliczne (czyli prywatne, wewnętrzne i chronione zdarzenia) w wyszukiwaniu. Tylko chroniony i zwracane są wewnętrzne zdarzenia w klasach bazowych; prywatne zdarzeń w klasach bazowych nie są zwracane.  
  
-   Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko zdarzenia, które są zadeklarowane w <xref:System.Type>, nie te zdarzenia, które zostały po prostu odziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Zdarzenie jest uważane za publiczne odbicie, jeżeli ma co najmniej jedną metodę lub metodę dostępu, która jest publiczna. W przeciwnym razie zdarzenie jest traktowane jako prywatne i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.EventInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje zdarzenia ograniczenia klasy.  
  
   
  
## Examples  
 W poniższym przykładzie uzyskano tablicę <xref:System.Reflection.EventInfo> obiektami spełniającymi podane flagi określone powiązanie pobiera wszystkie zdarzenia dla `Button` klasy, a następnie wyświetla nazwy zdarzenia. Aby skompilować przykład Visual Basic, użyj następującego polecenia:  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określonego pola bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę pola danych można pobrać.</param>
        <summary>Wyszukuje pole publiczne o określonej nazwie.</summary>
        <returns>Obiekt reprezentujący publiczne pole o określonej nazwie, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukaj `name` jest uwzględniana wielkość liter. Wyszukiwanie uwzględnia publiczne statyczne i publiczne pola wystąpień.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.FieldInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje pola ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład pobiera `Type` dla określonej klasy obiektu, uzyskuje <xref:System.Reflection.FieldInfo> obiektu dla pola i wyświetla wartość pola.  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">To <see cref="T:System.Type" /> obiekt jest <see cref="T:System.Reflection.Emit.TypeBuilder" /> którego <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> nie została jeszcze wywołana metoda.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę pola danych można pobrać.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>Wyszukuje określonego pola, za pomocą ograniczeń w określonym powiązaniu.</summary>
        <returns>Obiekt reprezentujący pola, które spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania pola do uwzględnienia w wyszukiwaniu:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.  
  
-   Określ `BindingFlags.Public` obejmujący pola publiczne w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący niepubliczne (czyli prywatne, wewnętrzne i chronione, pola) w wyszukiwaniu.  
  
-   Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko te pola, które są zadeklarowane w <xref:System.Type>, nie w przypadku pól, które zostały po prostu odziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.FieldInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje pola ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład pobiera `Type` dla określonej klasy obiektu, uzyskuje <xref:System.Reflection.FieldInfo> obiektu dla pola, które odpowiada flagi określone powiązanie i wyświetla wartość pola.  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera pola bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie publiczne pola bieżącego <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Reflection.FieldInfo" /> obiektów reprezentujących pola publiczne zdefiniowane dla bieżącego <see cref="T:System.Type" />.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.FieldInfo" />, jeśli nie ma publicznej pól zdefiniowanych dla bieżącego <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A> Metoda nie zwraca pola w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji. Twój kod nie może zależeć od kolejności, w której zwracane są pola, ponieważ kolejność się zmienia.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.FieldInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje pola publiczne ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład pokazuje wykorzystanie `GetFields()` metody.  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wyszukuje pól zdefiniowanych dla bieżącego <see cref="T:System.Type" />, za pomocą ograniczeń w określonym powiązaniu.</summary>
        <returns>Tablica <see cref="T:System.Reflection.FieldInfo" /> obiekty reprezentujące wszystkie pola zdefiniowane dla bieżącego <see cref="T:System.Type" /> zgodnych ograniczeń w określonym powiązaniu.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.FieldInfo" />, jeśli nie ma pól zdefiniowanych dla bieżącego <see cref="T:System.Type" />, lub jeśli żadne z pól zdefiniowanych być zgodne z ograniczeniami powiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A> Metoda nie zwraca pola w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji. Twój kod nie może zależeć od kolejności, w której zwracane są pola, ponieważ kolejność się zmienia.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania pola do uwzględnienia w wyszukiwaniu:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.  
  
-   Określ `BindingFlags.Public` obejmujący pola publiczne w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący niepubliczne (czyli prywatne, wewnętrzne i chronione, pola) w wyszukiwaniu. Tylko chronionych i wewnętrznych pól klasy bazowe są zwracane; pola prywatne na klasach bazowych nie są zwracane.  
  
-   Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko te pola, które są zadeklarowane w <xref:System.Type>, nie w przypadku pól, które zostały po prostu odziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.FieldInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje pola publiczne ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład pokazuje wykorzystanie `GetFields(BindingFlags)` metody.  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę <see cref="T:System.Type" /> obiekty reprezentujące argumentów typu zamkniętego typu ogólnego lub parametrów typu w definicji typu ogólnego.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiekty reprezentujące argumenty typu ogólnego typu. Zwraca pustą tablicę, jeśli bieżący typ nie jest typem ogólnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy tablicy są zwracane w kolejności, w jakiej są wyświetlane na liście argumentów typu dla typu ogólnego.  
  
-   Jeśli bieżącym typem jest zamknięty skonstruowanego typu (oznacza to, że <xref:System.Type.ContainsGenericParameters%2A> właściwość zwraca `false`), tablica zwrócona przez <xref:System.Type.GetGenericArguments%2A> metoda zawiera typy, które zostały przypisane do parametrów typu ogólnego definicji typu ogólnego .  
  
-   Jeśli bieżący typ jest definicja typu ogólnego, tablica zawiera parametry typu.  
  
-   Jeśli bieżący typ jest typem otwartym skonstruowany (oznacza to, <xref:System.Type.ContainsGenericParameters%2A> właściwość zwraca `true`), w których określonych typów nie zostały przypisane do wszystkich parametrów typu i parametrów typu w otaczającej typów ani metod ogólnych, tablica zawiera typy i parametrów typu. Użyj <xref:System.Type.IsGenericParameter%2A> właściwości, aby poinformować ich od siebie. Do pokazania w tym scenariuszu, zobacz przykład kodu dla <xref:System.Type.ContainsGenericParameters%2A> właściwości.  
  
 Aby uzyskać listę niezmiennych warunków dla terminów używanych w odbiciu rodzajowym, zobacz <xref:System.Type.IsGenericType%2A> uwagi dotyczące właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Type.GetGenericArguments%2A> metodę w celu wyświetlenia argumentów typu skonstruowanego typu i parametry typu jego definicję typu ogólnego.  
  
 Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Type.IsGenericTypeDefinition%2A> właściwości. Zobacz większego przykładu, aby uzyskać przykładowe dane wyjściowe.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej. Klasy pochodne muszą zapewniać implementację.</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę <see cref="T:System.Type" /> obiekty reprezentujące ograniczenia bieżącego ogólnego, parametr typu.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiekty reprezentujące ograniczenia bieżącego ogólnego, parametr typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każde ograniczenie parametru typu ogólnego jest wyrażona jako <xref:System.Type> obiektu. Użyj <xref:System.Type.IsClass%2A> właściwości w celu określenia, czy ograniczenie jest ograniczenie klasy bazowej; Jeśli właściwość ta zwraca `false`, ograniczenie jest ograniczenie interfejsu. Jeśli parametrem typu bez ograniczenia klasy i bez ograniczeń interfejsu, zwracana jest pusta tablica.  
  
 Aby uzyskać listę niezmiennych warunków dla terminów używanych w odbiciu rodzajowym, zobacz <xref:System.Type.IsGenericType%2A> uwagi dotyczące właściwości.  
  
   
  
## Examples  
 Poniższy kod definiuje typ ogólny `Test` z dwoma parametrami typu, które mają z nią związane inne ograniczenia. Gdy program będzie działać, ograniczenia są sprawdzane przy użyciu <xref:System.Type.GenericParameterAttributes%2A> właściwości i <xref:System.Type.GetGenericParameterConstraints%2A> metody.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący <see cref="T:System.Type" /> obiektu nie jest parametrem typu ogólnego. Oznacza to, że <see cref="P:System.Type.IsGenericParameter" /> właściwość zwraca <see langword="false" />.</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Type" /> obiekt, który reprezentuje definicji typu ogólnego, z którego można skonstruować bieżącego typu ogólnego.</summary>
        <returns>A <see cref="T:System.Type" /> obiekt reprezentujący typ ogólny, z którego można skonstruować bieżącego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definicja typu ogólnego jest szablonem, z którego można skonstruować innych typów. Na przykład z definicji typu ogólnego `G<T>` (wyrażony w języku C# składni; `G(Of T)` w języku Visual Basic lub `generic <typename T> ref class G` w języku C++) można utworzyć i utworzyć wystąpienie typu `G<int>` (`G(Of Integer)` w języku Visual Basic). Biorąc pod uwagę <xref:System.Type> obiekt reprezentujący to skonstruowany typ <xref:System.Type.GetGenericTypeDefinition%2A> metoda zwraca definicji typu ogólnego.  
  
 Jeśli dwa typy utworzone są tworzone na podstawie jednej definicji typu ogólnego, przy użyciu tych samych argumentów typu <xref:System.Type.GetGenericTypeDefinition%2A> metoda zwróci wartość taka sama <xref:System.Type> obiektu dla obu typów.  
  
 Jeśli wywołasz <xref:System.Type.GetGenericTypeDefinition%2A> metody <xref:System.Type> obiekt, który reprezentuje już definicji typu ogólnego, funkcja zwraca bieżący <xref:System.Type>.  
  
> [!IMPORTANT]
>  Tablica typów ogólnych nie jest sam ogólny. W kodzie języka C# `A<int>[] v;` lub kod języka Visual Basic `Dim v() As A(Of Integer)`, typ zmiennej `v` nie jest ogólna. Użyj <xref:System.Type.IsGenericType%2A> do ustalenia, czy typ jest ogólny przed wywołaniem <xref:System.Type.GetGenericTypeDefinition%2A>.  
  
 Aby uzyskać listę niezmiennych warunków dla terminów używanych w odbiciu rodzajowym, zobacz <xref:System.Type.IsGenericType%2A> uwagi dotyczące właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy wystąpienie skonstruowanego typu za pomocą tworzenia zwykłego wystąpienia, a następnie używa <xref:System.Type.GetType%2A> i <xref:System.Type.GetGenericTypeDefinition%2A> metody, aby pobrać skonstruowanego typu i definicji typu ogólnego. W tym przykładzie użyto ogólnego <xref:System.Collections.Generic.Dictionary%602> typ; reprezentuje zbudowany typ <xref:System.Collections.Generic.Dictionary%602> z `Test` obiektów za pomocą kluczy ciągu.  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący typ nie jest typem ogólnym.  Oznacza to, że <see cref="P:System.Type.IsGenericType" /> zwraca <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej. Klasy pochodne muszą zapewniać implementację.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego wystąpienia.</summary>
        <returns>Kod skrótu dla tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład wyświetla skrótu `System.Windows.Forms.Button` klasy.  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określony interfejs implementowany lub jest dziedziczona przez bieżący <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę interfejsu można pobrać. Interfejsy ogólne to zniekształcone nazwy.</param>
        <summary>Wyszukuje interfejsu o określonej nazwie.</summary>
        <returns>Obiekt reprezentujący interfejs o określonej nazwie zaimplementować lub dziedziczone przez bieżącą <see cref="T:System.Type" />, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukaj `name` jest uwzględniana wielkość liter.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Type> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje ograniczenia interfejsu i wszelkie interfejsy odziedziczone ograniczenia klasy lub interfejsu.  
  
> [!NOTE]
>  W przypadku ogólnych interfejsów `name` parametr jest zniekształcone nazwy, kończąc akcent (\`) i liczbę parametrów typu. Dotyczy to zarówno dla definicji interfejsów ogólnych i skonstruowany interfejsów ogólnych. Na przykład, aby znaleźć `IExample<T>` (`IExample(Of T)` w języku Visual Basic) lub `IExample<string>` (`IExample(Of String)` w języku Visual Basic), wyszukaj ``"IExample`1"``.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Type.GetInterface%28System.String%29> metodę wyszukiwania <xref:System.Collections.Hashtable> klasy dla <xref:System.Runtime.Serialization.IDeserializationCallback> interfejsu list i metody interfejsu.  
  
 Przykład kodu ilustruje też <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> przeciążenie metody i <xref:System.Type.GetInterfaceMap%2A> metody.  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Bieżący <see cref="T:System.Type" /> reprezentuje typ, który implementuje ten interfejs ogólny z argumentami innego typu.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę interfejsu można pobrać. Interfejsy ogólne to zniekształcone nazwy.</param>
        <param name="ignoreCase"><see langword="true" /> ignorowanie wielkości liter w tej części <paramref name="name" /> , który określa nazwę prosty interfejs (part, który określa przestrzeń nazw musi być poprawnie z uwzględnieniem wielkości liter).  
  
—lub— 
 <see langword="false" /> Aby wykonać wyszukiwanie dla wszystkich części <paramref name="name" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wyszukuje określonego interfejsu, określająca, czy wykonać wyszukiwanie bez uwzględniania wielkości liter z nazwą interfejsu.</summary>
        <returns>Obiekt reprezentujący interfejs o określonej nazwie zaimplementować lub dziedziczone przez bieżącą <see cref="T:System.Type" />, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ignoreCase` Parametr dotyczy tylko nazwę prosty interfejs, a nie do przestrzeni nazw. Część `name` , który określa przestrzeń nazw musi mieć poprawną wielkość lub interfejsu nie zostanie znaleziony. Na przykład ciąg "System.icomparable" znajdzie <xref:System.IComparable> interfejsu, lecz ciąg "system.icomparable" nie ma.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Type> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje ograniczenia interfejsu i wszelkie interfejsy odziedziczone ograniczenia klasy lub interfejsu.  
  
> [!NOTE]
>  W przypadku ogólnych interfejsów `name` parametr jest zniekształcone nazwy, kończąc akcent (\`) i liczbę parametrów typu. Dotyczy to zarówno dla definicji interfejsów ogólnych i skonstruowany interfejsów ogólnych. Na przykład, aby znaleźć `IExample<T>` (`IExample(Of T)` w języku Visual Basic) lub `IExample<string>` (`IExample(Of String)` w języku Visual Basic), wyszukaj `"IExample`1"".  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> metodę, aby wykonać wyszukiwanie bez uwzględniania wielkości liter z <xref:System.Collections.Hashtable> klasy dla <xref:System.Collections.IEnumerable> interfejsu.  
  
 Przykład kodu ilustruje też <xref:System.Type.GetInterface%28System.String%29> przeciążenie metody i <xref:System.Type.GetInterfaceMap%2A> metody.  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Bieżący <see cref="T:System.Type" /> reprezentuje typ, który implementuje ten interfejs ogólny z argumentami innego typu.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">Typ interfejsu, który można pobrać mapowanie.</param>
        <summary>Zwraca mapowania interfejsu dla typu określonego interfejsu.</summary>
        <returns>Obiekt, który reprezentuje mapowania interfejsu dla <paramref name="interfaceType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mapę interfejsu wskazuje, jak interfejs jest mapowany do rzeczywiste elementy członkowskie dla klasy, która implementuje ten interfejs.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, parametry są zastępowane przez odpowiednie argumenty typu w elementach typu <xref:System.Reflection.InterfaceMapping> zwracanego przez tę metodę.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Type.GetInterfaceMap%2A> metodę pozwala ustalić jak <xref:System.IFormatProvider> mapuje interfejsu <xref:System.Globalization.CultureInfo> metod i sposób, w jaki <xref:System.IAppDomainSetup> mapuje interfejsu <xref:System.AppDomainSetup> właściwości. Należy zauważyć, że ponieważ <xref:System.IAppDomainSetup> interfejs definiuje zestaw właściwości zwracanego <xref:System.Reflection.InterfaceMapping> obiekt zawiera osobne <xref:System.Reflection.MethodInfo> obiektów dla właściwości get i set metod dostępu.  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="interfaceType" /> nie jest zaimplementowana przez bieżący typ.  
  
—lub— 
<paramref name="interfaceType" /> Argumentu nie odwołuje się do interfejsu.  
  
—lub—

Bieżące wystąpienie lub <paramref name="interfaceType" /> argument jest to otwarty typ ogólny; czyli, <see cref="P:System.Type.ContainsGenericParameters" /> właściwość zwraca <see langword="true" />.

—lub—


 <paramref name="interfaceType" /> jest to interfejs generyczny i bieżącym typem jest typem tablicy.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="interfaceType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżący <see cref="T:System.Type" /> reprezentuje parametr typu ogólnego; czyli <see cref="P:System.Type.IsGenericParameter" /> jest <see langword="true" />.</exception>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej. Klasy pochodne muszą zapewniać implementację.</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wszystkie interfejsy implementowane lub dziedziczone przez bieżącą <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiekty reprezentujące wszystkie interfejsy implementowane lub jest dziedziczona przez bieżący <see cref="T:System.Type" />.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" />, jeśli interfejsy nie są implementowane lub dziedziczone przez bieżącą <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetInterfaces%2A> Metoda nie zwraca interfejsów w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji. Twój kod nie może zależeć od kolejności, w której zwracane są interfejsy, ponieważ kolejność się zmienia.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Type> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje ograniczenia interfejsu i wszelkie interfejsy odziedziczone ograniczenia klasy lub interfejsu.  
  
   
  
## Examples  
 Poniższy przykład pobiera typ określonej klasy i wyświetla wszystkie interfejsy, które typ implementuje lub dziedziczy. Aby skompilować przykład Visual Basic, użyj następujących poleceń kompilatora:  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Statycznego inicjatora jest wywoływany i zgłasza wyjątek.</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określony członków bieżącej <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę publiczne elementy członkowskie można pobrać.</param>
        <summary>Wyszukuje publiczne elementy członkowskie o określonej nazwie.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące publiczne elementy członkowskie o określonej nazwie, jeśli je znaleziono; w przeciwnym razie, pusta tablica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukaj `name` jest uwzględniana wielkość liter. Wyszukiwanie zawiera elementy publiczne wystąpienia static i public.  
  
 Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.  
  
 <xref:System.Type.GetMember%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji. Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.  
  
 Tego przeciążenia metody nie znajdzie inicjatory klasy (.cctor). Aby znaleźć klasy inicjatory, użyj przeciążenia, które przyjmuje <xref:System.Reflection.BindingFlags>, a następnie określ <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic). Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MemberInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje składowe ograniczenia klasy lub elementów członkowskich <xref:System.Object> przypadku bez ograniczenia klasy.  
  
> [!NOTE]
>  Dla metod rodzajowych nie ma argumentów typu w parametrze `name`. Na przykład, kod C# `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` ma jeden argument rodzajowy typu `int`.  
  
   
  
## Examples  
 Poniższy przykład wyświetla wszystkie elementy członkowskie `String` klasy, które zaczynają się na literę C.  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę elementy członkowskie można pobrać.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić pustą tablicę.</param>
        <summary>Wyszukuje określony elementów członkowskich za pomocą ograniczeń w określonym powiązaniu.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące publiczne elementy członkowskie o określonej nazwie, jeśli je znaleziono; w przeciwnym razie, pusta tablica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
 Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.  
  
 <xref:System.Type.GetMember%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji. Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania elementów członkowskich, które można uwzględnić w wyszukiwaniu:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.  
  
-   Określ `BindingFlags.Public` obejmujący publiczne elementy członkowskie w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący elementów członkowskich niepublicznych (czyli prywatne, wewnętrzne i chronione elementy członkowskie) w wyszukiwaniu.  
  
-   Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko do elementów członkowskich zadeklarowanych w <xref:System.Type>, nie elementów członkowskich, które zostały po prostu odziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Aby uzyskać inicjatora klasy (.cctor), za pomocą tego przeciążenia metody, należy określić ".cctor" dla `name`, i <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic) dla `bindingAttr`. Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MemberInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje składowe ograniczenia klasy lub elementów członkowskich <xref:System.Object> przypadku bez ograniczenia klasy.  
  
> [!NOTE]
>  Dla metod rodzajowych nie ma argumentów typu w parametrze `name`. Na przykład, kod C# `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` ma jeden argument rodzajowy typu `int`.  
  
   
  
## Examples  
 Poniższy przykład wyświetla wszystkie publiczne statyczne elementy członkowskie `myString` klasy, które zaczynają się na literę C.  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę elementy członkowskie można pobrać.</param>
        <param name="type">Wartość do wyszukania.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić pustą tablicę.</param>
        <summary>Wyszukuje określony elementy członkowskie typu określonego elementu członkowskiego, za pomocą ograniczeń w określonym powiązaniu.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące publiczne elementy członkowskie o określonej nazwie, jeśli je znaleziono; w przeciwnym razie, pusta tablica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.  
  
 <xref:System.Type.GetMember%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji. Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania elementów członkowskich, które można uwzględnić w wyszukiwaniu:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.  
  
-   Określ `BindingFlags.Public` obejmujący publiczne elementy członkowskie w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący elementów członkowskich niepublicznych (czyli prywatne, wewnętrzne i chronione elementy członkowskie) w wyszukiwaniu.  
  
-   Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko do elementów członkowskich zadeklarowanych w <xref:System.Type>, nie elementów członkowskich, które zostały po prostu odziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Aby uzyskać inicjatora klasy (.cctor), za pomocą tego przeciążenia metody, należy określić ".cctor" dla `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> dla `type`, i <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w Visual Basic) dla `bindingAttr`. Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MemberInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje składowe ograniczenia klasy lub elementów członkowskich <xref:System.Object> przypadku bez ograniczenia klasy.  
  
> [!NOTE]
>  Dla metod rodzajowych nie ma argumentów typu w parametrze `name`. Na przykład, kod C# `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` ma jeden argument rodzajowy typu `int`.  
  
   
  
## Examples  
 Poniższy przykład wyświetla wszystkie metody `myString` klasy, które zaczynają się na literę C.  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Klasy pochodnej musi zapewniać implementację.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera elementy członkowskie (właściwości, metody, pola, zdarzenia i tak dalej) bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie publiczne elementy członkowskie bieżącego <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące wszystkie publiczne elementy członkowskie bieżącego <see cref="T:System.Type" />.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.MemberInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma publicznych elementów członkowskich.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.  
  
 <xref:System.Type.GetMembers%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji. Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.  
  
 Tego przeciążenia metody wywołuje <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> przeciążenie metody z <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> w języku Visual Basic). Inicjatory klasy (.cctor) nie zostanie odnaleziony. Aby znaleźć klasy inicjatory, użyj przeciążenia, które przyjmuje <xref:System.Reflection.BindingFlags>, a następnie określ <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic). Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MemberInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje składowe ograniczenia klasy lub elementów członkowskich <xref:System.Object> przypadku bez ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Type.GetMembers> przeciążenia metody, aby zbierać informacje o wszystkich publicznych elementów członkowskich określonej klasy.  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero (<see cref="F:System.Reflection.BindingFlags.Default" />), aby zwrócić pustą tablicę.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wyszukuje elementy członkowskie zdefiniowane dla bieżącego <see cref="T:System.Type" />, za pomocą ograniczeń w określonym powiązaniu.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące wszystkie elementy członkowskie zdefiniowane dla bieżącego <see cref="T:System.Type" /> zgodnych ograniczeń w określonym powiązaniu.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.MemberInfo" />, jeśli żadne składowe są zdefiniowane dla bieżącego <see cref="T:System.Type" />, lub jeśli żadna z określonych elementów członkowskich ograniczenia wiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.  
  
 <xref:System.Type.GetMembers%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji. Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania elementów członkowskich, które można uwzględnić w wyszukiwaniu:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.  
  
-   Określ `BindingFlags.Public` obejmujący publiczne elementy członkowskie w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący elementów członkowskich niepublicznych (czyli prywatne, wewnętrzne i chronione elementy członkowskie) w wyszukiwaniu. Tylko chronionych i wewnętrznych składowych w klasach bazowych są zwracane; prywatne elementy członkowskie na klasach bazowych nie są zwracane.  
  
-   Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko do elementów członkowskich zadeklarowanych w <xref:System.Type>, nie elementów członkowskich, które zostały po prostu odziedziczone.  
  
 Wywołanie tej metody tylko z `Public` flagi lub tylko `NonPublic` flagi zwróci określone elementy członkowskie i nie wymaga inne flagi.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Aby uzyskać inicjatora klasy (.cctor), za pomocą tego przeciążenia metody, należy określić <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic). Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 Jeśli bieżący element T:System.Type reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MemberInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje składowe ograniczenia klasy lub elementów członkowskich <xref:System.Object> przypadku bez ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> przeciążenia metody, aby zbierać informacje o wszystkich członków publiczne wystąpienia określonej klasy.  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określonej metody bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę publicznej metody pobierania.</param>
        <summary>Wyszukuje publicznej metody o określonej nazwie.</summary>
        <returns>Obiekt, który reprezentuje publicznej metody o określonej nazwie, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukaj `name` jest uwzględniana wielkość liter. Wyszukiwanie obejmuje metody publiczne wystąpienia static i public.  
  
 Jeśli metoda jest przeciążona i ma więcej niż jednej metody publiczne, <xref:System.Type.GetMethod%28System.String%29> metoda zgłasza wyjątek <xref:System.Reflection.AmbiguousMatchException> wyjątku. W poniższym przykładzie, jest zgłaszany wyjątek, ponieważ ma więcej niż jednego przeciążenia publicznych <xref:System.Int32.ToString%2A?displayProperty=nameWithType> metody.  Z drugiej strony ponieważ `Person.ToString` zastąpienia metody <xref:System.Object.ToString%2A?displayProperty=nameWithType> i dlatego nie jest przeciążona, <xref:System.Type.GetMethod%28System.String%29> metoda jest w stanie pobrać <xref:System.Reflection.MethodInfo> obiektu.  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 Możesz wykonać jedną z następujących czynności, aby pobrać określonej metody:  
  
-   Wywołaj <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> metodę i określić `bindingAttr` argument, który unikatowo identyfikuje metodę. Na przykład, jeśli wyjątek jest zgłaszany, ponieważ typ ma statycznych i przeciążenie wystąpienia, można określić `bindingAttr` argument <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.  
  
-   Wywołanie przeciążenia <xref:System.Type.GetMethod%2A> metodę, która obejmuje `types` parametr, który definiuje typy parametrów metody.  
  
-   Wywołaj <xref:System.Type.GetMethods> metodę, która pobierze tablicę zawierającą wszystkie metody publiczne, należącymi do typu. Można następnie wykonać iterację do identyfikowania zduplikowanych metody o nazwie `name`.  
  
 Jeśli bieżący element T:System.Type reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MethodInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje metody ograniczenia klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.  
  
> [!NOTE]
>  Dla metod rodzajowych nie ma argumentów typu w parametrze `name`. Na przykład, kod C# `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` ma jeden argument rodzajowy typu `int`.  
  
   
  
## Examples  
 Poniższy przykład pobiera metodę o nazwie `MethodA`.  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jednej metody o określonej nazwie.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę metody pobierania.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>Wyszukiwanie określonej metody, za pomocą ograniczeń w określonym powiązaniu.</summary>
        <returns>Obiekt reprezentujący metodę, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania metod do uwzględnienia w wyszukiwaniu:  
  
-   Należy określić <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> lub <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> w celu uzyskania zwrotu.  
  
-   Określ <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> obejmujący metod publicznych w wyszukiwaniu.  
  
-   Określ <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> obejmujący metod niepublicznych (czyli prywatne, wewnętrzne i chronione metody) do wyszukiwania.  
  
-   Określ <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> Aby zignorować wielkość liter `name`.  
  
-   <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> Aby wyszukać tylko metod zadeklarowanych w <xref:System.Type>, nie metod, które zostały po prostu odziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Jeśli metoda jest przeciążona i więcej niż jednego przeciążenia spełnia ograniczenia określone przez `bindingAttr` argument, metoda zgłasza <xref:System.Reflection.AmbiguousMatchException> wyjątku. W poniższym przykładzie jest zgłaszany wyjątek, ponieważ:  
  
-   `TestClass` Typ ma dwa przeciążenia publiczne wystąpienia `DisplayValue` metody `DisplayValue(String)` i `DisplayValue(String, Object[])`.  
  
-   `TestClass` Typ ma dwa przeciążenia publiczne wystąpienia `Equals` metody, z których jeden jest dziedziczony z <xref:System.Object>: `Equals(TestClass)` i `Equals(Object)`.  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 Możesz wykonać jedną z następujących czynności, aby pobrać określonej metody:  
  
-   Zmienić ograniczenia wiązania. W poprzednim przykładzie próby pobrania publiczne wystąpienia `Equals` pobiera metodę, która jest deklarowana przez typ i nie są dziedziczone pomyślnie `Equals(TestClass)`.  
  
-   Wywołanie przeciążenia <xref:System.Type.GetMethod%2A> metodę, która obejmuje `types` parametr, który definiuje typy parametrów metody.  
  
-   Wywołaj <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> metodę, która pobierze tablicę zawierającą wszystkie metody należące do typu, które mają atrybuty określonego powiązania. Można następnie wykonać iterację do identyfikowania zduplikowanych metody o nazwie `name`. Podejście to zostało zilustrowane w poprzednim przykładzie obsługa <xref:System.Reflection.AmbiguousMatchException> wyjątku.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MethodInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje metody ograniczenia klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.  
  
> [!NOTE]
>  Dla metod rodzajowych nie ma argumentów typu w parametrze `name`. Na przykład, kod C# `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` ma jeden argument rodzajowy typu `int`.  
  
   
  
## Examples  
 Poniższy przykład pobiera metodę, która spełnia określone powiązanie flag.  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną metodę o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę publicznej metody pobierania.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla metody, aby uzyskać.  
  
—lub— 
Pusta tablica <see cref="T:System.Type" /> obiektów (zgodnie z informacjami od <see cref="F:System.Type.EmptyTypes" /> pole) do uzyskania metody, która nie przyjmuje żadnych parametrów.</param>
        <summary>Wyszukiwanie określonej metody publiczne, której parametry pasuje określone typy argumentów.</summary>
        <returns>Obiekt reprezentujący publicznej metody, której parametry pasuje określone typy argumentów, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukaj `name` jest uwzględniana wielkość liter. Wyszukiwanie obejmuje metody publiczne wystąpienia static i public.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MethodInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje metody ograniczenia klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.  
  
> [!NOTE]
>  `name` Parametru nie może zawierać argumentów typu. Na przykład, kod C# `GetMethod("MyGenericMethod<int>")` wyszukuje metody o nazwie tekst "`MyGenericMethod<int>`", a nie dla metodę o nazwie `MyGenericMethod` ma jeden argument rodzajowy typu `int`. Zamiast tego należy użyć `GetMethod("MyGenericMethod")` za pomocą odpowiednich parametrów w `types` tablicy.  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie określonego przeciążenia `MethodA`, określając różne typy argumentów.  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Przykład wymaga `/unsafe` — opcja kompilatora.  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 Poniższy przykład pobiera <xref:System.Reflection.MethodInfo> obiekty reprezentujące `Add` metod typu nieogólnego ( <xref:System.Collections.ArrayList> klasy), to otwarty typ ogólny ( <xref:System.Collections.Generic.List%601> klasy), a typem ogólnym zamknięte ( `List(Of String)` typu.  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 W przykładzie zdefiniowano `GetAddMethod` metodę, która pobiera odpowiednie <xref:System.Reflection.MethodInfo> obiektu. Aby zapewnić `types` argument to otwarty typ ogólny, wywoływanych przez nią <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metody. Aby zapewnić `types` argument zamknięty typ ogólny, pobiera wartość <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Więcej niż jednej metody znajduje się o określonej nazwie i określić parametry.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="types" /> jest <see langword="null" />.  
  
—lub— 
Jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ma charakter wielowymiarowy.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę publicznej metody pobierania.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla metody, aby uzyskać.  
  
—lub— 
Pusta tablica <see cref="T:System.Type" /> obiektów (zgodnie z informacjami od <see cref="F:System.Type.EmptyTypes" /> pole) do uzyskania metody, która nie przyjmuje żadnych parametrów.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <paramref name="types" /> tablicy. Można używać tylko podczas wywoływania przez parametry międzyoperacyjności i tylko wtedy COM, które są przekazywane przez odwołanie, są obsługiwane. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Wyszukiwanie określonej metody publiczne, której parametry odpowiadają określone typy argumentów i modyfikatorów.</summary>
        <returns>Obiekt reprezentujący metodę publiczną, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że domyślny integrator nie przetwarza <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `modifiers`. `ParameterModifier` jest używana tylko podczas wywoływania przez współdziałania z modelem COM i są obsługiwane tylko w przypadku parametrów, które są przekazywane przez odwołanie.  
  
 Wyszukaj `name` jest uwzględniana wielkość liter. Wyszukiwanie obejmuje metody publiczne wystąpienia static i public.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący element T:System.Type reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MethodInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje metody ograniczenia klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.  
  
> [!NOTE]
>  Dla metod rodzajowych nie ma argumentów typu w parametrze `name`. Na przykład, kod C# `GetMethod("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` ma jeden argument rodzajowy typu `int`. Zamiast tego należy użyć `GetMethod("MyMethod")` za pomocą odpowiednich parametrów w `types` tablicy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Więcej niż jednej metody znajduje się o określonej nazwie i określić parametry.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="types" /> jest <see langword="null" />.  
  
—lub— 
Jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ma charakter wielowymiarowy.  
  
—lub— 
 <paramref name="modifiers" /> ma charakter wielowymiarowy.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę metody pobierania.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla metody, aby uzyskać.  
  
—lub— 
Pusta tablica <see cref="T:System.Type" /> obiektów (zgodnie z informacjami od <see cref="F:System.Type.EmptyTypes" /> pole) do uzyskania metody, która nie przyjmuje żadnych parametrów.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <paramref name="types" /> tablicy. Można używać tylko podczas wywoływania przez parametry międzyoperacyjności i tylko wtedy COM, które są przekazywane przez odwołanie, są obsługiwane. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Wyszukuje określoną metodę, której parametry odpowiadają określone typy argumentów i modyfikatorów, za pomocą ograniczeń w określonym powiązaniu.</summary>
        <returns>Obiekt reprezentujący metodę, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że domyślny integrator nie przetwarza <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `modifiers`. `ParameterModifier` jest używana tylko podczas wywoływania przez współdziałania z modelem COM i są obsługiwane tylko w przypadku parametrów, które są przekazywane przez odwołanie.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania metod do uwzględnienia w wyszukiwaniu:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.  
  
-   Określ `BindingFlags.Public` obejmujący metod publicznych w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący metod niepublicznych (czyli prywatne, wewnętrzne i chronione metody) do wyszukiwania.  
  
-   Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko metod zadeklarowanych w <xref:System.Type>, nie metod, które zostały po prostu odziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący element T:System.Type reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MethodInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje metody ograniczenia klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.  
  
> [!NOTE]
>  Dla metod rodzajowych nie ma argumentów typu w parametrze `name`. Na przykład, kod C# `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` ma jeden argument rodzajowy typu `int`.  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie określonego przeciążenia `MethodA`, określając ograniczenia wiązania i różne typy argumentów.  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Przykład wymaga `/unsafe` — opcja kompilatora.  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną metodę o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="types" /> jest <see langword="null" />.  
  
—lub— 
Jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ma charakter wielowymiarowy.  
  
—lub— 
 <paramref name="modifiers" /> ma charakter wielowymiarowy.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę metody pobierania.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Obiekt, który określa zestaw reguł dotyczących kolejności i układ argumentów, jak wartość zwracana jest przekazywana, jakie rejestrów są używane dla argumentów i jak stos jest czyszczony.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla metody, aby uzyskać.  
  
—lub— 
Pusta tablica <see cref="T:System.Type" /> obiektów (zgodnie z informacjami od <see cref="F:System.Type.EmptyTypes" /> pole) do uzyskania metody, która nie przyjmuje żadnych parametrów.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <paramref name="types" /> tablicy. Można używać tylko podczas wywoływania przez parametry międzyoperacyjności i tylko wtedy COM, które są przekazywane przez odwołanie, są obsługiwane. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Wyszukuje określoną metodę, której parametry odpowiadają określone typy argumentów i modyfikatorów, za pomocą ograniczeń w określonym powiązaniu i określonej konwencji wywoływania.</summary>
        <returns>Obiekt reprezentujący metodę, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że domyślny integrator nie przetwarza <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `modifiers`. `ParameterModifier` jest używana tylko podczas wywoływania przez współdziałania z modelem COM i są obsługiwane tylko w przypadku parametrów, które są przekazywane przez odwołanie.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `GetXXX` metody uwzględnianiem typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania metod do uwzględnienia w wyszukiwaniu:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.  
  
-   Określ `BindingFlags.Public` obejmujący metod publicznych w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący metod niepublicznych (czyli prywatne, wewnętrzne i chronione metody) do wyszukiwania.  
  
-   Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko metod zadeklarowanych w <xref:System.Type>, nie metod, które zostały po prostu odziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący element T:System.Type reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MethodInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje metody ograniczenia klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.  
  
> [!NOTE]
>  Dla metod rodzajowych nie ma argumentów typu w parametrze `name`. Na przykład, kod C# `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` ma jeden argument rodzajowy typu `int`.  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie określonego przeciążenia `MethodA`, określając ograniczenia wiązania, Konwencje wywoływania oraz różne typy argumentów.  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Przykład wymaga `/unsafe` — opcja kompilatora.  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną metodę o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="types" /> jest <see langword="null" />.  
  
—lub— 
Jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ma charakter wielowymiarowy.  
  
—lub— 
 <paramref name="modifiers" /> ma charakter wielowymiarowy.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę metody pobierania.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Obiekt, który określa zestaw reguł dotyczących kolejności i układu argumentów, jak wartość zwracana jest przekazywana, jakie rejestrów są używane dla argumentów i jakie procesy czyści stos.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla metody, aby uzyskać.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie metodę, która nie przyjmuje żadnych parametrów.  
  
—lub— 
 <see langword="null" />. Jeśli <paramref name="types" /> jest <see langword="null" />, argumenty nie zostały dopasowane.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <paramref name="types" /> tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wyszukuje określoną metodę, której parametry odpowiadają określone typy argumentów i modyfikatorów, korzystając z ograniczeń w określonym powiązaniu i określonej konwencji wywoływania.</summary>
        <returns>Obiekt reprezentujący metodę, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że domyślny integrator nie przetwarza <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `modifiers`. `ParameterModifier` jest używana tylko podczas wywoływania przez współdziałania z modelem COM i są obsługiwane tylko w przypadku parametrów, które są przekazywane przez odwołanie.  
  
 Jeśli `types` jest `null`, argumenty nie zostały dopasowane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania metod do uwzględnienia w wyszukiwaniu:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.  
  
-   Określ `BindingFlags.Public` obejmujący metod publicznych w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący metod niepublicznych (czyli prywatne, wewnętrzne i chronione metody) do wyszukiwania.  
  
-   Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko metod zadeklarowanych w <xref:System.Type>, nie metod, które zostały po prostu odziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną metodę o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ma charakter wielowymiarowy.  
  
—lub— 
 <paramref name="modifiers" /> ma charakter wielowymiarowy.  
  
—lub— 
 <paramref name="types" /> i <paramref name="modifiers" /> nie mają tę samą długość.</exception>
        <exception cref="T:System.NotSupportedException">Bieżącym typem jest <see cref="T:System.Reflection.Emit.TypeBuilder" /> lub <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera metody bieżący <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie metody publiczne bieżącego <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MethodInfo" /> obiekty reprezentujące wszystkie metody publiczne zdefiniowane dla bieżącego <see cref="T:System.Type" />.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.MethodInfo" />, jeśli nie metody publiczne są zdefiniowane dla bieżącego <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetMethods%2A> Metoda nie zwraca metod w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji. Twój kod nie może zależeć od kolejności, w której zwracane są metody, ponieważ kolejność się zmienia.  
  
 Konstruktory nie są uwzględnione w tablicy zwrócony przez wywołanie tej metody. Wywołania oddzielnych `GetConstructors()` można pobrać metody konstruktora.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący element T:System.Type reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MethodInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje metody ograniczenia klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wyszukuje metody zdefiniowane dla bieżącego <see cref="T:System.Type" />, za pomocą ograniczeń w określonym powiązaniu.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MethodInfo" /> obiekty reprezentujące wszystkie metody zdefiniowane dla bieżącego <see cref="T:System.Type" /> zgodnych ograniczeń w określonym powiązaniu.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.MethodInfo" />, jeśli nie metody są zdefiniowane dla bieżącego <see cref="T:System.Type" />, lub jeśli żadna z metody zdefiniowane ograniczenia wiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetMethods%2A> Metoda nie zwraca metod w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji. Twój kod nie może zależeć od kolejności, w której zwracane są metody, ponieważ kolejność się zmienia.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania metod do uwzględnienia w wyszukiwaniu:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.  
  
-   Określ `BindingFlags.Public` obejmujący metod publicznych w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący metod niepublicznych (czyli prywatne, wewnętrzne i chronione metody) do wyszukiwania. Tylko chronionych i wewnętrznych metod w klasach bazowych są zwracane; metody prywatne na klasach bazowych nie są zwracane.  
  
-   Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko metod zadeklarowanych w <xref:System.Type>, nie metod, które zostały po prostu odziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący element T:System.Type reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MethodInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje metody ograniczenia klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę za pomocą dwóch metod publicznych i jedną metodę chronionych, tworzy `Type` obiekt odpowiadający `MyTypeClass`wszystkich metod publicznych i niepublicznych pobiera i wyświetla ich nazwy.  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określonego typu zagnieżdżone w obrębie bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę typu zagnieżdżonego, aby uzyskać.</param>
        <summary>Wyszukuje publicznego typu zagnieżdżonego o określonej nazwie.</summary>
        <returns>Obiekt reprezentujący publicznego typu zagnieżdżonego o określonej nazwie, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukaj `name` jest uwzględniana wielkość liter.  
  
 Użyj prostych nazwy klasy zagnieżdżonej dla `name`. Nie kwalifikuje się on z nazwą klasy zewnętrznej. Ogólne klasy zagnieżdżonej Użyj zniekształcone nazwy — to znaczy, Dołącz akcent i liczby argumentów rodzajowych. Na przykład użyć ciągu "wewnętrzny\`1" Aby uzyskać ogólny klasy zagnieżdżonej `Inner<T>` (`Inner(Of T)` w języku Visual Basic). Nie dołączaj parametrów typu składnia specyficzny dla języka.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje zagnieżdżone typy ograniczenia klasy.  
  
 Jeśli zagnieżdżony jest typ ogólny , metoda ta zwraca jego definicję typu ogólnego. Ta zasada obowiązuje, nawet jeśli otaczający typ ogólny jest skonstruowany jako zamknięty.  
  
> [!NOTE]
>  Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny zdefiniowany w języku C#, Visual Basic lub C++, jego zagnieżdżone typy są rodzajowe, nawet jeśli mają one nie parametrów ogólnych swoich własnych. To nie jest konieczne zagnieżdżonych typów zdefiniowanych w zestawach dynamicznych lub skompilowanych z [Ilasm.exe (asembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Aby uzyskać informacje o zagnieżdżonych typach rodzajowych oraz o konstruowaniu zagnieżdżonych typów rodzajowych z definicjami typu ogólnego, zobacz <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę typu zagnieżdżonego, aby uzyskać.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wyszukuje określonego typu zagnieżdżonego, za pomocą ograniczeń w określonym powiązaniu.</summary>
        <returns>Obiekt reprezentujący typ zagnieżdżony, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj prostych nazwy klasy zagnieżdżonej dla `name`. Nie kwalifikuje się on z nazwą klasy zewnętrznej. Ogólne klasy zagnieżdżonej Użyj zniekształcone nazwy — to znaczy, Dołącz akcent i liczby parametrów ogólnych. Na przykład użyć ciągu "wewnętrzny\`1" Aby uzyskać ogólny klasy zagnieżdżonej `Inner<T>` (`Inner(Of T)` w języku Visual Basic). Nie dołączaj parametrów typu składnia specyficzny dla języka.  
  
 Następujące <xref:System.Reflection.BindingFlags> filtr flagi może służyć do definiowania, które zagnieżdżonych typów do uwzględnienia w wyszukiwaniu:  
  
-   Należy określić <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> lub <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> do uzyskania zwrotu.  
  
-   Określ <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> obejmujący publiczne typy zagnieżdżone w wyszukiwaniu.  
  
-   Określ <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> obejmujący zagnieżdżonych typów niepublicznych (czyli prywatne, wewnętrzne i chronione typy zagnieżdżone) do wyszukiwania.  
  
 Ta metoda zwraca zagnieżdżone typy bieżącego typu. Wyszukiwanie klas bazowych bieżącego typu nie jest. Aby znaleźć typy, które są zagnieżdżone w klasach bazowych, musi zaprezentuje hierarchii dziedziczenia wywoływania <xref:System.Type.GetNestedType%2A> na każdym poziomie.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> i <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> są ignorowane.  
  
 Wywołanie tej metody tylko z <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flagi lub tylko <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flagi zwróci określoną zagnieżdżonych typów i nie wymaga inne flagi.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje zagnieżdżone typy ograniczenia klasy.  
  
 Jeśli zagnieżdżony jest typ ogólny , metoda ta zwraca jego definicję typu ogólnego. Ta zasada obowiązuje, nawet jeśli otaczający typ ogólny jest skonstruowany jako zamknięty.  
  
> [!NOTE]
>  Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny zdefiniowany w języku C#, Visual Basic lub C++, jego zagnieżdżone typy są rodzajowe, nawet jeśli mają one nie parametrów ogólnych swoich własnych. To nie jest konieczne zagnieżdżonych typów zdefiniowanych w zestawach dynamicznych lub skompilowanych z [Ilasm.exe (asembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Aby uzyskać informacje o zagnieżdżonych typach rodzajowych oraz o konstruowaniu zagnieżdżonych typów rodzajowych z definicjami typu ogólnego, zobacz <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera typy zagnieżdżone w obrębie bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca typy publiczne zagnieżdżone w bieżącym <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiektów reprezentujących typy publiczne zagnieżdżone w bieżącym <see cref="T:System.Type" /> (wyszukiwanie nie jest cykliczna), lub pusta tablica typu <see cref="T:System.Type" /> Jeśli nie typy publiczne są zagnieżdżone w bieżącym <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetNestedTypes%2A> Metoda nie zwraca typów w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji. Twój kod nie może zależeć od kolejności, w której są zwracane typy, ponieważ kolejność się zmienia.  
  
 Zwracane są tylko typy publiczne bezpośrednio zagnieżdżona w bieżącym typem; w wyszukiwaniu nie jest cykliczna.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje zagnieżdżone typy ograniczenia klasy.  
  
 Jeśli zagnieżdżony jest typ ogólny , metoda ta zwraca jego definicję typu ogólnego. Ta zasada obowiązuje, nawet jeśli otaczający typ ogólny jest skonstruowany jako zamknięty.  
  
> [!NOTE]
>  Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny zdefiniowany w języku C#, Visual Basic lub C++, jego zagnieżdżone typy są rodzajowe, nawet jeśli mają one nie parametrów ogólnych swoich własnych. To nie jest konieczne zagnieżdżonych typów zdefiniowanych w zestawach dynamicznych lub skompilowanych z [Ilasm.exe (asembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Aby uzyskać informacje o zagnieżdżonych typach rodzajowych oraz o konstruowaniu zagnieżdżonych typów rodzajowych z definicjami typu ogólnego, zobacz <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano klasę zagnieżdżoną i `struct` w `MyClass`, a następnie uzyskuje obiektów zagnieżdżonych typów, przy użyciu typu `MyClass`.  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wyszukuje typy zagnieżdżone w bieżącym <see cref="T:System.Type" />, za pomocą ograniczeń w określonym powiązaniu.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiekty reprezentujące wszystkie typy zagnieżdżone w bieżącym <see cref="T:System.Type" /> zgodnych ograniczenia określone powiązanie (wyszukiwanie nie jest cykliczna), lub pusta tablica typu <see cref="T:System.Type" />, jeśli nie typy zagnieżdżone nie zostaną znalezione zgodnych ograniczenia wiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukaj typy zagnieżdżone nie jest cykliczna.  
  
 <xref:System.Type.GetNestedTypes%2A> Metoda nie zwraca typów w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji. Twój kod nie może zależeć od kolejności, w której są zwracane typy, ponieważ kolejność się zmienia.  
  
 Następujące <xref:System.Reflection.BindingFlags> filtr flagi może służyć do definiowania, które zagnieżdżonych typów do uwzględnienia w wyszukiwaniu:  
  
-   Należy określić <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> lub <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> do uzyskania zwrotu.  
  
-   Określ <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> obejmujący publiczne typy zagnieżdżone w wyszukiwaniu.  
  
-   Określ <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> obejmujący zagnieżdżonych typów niepublicznych (czyli prywatne, wewnętrzne i chronione typy zagnieżdżone) do wyszukiwania.  
  
 Ta metoda zwraca zagnieżdżone typy bieżącego typu. Wyszukiwanie klas bazowych bieżącego typu nie jest. Aby znaleźć typy, które są zagnieżdżone w klasach bazowych, musi zaprezentuje hierarchii dziedziczenia wywoływania <xref:System.Type.GetNestedTypes%2A> na każdym poziomie.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> i <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> są ignorowane.  
  
 Wywołanie tej metody tylko z <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flagi lub tylko <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flagi zwróci określoną zagnieżdżonych typów i nie wymaga inne flagi.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje zagnieżdżone typy ograniczenia klasy.  
  
 Jeśli zagnieżdżony jest typ ogólny , metoda ta zwraca jego definicję typu ogólnego. Ta zasada obowiązuje, nawet jeśli otaczający typ ogólny jest skonstruowany jako zamknięty.  
  
> [!NOTE]
>  Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny zdefiniowany w języku C#, Visual Basic lub C++, jego zagnieżdżone typy są rodzajowe, nawet jeśli mają one nie parametrów ogólnych swoich własnych. To nie jest konieczne zagnieżdżonych typów zdefiniowanych w zestawach dynamicznych lub skompilowanych z [Ilasm.exe (asembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Aby uzyskać informacje o zagnieżdżonych typach rodzajowych oraz o konstruowaniu zagnieżdżonych typów rodzajowych z definicjami typu ogólnego, zobacz <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 Poniższy przykład tworzy dwie klasy publiczne zagnieżdżonych i dwie klasy chronionych zagnieżdżonych i wyświetla informacje dotyczące klas, które odpowiadają ograniczeń w określonym powiązaniu.  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera właściwości bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie publiczne właściwości bieżącego <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Reflection.PropertyInfo" /> obiekty reprezentujące wszystkie publiczne właściwości bieżącego <see cref="T:System.Type" />.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.PropertyInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma właściwości publiczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie wywołanie jest równoważne z wywoływaniem <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> przeciążenia z `bindingAttr` argument równa `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` w języku C# i `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` w języku Visual Basic. Zwraca wszystkie publiczne wystąpienia i statycznej właściwości, z których oba te są definiowane przez typ reprezentowany przez bieżącą <xref:System.Type> obiektu, a także tych dziedziczone z jej typów podstawowych.  
  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie właściwość jest traktowana jako prywatna i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.  
  
 <xref:System.Type.GetProperties%2A> Metoda nie zwraca właściwości w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji. Twój kod nie może zależeć od kolejności, w której zwracane są właściwości, ponieważ kolejność się zmienia.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący element T:System.Type reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.PropertyInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta przeszukuje właściwości ograniczenia klasy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie `GetProperties` metody.  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wyszukuje właściwości bieżącego <see cref="T:System.Type" />, za pomocą ograniczeń w określonym powiązaniu.</summary>
        <returns>Tablica <see cref="T:System.Reflection.PropertyInfo" /> obiekty reprezentujące wszystkie właściwości bieżącego <see cref="T:System.Type" /> zgodnych ograniczeń w określonym powiązaniu.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.PropertyInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma właściwości, lub jeśli żadna z właściwości ograniczenia wiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie właściwość jest traktowana jako prywatna i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.  
  
 <xref:System.Type.GetProperties%2A> Metoda nie zwraca właściwości w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji. Twój kod nie może zależeć od kolejności, w której zwracane są właściwości, ponieważ kolejność się zmienia.  
  
 Następujące <xref:System.Reflection.BindingFlags> filtr flagi może służyć do definiowania, które zagnieżdżonych typów do uwzględnienia w wyszukiwaniu:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.  
  
-   Określ `BindingFlags.Public` obejmujący właściwości publiczne w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący w w wyszukiwaniu właściwości niepubliczne (czyli prywatne, wewnętrzne i chronione właściwości). Tylko chronionych i wewnętrznych właściwości klasy bazowe są zwracane; właściwości prywatnych na klasach bazowych nie są zwracane.  
  
-   Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko właściwości zadeklarowanych w <xref:System.Type>, nie właściwości, które zostały po prostu odziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie właściwość jest traktowana jako prywatna i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.  
  
 Jeśli bieżący element T:System.Type reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.PropertyInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta przeszukuje właściwości ograniczenia klasy.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano klasę o nazwie `PropertyClass` zawierającej sześć właściwości: dwa są publiczne, jeden jest prywatny, jeden jest chroniony, jest jeden wewnętrzny (`Friend` w języku Visual Basic), i jest chronionych wewnętrznych (`Protected Friend` w języku Visual Basic). Następnie wyświetla informacje o niektórych właściwości podstawowe (nazwę właściwości i typ, czy jest ona odczytu/zapisu, a widoczność jego `get` i `set` metod dostępu) dla właściwości, które odpowiadają ograniczeń w określonym powiązaniu.  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określoną właściwość bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości publicznej do pobrania.</param>
        <summary>Wyszukiwanie właściwości publicznej przy użyciu określonej nazwy.</summary>
        <returns>Obiekt reprezentujący właściwość publiczną o określonej nazwie, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukaj `name` jest uwzględniana wielkość liter. Wyszukiwanie uwzględnia właściwości wystąpienia statycznego publicznego i publicznego.  
  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie właściwość jest traktowana jako prywatna i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.PropertyInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta przeszukuje właściwości ograniczenia klasy.  
  
 Sytuacje, w których <xref:System.Reflection.AmbiguousMatchException> występuje obejmują następujące elementy:  
  
-   Typ zawiera dwa indeksowanej właściwości, które mają taką samą nazwę, ale o innej liczby parametrów. Aby rozstrzygnąć niejednoznaczność, użyj przeciążenia <xref:System.Type.GetProperty%2A> metody, która określa typy parametrów.  
  
-   Typ pochodny deklaruje właściwość, która ukrywa to właściwość dziedziczona z taką samą nazwę, za pomocą `new` modyfikator (`Shadows` w języku Visual Basic). Aby rozstrzygnąć niejednoznaczność, użyj <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> metoda przeciążenia i Dodaj <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> flagę, aby ograniczyć wyszukiwanie do elementów członkowskich, które nie są dziedziczone.  
  
## <a name="indexers-and-default-properties"></a>Indeksatory i domyślne właściwości  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], i [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczoną składnię do uzyskiwania dostępu do właściwości indeksowanych i zezwolić na jedną z indeksowanych właściwości jako domyślną dla tego typu. Na przykład jeśli zmienna `myList` odwołuje się do <xref:System.Collections.ArrayList>, składnia `myList[3]` (`myList(3)` w języku Visual Basic) pobiera element z indeksem 3. Można doprowadzić do przeciążenia właściwości.  
  
 W języku C# ta funkcja nosi nazwę indeksatora i nie może być określona przez nazwę. Domyślnie indeksatora języka C# pojawia się w metadanych jako indeksowana właściwość o nazwie "Item". Jednak Deweloper biblioteki klas można używać <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atrybutu, aby zmienić nazwę indeksatora w metadanych. Na przykład <xref:System.String> klasa ma indeksatora o nazwie <xref:System.String.Chars%2A>. Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.  
  
 Aby określić, czy typ ma właściwość domyślną, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metoda do testowania <xref:System.Reflection.DefaultMemberAttribute> atrybutu. Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> właściwość zwraca nazwę właściwości domyślnej.  
  
   
  
## Examples  
 Poniższy przykład pobiera `Type` obiekt klasy zdefiniowane przez użytkownika, pobiera właściwości tej klasy i wyświetla nazwę właściwości.  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 Wewnętrznie ta właściwość jest określany w metadanych o nazwie "Item". Dowolne próba uzyskania `PropertyInfo` przy użyciu odbicia należy określić to wewnętrzna nazwa celu zwrócenie poprawnie `PropertyInfo` właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną właściwość o określonej nazwie.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości do pobrania.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <summary>Wyszukuje dla określonej właściwości, za pomocą ograniczeń w określonym powiązaniu.</summary>
        <returns>Obiekt reprezentujący właściwość, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie właściwość jest traktowana jako prywatna i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania właściwości, które można uwzględnić w wyszukiwaniu:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.  
  
-   Określ `BindingFlags.Public` obejmujący właściwości publiczne w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący w w wyszukiwaniu właściwości niepubliczne (czyli prywatne, wewnętrzne i chronione właściwości).  
  
-   Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko właściwości zadeklarowanych w <xref:System.Type>, nie właściwości, które zostały po prostu odziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.PropertyInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta przeszukuje właściwości ograniczenia klasy.  
  
 Sytuacje, w których <xref:System.Reflection.AmbiguousMatchException> występuje obejmują następujące elementy:  
  
-   Typ zawiera dwa indeksowanej właściwości, które mają taką samą nazwę, ale o innej liczby parametrów. Aby rozstrzygnąć niejednoznaczność, użyj przeciążenia <xref:System.Type.GetProperty%2A> metody, która określa typy parametrów.  
  
-   Typ pochodny deklaruje właściwość, która ukrywa to właściwość dziedziczona z taką samą nazwę, za pomocą `new` modyfikator (`Shadows` w języku Visual Basic). Aby rozstrzygnąć niejednoznaczność, obejmują <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> ograniczyć wyszukiwanie do elementów członkowskich, które nie są dziedziczone.  
  
## <a name="indexers-and-default-properties"></a>Indeksatory i domyślne właściwości  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], i [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczoną składnię do uzyskiwania dostępu do właściwości indeksowanych i zezwolić na jedną z indeksowanych właściwości jako domyślną dla tego typu. Na przykład jeśli zmienna `myList` odwołuje się do <xref:System.Collections.ArrayList>, składnia `myList[3]` (`myList(3)` w języku Visual Basic) pobiera element z indeksem 3. Można doprowadzić do przeciążenia właściwości.  
  
 W języku C# ta funkcja nosi nazwę indeksatora i nie może być określona przez nazwę. Domyślnie indeksatora języka C# pojawia się w metadanych jako indeksowana właściwość o nazwie "Item". Jednak Deweloper biblioteki klas można używać <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atrybutu, aby zmienić nazwę indeksatora w metadanych. Na przykład <xref:System.String> klasa ma indeksatora o nazwie <xref:System.String.Chars%2A>. Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.  
  
 Aby określić, czy typ ma właściwość domyślną, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metoda do testowania <xref:System.Reflection.DefaultMemberAttribute> atrybutu. Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> właściwość zwraca nazwę właściwości domyślnej.  
  
   
  
## Examples  
 Poniższy przykład pobiera typ klasy zdefiniowane przez użytkownika, pobiera właściwości tej klasy i wyświetla nazwę właściwości, zgodnie z ograniczeń w określonym powiązaniu.  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Odnaleziono więcej niż jedną właściwość o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości publicznej do pobrania.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <summary>Wyszukiwanie właściwości publicznej o określonej nazwie i typ zwracany.</summary>
        <returns>Obiekt reprezentujący właściwość publiczną o określonej nazwie, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie właściwość jest traktowana jako prywatna i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.  
  
 Wyszukaj `name` jest uwzględniana wielkość liter. Wyszukiwanie uwzględnia właściwości wystąpienia statycznego publicznego i publicznego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.PropertyInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta przeszukuje właściwości ograniczenia klasy.  
  
## <a name="indexers-and-default-properties"></a>Indeksatory i domyślne właściwości  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], i [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczoną składnię do uzyskiwania dostępu do właściwości indeksowanych i zezwolić na jedną z indeksowanych właściwości jako domyślną dla tego typu. Na przykład jeśli zmienna `myList` odwołuje się do <xref:System.Collections.ArrayList>, składnia `myList[3]` (`myList(3)` w języku Visual Basic) pobiera element z indeksem 3. Można doprowadzić do przeciążenia właściwości.  
  
 W języku C# ta funkcja nosi nazwę indeksatora i nie może być określona przez nazwę. Domyślnie indeksatora języka C# pojawia się w metadanych jako indeksowana właściwość o nazwie "Item". Jednak Deweloper biblioteki klas można używać <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atrybutu, aby zmienić nazwę indeksatora w metadanych. Na przykład <xref:System.String> klasa ma indeksatora o nazwie <xref:System.String.Chars%2A>. Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.  
  
 Aby określić, czy typ ma właściwość domyślną, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metoda do testowania <xref:System.Reflection.DefaultMemberAttribute> atrybutu. Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> właściwość zwraca nazwę właściwości domyślnej.  
  
   
  
## Examples  
 Poniższy przykład definiuje klasę z jedną właściwością i pobiera nazwę i typ właściwości.  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną właściwość o określonej nazwie.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />, lub <paramref name="returnType" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości publicznej do pobrania.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów właściwości indeksowanej, aby uzyskać.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie właściwości, która nie jest indeksowana.</param>
        <summary>Wyszukuje określony właściwość publiczną, której parametry pasuje określone typy argumentów.</summary>
        <returns>Obiekt reprezentujący właściwość publiczną, której parametry pasuje określone typy argumentów, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie właściwość jest traktowana jako prywatna i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.  
  
 Wyszukaj `name` jest uwzględniana wielkość liter. Wyszukiwanie uwzględnia właściwości wystąpienia statycznego publicznego i publicznego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.PropertyInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta przeszukuje właściwości ograniczenia klasy.  
  
## <a name="indexers-and-default-properties"></a>Indeksatory i domyślne właściwości  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], i [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczoną składnię do uzyskiwania dostępu do właściwości indeksowanych i zezwolić na jedną z indeksowanych właściwości jako domyślną dla tego typu. Na przykład jeśli zmienna `myList` odwołuje się do <xref:System.Collections.ArrayList>, składnia `myList[3]` (`myList(3)` w języku Visual Basic) pobiera element z indeksem 3. Można doprowadzić do przeciążenia właściwości.  
  
 W języku C# ta funkcja nosi nazwę indeksatora i nie może być określona przez nazwę. Domyślnie indeksatora języka C# pojawia się w metadanych jako indeksowana właściwość o nazwie "Item". Jednak Deweloper biblioteki klas można używać <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atrybutu, aby zmienić nazwę indeksatora w metadanych. Na przykład <xref:System.String> klasa ma indeksatora o nazwie <xref:System.String.Chars%2A>. Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.  
  
 Aby określić, czy typ ma właściwość domyślną, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metoda do testowania <xref:System.Reflection.DefaultMemberAttribute> atrybutu. Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> właściwość zwraca nazwę właściwości domyślnej.  
  
   
  
## Examples  
 Poniższy przykład pobiera `Type` obiekt klasy zdefiniowane przez użytkownika, pobiera właściwości tej klasy i wyświetla nazwę właściwości i typ właściwości zgodnie z argumentów przekazanych do `GetProperty`.  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Odnaleziono więcej niż jedną właściwość o określonej nazwie i pasującą określone typy argumentów.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ma charakter wielowymiarowy.</exception>
        <exception cref="T:System.NullReferenceException">Element <paramref name="types" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości publicznej do pobrania.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów właściwości indeksowanej, aby uzyskać.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie właściwości, która nie jest indeksowana.</param>
        <summary>Wyszukuje określony właściwość publiczną, której parametry pasuje określone typy argumentów.</summary>
        <returns>Obiekt reprezentujący właściwość publiczną, której parametry pasuje określone typy argumentów, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie właściwość jest traktowana jako prywatna i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.  
  
 Wyszukaj `name` jest uwzględniana wielkość liter. Wyszukiwanie uwzględnia właściwości wystąpienia statycznego publicznego i publicznego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.PropertyInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta przeszukuje właściwości ograniczenia klasy.  
  
## <a name="indexers-and-default-properties"></a>Indeksatory i domyślne właściwości  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], i [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczoną składnię do uzyskiwania dostępu do właściwości indeksowanych i zezwolić na jedną z indeksowanych właściwości jako domyślną dla tego typu. Na przykład jeśli zmienna `myList` odwołuje się do <xref:System.Collections.ArrayList>, składnia `myList[3]` (`myList(3)` w języku Visual Basic) pobiera element z indeksem 3. Można doprowadzić do przeciążenia właściwości.  
  
 W języku C# ta funkcja nosi nazwę indeksatora i nie może być określona przez nazwę. Domyślnie indeksatora języka C# pojawia się w metadanych jako indeksowana właściwość o nazwie "Item". Jednak Deweloper biblioteki klas można używać <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atrybutu, aby zmienić nazwę indeksatora w metadanych. Na przykład <xref:System.String> klasa ma indeksatora o nazwie <xref:System.String.Chars%2A>. Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.  
  
 Aby określić, czy typ ma właściwość domyślną, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metoda do testowania <xref:System.Reflection.DefaultMemberAttribute> atrybutu. Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> właściwość zwraca nazwę właściwości domyślnej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Odnaleziono więcej niż jedną właściwość o określonej nazwie i pasującą określone typy argumentów.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ma charakter wielowymiarowy.</exception>
        <exception cref="T:System.NullReferenceException">Element <paramref name="types" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości publicznej do pobrania.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów właściwości indeksowanej, aby uzyskać.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie właściwości, która nie jest indeksowana.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <paramref name="types" /> tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Wyszukuje określony właściwość publiczną, której parametry odpowiadają określone typy argumentów i modyfikatorów.</summary>
        <returns>Obiekt reprezentujący właściwość publiczną, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie właściwość jest traktowana jako prywatna i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.  
  
 Mimo że domyślny integrator nie przetwarza <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `modifiers`. `ParameterModifier` jest używana tylko podczas wywoływania przez współdziałania z modelem COM i są obsługiwane tylko w przypadku parametrów, które są przekazywane przez odwołanie.  
  
 Wyszukaj `name` jest uwzględniana wielkość liter. Wyszukiwanie uwzględnia właściwości wystąpienia statycznego publicznego i publicznego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.PropertyInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta przeszukuje właściwości ograniczenia klasy.  
  
## <a name="indexers-and-default-properties"></a>Indeksatory i domyślne właściwości  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], i [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczoną składnię do uzyskiwania dostępu do właściwości indeksowanych i zezwolić na jedną z indeksowanych właściwości jako domyślną dla tego typu. Na przykład jeśli zmienna `myList` odwołuje się do <xref:System.Collections.ArrayList>, składnia `myList[3]` (`myList(3)` w języku Visual Basic) pobiera element z indeksem 3. Można doprowadzić do przeciążenia właściwości.  
  
 W języku C# ta funkcja nosi nazwę indeksatora i nie może być określona przez nazwę. Domyślnie indeksatora języka C# pojawia się w metadanych jako indeksowana właściwość o nazwie "Item". Jednak Deweloper biblioteki klas można używać <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atrybutu, aby zmienić nazwę indeksatora w metadanych. Na przykład <xref:System.String> klasa ma indeksatora o nazwie <xref:System.String.Chars%2A>. Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.  
  
 Aby określić, czy typ ma właściwość domyślną, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metoda do testowania <xref:System.Reflection.DefaultMemberAttribute> atrybutu. Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> właściwość zwraca nazwę właściwości domyślnej.  
  
   
  
## Examples  
 W poniższym przykładzie uzyskano `Type` obiekt odpowiadający `MyPropertyClass`, i indeksowanej właściwości tej klasy są pobierane przy użyciu argumentów przekazanych do `GetProperty` metody.  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Odnaleziono więcej niż jedną właściwość o określonej nazwie i pasującą określone typy argumentów i modyfikatorów.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ma charakter wielowymiarowy.  
  
—lub— 
 <paramref name="modifiers" /> ma charakter wielowymiarowy.  
  
—lub— 
 <paramref name="types" /> i <paramref name="modifiers" /> nie mają tę samą długość.</exception>
        <exception cref="T:System.NullReferenceException">Element <paramref name="types" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości do pobrania.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów właściwości indeksowanej, aby uzyskać.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie właściwości, która nie jest indeksowana.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <paramref name="types" /> tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Wyszukuje określoną właściwość, której parametry odpowiadają określone typy argumentów i modyfikatorów, za pomocą ograniczeń w określonym powiązaniu.</summary>
        <returns>Obiekt reprezentujący właściwość, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie właściwość jest traktowana jako prywatna i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.  
  
 Mimo że domyślny integrator nie przetwarza <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `modifiers`. `ParameterModifier` jest używana tylko podczas wywoływania przez współdziałania z modelem COM i są obsługiwane tylko w przypadku parametrów, które są przekazywane przez odwołanie.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania właściwości, które można uwzględnić w wyszukiwaniu:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.  
  
-   Określ `BindingFlags.Public` obejmujący właściwości publiczne w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący w w wyszukiwaniu właściwości niepubliczne (czyli prywatne, wewnętrzne i chronione właściwości).  
  
-   Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko właściwości zadeklarowanych w <xref:System.Type>, nie właściwości, które zostały po prostu odziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.PropertyInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta przeszukuje właściwości ograniczenia klasy.  
  
## <a name="indexers-and-default-properties"></a>Indeksatory i domyślne właściwości  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], i [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczoną składnię do uzyskiwania dostępu do właściwości indeksowanych i zezwolić na jedną z indeksowanych właściwości jako domyślną dla tego typu. Na przykład jeśli zmienna `myList` odwołuje się do <xref:System.Collections.ArrayList>, składnia `myList[3]` (`myList(3)` w języku Visual Basic) pobiera element z indeksem 3. Można doprowadzić do przeciążenia właściwości.  
  
 W języku C# ta funkcja nosi nazwę indeksatora i nie może być określona przez nazwę. Domyślnie indeksatora języka C# pojawia się w metadanych jako indeksowana właściwość o nazwie "Item". Jednak Deweloper biblioteki klas można używać <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atrybutu, aby zmienić nazwę indeksatora w metadanych. Na przykład <xref:System.String> klasa ma indeksatora o nazwie <xref:System.String.Chars%2A>. Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.  
  
 Aby określić, czy typ ma właściwość domyślną, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metoda do testowania <xref:System.Reflection.DefaultMemberAttribute> atrybutu. Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> właściwość zwraca nazwę właściwości domyślnej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Odnaleziono więcej niż jedną właściwość o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ma charakter wielowymiarowy.  
  
—lub— 
 <paramref name="modifiers" /> ma charakter wielowymiarowy.  
  
—lub— 
 <paramref name="types" /> i <paramref name="modifiers" /> nie mają tę samą długość.</exception>
        <exception cref="T:System.NullReferenceException">Element <paramref name="types" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości do pobrania.</param>
        <param name="bindingAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  
  
—lub— 
Zero, aby zwrócić <see langword="null" />.</param>
        <param name="binder">Obiekt, który definiuje zestaw właściwości i umożliwia powiązanie, które może obejmować Wybór elementu członkowskiego przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów właściwości indeksowanej, aby uzyskać.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie właściwości, która nie jest indeksowana.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <paramref name="types" /> tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wyszukuje określoną właściwość, której parametry odpowiadają określone typy argumentów i modyfikatorów, za pomocą ograniczeń w określonym powiązaniu.</summary>
        <returns>Obiekt reprezentujący właściwość, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że domyślny integrator nie przetwarza <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `modifiers`. `ParameterModifier` jest używana tylko podczas wywoływania przez współdziałania z modelem COM i są obsługiwane tylko w przypadku parametrów, które są przekazywane przez odwołanie.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania właściwości, które można uwzględnić w wyszukiwaniu:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.  
  
-   Określ `BindingFlags.Public` obejmujący właściwości publiczne w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący w w wyszukiwaniu właściwości niepubliczne (czyli prywatne, wewnętrzne i chronione właściwości).  
  
-   Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko właściwości zadeklarowanych w <xref:System.Type>, nie właściwości, które zostały po prostu odziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Odnaleziono więcej niż jedną właściwość o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="types" /> jest <see langword="null" />.  
  
—lub— 
Jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ma charakter wielowymiarowy.  
  
—lub— 
 <paramref name="modifiers" /> ma charakter wielowymiarowy.  
  
—lub— 
 <paramref name="types" /> i <paramref name="modifiers" /> nie mają tę samą długość.</exception>
        <exception cref="T:System.NotSupportedException">Bieżącym typem jest <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" />, lub <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="T:System.Type" /> obiekt, który reprezentuje określonego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera bieżący <see cref="T:System.Type" />.</summary>
        <returns>Bieżący <see cref="T:System.Type" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Określanie w pełni kwalifikowanych nazw typów</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa kwalifikowanego dla zestawu typu można pobrać. Zobacz <see cref="P:System.Type.AssemblyQualifiedName" />. Jeśli typ jest zawierający obecnie wykonywany zestaw lub biblioteki Mscorlib.dll, wystarczy podać nazwę typu kwalifikowana przez jego przestrzeń nazw.</param>
        <summary>Pobiera <see cref="T:System.Type" /> o określonej nazwie, wyszukując uwzględniana wielkość liter.</summary>
        <returns>Typ o określonej nazwie, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Type.GetType%2A> metodę, aby uzyskać <xref:System.Type> obiektu dla typu w innym zestawie, jeśli znasz jego nazwę kwalifikowaną dla zestawu, który można uzyskać z <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A> powoduje, że ładowanie zestawu określonego w `typeName`. Można również załadować zestawu przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody, a następnie użyj <xref:System.Type.GetType%2A> lub <xref:System.Reflection.Assembly.GetTypes%2A> metody <xref:System.Reflection.Assembly> klasy, aby uzyskać <xref:System.Type> obiektów. Jeśli typ znajduje się w zestawie znane w czasie kompilacji program, jest bardziej wydajne, do użycia w języku C# <xref:System.Type.GetType%2A> w języku Visual Basic lub języka C++.  
  
> [!NOTE]
>  Jeśli `typeName` nie można znaleźć, wywołanie <xref:System.Type.GetType%28System.String%29> metoda zwraca `null`. Nie zostanie zgłoszony wyjątek. Do kontrolowania tego, czy wyjątek jest generowany, wywołania przeciążenia <xref:System.Type.GetType%2A> metody, która ma `throwOnError` parametru.  
  
 <xref:System.Type.GetType%2A> działa tylko na zestawy, ładowane z dysku. Jeśli wywołasz <xref:System.Type.GetType%2A> do wyszukania w typ zdefiniowany w zestawie dynamicznym zdefiniowane przy użyciu <xref:System.Reflection.Emit> usług, możesz otrzymać niespójne zachowanie. Zachowanie zależy od tego, czy zestaw dynamiczny jest trwała, oznacza to, utworzony za pomocą `RunAndSave` lub `Save` dostępu tryby <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> wyliczenia. Jeśli zestaw dynamiczny jest trwały i został zapisany na dysku przed `GetType` jest wywoływana, moduł ładujący wyszukuje zestaw zapisane na dysku, ładuje tego zestawu i pobiera typ z tego zestawu. Jeśli zestaw nie został zapisany na dysku po `GetType` jest wywoływana metoda zwraca `null`. `GetType` nie rozpoznaje przejściowy dynamicznych zestawów; Dlatego wywołanie `GetType` można pobrać typu na przejściowy zwraca zestaw dynamiczny `null`.  
  
 Aby użyć `GetType` na modułu dynamicznego subskrybować <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> zdarzenia i wywołania `GetType` przed zapisaniem. W przeciwnym razie otrzymasz dwie kopie zestawu w pamięci.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Tablic lub typów modelu COM nie są wyszukiwane chyba, że już zostały załadowane do tabeli dostępnych klas.  
  
 `typeName` może być nazwa typu kwalifikowana przez jego przestrzeń nazw lub kwalifikowaną dla zestawu, która zawiera nazwę specyfikacja nazwy zestawu. Zobacz <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Jeśli `typeName` obejmuje przestrzeń nazw, ale nie nazwę zestawu, Metoda ta wyszukuje tylko do obiektu wywołującego zestawu i Mscorlib.dll, w tej kolejności. Jeśli typeName jest w pełni kwalifikowaną nazwą zestawu częściowego lub pełny, Metoda ta wyszukuje w określonym zestawie. Jeśli zestaw ma silną nazwą, wymagana jest nazwa kompletny zestaw.  
  
 <xref:System.Type.AssemblyQualifiedName%2A> Właściwość zwraca w pełni kwalifikowaną nazwę typu w tym typów zagnieżdżonych, nazwa zestawu i argumenty typu ogólnego. Wszystkie kompilatory, które obsługują aparat plików wykonywalnych języka wspólnego, w trakcie wykonania wyemitują prostą nazwę klasy zagnieżdżonej, a odbicie podczas kwerendy stworzy zniekształcone nazwy zgodnie z następującymi konwencjami.  
  
> [!NOTE]
>  W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw. Na przykład "ProcessorArchitecture = msil". Jednak nie są uwzględnione w ciągu zwracanego przez <xref:System.Type.AssemblyQualifiedName%2A> właściwość ze względu na zgodność. Można również załadować typów, tworząc <xref:System.Reflection.AssemblyName> obiektu i przekazywania go do odpowiedniego przeciążenia <xref:System.Reflection.Assembly.Load%2A> metody. Następnie można użyć <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> metodę, aby załadować typów z zestawu. Zobacz też <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Ogranicznik|Znaczenie|  
|---------------|-------------|  
|Ukośnik odwrotny (\\)|Znak ucieczki.|  
|Backtick (`)|Poprzedza co najmniej jedną cyfrę reprezentującą liczbę parametrów typu, znajduje się na końcu nazwy typu ogólnego.|  
|Nawiasy kwadratowe ([])|Ujmij listy argumentów typu rodzajowego, aby uzyskać skonstruowany typ rodzajowy; na liście argumentów typu należy ująć typu kwalifikowanego zestawu.|  
|Przecinek (,)|Poprzedza nazwę zestawu.|  
|Kropka (.)|Wskazuje przestrzeń nazw identyfikatorów.|  
|Znak plus (+)|Poprzedza klasę zagnieżdżoną.|  
  
 Na przykład w pełni kwalifikowana nazwa klasy może wyglądać następująco:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Jeśli przestrzeń nazw zostały TopNamespace.Sub+Namespace, a następnie ciąg musi poprzedzać znak plus (+) przy użyciu znaku ucieczki (\\), aby zapobiec interpretacji jako separator zagnieżdżenia. Odbicie emituje tego ciągu w następujący sposób:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A "++" staje się "\\+\\+", a "\\"staje się"\\\\".  
  
 Ta nazwa kwalifikowana może utrwalona i później używana do ładowania <xref:System.Type>. Aby wyszukać i załadować <xref:System.Type>, użyj <xref:System.Type.GetType%2A> albo z typem nazwy tylko lub nazwą kwalifikowaną typu zestawu. <xref:System.Type.GetType%2A> z typem nazwy tylko będzie szukać <xref:System.Type> w zestawie wywołującego, a następnie w zestawie systemowym. <xref:System.Type.GetType%2A> z zestawem kwalifikowanej nazwy typu będzie szukać <xref:System.Type> w każdym zestawie.  
  
 Nazwy typów mogą obejmować końcowe znaki, które wyznaczają dodatkowe informacje dotyczące typu, na przykład to, czy typ jest typem odwołania, typem wskaźnika lub typem tablicowym. Aby pobrać, wpisz nazwę bez tych znaków końcowych, należy użyć `t.GetElementType().ToString()`, gdzie `t` jest typem.  
  
 Spacje są istotne we wszystkich składnikach nazwy z wyjątkiem nazwy zestawu. Spacje przed separatorem w nazwie zestawu ',' są istotne, ale spacje po separatorze ',' są ignorowane.  
  
 Nazwa typu ogólnego kończy się ciągiem początkowych (\`) następują cyfry reprezentujący liczbę wszystkich argumentów typu rodzajowego. Celem tego przekręcaniu nazwy jest umożliwienie kompilatory do obsługi typów ogólnych o takiej samej nazwie, ale z różną liczbę parametrów typu, w tym samym zakresie. Na przykład odbicia zwraca zniekształcone nazwy `Tuple`1` and `krotki`2` z metod ogólnych `Tuple(Of T)` i `Tuple(Of T0, T1)` w języku Visual Basic lub `Tuple<T>` i krotki`\<T0, T1>` w języku Visual C#.  
  
 Dla typów ogólnych lista argumentów typu jest ujęty w nawiasy i argumenty typu są oddzielone przecinkami. Na przykład ogólny <xref:System.Collections.Generic.Dictionary%602> ma dwa parametry typu. A <xref:System.Collections.Generic.Dictionary%602> z `MyType` przy użyciu kluczy typu <xref:System.String> może być reprezentowany w następujący sposób:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Aby określić typu kwalifikowanego zestawu w obrębie listy argumentów typu, należy ująć typu kwalifikowanego zestawu w nawiasy kwadratowe. W przeciwnym razie przecinki oddzielające części nazwy kwalifikowanej zestawu są interpretowane jako rozdzielający argumentów typu dodatkowe. Na przykład <xref:System.Collections.Generic.Dictionary%602> z `MyType` fromMyAssembly.dll przy użyciu kluczy typu <xref:System.String>, może być następujący:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Typu kwalifikowanego zestawu mogą być ujęte w nawiasy kwadratowe, tylko wtedy, gdy pojawia się on w obrębie lista parametrów typu. Reguły dotyczące wyszukiwania zestawów dla typów kwalifikowana i niekwalifikowanej w liście parametrów typu są takie same jak reguły dla typów nierodzajowymi kwalifikowana i niekwalifikowane.  
  
 Typy dopuszczające wartości zerowe są w wyjątkowym przypadku okna typów ogólnych. Na przykład dopuszczający wartości null <xref:System.Int32> jest reprezentowany przez ciąg "System.Nullable'1[System.Int32]".  
  
> [!NOTE]
>  W języku C#, C++ i Visual Basic można również uzyskać przy użyciu operatorów typu typy dopuszczające wartości null. Na przykład nullable <xref:System.Boolean> typ zwracany przez `typeof(Nullable<bool>)` w języku C#, `Nullable<Boolean>::typeid` w języku C++ i przez `GetType(Nullable(Of Boolean))` w języku Visual Basic.  
  
 W poniższej tabeli przedstawiono składnię, możesz za pomocą `GetType` dla różnych typów.  
  
|Aby uzyskać|Zastosowanie|  
|------------|---------|  
|Dopuszczający wartości null <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Niezarządzany wskaźnik do `MyType`|`Type.GetType("MyType*")`|  
|Niezarządzany wskaźnik do wskaźnika do `MyType`|`Type.GetType("MyType**")`|  
|Zarządzane wskaźnik lub odwołanie do `MyType`|`Type.GetType("MyType&")`. Należy pamiętać, że w przeciwieństwie do wskaźników, odwołań są ograniczone do jednego poziomu.|  
|Klasy nadrzędnej i zagnieżdżone klasy|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Jednowymiarowa tablica dolną granicę równą 0|`Type.GetType("MyType[]")`|  
|Jednowymiarowa tablica o nieznanych dolna granica|`Type.GetType("MyType[*]")`|  
|N wymiarową tablicą|Przecinek (,) znajduje się wewnątrz nawiasów w sumie n-1 razy. Na przykład `System.Object[,,]` reprezentuje trójwymiarowym `Object` tablicy.|  
|Tablica tablice jednowymiarowe|`Type.GetType("MyType[][]")`|  
|Prostokątnej dwuwymiarowej tablicy przy użyciu nieznanego dolne granice|`Type.GetType("MyType[,]")`|  
|Typ ogólny z jednego typu argumentu|``Type.GetType("MyGenericType`1[MyType]")``|  
|Typ ogólny z dwoma argumentami typu|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|Typ ogólny z dwóch argumentów typu kwalifikowanego zestawu|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|Kwalifikowanych dla zestawu typu ogólnego z nieprawidłowym argumentem typu kwalifikowanego zestawu|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`|  
|Typ ogólny, którego argument typu jest typ ogólny z dwoma argumentami typu|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 Poniższy przykład pobiera typ `System.Int32` i używa tego typu obiektu do wyświetlenia <xref:System.Type.FullName%2A> właściwość `System.Int32`.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> reprezentuje typ ogólny, który jest typem wskaźnika <see langword="ByRef" /> typu, lub <see cref="T:System.Void" /> jako jeden z argumentów typu.  
  
—lub— 
 <paramref name="typeName" /> reprezentuje typ ogólny, który ma niepoprawną liczbę argumentów typu.  
  
—lub— 
 <paramref name="typeName" /> reprezentuje typ ogólny i jeden z argumentów typu nie spełniają ograniczeń dla odpowiedniego parametru typu.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> reprezentuje tablicę <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.IO.IOException" />, a zamiast tego.  
  
</para>
          </block>  
  
 Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana, a zestaw został skompilowany przy użyciu nowszej wersji.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Określanie w pełni kwalifikowanych nazw typów</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa kwalifikowanego dla zestawu typu można pobrać. Zobacz <see cref="P:System.Type.AssemblyQualifiedName" />. Jeśli typ jest zawierający obecnie wykonywany zestaw lub biblioteki Mscorlib.dll, wystarczy podać nazwę typu kwalifikowana przez jego przestrzeń nazw.</param>
        <param name="throwOnError"><see langword="true" /> Aby zgłosić wyjątek, jeśli nie można odnaleźć typu; <see langword="false" /> do zwrócenia <see langword="null" />. Określanie <see langword="false" /> powoduje również pominięcie niektórych warunków wyjątków, ale nie wszystkie z nich. Zobacz sekcję Wyjątki.</param>
        <summary>Pobiera <see cref="T:System.Type" /> o określonej nazwie, wykonując wyszukiwanie i określeniu, czy zgłosić wyjątek, jeśli typ nie zostanie znaleziony.</summary>
        <returns>Typ o określonej nazwie. Jeśli typ nie zostanie znaleziony, <paramref name="throwOnError" /> parametr określa, czy <see langword="null" /> zwracany jest lub zostanie zgłoszony wyjątek. W niektórych przypadkach występuje wyjątek niezależnie od wartości <paramref name="throwOnError" />. Zobacz sekcję Wyjątki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Type.GetType%2A> metodę, aby uzyskać <xref:System.Type> obiektu dla typu w innym zestawie, jeśli znasz jego nazwę kwalifikowaną dla zestawu, który można uzyskać z <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A> powoduje, że ładowanie zestawu określonego w `typeName`. Można również załadować zestawu przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody, a następnie użyj <xref:System.Type.GetType%2A> lub <xref:System.Reflection.Assembly.GetTypes%2A> metody <xref:System.Reflection.Assembly> klasy, aby uzyskać <xref:System.Type> obiektów. Jeśli typ znajduje się w zestawie znane w czasie kompilacji program, jest bardziej wydajne, aby użyć `typeof` w języku C# <xref:System.Type.GetType%2A> w języku Visual Basic lub `typeid` w języku C++.  
  
 `GetType` działa tylko na zestawy, ładowane z dysku. Jeśli wywołasz `GetType` do wyszukania w typ zdefiniowany w zestawie dynamicznym zdefiniowane przy użyciu <xref:System.Reflection.Emit> usług, możesz otrzymać niespójne zachowanie. Zachowanie zależy od tego, czy zestaw dynamiczny jest trwała, oznacza to, utworzony za pomocą `RunAndSave` lub `Save` dostępu tryby <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> wyliczenia. Jeśli zestaw dynamiczny jest trwały i został zapisany na dysku przed `GetType` jest wywoływana, moduł ładujący wyszukuje zestaw zapisane na dysku, ładuje tego zestawu i pobiera typ z tego zestawu. Jeśli zestaw nie został zapisany na dysku po `GetType` jest wywoływana metoda zwraca `null`. `GetType` nie rozpoznaje przejściowy dynamicznych zestawów; Dlatego wywołanie `GetType` można pobrać typu na przejściowy zwraca zestaw dynamiczny `null`.  
  
 Aby użyć `GetType` na modułu dynamicznego subskrybować <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> zdarzenia i wywołania `GetType` przed zapisaniem. W przeciwnym razie otrzymasz dwie kopie zestawu w pamięci.  
  
 `throwOnError` Parametr określa, co się stanie, gdy typ nie zostanie znaleziony i powoduje również pominięcie niektórych warunków wyjątków, zgodnie z opisem w sekcji wyjątki. Niektóre wyjątki są zgłaszane niezależnie od wartości `throwOnError`. Na przykład, jeśli typ zostanie znaleziony, ale nie może zostać załadowany <xref:System.TypeLoadException> jest zgłaszany nawet wtedy, gdy `throwOnError` jest `false`.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Tablic lub typów modelu COM nie są wyszukiwane chyba, że już zostały załadowane do tabeli dostępnych klas.  
  
 `typeName` może być nazwa typu kwalifikowana przez jego przestrzeń nazw lub kwalifikowaną dla zestawu, która zawiera nazwę specyfikacja nazwy zestawu. Zobacz <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Jeśli `typeName` obejmuje przestrzeń nazw, ale nie nazwę zestawu, Metoda ta wyszukuje tylko do obiektu wywołującego zestawu i Mscorlib.dll, w tej kolejności. Jeśli typeName jest w pełni kwalifikowaną nazwą zestawu częściowego lub pełny, Metoda ta wyszukuje w określonym zestawie. Jeśli zestaw ma silną nazwą, wymagana jest nazwa kompletny zestaw.  
  
 <xref:System.Type.AssemblyQualifiedName%2A> Właściwość zwraca w pełni kwalifikowaną nazwę typu w tym typów zagnieżdżonych, nazwa zestawu i argumenty ogólne. Wszystkie kompilatory, które obsługują aparat plików wykonywalnych języka wspólnego, w trakcie wykonania wyemitują prostą nazwę klasy zagnieżdżonej, a odbicie podczas kwerendy stworzy zniekształcone nazwy zgodnie z następującymi konwencjami.  
  
> [!NOTE]
>  W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw. Na przykład "ProcessorArchitecture = msil". Jednak nie są uwzględnione w ciągu zwracanego przez <xref:System.Type.AssemblyQualifiedName%2A> właściwość ze względu na zgodność. Można również załadować typów, tworząc <xref:System.Reflection.AssemblyName> obiektu i przekazywania go do odpowiedniego przeciążenia <xref:System.Reflection.Assembly.Load%2A> metody. Następnie można użyć <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> metodę, aby załadować typów z zestawu. Zobacz też <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Ogranicznik|Znaczenie|  
|---------------|-------------|  
|Ukośnik odwrotny (\\)|Znak ucieczki.|  
|Backtick (`)|Poprzedza co najmniej jedną cyfrę reprezentującą liczbę parametrów typu, znajduje się na końcu nazwy typu ogólnego.|  
|Nawiasy kwadratowe ([])|Ujmij listy argumentów typu rodzajowego, aby uzyskać skonstruowany typ rodzajowy; na liście argumentów typu należy ująć typu kwalifikowanego zestawu.|  
|Przecinek (,)|Poprzedza nazwę zestawu.|  
|Kropka (.)|Wskazuje przestrzeń nazw identyfikatorów.|  
|Znak plus (+)|Poprzedza klasę zagnieżdżoną.|  
  
 Na przykład w pełni kwalifikowana nazwa klasy może wyglądać następująco:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Jeśli przestrzeń nazw zostały TopNamespace.Sub+Namespace, a następnie ciąg musi poprzedzać znak plus (+) przy użyciu znaku ucieczki (\\), aby zapobiec interpretacji jako separator zagnieżdżenia. Odbicie emituje tego ciągu w następujący sposób:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A "++" staje się "\\+\\+", a "\\"staje się"\\\\".  
  
 Ta nazwa kwalifikowana może utrwalona i później używana do ładowania <xref:System.Type>. Aby wyszukać i załadować <xref:System.Type>, użyj <xref:System.Type.GetType%2A> albo z typem nazwy tylko lub nazwą kwalifikowaną typu zestawu. <xref:System.Type.GetType%2A> z typem nazwy tylko będzie szukać <xref:System.Type> w zestawie wywołującego, a następnie w zestawie systemowym. <xref:System.Type.GetType%2A> z zestawem kwalifikowanej nazwy typu będzie szukać <xref:System.Type> w każdym zestawie.  
  
 Nazwy typów mogą obejmować końcowe znaki, które wyznaczają dodatkowe informacje dotyczące typu, na przykład to, czy typ jest typem odwołania, typem wskaźnika lub typem tablicowym. Aby pobrać, wpisz nazwę bez tych znaków końcowych, należy użyć `t.GetElementType().ToString()`, gdzie `t` jest typem.  
  
 Spacje są istotne we wszystkich składnikach nazwy z wyjątkiem nazwy zestawu. Spacje przed separatorem w nazwie zestawu ',' są istotne, ale spacje po separatorze ',' są ignorowane.  
  
 Nazwa typu ogólnego kończy się ciągiem początkowych (\`) następują cyfry reprezentujący liczbę wszystkich argumentów typu rodzajowego. Celem tego przekręcaniu nazwy jest umożliwienie kompilatory do obsługi typów ogólnych o takiej samej nazwie, ale z różną liczbę parametrów typu, w tym samym zakresie. Na przykład odbicia zwraca zniekształcone nazwy `Tuple`1` and `krotki`2` z metod ogólnych `Tuple(Of T)` i `Tuple(Of T0, T1)` w języku Visual Basic lub `Tuple<T>` i krotki`\<T0, T1>` w języku Visual C#.  
  
 Dla typów ogólnych lista argumentów typu jest ujęty w nawiasy i argumenty typu są oddzielone przecinkami. Na przykład ogólny <xref:System.Collections.Generic.Dictionary%602> ma dwa parametry typu. A <xref:System.Collections.Generic.Dictionary%602> z `MyType` przy użyciu kluczy typu <xref:System.String> może być reprezentowany w następujący sposób:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Aby określić typu kwalifikowanego zestawu w obrębie listy argumentów typu, należy ująć typu kwalifikowanego zestawu w nawiasy kwadratowe. W przeciwnym razie przecinki oddzielające części nazwy kwalifikowanej zestawu są interpretowane jako rozdzielający argumentów typu dodatkowe. Na przykład <xref:System.Collections.Generic.Dictionary%602> z `MyType` z MyAssembly.dll przy użyciu kluczy typu <xref:System.String>, może być następujący:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Typu kwalifikowanego zestawu mogą być ujęte w nawiasy kwadratowe, tylko wtedy, gdy pojawia się on w obrębie lista parametrów typu. Reguły dotyczące wyszukiwania zestawów dla typów kwalifikowana i niekwalifikowanej w liście parametrów typu są takie same jak reguły dla typów nierodzajowymi kwalifikowana i niekwalifikowane.  
  
 Typy dopuszczające wartości zerowe są w wyjątkowym przypadku okna typów ogólnych. Na przykład dopuszczający wartości null <xref:System.Int32> jest reprezentowany przez ciąg "System.Nullable'1[System.Int32]".  
  
> [!NOTE]
>  W języku C#, C++ i Visual Basic można również uzyskać przy użyciu operatorów typu typy dopuszczające wartości null. Na przykład nullable <xref:System.Boolean> typ zwracany przez `typeof(Nullable<bool>)` w języku C#, `Nullable<Boolean>::typeid` w języku C++ i przez `GetType(Nullable(Of Boolean))` w języku Visual Basic.  
  
 W poniższej tabeli przedstawiono składnię, możesz za pomocą `GetType` dla różnych typów.  
  
|Aby uzyskać|Zastosowanie|  
|------------|---------|  
|Dopuszczający wartości null <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Niezarządzany wskaźnik do `MyType`|`Type.GetType("MyType*")`|  
|Niezarządzany wskaźnik do wskaźnika do `MyType`|`Type.GetType("MyType**")`|  
|Zarządzane wskaźnik lub odwołanie do `MyType`|`Type.GetType("MyType&")`. Należy pamiętać, że w przeciwieństwie do wskaźników, odwołań są ograniczone do jednego poziomu.|  
|Klasy nadrzędnej i zagnieżdżone klasy|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Jednowymiarowa tablica dolną granicę równą 0|`Type.GetType("MyArray[]")`|  
|Jednowymiarowa tablica o nieznanych dolna granica|`Type.GetType("MyArray[*]")`|  
|N wymiarową tablicą|Przecinek (,) znajduje się wewnątrz nawiasów w sumie n-1 razy. Na przykład `System.Object[,,]` reprezentuje trójwymiarowym `Object` tablicy.|  
|Tablicy dwuwymiarowej tablicy|`Type.GetType("MyArray[][]")`|  
|Prostokątnej dwuwymiarowej tablicy przy użyciu nieznanego dolne granice|`Type.GetType("MyArray[,]")`|  
|Typ ogólny z jednego typu argumentu|``Type.GetType("MyGenericType`1[MyType]")``|  
|Typ ogólny z dwoma argumentami typu|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|Typ ogólny z dwóch argumentów typu kwalifikowanego zestawu|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|Kwalifikowanych dla zestawu typu ogólnego z nieprawidłowym argumentem typu kwalifikowanego zestawu|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|Typ ogólny, którego argument typu jest typ ogólny z dwoma argumentami typu|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 Poniższy przykład pobiera typ `System.Int32` i używa tego typu obiektu do wyświetlenia <xref:System.Type.FullName%2A> właściwość `System.Int32`. Jeśli obiekt typu odwołuje się do zestawu, który nie istnieje, w tym przykładzie zgłasza wyjątek.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> jest <see langword="true" /> i nie można odnaleźć typu.  
  
—lub— 
 <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> zawiera nieprawidłowe znaki, takie jak osadzona karta. 
—lub— 
 <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> reprezentuje typ tablicy z nieprawidłowym rozmiarem.  
  
—lub— 
 <paramref name="typeName" /> reprezentuje tablicę <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> ma nieprawidłową składnię. Na przykład "MyType [, *,]".  
  
—lub— 
 <paramref name="typeName" /> reprezentuje typ ogólny, który jest typem wskaźnika <see langword="ByRef" /> typu, lub <see cref="T:System.Void" /> jako jeden z argumentów typu.  
  
—lub— 
 <paramref name="typeName" /> reprezentuje typ ogólny, który ma niepoprawną liczbę argumentów typu.  
  
—lub— 
 <paramref name="typeName" /> reprezentuje typ ogólny i jeden z argumentów typu nie spełniają ograniczeń dla odpowiedniego parametru typu.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> jest <see langword="true" /> i nie znaleziono zestawu lub jednej z jego zależności.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.IO.IOException" />, a zamiast tego.  
  
</para>
          </block>  
  
 Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana, a zestaw został skompilowany przy użyciu nowszej wersji.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Określanie w pełni kwalifikowanych nazw typów</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa kwalifikowanego dla zestawu typu można pobrać. Zobacz <see cref="P:System.Type.AssemblyQualifiedName" />. Jeśli typ jest zawierający obecnie wykonywany zestaw lub biblioteki Mscorlib.dll, wystarczy podać nazwę typu kwalifikowana przez jego przestrzeń nazw.</param>
        <param name="throwOnError"><see langword="true" /> Aby zgłosić wyjątek, jeśli nie można odnaleźć typu; <see langword="false" /> do zwrócenia <see langword="null" />. Określanie <see langword="false" /> powoduje również pominięcie niektórych warunków wyjątków, ale nie wszystkie z nich. Zobacz sekcję Wyjątki.</param>
        <param name="ignoreCase"><see langword="true" /> Aby wykonać wyszukiwanie bez uwzględniania wielkości liter dla <paramref name="typeName" />, <see langword="false" /> przeprowadzić wyszukiwanie dla <paramref name="typeName" />.</param>
        <summary>Pobiera <see cref="T:System.Type" /> o określonej nazwie, określając czy zgłosić wyjątek, jeśli typ nie zostanie znaleziony i przeprowadzić wyszukiwanie.</summary>
        <returns>Typ o określonej nazwie. Jeśli typ nie zostanie znaleziony, <paramref name="throwOnError" /> parametr określa, czy <see langword="null" /> zwracany jest lub zostanie zgłoszony wyjątek. W niektórych przypadkach występuje wyjątek niezależnie od wartości <paramref name="throwOnError" />. Zobacz sekcję Wyjątki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Type.GetType%2A> metodę, aby uzyskać <xref:System.Type> obiektu dla typu w innym zestawie, jeśli znasz jego nazwę kwalifikowaną dla zestawu, który można uzyskać z <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A> powoduje, że ładowanie zestawu określonego w `typeName`. Można również załadować zestawu przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody, a następnie użyj <xref:System.Type.GetType%2A> lub <xref:System.Reflection.Assembly.GetTypes%2A> metody <xref:System.Reflection.Assembly> klasy, aby uzyskać <xref:System.Type> obiektów. Jeśli typ znajduje się w zestawie znane w czasie kompilacji program, jest bardziej wydajne, aby użyć `typeof` w języku C# <xref:System.Type.GetType%2A> w języku Visual Basic lub `typeid` w języku C++.  
  
 `GetType` działa tylko na zestawy, ładowane z dysku. Jeśli wywołasz `GetType` do wyszukania w typ zdefiniowany w zestawie dynamicznym zdefiniowane przy użyciu <xref:System.Reflection.Emit> usług, możesz otrzymać niespójne zachowanie. Zachowanie zależy od tego, czy zestaw dynamiczny jest trwała, oznacza to, utworzony za pomocą `RunAndSave` lub `Save` dostępu tryby <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> wyliczenia. Jeśli zestaw dynamiczny jest trwały i został zapisany na dysku przed `GetType` jest wywoływana, moduł ładujący wyszukuje zestaw zapisane na dysku, ładuje tego zestawu i pobiera typ z tego zestawu. Jeśli zestaw nie został zapisany na dysku po `GetType` jest wywoływana metoda zwraca `null`. `GetType` nie rozpoznaje przejściowy dynamicznych zestawów; Dlatego wywołanie `GetType` można pobrać typu na przejściowy zwraca zestaw dynamiczny `null`.  
  
 Aby użyć `GetType` na modułu dynamicznego subskrybować <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> zdarzenia i wywołania `GetType` przed zapisaniem. W przeciwnym razie otrzymasz dwie kopie zestawu w pamięci.  
  
 `throwOnError` Parametr określa, co się stanie, gdy typ nie zostanie znaleziony i powoduje również pominięcie niektórych warunków wyjątków, zgodnie z opisem w sekcji wyjątki. Niektóre wyjątki są zgłaszane niezależnie od wartości `throwOnError`. Na przykład, jeśli typ zostanie znaleziony, ale nie może zostać załadowany <xref:System.TypeLoadException> jest zgłaszany nawet wtedy, gdy `throwOnError` jest `false`.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Tablic lub typów modelu COM nie są wyszukiwane chyba, że już zostały załadowane do tabeli dostępnych klas.  
  
 `typeName` może być nazwa typu kwalifikowana przez jego przestrzeń nazw lub kwalifikowaną dla zestawu, która zawiera nazwę specyfikacja nazwy zestawu. Zobacz <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Jeśli `typeName` obejmuje przestrzeń nazw, ale nie nazwę zestawu, Metoda ta wyszukuje tylko do obiektu wywołującego zestawu i Mscorlib.dll, w tej kolejności. Jeśli typeName jest w pełni kwalifikowaną nazwą zestawu częściowego lub pełny, Metoda ta wyszukuje w określonym zestawie. Jeśli zestaw ma silną nazwą, wymagana jest nazwa kompletny zestaw.  
  
 <xref:System.Type.AssemblyQualifiedName%2A> Właściwość zwraca w pełni kwalifikowaną nazwę typu w tym typów zagnieżdżonych, nazwa zestawu i argumentów typu. Wszystkie kompilatory, które obsługują aparat plików wykonywalnych języka wspólnego, w trakcie wykonania wyemitują prostą nazwę klasy zagnieżdżonej, a odbicie podczas kwerendy stworzy zniekształcone nazwy zgodnie z następującymi konwencjami.  
  
> [!NOTE]
>  W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw. Na przykład "ProcessorArchitecture = msil". Jednak nie są uwzględnione w ciągu zwracanego przez <xref:System.Type.AssemblyQualifiedName%2A> właściwość ze względu na zgodność. Można również załadować typów, tworząc <xref:System.Reflection.AssemblyName> obiektu i przekazywania go do odpowiedniego przeciążenia <xref:System.Reflection.Assembly.Load%2A> metody. Następnie można użyć <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> metodę, aby załadować typów z zestawu. Zobacz też <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Ogranicznik|Znaczenie|  
|---------------|-------------|  
|Ukośnik odwrotny (\\)|Znak ucieczki.|  
|Backtick (`)|Poprzedza co najmniej jedną cyfrę reprezentującą liczbę parametrów typu, znajduje się na końcu nazwy typu ogólnego.|  
|Nawiasy kwadratowe ([])|Ujmij listy argumentów typu rodzajowego, aby uzyskać skonstruowany typ rodzajowy; na liście argumentów typu należy ująć typu kwalifikowanego zestawu.|  
|Przecinek (,)|Poprzedza nazwę zestawu.|  
|Kropka (.)|Wskazuje przestrzeń nazw identyfikatorów.|  
|Znak plus (+)|Poprzedza klasę zagnieżdżoną.|  
  
 Na przykład w pełni kwalifikowana nazwa klasy może wyglądać następująco:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Jeśli przestrzeń nazw zostały TopNamespace.Sub+Namespace, a następnie ciąg musi poprzedzać znak plus (+) przy użyciu znaku ucieczki (\\), aby zapobiec interpretacji jako separator zagnieżdżenia. Odbicie emituje tego ciągu w następujący sposób:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A "++" staje się "\\+\\+", a "\\"staje się"\\\\".  
  
 Ta nazwa kwalifikowana może utrwalona i później używana do ładowania <xref:System.Type>. Aby wyszukać i załadować <xref:System.Type>, użyj <xref:System.Type.GetType%2A> albo z typem nazwy tylko lub nazwą kwalifikowaną typu zestawu. <xref:System.Type.GetType%2A> z typem nazwy tylko będzie szukać <xref:System.Type> w zestawie wywołującego, a następnie w zestawie systemowym. <xref:System.Type.GetType%2A> z zestawem kwalifikowanej nazwy typu będzie szukać <xref:System.Type> w każdym zestawie.  
  
 Nazwy typów mogą obejmować końcowe znaki, które wyznaczają dodatkowe informacje dotyczące typu, na przykład to, czy typ jest typem odwołania, typem wskaźnika lub typem tablicowym. Aby pobrać, wpisz nazwę bez tych znaków końcowych, należy użyć `t.GetElementType().ToString()`, gdzie `t` jest typem.  
  
 Spacje są istotne we wszystkich składnikach nazwy z wyjątkiem nazwy zestawu. Spacje przed separatorem w nazwie zestawu ',' są istotne, ale spacje po separatorze ',' są ignorowane.  
  
 Nazwa typu ogólnego kończy się ciągiem początkowych (\`) następują cyfry reprezentujący liczbę wszystkich argumentów typu rodzajowego. Celem tego przekręcaniu nazwy jest umożliwienie kompilatory do obsługi typów ogólnych o takiej samej nazwie, ale z różną liczbę parametrów typu, w tym samym zakresie. Na przykład odbicia zwraca zniekształcone nazwy `Tuple`1` and `krotki`2` z metod ogólnych `Tuple(Of T)` i `Tuple(Of T0, T1)` w języku Visual Basic lub `Tuple<T>` i krotki`\<T0, T1>` w języku Visual C#.  
  
 Dla typów ogólnych lista argumentów typu jest ujęty w nawiasy i argumenty typu są oddzielone przecinkami. Na przykład ogólny <xref:System.Collections.Generic.Dictionary%602> ma dwa parametry typu. A <xref:System.Collections.Generic.Dictionary%602> z `MyType` przy użyciu kluczy typu <xref:System.String> może być reprezentowany w następujący sposób:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Aby określić typu kwalifikowanego zestawu w obrębie listy argumentów typu, należy ująć typu kwalifikowanego zestawu w nawiasy kwadratowe. W przeciwnym razie przecinki oddzielające części nazwy kwalifikowanej zestawu są interpretowane jako rozdzielający argumentów typu dodatkowe. Na przykład <xref:System.Collections.Generic.Dictionary%602> z `MyType` z MyAssembly.dll przy użyciu kluczy typu <xref:System.String>, może być następujący:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Typu kwalifikowanego zestawu mogą być ujęte w nawiasy kwadratowe, tylko wtedy, gdy pojawia się on w obrębie lista parametrów typu. Reguły dotyczące wyszukiwania zestawów dla typów kwalifikowana i niekwalifikowanej w liście parametrów typu są takie same jak reguły dla typów nierodzajowymi kwalifikowana i niekwalifikowane.  
  
 Typy dopuszczające wartości zerowe są w wyjątkowym przypadku okna typów ogólnych. Na przykład dopuszczający wartości null <xref:System.Int32> jest reprezentowany przez ciąg "System.Nullable'1[System.Int32]".  
  
> [!NOTE]
>  W języku C#, C++ i Visual Basic można również uzyskać przy użyciu operatorów typu typy dopuszczające wartości null. Na przykład nullable <xref:System.Boolean> typ zwracany przez `typeof(Nullable<bool>)` w języku C#, `Nullable<Boolean>::typeid` w języku C++ i przez `GetType(Nullable(Of Boolean))` w języku Visual Basic.  
  
 W poniższej tabeli przedstawiono składnię, możesz za pomocą `GetType` dla różnych typów.  
  
|Aby uzyskać|Zastosowanie|  
|------------|---------|  
|Dopuszczający wartości null <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Niezarządzany wskaźnik do `MyType`|`Type.GetType("MyType*")`|  
|Niezarządzany wskaźnik do wskaźnika do `MyType`|`Type.GetType("MyType**")`|  
|Zarządzane wskaźnik lub odwołanie do `MyType`|`Type.GetType("MyType&")`. Należy pamiętać, że w przeciwieństwie do wskaźników, odwołań są ograniczone do jednego poziomu.|  
|Klasy nadrzędnej i zagnieżdżone klasy|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Jednowymiarowa tablica dolną granicę równą 0|`Type.GetType("MyArray[]")`|  
|Jednowymiarowa tablica o nieznanych dolna granica|`Type.GetType("MyArray[*]")`|  
|N wymiarową tablicą|Przecinek (,) znajduje się wewnątrz nawiasów w sumie n-1 razy. Na przykład `System.Object[,,]` reprezentuje trójwymiarowym `Object` tablicy.|  
|Tablicy dwuwymiarowej tablicy|`Type.GetType("MyArray[][]")`|  
|Prostokątnej dwuwymiarowej tablicy przy użyciu nieznanego dolne granice|`Type.GetType("MyArray[,]")`|  
|Typ ogólny z jednego typu argumentu|``Type.GetType("MyGenericType`1[MyType]")``|  
|Typ ogólny z dwoma argumentami typu|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|Typ ogólny z dwóch argumentów typu kwalifikowanego zestawu|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|Kwalifikowanych dla zestawu typu ogólnego z nieprawidłowym argumentem typu kwalifikowanego zestawu|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|Typ ogólny, którego argument typu jest typ ogólny z dwoma argumentami typu|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> jest <see langword="true" /> i nie można odnaleźć typu.  
  
—lub— 
 <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> zawiera nieprawidłowe znaki, takie jak osadzona karta. 
—lub— 
 <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> reprezentuje typ tablicy z nieprawidłowym rozmiarem.  
  
—lub— 
 <paramref name="typeName" /> reprezentuje tablicę <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> ma nieprawidłową składnię. Na przykład "MyType [, *,]".  
  
—lub— 
 <paramref name="typeName" /> reprezentuje typ ogólny, który jest typem wskaźnika <see langword="ByRef" /> typu, lub <see cref="T:System.Void" /> jako jeden z argumentów typu.  
  
—lub— 
 <paramref name="typeName" /> reprezentuje typ ogólny, który ma niepoprawną liczbę argumentów typu.  
  
—lub— 
 <paramref name="typeName" /> reprezentuje typ ogólny i jeden z argumentów typu nie spełniają ograniczeń dla odpowiedniego parametru typu.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> jest <see langword="true" /> i nie znaleziono zestawu lub jednej z jego zależności.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.  
  
—lub— 
W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana, a zestaw został skompilowany przy użyciu nowszej wersji.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Określanie w pełni kwalifikowanych nazw typów</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa typu, który można pobrać. Jeśli <paramref name="typeResolver" /> parametr zostanie podany, nazwa typu może być dowolny ciąg, który <paramref name="typeResolver" /> jest w stanie rozwiązywania. Jeśli <paramref name="assemblyResolver" /> parametr ma pod warunkiem, lub jeśli rozpoznawania typu Standardowy jest używany, <paramref name="typeName" /> musi być kwalifikowana nazwa zestawu (zobacz <see cref="P:System.Type.AssemblyQualifiedName" />), chyba że typ jest zawierający obecnie wykonywany zestaw lub biblioteki Mscorlib.dll, w którym to przypadku wystarczy Podaj nazwę typu kwalifikowana przez jego przestrzeń nazw.</param>
        <param name="assemblyResolver">Metoda, która lokalizuje i zwraca zestaw, który jest określony w <paramref name="typeName" />. Nazwa zestawu jest przekazywany do <paramref name="assemblyResolver" /> jako <see cref="T:System.Reflection.AssemblyName" /> obiektu. Jeśli <paramref name="typeName" /> nie zawiera nazwy zestawu, <paramref name="assemblyResolver" /> nie zostanie wywołana. Jeśli <paramref name="assemblyResolver" /> nie jest podany, standardowego zestawu rozpoznawanie odbywa się.  
  
Uwaga nie przechodzą z nieznanych lub niezaufanych wywołujących. Ten sposób może spowodować podniesienie uprawnień dla złośliwego kodu. Użyj tylko określonych przez siebie metod lub tych, które znasz.</param>
        <param name="typeResolver">Metody, która lokalizuje i zwraca typ, który jest określony przez <paramref name="typeName" /> z zestawu, który jest zwracany przez <paramref name="assemblyResolver" /> lub rozpoznawania zestawu standardowych. Jeśli nie podano żadnego zestawu, <paramref name="typeResolver" /> metoda może dostarczyć jeden. Ta metoda również przyjmuje parametr, który określa, czy należy wykonać wyszukiwanie bez uwzględniania wielkości liter; <see langword="false" /> jest przekazywany do tego parametru.  
  
Uwaga nie przechodzą z nieznanych lub niezaufanych wywołujących.</param>
        <summary>Pobiera typ o określonej nazwie, opcjonalnie podania niestandardowych metod można rozpoznać zestawu i typu.</summary>
        <returns>Typ o określonej nazwie lub <see langword="null" /> Jeśli typ nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Scenariusze użycia dotyczące tę metodę i szczegółowe informacje o `assemblyResolver` i `typeResolver` parametrów można znaleźć w <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenie metody.  
  
> [!NOTE]
>  Jeśli `typeName` nie można znaleźć, wywołanie <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> metoda zwraca `null`. Nie zostanie zgłoszony wyjątek. Do kontrolowania tego, czy wyjątek jest generowany, wywołania przeciążenia <xref:System.Type.GetType%2A> metody, która ma `throwOnError` parametru.  
  
 Wywołanie tego przeciążenia metody jest taka sama jak wywołanie <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenie metody i określając `false` dla `throwOnError` i `ignoreCase` parametrów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.ArgumentException">Błąd występuje, gdy <paramref name="typeName" /> jest przekształcany do nazwy typu i nazwy zestawu (na przykład, gdy nazwa typu prostego zawiera specjalne znaku o niezmienionym znaczeniu).  
  
—lub— 
 <paramref name="typeName" /> reprezentuje typ ogólny, który jest typem wskaźnika <see langword="ByRef" /> typu, lub <see cref="T:System.Void" /> jako jeden z argumentów typu.  
  
—lub— 
 <paramref name="typeName" /> reprezentuje typ ogólny, który ma niepoprawną liczbę argumentów typu.  
  
—lub— 
 <paramref name="typeName" /> reprezentuje typ ogólny i jeden z argumentów typu nie spełniają ograniczeń dla odpowiedniego parametru typu.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> reprezentuje tablicę <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.  
  
—lub— 
 <paramref name="typeName" /> zawiera nieprawidłową nazwę zestawu.  
  
—lub— 
 <paramref name="typeName" /> jest nazwą prawidłowego zestawu bez nazwy typu.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.  
  
—lub— 
Zestaw został skompilowany przy użyciu nowszej wersji aparatu plików wykonywalnych języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa typu, który można pobrać. Jeśli <paramref name="typeResolver" /> parametr zostanie podany, nazwa typu może być dowolny ciąg, który <paramref name="typeResolver" /> jest w stanie rozwiązywania. Jeśli <paramref name="assemblyResolver" /> parametr ma pod warunkiem, lub jeśli rozpoznawania typu Standardowy jest używany, <paramref name="typeName" /> musi być kwalifikowana nazwa zestawu (zobacz <see cref="P:System.Type.AssemblyQualifiedName" />), chyba że typ jest zawierający obecnie wykonywany zestaw lub biblioteki Mscorlib.dll, w którym to przypadku wystarczy Podaj nazwę typu kwalifikowana przez jego przestrzeń nazw.</param>
        <param name="assemblyResolver">Metoda, która lokalizuje i zwraca zestaw, który jest określony w <paramref name="typeName" />. Nazwa zestawu jest przekazywany do <paramref name="assemblyResolver" /> jako <see cref="T:System.Reflection.AssemblyName" /> obiektu. Jeśli <paramref name="typeName" /> nie zawiera nazwy zestawu, <paramref name="assemblyResolver" /> nie zostanie wywołana. Jeśli <paramref name="assemblyResolver" /> nie jest podany, standardowego zestawu rozpoznawanie odbywa się.  
  
Uwaga nie przechodzą z nieznanych lub niezaufanych wywołujących. Ten sposób może spowodować podniesienie uprawnień dla złośliwego kodu. Użyj tylko określonych przez siebie metod lub tych, które znasz.</param>
        <param name="typeResolver">Metody, która lokalizuje i zwraca typ, który jest określony przez <paramref name="typeName" /> z zestawu, który jest zwracany przez <paramref name="assemblyResolver" /> lub rozpoznawania zestawu standardowych. Jeśli nie podano żadnego zestawu, metoda może dostarczyć jeden. Ta metoda również przyjmuje parametr, który określa, czy należy wykonać wyszukiwanie bez uwzględniania wielkości liter; <see langword="false" /> jest przekazywany do tego parametru.  
  
Uwaga nie przechodzą z nieznanych lub niezaufanych wywołujących.</param>
        <param name="throwOnError"><see langword="true" /> Aby zgłosić wyjątek, jeśli nie można odnaleźć typu; <see langword="false" /> do zwrócenia <see langword="null" />. Określanie <see langword="false" /> powoduje również pominięcie niektórych warunków wyjątków, ale nie wszystkie z nich. Zobacz sekcję Wyjątki.</param>
        <summary>Pobiera typ o określonej nazwie, określająca, czy zgłosić wyjątek, jeśli typ nie zostanie znaleziony i opcjonalnie podania niestandardowych metod można rozpoznać zestawu i typu.</summary>
        <returns>Typ o określonej nazwie. Jeśli typ nie zostanie znaleziony, <paramref name="throwOnError" /> parametr określa, czy <see langword="null" /> zwracany jest lub zostanie zgłoszony wyjątek. W niektórych przypadkach występuje wyjątek niezależnie od wartości <paramref name="throwOnError" />. Zobacz sekcję Wyjątki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Scenariusze użycia dotyczące tę metodę i szczegółowe informacje o `assemblyResolver` i `typeResolver` parametrów można znaleźć w <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenie metody.  
  
 Wywołanie tego przeciążenia metody jest taka sama jak wywołanie <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenie metody i określając `false` dla `ignoreCase` parametru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> jest <see langword="true" /> i nie można odnaleźć typu.  
  
—lub— 
 <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> zawiera nieprawidłowe znaki, takie jak osadzona karta. 
—lub— 
 <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> reprezentuje typ tablicy z nieprawidłowym rozmiarem.  
  
—lub— 
 <paramref name="typeName" /> reprezentuje tablicę <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">Błąd występuje, gdy <paramref name="typeName" /> jest przekształcany do nazwy typu i nazwy zestawu (na przykład, gdy nazwa typu prostego zawiera specjalne znaku o niezmienionym znaczeniu).  
  
—lub— 
 <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> ma nieprawidłową składnię "(na przykład MyType[,*,]").  
  
—lub— 
 <paramref name="typeName" /> reprezentuje typ ogólny, który jest typem wskaźnika <see langword="ByRef" /> typu, lub <see cref="T:System.Void" /> jako jeden z argumentów typu.  
  
—lub— 
 <paramref name="typeName" /> reprezentuje typ ogólny, który ma niepoprawną liczbę argumentów typu.  
  
—lub— 
 <paramref name="typeName" /> reprezentuje typ ogólny i jeden z argumentów typu nie spełniają ograniczeń dla odpowiedniego parametru typu.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> jest <see langword="true" /> i nie znaleziono zestawu lub jednej z jego zależności.  
  
—lub— 
 <paramref name="typeName" /> zawiera nieprawidłową nazwę zestawu.  
  
—lub— 
 <paramref name="typeName" /> jest nazwą prawidłowego zestawu bez nazwy typu.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.  
  
—lub— 
Zestaw został skompilowany przy użyciu nowszej wersji aparatu plików wykonywalnych języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa typu, który można pobrać. Jeśli <paramref name="typeResolver" /> parametr zostanie podany, nazwa typu może być dowolny ciąg, który <paramref name="typeResolver" /> jest w stanie rozwiązywania. Jeśli <paramref name="assemblyResolver" /> parametr ma pod warunkiem, lub jeśli rozpoznawania typu Standardowy jest używany, <paramref name="typeName" /> musi być kwalifikowana nazwa zestawu (zobacz <see cref="P:System.Type.AssemblyQualifiedName" />), chyba że typ jest zawierający obecnie wykonywany zestaw lub biblioteki Mscorlib.dll, w którym to przypadku wystarczy Podaj nazwę typu kwalifikowana przez jego przestrzeń nazw.</param>
        <param name="assemblyResolver">Metoda, która lokalizuje i zwraca zestaw, który jest określony w <paramref name="typeName" />. Nazwa zestawu jest przekazywany do <paramref name="assemblyResolver" /> jako <see cref="T:System.Reflection.AssemblyName" /> obiektu. Jeśli <paramref name="typeName" /> nie zawiera nazwy zestawu, <paramref name="assemblyResolver" /> nie zostanie wywołana. Jeśli <paramref name="assemblyResolver" /> nie jest podany, standardowego zestawu rozpoznawanie odbywa się.  
  
Uwaga nie przechodzą z nieznanych lub niezaufanych wywołujących. Ten sposób może spowodować podniesienie uprawnień dla złośliwego kodu. Użyj tylko określonych przez siebie metod lub tych, które znasz.</param>
        <param name="typeResolver">Metody, która lokalizuje i zwraca typ, który jest określony przez <paramref name="typeName" /> z zestawu, który jest zwracany przez <paramref name="assemblyResolver" /> lub rozpoznawania zestawu standardowych. Jeśli nie podano żadnego zestawu, metoda może dostarczyć jeden. Ta metoda również przyjmuje parametr, który określa, czy należy wykonać wyszukiwanie bez uwzględniania wielkości liter; wartość <paramref name="ignoreCase" /> jest przekazywany do tego parametru.  
  
Uwaga nie przechodzą z nieznanych lub niezaufanych wywołujących.</param>
        <param name="throwOnError"><see langword="true" /> Aby zgłosić wyjątek, jeśli nie można odnaleźć typu; <see langword="false" /> do zwrócenia <see langword="null" />. Określanie <see langword="false" /> powoduje również pominięcie niektórych warunków wyjątków, ale nie wszystkie z nich. Zobacz sekcję Wyjątki.</param>
        <param name="ignoreCase"><see langword="true" /> Aby wykonać wyszukiwanie bez uwzględniania wielkości liter dla <paramref name="typeName" />, <see langword="false" /> przeprowadzić wyszukiwanie dla <paramref name="typeName" />.</param>
        <summary>Pobiera typ o określonej nazwie, określania, czy przeprowadzić wyszukiwanie i czy chcesz zgłosić wyjątek, jeśli typ nie zostanie znaleziony i opcjonalnie podania niestandardowych metod można rozpoznać zestawu i typu.</summary>
        <returns>Typ o określonej nazwie. Jeśli typ nie zostanie znaleziony, <paramref name="throwOnError" /> parametr określa, czy <see langword="null" /> zwracany jest lub zostanie zgłoszony wyjątek. W niektórych przypadkach występuje wyjątek niezależnie od wartości <paramref name="throwOnError" />. Zobacz sekcję Wyjątki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia metody i jego skojarzone przeciążenia (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> i <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) zastąpić domyślną implementację elementu <xref:System.Type.GetType%2A> metody z implementacjami bardziej elastyczne. Podając własne metody, które rozpoznać nazwy typu i nazwy zestawów, zawierające je, możesz wykonać następujące czynności:  
  
-   Kontroli wersji typu jest ładowany z zestawu.  
  
-   Podaj inne miejsce do wyszukania nazwy typu, który nie zawiera nazwy zestawu.  
  
-   Ładowanie zestawów przy użyciu nazwy zestawów częściowej.  
  
-   Zwróć podklasy <xref:System.Type?displayProperty=nameWithType> nie są tworzone przez środowisko uruchomieniowe języka wspólnego (CLR).  
  
 Na przykład serializacji z tolerancją dla wersji ta metoda umożliwia wyszukiwanie dla zestawu "o najlepszej zgodności" przy użyciu nazwy częściowej. Inne przeciążenia <xref:System.Type.GetType%2A> metody wymagają nazwę typu kwalifikowanego zestawu, który zawiera numer wersji.  
  
 Alternatywnych implementacji system typów może być konieczne do zwrócenia podklasy <xref:System.Type?displayProperty=nameWithType> nie są tworzone przez środowisko CLR; wszystkie typy, które są zwracane przez inne przeciążenia <xref:System.Type.GetType%2A> metody są typami środowiska wykonawczego.  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>Uwagi dotyczące użytkowania  
 Tego przeciążenia metody i jego skojarzone przeciążenia przeanalizować `typeName` w nazwie typu i nazwy zestawu, a następnie rozpoznawania nazw. Rozpoznawanie nazwy zestawu wcześniejsza rozpoznawanie nazwy typu, ponieważ nazwa typu muszą być rozwiązane w kontekście zestawu.  
  
> [!NOTE]
>  Jeśli nie jesteś zaznajomiony z pojęciem nazw kwalifikowanych dla zestawu typu, zobacz <xref:System.Type.AssemblyQualifiedName%2A> właściwości.  
  
 Jeśli `typeName` nie jest kwalifikowana nazwa zestawu, rozpoznawania zestawu jest pomijany. Można rozwiązać nazwy niekwalifikowanej typów w kontekście Mscorlib.dll lub zawierający obecnie wykonywany zestaw lub opcjonalnie możesz podać zestawu w `typeResolver` parametru. W tym lub pominięcie Nazwa zestawu dla różnych rodzajów rozpoznawania nazw są wyświetlane jako tabelę w [rozpoznawanie nazw mieszanych](#mixed_name_resolution) sekcji.  
  
 Uwagi dotyczące użycia ogólne:  
  
-   Nie przekazuj metody `assemblyResolver` lub `typeResolver` jeśli pochodzą z nieznanych lub niezaufanych wywołujących. Użyj tylko określonych przez siebie metod lub tych, które znasz.  
  
    > [!CAUTION]
    >  Za pomocą metod z nieznanych lub niezaufanych wywołujących może spowodować podniesienie uprawnień dla złośliwego kodu.  
  
-   Jeżeli pominięto `assemblyResolver` i/lub `typeResolver` parametrów, wartość `throwOnError` parametr został przekazany do metody, które wykonują domyślnego rozwiązania.  
  
-   Jeśli `throwOnError` jest `true`, ta metoda wyrzuca <xref:System.TypeLoadException> podczas `typeResolver` zwraca `null`, a <xref:System.IO.FileNotFoundException> podczas `assemblyResolver` zwraca `null`.  
  
-   Ta metoda nie przechwytuje wyjątków zgłaszanych przez `assemblyResolver` i `typeResolver`. Odpowiedzialność za wszelkie wyjątki wyrzucane przez metody rozpoznawania nazw.  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>Rozpoznawanie zespołów  
 `assemblyResolver` Metoda otrzymuje <xref:System.Reflection.AssemblyName> obiektu, który jest generowany przez analizowanie ciągu nazwy zestawu, który znajduje się w `typeName`. Jeśli `typeName` nie zawiera nazwy zestawu `assemblyResolver` nie jest wywoływany i `null` jest przekazywany do `typeResolver`.  
  
 Jeśli `assemblyResolver` nie jest podany, standardowego zestawu badania jest używana do lokalizowania zestawu. Jeśli `assemblyResolver` zostanie podany, <xref:System.Type.GetType%2A> metody nie powoduje standardowa badania; w takim przypadku należy zagwarantować, że Twoje `assemblyResolver` może obsłużyć wszystkie zestawy przekazywania do niej.  
  
 `assemblyResolver` Metoda powinna zwrócić `null` Jeśli zestaw nie jest możliwe. Jeśli `assemblyResolver` zwraca `null`, `typeResolver` nie jest wywoływana, a żadne dalsze przetwarzanie odbywa się; ponadto, jeśli `throwOnError` jest `true`, <xref:System.IO.FileNotFoundException> zgłaszany.  
  
 Jeśli <xref:System.Reflection.AssemblyName> przekazana do `assemblyResolver` częściowym jest nazwa co najmniej jeden z jego części `null`. Na przykład, jeśli go nie ma wersji <xref:System.Reflection.AssemblyName.Version%2A> właściwość `null`. Jeśli <xref:System.Reflection.AssemblyName.Version%2A> właściwości <xref:System.Reflection.AssemblyName.CultureInfo%2A> właściwości i <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> wszystkie zwrotu metody `null`, a następnie podano prostą nazwę zestawu. `assemblyResolver` Metody można użyć lub zignorować wszystkie części nazwy zestawu.  
  
 Efekty opcje rozdzielczości w innym zestawie są wyświetlane jako tabeli [rozpoznawanie nazw mieszanych](#mixed_name_resolution) dotyczącej nazwy typów prostych i kwalifikowanych dla zestawu.  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>Rozpoznawanie typów  
 Jeśli `typeName` nie określa nazwy zestawu `typeResolver` zawsze jest wywoływany. Jeśli `typeName` Określa nazwę zestawu `typeResolver` jest wywoływana tylko wtedy, gdy jest to nazwa zestawu jest pomyślnie rozpoznana. Jeśli `assemblyResolver` lub standardowego zestawu sondowanie zwraca `null`, `typeResolver` nie zostanie wywołana.  
  
 `typeResolver` Metoda otrzymuje trzy argumenty:  
  
-   Zestaw do wyszukiwania lub `null` Jeśli `typeName` nie zawiera nazwy zestawu.  
  
-   Prosta nazwa typu. W przypadku typu zagnieżdżonego to najbardziej zewnętrznego typu zawierającego. W przypadku typu ogólnego to prostą nazwę typu ogólnego.  
  
-   Wartość logiczna, która jest `true` Jeśli wielkość liter nazwy typu ma być ignorowane.  
  
 Implementacja określa sposób, są używane następujące argumenty. `typeResolver` Metoda powinna zwrócić `null` Jeśli nie można rozpoznać typu. Jeśli `typeResolver` zwraca `null` i `throwOnError` jest `true`, to przeciążenie <xref:System.Type.GetType%2A> zgłasza <xref:System.TypeLoadException>.  
  
 Efekty opcje rozpoznawania innego typu są wyświetlane jako tabeli [rozpoznawanie nazw mieszanych](#mixed_name_resolution) dotyczącej nazwy typów prostych i kwalifikowanych dla zestawu.  
  
#### <a name="resolving-nested-types"></a>Rozpoznawanie zagnieżdżonych typów  
 Jeśli `typeName` jest typem zagnieżdżonym tylko nazwę prowadzące z typem jest przekazywany do `typeResolver`. Gdy `typeResolver` zwraca tego typu <xref:System.Type.GetNestedType%2A> metoda jest wywoływana cyklicznie, dopóki najbardziej typu zagnieżdżonego zostanie rozwiązany.  
  
#### <a name="resolving-generic-types"></a>Rozpoznawanie typów rodzajowych  
 <xref:System.Type.GetType%2A> Nosi nazwę cyklicznie, aby rozwiązać typów ogólnych: Aby rozpoznać typu rodzajowego, a następnie Rozwiąż argumentów typu. Jeśli argument typu ogólnego, <xref:System.Type.GetType%2A> nosi nazwę cyklicznie, aby rozwiązać argumentów typu i tak dalej.  
  
 Kombinacja `assemblyResolver` i `typeResolver` podane muszą być w stanie rozwiązywania wszystkich poziomów to rekursji. Załóżmy, że podajesz `assemblyResolver` sterującą ładowanie `MyAssembly`. Załóżmy, że chcesz usunąć typ ogólny `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` w języku Visual Basic). Następująca nazwa typu ogólnego może zostać przekazany:  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 Należy zauważyć, że `MyType` jest argumentem typu tylko kwalifikowanego zestawu. Nazwy <xref:System.Collections.Generic.Dictionary%602> i <xref:System.String> klasy nie są kwalifikowaną dla zestawu. Twoje `typeResolver` stanie dojścia musi być jednym z zestawów lub `null`, ponieważ będzie ona otrzymywać `null` dla <xref:System.Collections.Generic.Dictionary%602> i <xref:System.String>. Może obsługiwać tego przypadku poprzez wywołanie przeciążenia <xref:System.Type.GetType%2A> metody, która przyjmuje ciąg, ponieważ obie nazwy niekwalifikowanej typów Mscorlib.dll:  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 `assemblyResolver` Metoda nie jest wywoływana dla typu słownika i typu string, ponieważ te nazwy typów nie są kwalifikowaną dla zestawu.  
  
 Teraz załóżmy, że zamiast `System.String`, pierwszy typ ogólny, argument jest `YourType`, z `YourAssembly`:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 Ponieważ ten zestaw jest, aby biblioteka Mscorlib.dll ani zawierający obecnie wykonywany zestaw, nie można rozpoznać `YourType` bez nazwy kwalifikowanej zestawu. Ponieważ Twoje `assemblyResolve` będzie wywoływany rekursywnie, musi być w stanie obsłużyć tego przypadku. Zamiast zwracać `null` dla zestawów innych niż `MyAssembly`, wykonuje obecnie ładowanie zestawu z użyciem podane <xref:System.Reflection.AssemblyName> obiektu.  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 Powrót do [uwagi dotyczące użycia](#usage_notes).  
  
#### <a name="resolving-type-names-with-special-characters"></a>Rozpoznawanie nazw typów ze znakami specjalnymi  
 Niektóre znaki mają specjalne znaczenie w nazw kwalifikowanych dla zestawu. Nazwa typu prostego, który zawiera te znaki, znaki powodować błędy podczas analizowania gdy prosta nazwa jest częścią kwalifikowana nazwa zestawu. Aby uniknąć błędów podczas analizowania, znaki specjalne znakiem kreski ułamkowej odwróconej ucieczki musi przed można przekazać nazwę kwalifikowaną dla zestawu, aby <xref:System.Type.GetType%2A> metody. Na przykład, jeśli typ ma nazwę `Strange]Type`, znaku ucieczki musi zostać dodany wcześniej nawias kwadratowy w następujący sposób: `Strange\]Type`.  
  
> [!NOTE]
>  Nazwy tych znaków specjalnych nie można utworzyć w języku Visual Basic lub C#, ale można utworzyć za pomocą języka Microsoft intermediate language (MSIL) lub emitowanie dynamicznych zestawów.  
  
 W poniższej tabeli przedstawiono znaki specjalne dla nazwy typu.  
  
|Znak|Znaczenie|  
|---------------|-------------|  
|`,` (przecinek)|/ / / Ogranicznik nazw kwalifikowanych dla zestawu.|  
|`[]` (nawiasy kwadratowe)|Jako parę sufiks wskazuje typ tablicy; jako parę ogranicznik otacza listy argumentów ogólnych i nazw kwalifikowanych dla zestawu.|  
|`&` (handlowe "i")|Jako sufiks wskazuje, że typ jest typem referencyjnym.|  
|`*` (gwiazdka)|Jako sufiks wskazuje, że typ jest typem wskaźnika.|  
|`+` (znak plus)|/ / / Ogranicznik zagnieżdżone typy.|  
|`\` (ukośnik odwrotny)|Znak ucieczki.|  
  
 Właściwości, takie jak <xref:System.Type.AssemblyQualifiedName%2A> return prawidłowo poprzedzone znakiem zmiany znaczenia ciągów. Należy przekazać poprawnie o zmienionym znaczeniu ciągów w celu <xref:System.Type.GetType%2A> metody. Z kolei <xref:System.Type.GetType%2A> metoda przekazuje poprawnie o zmienionym znaczeniu nazwy `typeResolver` oraz metody rozpoznawania typu domyślnego. Jeśli chcesz porównać nazwy do nazwy o niezmienionym znaczeniu w `typeResolver`, należy usunąć znaki ucieczki.  
  
 Powrót do [uwagi dotyczące użycia](#usage_notes).  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>Rozpoznawanie nazw mieszanych  
 W poniższej tabeli przedstawiono interakcje między `assemblyResolver`, `typeResolver`i rozpoznawania nazw domyślnego dla wszystkich kombinacji nazwy typu i nazwy zestawu w `typeName`:  
  
|Nazwa typu zawartości|Metoda rozpoznawania zestawu|Metody rozpoznawania typu|Wynik|  
|---------------------------|------------------------------|--------------------------|------------|  
|typ, zestaw|null|null|Równoważne z wywoływaniem <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> przeciążenie metody.|  
|typ, zestaw|podano|null|`assemblyResolver` Zwraca zestaw lub zwraca `null` Jeśli nie można rozpoznać zestawu. Jeśli zestaw nie zostanie rozwiązany, <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> przeciążenie metody jest używana do ładowania typów z zestawu; w przeciwnym razie wystąpi próba rozpoznać typu.|  
|typ, zestaw|null|podano|Równoważne do konwertowania nazwy zestawu, aby <xref:System.Reflection.AssemblyName> obiektu i wywoływania <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> przeciążenia metody, aby uzyskać zestawu. Jeśli zestaw nie zostanie rozwiązany, zostanie on przekazany do `typeResolver`; w przeciwnym razie `typeResolver` nie jest wywoływany i nie dalsze próby rozwiązania typu.|  
|typ, zestaw|podano|podano|`assemblyResolver` Zwraca zestaw lub zwraca `null` Jeśli nie można rozpoznać zestawu. Jeśli zestaw nie zostanie rozwiązany, zostanie on przekazany do `typeResolver`; w przeciwnym razie `typeResolver` nie jest wywoływany i nie dalsze próby rozwiązania typu.|  
|— typ|wartość NULL, podana|null|Równoważne z wywoływaniem <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> przeciążenie metody. Ponieważ nie podano nazwy zestawu, przeszukiwane są tylko Biblioteka Mscorlib.dll i zawierający obecnie wykonywany zestaw. Jeśli `assemblyResolver` zostanie podana, zostanie zignorowany.|  
|— typ|wartość NULL, podana|podano|`typeResolver` jest wywoływana, i `null` jest przekazywana do zestawu. `typeResolver` można podać typ z dowolnego zestawu, w tym zestawów, które ładuje do tego celu. Jeśli `assemblyResolver` zostanie podana, zostanie zignorowany.|  
|zestaw|wartość NULL, podana|wartość NULL, podana|Element <xref:System.IO.FileLoadException> jest generowany, ponieważ nazwa zestawu jest analizowany, tak jakby był on nazwę typu kwalifikowanego zestawu. Skutkuje to nieprawidłowa nazwa zestawu.|  
  
 Powrót do: [Uwagi dotyczące użycia](#usage_notes), [rozpoznawania zestawów](#resolving_assemblies), [rozpoznawanie typów](#resolving_types).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> jest <see langword="true" /> i nie można odnaleźć typu.  
  
—lub— 
 <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> zawiera nieprawidłowe znaki, takie jak osadzona karta. 
—lub— 
 <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> reprezentuje typ tablicy z nieprawidłowym rozmiarem.  
  
—lub— 
 <paramref name="typeName" /> reprezentuje tablicę <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">Błąd występuje, gdy <paramref name="typeName" /> jest przekształcany do nazwy typu i nazwy zestawu (na przykład, gdy nazwa typu prostego zawiera specjalne znaku o niezmienionym znaczeniu).  
  
—lub— 
 <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> ma nieprawidłową składnię "(na przykład MyType[,*,]").  
  
—lub— 
 <paramref name="typeName" /> reprezentuje typ ogólny, który jest typem wskaźnika <see langword="ByRef" /> typu, lub <see cref="T:System.Void" /> jako jeden z argumentów typu.  
  
—lub— 
 <paramref name="typeName" /> reprezentuje typ ogólny, który ma niepoprawną liczbę argumentów typu.  
  
—lub— 
 <paramref name="typeName" /> reprezentuje typ ogólny i jeden z argumentów typu nie spełniają ograniczeń dla odpowiedniego parametru typu.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> jest <see langword="true" /> i nie znaleziono zestawu lub jednej z jego zależności.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.  
  
—lub— 
 <paramref name="typeName" /> zawiera nieprawidłową nazwę zestawu.  
  
—lub— 
 <paramref name="typeName" /> jest nazwą prawidłowego zestawu bez nazwy typu.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.  
  
—lub— 
Zestaw został skompilowany przy użyciu nowszej wersji aparatu plików wykonywalnych języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">Tablica obiektów o typach, aby określić.</param>
        <summary>Pobiera typy obiektów w określonej tablicy.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiektów reprezentujących rodzaje odpowiednie elementy w <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Type.GetTypeArray%2A> metody, aby wyświetlić listę typów elementów tablicy.  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" /> jest <see langword="null" />.  
  
—lub— 
Co najmniej jeden z elementów w <paramref name="args" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjatory klasy są wywoływane, i zgłasza wyjątek, co najmniej jeden.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Typ, którego bazowego typu kodu.</param>
        <summary>Pobiera podstawowy kod typu określonego <see cref="T:System.Type" />.</summary>
        <returns>Kod typu podstawowego lub <see cref="F:System.TypeCode.Empty" /> Jeśli <paramref name="type" /> jest <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przy dziedziczeniu z <xref:System.Type>, zachowania tej metody można zmienić poprzez zastąpienie <xref:System.Type.GetTypeCodeImpl%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób, w jaki <xref:System.TypeCode> używać wyliczenia. W bloku decyzji wewnątrz `WriteObjectInfo` metody <xref:System.TypeCode> z <xref:System.Object> parametru jest badany i odpowiedni komunikat jest wyświetlony w konsoli.  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca podstawowy kod typu tego <see cref="T:System.Type" /> wystąpienia.</summary>
        <returns>Kod typu podstawowego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapewnia to implementacja `static` (w języku C#) lub `Shared` (w języku Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> metody. Przy dziedziczeniu z <xref:System.Type>, możesz zastąpić tę metodę, aby podać własną implementację <xref:System.Type.GetTypeCode%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera typ ze skojarzonym identyfikatorem określonej klasy (CLSID).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">Identyfikator CLSID typu, który można pobrać.</param>
        <summary>Pobiera typ ze skojarzonym identyfikatorem określonej klasy (CLSID).</summary>
        <returns><see langword="System.__ComObject" /> niezależnie od tego, czy identyfikator CLSID jest nieprawidłowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> Metoda obsługuje dostęp z późnym wiązaniem do niezarządzanych obiektów COM z aplikacji .NET Framework, gdy wiesz identyfikator klasy obiektu COM (CLSID).  Identyfikator klasy dla klasy COM jest zdefiniowany w kluczu HKEY_CLASSES_ROOT\CLSID rejestru. Można pobrać wartość <xref:System.Type.IsCOMObject%2A> właściwości w celu określenia, czy typ zwracany przez tę metodę jest obiektem COM.  
  
> [!TIP]
>  Możesz wywołać <xref:System.Type.GetTypeFromProgID%2A> metody z późnym wiązaniem dostępu do modelu COM obiekty, których identyfikator programowy (ProgID) wiadomo.  
  
 Utworzenie wystąpienia niezarządzanych obiektu modelu COM z jego identyfikator CLSID jest procesem dwuetapowym:  
  
1.  Pobierz <xref:System.Type> obiekt, który reprezentuje`__ComObject` , który odpowiada identyfikator CLSID, wywołując <xref:System.Type.GetTypeFromCLSID%2A> metody.  
  
2.  Wywołaj <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metodę, aby utworzyć wystąpienie obiektu COM.  
  
 Zobacz przykład ilustracja.  
  
 <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> Przeciążenia ignoruje wszelkie wyjątki, które mogą wystąpić podczas tworzenia wystąpienia <xref:System.Type> na podstawie obiektu `clsid` argumentu. Należy zauważyć, że jest zgłaszany żaden wyjątek, jeśli `clsid` nie zostanie znaleziony w rejestrze.  
  
   
  
## Examples  
 W poniższym przykładzie użyto identyfikator CLSID programu Microsoft Word [obiekt aplikacji](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) można pobrać typu modelu COM, który reprezentuje aplikację Microsoft Word. Następnie tworzy wystąpienie typu przez wywołanie metody <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metody i zamyka te błędy, wywołując [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) metody.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Ta metoda jest przeznaczona do użycia podczas pracy z obiektami COM, a nie z obiektami .NET Framework. Wszystkie zarządzane obiekty, w tym te, które są widoczne dla modelu COM (oznacza to, że ich <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atrybut jest <see langword="true" />) ma identyfikator GUID, który jest zwracany przez <see cref="P:System.Type.GUID" /> właściwości. Mimo że metoda zwraca <see cref="T:System.Type" /> obiektów obiekt, który odnosi się do identyfikatora GUID dla programu .NET Framework, nie można użyć, które <see cref="T:System.Type" /> obiektu do utworzenia wystąpienia typu przez wywołanie metody <see cref="M:System.Activator.CreateInstance(System.Type)" /> metody, jak w poniższym przykładzie pokazano.  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Zamiast tego <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> powinna służyć wyłącznie do pobrania identyfikatora GUID niezarządzanych obiektów COM i wynikowy <see cref="T:System.Type" /> obiekt, który jest przekazywany do <see cref="M:System.Activator.CreateInstance(System.Type)" /> metody musi reprezentować obiekt COM niezarządzanych.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">Identyfikator CLSID typu, który można pobrać.</param>
        <param name="throwOnError"><see langword="true" /> Umożliwia zgłoszenie każdego wyjątku, który występuje.  
  
—lub— 
 <see langword="false" /> umożliwia zignorowanie każdego wyjątku, który występuje.</param>
        <summary>Pobiera typ ze skojarzonym identyfikatorem określonej klasy (CLSID) określająca, czy zgłosić wyjątek, jeśli wystąpi błąd podczas ładowania typu.</summary>
        <returns><see langword="System.__ComObject" /> niezależnie od tego, czy identyfikator CLSID jest nieprawidłowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> Metoda obsługuje dostęp z późnym wiązaniem do niezarządzanych obiektów COM z aplikacji .NET Framework, gdy wiesz identyfikator klasy obiektu COM (CLSID).  Identyfikator klasy dla klasy COM jest zdefiniowany w kluczu HKEY_CLASSES_ROOT\CLSID rejestru. Można pobrać wartość <xref:System.Type.IsCOMObject%2A> właściwości w celu określenia, czy typ zwracany przez tę metodę jest obiektem COM.  
  
> [!TIP]
>  Możesz wywołać <xref:System.Type.GetTypeFromProgID%2A> metody z późnym wiązaniem dostępu do modelu COM obiekty, których identyfikator programowy (ProgID) wiadomo.  
  
 Utworzenie wystąpienia niezarządzanych obiektu modelu COM z jego identyfikator CLSID jest procesem dwuetapowym:  
  
1.  Pobierz <xref:System.Type> obiekt, który reprezentuje `__ComObject` , który odpowiada identyfikator CLSID, wywołując <xref:System.Type.GetTypeFromCLSID%2A> metody.  
  
2.  Wywołaj <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metodę, aby utworzyć wystąpienie obiektu COM.  
  
 Zobacz przykład ilustracja.  
  
 Wyjątki, takie jak <xref:System.OutOfMemoryException> zostanie zgłoszony podczas określania `true` dla `throwOnError`, ale zakończy się niepowodzeniem dla niezarejestrowanych CLSID.  
  
   
  
## Examples  
 W poniższym przykładzie użyto identyfikator CLSID programu Microsoft Word [obiekt aplikacji](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) można pobrać typu modelu COM, który reprezentuje aplikację Microsoft Word. Następnie tworzy wystąpienie typu przez wywołanie metody <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metody i zamyka te błędy, wywołując [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) metody. Wyjątek jest generowany, jeśli wystąpi błąd podczas ładowania typu.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Ta metoda jest przeznaczona do użycia podczas pracy z obiektami COM, a nie z obiektami .NET Framework. Wszystkie zarządzane obiekty, w tym te, które są widoczne dla modelu COM (oznacza to, że ich <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atrybut jest <see langword="true" />) ma identyfikator GUID, który jest zwracany przez <see cref="P:System.Type.GUID" /> właściwości. Mimo że metoda zwraca <see cref="T:System.Type" /> obiektów obiekt, który odnosi się do identyfikatora GUID dla programu .NET Framework, nie można użyć, które <see cref="T:System.Type" /> obiektu do utworzenia wystąpienia typu przez wywołanie metody <see cref="M:System.Activator.CreateInstance(System.Type)" /> metody, jak w poniższym przykładzie pokazano.  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Zamiast tego <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> powinna służyć wyłącznie do pobrania identyfikatora GUID niezarządzanych obiektów COM i wynikowy <see cref="T:System.Type" /> obiekt, który jest przekazywany do <see cref="M:System.Activator.CreateInstance(System.Type)" /> metody musi reprezentować obiekt COM niezarządzanych.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">Identyfikator CLSID typu, który można pobrać.</param>
        <param name="server">Serwer, z którego można załadować typ. Jeśli nazwa serwera jest <see langword="null" />, ta metoda zostanie automatycznie przywrócona do komputera lokalnego.</param>
        <summary>Pobiera typ ze skojarzonym identyfikatorem określonej klasy (CLSID) z określonego serwera.</summary>
        <returns><see langword="System.__ComObject" /> niezależnie od tego, czy identyfikator CLSID jest nieprawidłowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> Metoda obsługuje dostęp z późnym wiązaniem do niezarządzanych obiektów COM z aplikacji .NET Framework, gdy wiesz identyfikator klasy obiektu COM (CLSID).  Identyfikator klasy dla klasy COM jest zdefiniowany w kluczu HKEY_CLASSES_ROOT\CLSID rejestru. Można pobrać wartość <xref:System.Type.IsCOMObject%2A> właściwości w celu określenia, czy typ zwracany przez tę metodę jest obiektem COM.  
  
> [!TIP]
>  Możesz wywołać <xref:System.Type.GetTypeFromProgID%2A> metody z późnym wiązaniem dostępu do modelu COM obiekty, których identyfikator programowy (ProgID) wiadomo.  
  
 Utworzenie wystąpienia niezarządzanych obiektu modelu COM z jego identyfikator CLSID jest procesem dwuetapowym:  
  
1.  Pobierz <xref:System.Type> obiekt, który reprezentuje `__ComObject` , który odpowiada identyfikator CLSID, wywołując <xref:System.Type.GetTypeFromCLSID%2A> metody.  
  
2.  Wywołaj <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metodę, aby utworzyć wystąpienie obiektu COM.  
  
   
  
## Examples  
 W poniższym przykładzie użyto identyfikator CLSID programu Microsoft Word [obiekt aplikacji](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) można pobrać typu modelu COM, który reprezentuje aplikację Microsoft Word z serwerem o nazwie computer17.central.contoso.com. Następnie tworzy wystąpienie typu przez wywołanie metody <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metody i zamyka te błędy, wywołując [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) metody.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Ta metoda jest przeznaczona do użycia podczas pracy z obiektami COM, a nie z obiektami .NET Framework. Wszystkie zarządzane obiekty, w tym te, które są widoczne dla modelu COM (oznacza to, że ich <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atrybut jest <see langword="true" />) ma identyfikator GUID, który jest zwracany przez <see cref="P:System.Type.GUID" /> właściwości. Mimo że metoda zwraca <see cref="T:System.Type" /> obiektów obiekt, który odnosi się do identyfikatora GUID dla programu .NET Framework, nie można użyć, które <see cref="T:System.Type" /> obiektu do utworzenia wystąpienia typu przez wywołanie metody <see cref="M:System.Activator.CreateInstance(System.Type)" /> metody, jak w poniższym przykładzie pokazano.  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Zamiast tego <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> powinna służyć wyłącznie do pobrania identyfikatora GUID niezarządzanych obiektów COM i wynikowy <see cref="T:System.Type" /> obiekt, który jest przekazywany do <see cref="M:System.Activator.CreateInstance(System.Type)" /> metody musi reprezentować obiekt COM niezarządzanych.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">Identyfikator CLSID typu, który można pobrać.</param>
        <param name="server">Serwer, z którego można załadować typ. Jeśli nazwa serwera jest <see langword="null" />, ta metoda zostanie automatycznie przywrócona do komputera lokalnego.</param>
        <param name="throwOnError"><see langword="true" /> Umożliwia zgłoszenie każdego wyjątku, który występuje.  
  
—lub— 
 <see langword="false" /> umożliwia zignorowanie każdego wyjątku, który występuje.</param>
        <summary>Pobiera typ ze skojarzonym identyfikatorem określonej klasy (CLSID) z określonego serwera w określeniu, czy zgłosić wyjątek, jeśli wystąpi błąd podczas ładowania typu.</summary>
        <returns><see langword="System.__ComObject" /> niezależnie od tego, czy identyfikator CLSID jest nieprawidłowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> Metoda obsługuje dostęp z późnym wiązaniem do niezarządzanych obiektów COM z aplikacji .NET Framework, gdy wiesz identyfikator klasy obiektu COM (CLSID).  Identyfikator klasy dla klasy COM jest zdefiniowany w kluczu HKEY_CLASSES_ROOT\CLSID rejestru. Można pobrać wartość <xref:System.Type.IsCOMObject%2A> właściwości w celu określenia, czy typ zwracany przez tę metodę jest obiektem COM.  
  
> [!TIP]
>  Możesz wywołać <xref:System.Type.GetTypeFromProgID%2A> metody z późnym wiązaniem dostępu do modelu COM obiekty, których identyfikator programowy (ProgID) wiadomo.  
  
 Utworzenie wystąpienia niezarządzanych obiektu modelu COM z jego identyfikator CLSID jest procesem dwuetapowym:  
  
1.  Pobierz <xref:System.Type> obiekt, który reprezentuje `__ComObject` , który odpowiada identyfikator CLSID, wywołując <xref:System.Type.GetTypeFromCLSID%2A> metody.  
  
2.  Wywołaj <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metodę, aby utworzyć wystąpienie obiektu COM.  
  
 Wyjątki, takie jak <xref:System.OutOfMemoryException> zostanie zgłoszony podczas określania `true` dla `throwOnError`, ale zakończy się niepowodzeniem dla niezarejestrowanych CLSID.  
  
   
  
## Examples  
 W poniższym przykładzie użyto identyfikator CLSID programu Microsoft Word [obiekt aplikacji](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) można pobrać typu modelu COM, który reprezentuje aplikację Microsoft Word z serwerem o nazwie computer17.central.contoso.com. Następnie tworzy wystąpienie typu przez wywołanie metody <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metody i zamyka te błędy, wywołując [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) metody. Wyjątek jest generowany, jeśli wystąpi błąd podczas ładowania typu.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Ta metoda jest przeznaczona do użycia podczas pracy z obiektami COM, a nie z obiektami .NET Framework. Wszystkie zarządzane obiekty, w tym te, które są widoczne dla modelu COM (oznacza to, że ich <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atrybut jest <see langword="true" />) ma identyfikator GUID, który jest zwracany przez <see cref="P:System.Type.GUID" /> właściwości. Mimo że <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> metoda zwraca <see cref="T:System.Type" /> obiekt, który odnosi się do identyfikatora GUID dla konkretnego obiektu zarządzanego nie można użyć, które <see cref="T:System.Type" /> obiektu do utworzenia wystąpienia typu przez wywołanie metody <see cref="M:System.Activator.CreateInstance(System.Type)" /> metody, jak w poniższym przykładzie pojawi się.  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Zamiast tego <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> powinna służyć wyłącznie do pobrania identyfikatora GUID niezarządzanych obiektów COM i wynikowy <see cref="T:System.Type" /> obiekt, który jest przekazywany do <see cref="M:System.Activator.CreateInstance(System.Type)" /> metody musi reprezentować obiekt COM niezarządzanych.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Obiekt, który odwołuje się do typu.</param>
        <summary>Pobiera typ przywoływany przez dojście do określonego typu.</summary>
        <returns>Typ odwołuje się określony <see cref="T:System.RuntimeTypeHandle" />, lub <see langword="null" /> Jeśli <see cref="P:System.RuntimeTypeHandle.Value" /> właściwość <paramref name="handle" /> jest <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uchwyty są prawidłowe tylko w domenie aplikacji, w którym zostały uzyskane.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Type.GetTypeFromHandle%2A> metodę, aby uzyskać <xref:System.Type> obiektu z <xref:System.RuntimeTypeHandle> dostarczone przez <xref:System.Type.GetTypeHandle%2A> metody.  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera typ skojarzony z identyfikatorem określony program (ProgID).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">Identyfikator ProgID typ do pobrania.</param>
        <summary>Pobiera typ ze skojarzonym identyfikatorem określony program (ProgID), zwracając wartość null, jeśli napotka błąd podczas ładowania <see cref="T:System.Type" />.</summary>
        <returns>Typ skojarzoną z określonym identyfikatorem ProgID, jeśli <paramref name="progID" /> jest prawidłowego wpisu w rejestrze, a typem jest z nią skojarzona; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia obsługę COM. ProgID nie są używane w Microsoft .NET Framework, ponieważ zostały zastąpione przez koncepcji przestrzeni nazw.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">Identyfikator ProgID typ do pobrania.</param>
        <param name="throwOnError"><see langword="true" /> Umożliwia zgłoszenie każdego wyjątku, który występuje.  
  
—lub— 
 <see langword="false" /> umożliwia zignorowanie każdego wyjątku, który występuje.</param>
        <summary>Pobiera typ ze skojarzonym identyfikatorem określony program (ProgID) określająca, czy zgłosić wyjątek, jeśli wystąpi błąd podczas ładowania typu.</summary>
        <returns>Typ skojarzony z identyfikatorem określony program (ProgID), jeśli <paramref name="progID" /> jest prawidłowego wpisu w rejestrze, a typem jest z nią skojarzona; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia obsługę COM. Identyfikatorów programu nie są używane w programie Microsoft .NET Framework, ponieważ zostały zastąpione przez koncepcji przestrzeni nazw.  
  
   
  
## Examples  
 Poniższy przykład pobiera typ, przekazując ProgID, określająca, czy zgłosić wyjątek, jeśli identyfikator ProgID jest nieprawidłowy. Przykład następnie wyświetla identyfikator klasy związane z ProgID, wraz z dowolnego komunikat o wyjątku dotyczy.  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Określony identyfikator ProgID nie jest zarejestrowany.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">ProgID typ do pobrania.</param>
        <param name="server">Serwer, z którego można załadować typ. Jeśli nazwa serwera jest <see langword="null" />, ta metoda zostanie automatycznie przywrócona do komputera lokalnego.</param>
        <summary>Pobiera typ ze skojarzonym identyfikatorem określony program (progID) z określonego serwera, zwracając wartość null, jeśli wystąpił błąd podczas ładowania typu.</summary>
        <returns>Typ skojarzony z identyfikatorem określony program (progID), jeśli <paramref name="progID" /> jest prawidłowego wpisu w rejestrze, a typem jest z nią skojarzona; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia obsługę COM. Identyfikatorów programu nie są używane w programie Microsoft .NET Framework, ponieważ zostały zastąpione przez koncepcji przestrzeni nazw.  
  
   
  
## Examples  
 Poniższy przykład pobiera typ, przekazując ProgID i nazwę serwera. Przykład następnie wyświetla identyfikator klasy związane z identyfikator ProgID lub zgłasza wyjątek, jeśli identyfikator ProgID lub nazwa serwera jest nieprawidłowa.  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="prodID" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">ProgID <see cref="T:System.Type" /> można pobrać.</param>
        <param name="server">Serwer, z którego można załadować typ. Jeśli nazwa serwera jest <see langword="null" />, ta metoda zostanie automatycznie przywrócona do komputera lokalnego.</param>
        <param name="throwOnError"><see langword="true" /> Umożliwia zgłoszenie każdego wyjątku, który występuje.  
  
—lub— 
 <see langword="false" /> umożliwia zignorowanie każdego wyjątku, który występuje.</param>
        <summary>Pobiera typ ze skojarzonym identyfikatorem określony program (progID) z określonego serwera w określeniu, czy zgłosić wyjątek, jeśli wystąpi błąd podczas ładowania typu.</summary>
        <returns>Typ skojarzony z identyfikatorem określony program (progID), jeśli <paramref name="progID" /> jest prawidłowego wpisu w rejestrze, a typem jest z nią skojarzona; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia obsługę COM. Identyfikatorów programu nie są używane w programie Microsoft .NET Framework, ponieważ zostały zastąpione przez koncepcji przestrzeni nazw.  
  
   
  
## Examples  
 Poniższy przykład pobiera typ, przekazując ProgID i nazwę serwera. Przykład następnie wyświetla identyfikator klasy związane z ProgID, określająca, czy zgłosić wyjątek, jeśli identyfikator ProgID lub nazwa serwera jest nieprawidłowa.  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Określony identyfikator progID nie jest zarejestrowany.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt, dla którego można pobrać typu obsługi.</param>
        <summary>Pobiera uchwytu <see cref="T:System.Type" /> określonego obiektu.</summary>
        <returns>Dojście do <see cref="T:System.Type" /> określonego <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uchwyty są prawidłowe tylko w domenie aplikacji, w którym zostały uzyskane.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano klasę `MyClass1`, pobiera jego wystąpienie i pobiera uchwyt środowiska uruchomieniowego obiektu.  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="o" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator GUID skojarzony z <see cref="T:System.Type" />.</summary>
        <value>Identyfikator GUID skojarzony z <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator GUID jest skojarzony z typu przy użyciu <xref:System.Runtime.InteropServices.GuidAttribute> atrybutu.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę `MyClass1` w metodę publiczną, tworzy `Type` obiekt odpowiadający `MyClass1`i pobiera <xref:System.Guid> struktury za pomocą `GUID` właściwość `Type` klasy.  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy bieżący <see cref="T:System.Type" /> obejmuje lub odwołuje się do innego typu; który jest, czy bieżący <see cref="T:System.Type" /> jest tablicą, wskaźnik, lub jest przekazywany przez odwołanie.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest tablicą, wskaźnik, lub jest przekazywany przez odwołanie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład Type.GetType("Int32[]"). Zwraca HasElementType `true`, ale Type.GetType("Int32"). Zwraca HasElementType `false`. Zwraca także HasElementType `true` dla "Int32 *" i "Int32 &".  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny lub parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.  
  
   
  
## Examples  
 Poniższy przykład zwraca `true` lub `false` w zależności od tego, czy obiekt jest tablicą, typu odwołania lub wskaźnik.  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, implementuje <see cref="P:System.Type.HasElementType" /> właściwości i określa, czy bieżący <see cref="T:System.Type" /> obejmuje lub odwołuje się do innego typu; który jest, czy bieżący <see cref="T:System.Type" /> jest tablicą, wskaźnik, lub jest przekazywany przez odwołanie.</summary>
        <returns><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest tablicą, wskaźnik, lub jest przekazywany przez odwołanie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład Type.GetType("Int32[]"). Zwraca HasElementTypeImpl `true`, ale Type.GetType("Int32"). Zwraca HasElementTypeImpl `false`. Zwraca także HasElementTypeImpl `true` dla "Int32 *" i "Int32 &".  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano klasę `MyTypeDelegator`, co zastępuje `HasElementTypeImpl` metody. Sprawdza, czy główna klasa `HasElementType` właściwości i wyświetla typ elementu.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wywołuje określonego członka bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę konstruktora, metody, właściwości lub pól członka do wywołania.  
  
—lub— 
Ciąg pusty ("") do wywołania domyślny element członkowski.  
  
—lub— 
Aby uzyskać <see langword="IDispatch" /> członków, ciąg reprezentujący identyfikator DispID, na przykład "[identyfikator DispID = 3]".</param>
        <param name="invokeAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie. Dostęp może być jednym z <see langword="BindingFlags" /> takich jak <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />i tak dalej. Typ wyszukiwania nie muszą być określane. W przypadku pominięcia typ wyszukiwania <see langword="BindingFlags.Public" />  |  <see langword="BindingFlags.Instance" />  |  <see langword="BindingFlags.Static" /> są używane.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />. Należy pamiętać, że jawne określenie <see cref="T:System.Reflection.Binder" /> obiekt może być wymagane dla pomyślnie wywołanie przeciążenia metody ze zmiennymi argumentami.</param>
        <param name="target">Obiekt do wywołania określonego elementu członkowskiego.</param>
        <param name="args">Tablica zawierająca argumenty do przekazania do składowej na potrzeby wywołania.</param>
        <summary>Wywołuje określony element członkowski, dopasowanie określoną listę argumentów i za pomocą ograniczeń w określonym powiązaniu.</summary>
        <returns>Obiekt reprezentujący wartość zwracaną wywołanego elementu członkowskiego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nie można użyć <xref:System.Type.InvokeMember%2A> do wywoływania metody rodzajowej.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania elementów członkowskich, które można uwzględnić w wyszukiwaniu:  
  
-   Określ `BindingFlags.Public` obejmujący publiczne elementy członkowskie w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący elementów członkowskich niepublicznych (czyli prywatnych i chronionych elementów członkowskich) w wyszukiwaniu.  
  
-   Określ `BindingFlags.FlattenHierarchy` obejmujący statyczne elementy członkowskie w hierarchii.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko do elementów członkowskich zadeklarowanych w <xref:System.Type>, nie elementów członkowskich, które zostały po prostu odziedziczone.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi wywołania może służyć do określenia, jaką akcję należy podjąć przy użyciu elementu członkowskiego:  
  
-   `CreateInstance` Aby wywołać konstruktora. `name` jest ignorowany. Nieprawidłowy inne flagi wywołania.  
  
-   `InvokeMethod` do wywołania metody, ale nie konstruktorze lub inicjatorze typu. Nie jest prawidłowy z `SetField` lub `SetProperty`. Jeśli `InvokeMethod` jest określony przez siebie, `BindingFlags.Public`, `BindingFlags.Instance`, i `BindingFlags.Static` są automatycznie dołączane.  
  
-   `GetField` można pobrać wartości pola. Nie jest prawidłowy z `SetField`.  
  
-   `SetField` można ustawić wartości pola. Nie jest prawidłowy z `GetField`.  
  
-   `GetProperty` można pobrać właściwości. Nie jest prawidłowy z `SetProperty`.  
  
-   `SetProperty` można ustawić właściwości. Nie jest prawidłowy z `GetProperty`.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Metoda zostanie wywołana, jeśli są spełnione oba poniższe warunki:  
  
-   Liczba parametrów w deklaracji metody jest równa liczbie argumentów `args` tablicy (chyba że argumenty domyślne są zdefiniowane w składowej i `BindingFlags.OptionalParamBinding` jest określony).  
  
-   Typ każdego argumentu mogą być konwertowane przez binder typowi parametru.  
  
 Obiekt wiążący znajdzie wszystkie metody dopasowania. Te metody zostaną znalezione, oparte na typie powiązania żądane (<xref:System.Reflection.BindingFlags> wartości `InvokeMethod`, `GetProperty`i tak dalej). Zestaw metod są filtrowane według nazwy, liczba argumentów i zestaw modyfikatorów wyszukiwania zdefiniowane w obiekt wiążący.  
  
 Po wybraniu metody jest wywoływana. Dostępność jest sprawdzana w tym momencie. Wyszukiwanie może kontrolować, które zestaw metod, przeszukiwane są na podstawie atrybutu ułatwień dostępu powiązany z metodą. <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Metody <xref:System.Reflection.Binder> klasy jest odpowiedzialny za wybranie wywoływanej metody. Domyślny integrator wybiera najbardziej określonego dopasowania.  
  
 Ograniczenia dostępu są ignorowane w przypadku w pełni zaufany kod; oznacza to, konstruktory prywatne, metody, pola i właściwości mogą być dostępne i wywoływane za pośrednictwem <xref:System.Reflection> zawsze, gdy kod jest w pełni zaufany.  
  
 Możesz użyć `Type.InvokeMember` można ustawić pola na określoną wartość, określając <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Na przykład, jeśli chcesz ustawić pole publiczne wystąpienia o nazwie F klasy C i F jest `String`, można użyć kodu takiego jak:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 Jeśli jest F `String[]`, można użyć kodu takiego jak:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 która zainicjuje pole F do tej nowej tablicy. Można również użyć `Type.InvokeMember` próba ustawienia pozycji w tablicy, podając indeks wartości, a następnie wartość następnego przy użyciu następującego kodu:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 Spowoduje to zmianę w tablicy, która F zawiera ciąg "b", ciąg "z".  
  
 Gdy wywołujesz `IDispatch` elementu członkowskiego, możesz określić identyfikator DispID zamiast nazwy elementu członkowskiego, używając formatu ciągu "[identyfikator DispID = ##]". Na przykład, jeśli identyfikator DispID MyComMethod wynosi 3, możesz określić ciąg "[identyfikator DispID = 3]" zamiast "MyComMethod". Wywoływanie składowej przez identyfikator DispID jest szybsze niż Wyszukiwanie elementu członkowskiego według nazwy. W scenariuszach złożoną agregację DispID czasami jest jedynym sposobem, aby wywołać żądanego elementu.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do dostępu do elementów członkowskich niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga, a jeśli zestaw uprawnień elementów członkowskich niepublicznych jest ograniczony do obiektu wywołującego przyznania zestawu lub być podzbiorem jej. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 W poniższym przykładzie użyto `InvokeMember` do dostępu do elementów członkowskich typu.  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> nie zawiera <see langword="CreateInstance" /> i <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" /> nie jest prawidłowym <see cref="T:System.Reflection.BindingFlags" /> atrybutu.  
  
—lub— 
 <paramref name="invokeAttr" /> nie zawiera jedną z następujących flag powiązania: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, lub <see langword="SetProperty" />.  
  
—lub— 
 <paramref name="invokeAttr" /> zawiera <see langword="CreateInstance" /> w połączeniu z <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, lub <see langword="SetProperty" />.  
  
—lub— 
 <paramref name="invokeAttr" /> zawiera zarówno <see langword="GetField" /> i <see langword="SetField" />.  
  
—lub— 
 <paramref name="invokeAttr" /> zawiera zarówno <see langword="GetProperty" /> i <see langword="SetProperty" />.  
  
—lub— 
 <paramref name="invokeAttr" /> zawiera <see langword="InvokeMethod" /> w połączeniu z <see langword="SetField" /> lub <see langword="SetProperty" />.  
  
—lub— 
 <paramref name="invokeAttr" /> zawiera <see langword="SetField" /> i <paramref name="args" /> ma więcej niż jeden element.  
  
—lub— 
Ta metoda jest wywoływana dla obiektu COM i jedną z następujących flag powiązania nie przekazano: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, lub <see langword="BindingFlags.PutRefDispProperty" />.  
  
—lub— 
Jedna z nich tablic nazwany parametr zawiera ciąg, który jest <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">Określony element członkowski jest inicjator klasy.</exception>
        <exception cref="T:System.MissingFieldException">Nie można odnaleźć pola lub właściwości.</exception>
        <exception cref="T:System.MissingMethodException">Brak metody można znaleźć odpowiadającej argumentów <paramref name="args" />.  
  
—lub— 
Bieżący <see cref="T:System.Type" /> obiekt reprezentuje typ, który zawiera parametry typu otwartego, czyli <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">Nie można wywołać określonego elementu członkowskiego <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Więcej niż jednej metody odpowiadającego kryteriom powiązania.</exception>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework nie obsługuje obecnie tej metody.</exception>
        <exception cref="T:System.InvalidOperationException">Metody reprezentowanej przez <paramref name="name" /> ma jeden lub więcej określonych parametrów typu rodzajowego. Oznacza to, że metody <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> właściwość zwraca <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">W celu uzyskiwania dostępu do elementów członkowskich niepublicznych, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby wywoływać kod niezarządzany. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę konstruktora, metody, właściwości lub pól członka do wywołania.  
  
—lub— 
Ciąg pusty ("") do wywołania domyślny element członkowski.  
  
—lub— 
Aby uzyskać <see langword="IDispatch" /> członków, ciąg reprezentujący identyfikator DispID, na przykład "[identyfikator DispID = 3]".</param>
        <param name="invokeAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie. Dostęp może być jednym z <see langword="BindingFlags" /> takich jak <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />i tak dalej. Typ wyszukiwania nie muszą być określane. W przypadku pominięcia typ wyszukiwania <see langword="BindingFlags.Public" />  |  <see langword="BindingFlags.Instance" />  |  <see langword="BindingFlags.Static" /> są używane.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />. Należy pamiętać, że jawne określenie <see cref="T:System.Reflection.Binder" /> obiekt może być wymagane dla pomyślnie wywołanie przeciążenia metody ze zmiennymi argumentami.</param>
        <param name="target">Obiekt do wywołania określonego elementu członkowskiego.</param>
        <param name="args">Tablica zawierająca argumenty do przekazania do składowej na potrzeby wywołania.</param>
        <param name="culture">Obiekt reprezentujący globalizacji ustawienia regionalne, które będą niezbędne do konwersji specyficzne dla ustawień regionalnych, takich jak konwertowanie liczbowych <see cref="T:System.String" /> do <see cref="T:System.Double" />.  
  
—lub— 
Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic) do użycia bieżący wątek <see cref="T:System.Globalization.CultureInfo" />.</param>
        <summary>Wywołuje określony element członkowski, dopasowanie określoną listę argumentów i kultury i za pomocą ograniczeń w określonym powiązaniu.</summary>
        <returns>Obiekt reprezentujący wartość zwracaną wywołanego elementu członkowskiego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że domyślny integrator nie przetwarza <xref:System.Globalization.CultureInfo> ( `culture` parametru), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `culture`.  
  
> [!NOTE]
>  Nie można użyć <xref:System.Type.InvokeMember%2A> do wywoływania metody rodzajowej.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania elementów członkowskich, które można uwzględnić w wyszukiwaniu:  
  
-   Określ `BindingFlags.Public` obejmujący publiczne elementy członkowskie w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący elementów członkowskich niepublicznych (czyli prywatne, wewnętrzne i chronione elementy członkowskie) w wyszukiwaniu.  
  
-   Określ `BindingFlags.FlattenHierarchy` obejmujący statyczne elementy członkowskie w hierarchii.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko do elementów członkowskich zadeklarowanych w <xref:System.Type>, nie elementów członkowskich, które zostały po prostu odziedziczone.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi wywołania może służyć do określenia, jaką akcję należy podjąć przy użyciu elementu członkowskiego:  
  
-   `CreateInstance` Aby wywołać konstruktora. `name` jest ignorowany. Nieprawidłowy inne flagi wywołania.  
  
-   `InvokeMethod` do wywołania metody, ale nie konstruktorze lub inicjatorze typu. Nie jest prawidłowy z `SetField` lub `SetProperty`. Jeśli `InvokeMethod` jest określony przez siebie, `BindingFlags.Public`, `BindingFlags.Instance`, i `BindingFlags.Static` są automatycznie dołączane.  
  
-   `GetField` można pobrać wartości pola. Nie jest prawidłowy z `SetField`.  
  
-   `SetField` można ustawić wartości pola. Nie jest prawidłowy z `GetField`.  
  
-   `GetProperty` można pobrać właściwości. Nie jest prawidłowy z `SetProperty`.  
  
-   `SetProperty` można ustawić właściwości. Nie jest prawidłowy z `GetProperty`.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Metoda zostanie wywołana, jeśli są spełnione oba poniższe warunki:  
  
-   Liczba parametrów w deklaracji metody jest równa liczbie argumentów `args` tablicy (chyba że argumenty domyślne są zdefiniowane w składowej i `BindingFlags.OptionalParamBinding` jest określony).  
  
-   Typ każdego argumentu mogą być konwertowane przez binder typowi parametru.  
  
 Obiekt wiążący znajdzie wszystkie metody dopasowania. Te metody zostaną znalezione, oparte na typie powiązania żądane (<xref:System.Reflection.BindingFlags> wartości `InvokeMethod`, `GetProperty`i tak dalej). Zestaw metod są filtrowane według nazwy, liczba argumentów i zestaw modyfikatorów wyszukiwania zdefiniowane w obiekt wiążący.  
  
 Po wybraniu metody jest wywoływana. Dostępność jest sprawdzana w tym momencie. Wyszukiwanie może kontrolować, które zestaw metod, przeszukiwane są na podstawie atrybutu ułatwień dostępu powiązany z metodą. <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Metody <xref:System.Reflection.Binder> klasy jest odpowiedzialny za wybranie wywoływanej metody. Domyślny integrator wybiera najbardziej określonego dopasowania.  
  
 Ograniczenia dostępu są ignorowane w przypadku w pełni zaufany kod; oznacza to, że konstruktory prywatne, metody, pola i właściwości umożliwia dostęp i wywoływany przez odbicie, zawsze wtedy, gdy kod jest w pełni zaufany.  
  
 Możesz użyć `Type.InvokeMember` można ustawić pola na określoną wartość, określając <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Na przykład, jeśli chcesz ustawić pole publiczne wystąpienia o nazwie F klasy C i F jest `String` można użyć kodu takiego jak:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 Jeśli jest F `String[]`, można użyć kodu takiego jak:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 która zainicjuje pole F do tej nowej tablicy. Można również użyć `Type.InvokeMember` próba ustawienia pozycji w tablicy, podając indeks wartości, a następnie wartość następnego przy użyciu następującego kodu:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 Spowoduje to zmianę w tablicy, która F zawiera ciąg "b", ciąg "z".  
  
 Gdy wywołujesz `IDispatch` elementu członkowskiego, możesz określić identyfikator DispID zamiast nazwy elementu członkowskiego, używając formatu ciągu "[identyfikator DispID = ##]". Na przykład, jeśli identyfikator DispID MyComMethod wynosi 3, możesz określić ciąg "[identyfikator DispID = 3]" zamiast "MyComMethod". Wywoływanie składowej przez identyfikator DispID jest szybsze niż Wyszukiwanie elementu członkowskiego według nazwy. W scenariuszach złożoną agregację DispID czasami jest jedynym sposobem, aby wywołać żądanego elementu.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do dostępu do elementów członkowskich niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga, a jeśli zestaw uprawnień elementów członkowskich niepublicznych jest ograniczony do obiektu wywołującego przyznania zestawu lub być podzbiorem jej. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> nie zawiera <see langword="CreateInstance" /> i <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" /> nie jest prawidłowym <see cref="T:System.Reflection.BindingFlags" /> atrybutu.  
  
—lub— 
 <paramref name="invokeAttr" /> nie zawiera jedną z następujących flag powiązania: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, lub <see langword="SetProperty" />.  
  
—lub— 
 <paramref name="invokeAttr" /> zawiera <see langword="CreateInstance" /> w połączeniu z <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, lub <see langword="SetProperty" />.  
  
—lub— 
 <paramref name="invokeAttr" /> zawiera zarówno <see langword="GetField" /> i <see langword="SetField" />.  
  
—lub— 
 <paramref name="invokeAttr" /> zawiera zarówno <see langword="GetProperty" /> i <see langword="SetProperty" />.  
  
—lub— 
 <paramref name="invokeAttr" /> zawiera <see langword="InvokeMethod" /> w połączeniu z <see langword="SetField" /> lub <see langword="SetProperty" />.  
  
—lub— 
 <paramref name="invokeAttr" /> zawiera <see langword="SetField" /> i <paramref name="args" /> ma więcej niż jeden element.  
  
—lub— 
Ta metoda jest wywoływana dla obiektu COM i jedną z następujących flag powiązania nie przekazano: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, lub <see langword="BindingFlags.PutRefDispProperty" />.  
  
—lub— 
Jedna z nich tablic nazwany parametr zawiera ciąg, który jest <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">Określony element członkowski jest inicjator klasy.</exception>
        <exception cref="T:System.MissingFieldException">Nie można odnaleźć pola lub właściwości.</exception>
        <exception cref="T:System.MissingMethodException">Brak metody można znaleźć odpowiadającej argumentów <paramref name="args" />.  
  
—lub— 
Bieżący <see cref="T:System.Type" /> obiekt reprezentuje typ, który zawiera parametry typu otwartego, czyli <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">Nie można wywołać określonego elementu członkowskiego <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Więcej niż jednej metody odpowiadającego kryteriom powiązania.</exception>
        <exception cref="T:System.InvalidOperationException">Metody reprezentowanej przez <paramref name="name" /> ma jeden lub więcej określonych parametrów typu rodzajowego. Oznacza to, że metody <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> właściwość zwraca <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">W celu uzyskiwania dostępu do elementów członkowskich niepublicznych, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby wywoływać kod niezarządzany. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę konstruktora, metody, właściwości lub pól członka do wywołania.  
  
—lub— 
Ciąg pusty ("") do wywołania domyślny element członkowski.  
  
—lub— 
Aby uzyskać <see langword="IDispatch" /> członków, ciąg reprezentujący identyfikator DispID, na przykład "[identyfikator DispID = 3]".</param>
        <param name="invokeAttr">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie. Dostęp może być jednym z <see langword="BindingFlags" /> takich jak <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />i tak dalej. Typ wyszukiwania nie muszą być określane. W przypadku pominięcia typ wyszukiwania <see langword="BindingFlags.Public" />  |  <see langword="BindingFlags.Instance" />  |  <see langword="BindingFlags.Static" /> są używane.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
Odwołanie o wartości null (Nothing w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />. Należy pamiętać, że jawne określenie <see cref="T:System.Reflection.Binder" /> obiekt może być wymagane dla pomyślnie wywołanie przeciążenia metody ze zmiennymi argumentami.</param>
        <param name="target">Obiekt do wywołania określonego elementu członkowskiego.</param>
        <param name="args">Tablica zawierająca argumenty do przekazania do składowej na potrzeby wywołania.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <paramref name="args" /> tablicy. Parametr skojarzonych z nimi atrybutów są przechowywane w podpisie elementu członkowskiego.  
  
Tylko wtedy, gdy wywołanie składnika modelu COM, domyślny integrator przetwarza tego parametru.</param>
        <param name="culture"><see cref="T:System.Globalization.CultureInfo" /> Obiekt reprezentujący globalizacji ustawienia regionalne, które mogą być konieczne w przypadku konwersji specyficzne dla ustawień regionalnych, takich jak konwertowanie ciągów liczbowych na wartość o podwójnej precyzji.  
  
—lub— 
Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic) do użycia bieżący wątek <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="namedParameters">Tablica zawierająca nazwy parametrów, do której wartości w <paramref name="args" /> tablicy są przekazywane.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wywołuje określonego elementu członkowskiego, dopasowanie określoną listę argumentów, Modyfikatory i kultury i za pomocą ograniczeń w określonym powiązaniu.</summary>
        <returns>Obiekt reprezentujący wartość zwracaną wywołanego elementu członkowskiego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember` wywołuje członek konstruktora lub metody, pobiera lub ustawia element właściwości, pobiera lub ustawia element członkowski pola danych lub pobiera lub ustawia element członkowski tablicy.  
  
> [!NOTE]
>  Nie można użyć <xref:System.Type.InvokeMember%2A> do wywoływania metody rodzajowej.  
  
 Gdy wywołujesz `IDispatch` elementu członkowskiego, możesz określić identyfikator DispID zamiast nazwy elementu członkowskiego, używając formatu ciągu "[identyfikator DispID = ##]". Na przykład, jeśli identyfikator DispID MyComMethod wynosi 3, możesz określić ciąg "[identyfikator DispID = 3]" zamiast "MyComMethod". Wywoływanie składowej przez identyfikator DispID jest szybsze niż Wyszukiwanie elementu członkowskiego według nazwy. W scenariuszach złożoną agregację DispID czasami jest jedynym sposobem, aby wywołać żądanego elementu.  
  
 Mimo że domyślny integrator nie przetwarza <xref:System.Reflection.ParameterModifier> lub <xref:System.Globalization.CultureInfo> ( `modifiers` i `culture` parametrów), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `modifiers` i `culture`. `ParameterModifier` jest używana tylko podczas wywoływania przez współdziałania z modelem COM i są obsługiwane tylko w przypadku parametrów, które są przekazywane przez odwołanie.  
  
 Każdy parametr w `namedParameters` tablicy pobiera wartość w odpowiednim elementem w `args` tablicy. Jeśli długość `args` jest większa niż długość `namedParameters`, pozostałe wartości argumentów są przekazywane w kolejności.  
  
 `namedParameters` Tablicy można zmienić kolejność argumentów w tablicy wejściowej. Na przykład, biorąc pod uwagę metody `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` w języku Visual Basic) i Tablica wejściowa `{ 42, "x" }`, Tablica wejściowa mogą być przekazywane bez zmian do `args` Jeśli tablica `{ "b", "a" }` podano dla `namedParameters`.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania elementów członkowskich, które można uwzględnić w wyszukiwaniu:  
  
-   Określ `BindingFlags.Public` obejmujący publiczne elementy członkowskie w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` obejmujący elementów członkowskich niepublicznych (czyli prywatne, wewnętrzne i chronione elementy członkowskie) w wyszukiwaniu.  
  
-   Określ `BindingFlags.FlattenHierarchy` obejmujący statyczne elementy członkowskie w hierarchii.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko do elementów członkowskich zadeklarowanych w <xref:System.Type>, nie elementów członkowskich, które zostały po prostu odziedziczone.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi wywołania może służyć do określenia, jaką akcję należy podjąć przy użyciu elementu członkowskiego:  
  
-   `CreateInstance` Aby wywołać konstruktora. `name` jest ignorowany. Nieprawidłowy inne flagi wywołania.  
  
-   `InvokeMethod` do wywołania metody, ale nie konstruktorze lub inicjatorze typu. Nie jest prawidłowy z `SetField` lub `SetProperty`. Jeśli `InvokeMethod` jest określony przez siebie, `BindingFlags.Public`, `BindingFlags.Instance`, i `BindingFlags.Static` są automatycznie dołączane.  
  
-   `GetField` można pobrać wartości pola. Nie jest prawidłowy z `SetField`.  
  
-   `SetField` można ustawić wartości pola. Nie jest prawidłowy z `GetField`.  
  
-   `GetProperty` można pobrać właściwości. Nie jest prawidłowy z `SetProperty`.  
  
-   `SetProperty` można ustawić właściwości. Nie jest prawidłowy z `GetProperty`.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Metoda zostanie wywołana, jeśli są spełnione oba poniższe warunki:  
  
-   Liczba parametrów w deklaracji metody jest równa liczbie argumentów `args` tablicy (chyba że argumenty domyślne są zdefiniowane w składowej i `BindingFlags.OptionalParamBinding` jest określony).  
  
-   Typ każdego argumentu mogą być konwertowane przez binder typowi parametru.  
  
 Obiekt wiążący znajdzie wszystkie metody dopasowania. Te metody zostaną znalezione, oparte na typie powiązania żądane (<xref:System.Reflection.BindingFlags> wartości `InvokeMethod`, `GetProperty`i tak dalej). Zestaw metod są filtrowane według nazwy, liczba argumentów i zestaw modyfikatorów wyszukiwania zdefiniowane w obiekt wiążący.  
  
 Po wybraniu metody jest wywoływana. Dostępność jest sprawdzana w tym momencie. Wyszukiwanie może kontrolować, które zestaw metod, przeszukiwane są na podstawie atrybutu ułatwień dostępu powiązany z metodą. <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Metody <xref:System.Reflection.Binder> klasy jest odpowiedzialny za wybranie wywoływanej metody. Domyślny integrator wybiera najbardziej określonego dopasowania.  
  
 `InvokeMember` może służyć do wywołania metody z parametrami, które mają przypisane wartości domyślne. Aby powiązać z tych metod, wymaga odbicia <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> należy określić. Dla parametru, który ma wartość domyślną, możesz podać inną wartość, lub podaj <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> Aby użyć wartości domyślnej.  
  
 Rozważmy na przykład metody takie jak MyMethod (int x, float y = w wersji 2.0). Aby wywołać tej metody za pomocą tylko pierwszy argument jako MyMethod(4), jedną z powyższych flag powiązania i przekazać dwa argumenty, a mianowicie 4 dla pierwszego argumentu i `Missing.Value` dla drugiego argumentu. Chyba że używasz `Missing.Value`, nie może pominąć parametrów opcjonalnych za pomocą `Invoke` metody. Jeśli należy to zrobić, użyj `InvokeMember` zamiast tego.  
  
 Ograniczenia dostępu są ignorowane w przypadku w pełni zaufany kod; oznacza to, konstruktory prywatne, metody, pola i właściwości mogą być dostępne i wywoływane za pośrednictwem <xref:System.Reflection> zawsze, gdy kod jest w pełni zaufany.  
  
 Możesz użyć `Type.InvokeMember` można ustawić pola na określoną wartość, określając <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Na przykład, jeśli chcesz ustawić pole publiczne wystąpienia o nazwie F klasy C i F jest `String`, można użyć kodu takiego jak:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 Jeśli jest F `String[]`, można użyć kodu takiego jak:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 która zainicjuje pole F do tej nowej tablicy. Można również użyć `Type.InvokeMember` próba ustawienia pozycji w tablicy, podając indeks wartości, a następnie wartość następnego przy użyciu następującego kodu:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 Spowoduje to zmianę w tablicy, która F zawiera ciąg "b", ciąg "z".  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do dostępu do elementów członkowskich niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga, a jeśli zestaw uprawnień elementów członkowskich niepublicznych jest ograniczony do obiektu wywołującego przyznania zestawu lub być podzbiorem jej. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> nie zawiera <see langword="CreateInstance" /> i <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="args" /> i <paramref name="modifiers" /> nie mają tę samą długość.  
  
—lub— 
 <paramref name="invokeAttr" /> nie jest prawidłowym <see cref="T:System.Reflection.BindingFlags" /> atrybutu.  
  
—lub— 
 <paramref name="invokeAttr" /> nie zawiera jedną z następujących flag powiązania: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, lub <see langword="SetProperty" />.  
  
—lub— 
 <paramref name="invokeAttr" /> zawiera <see langword="CreateInstance" /> w połączeniu z <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, lub <see langword="SetProperty" />.  
  
—lub— 
 <paramref name="invokeAttr" /> zawiera zarówno <see langword="GetField" /> i <see langword="SetField" />.  
  
—lub— 
 <paramref name="invokeAttr" /> zawiera zarówno <see langword="GetProperty" /> i <see langword="SetProperty" />.  
  
—lub— 
 <paramref name="invokeAttr" /> zawiera <see langword="InvokeMethod" /> w połączeniu z <see langword="SetField" /> lub <see langword="SetProperty" />.  
  
—lub— 
 <paramref name="invokeAttr" /> zawiera <see langword="SetField" /> i <paramref name="args" /> ma więcej niż jeden element.  
  
—lub— 
Tablica parametrów nazwanych jest większa niż tablica argumentów.  
  
—lub— 
Ta metoda jest wywoływana dla obiektu COM i jedną z następujących flag powiązania nie przekazano: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, lub <see langword="BindingFlags.PutRefDispProperty" />.  
  
—lub— 
Jedna z nich tablic nazwany parametr zawiera ciąg, który jest <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">Określony element członkowski jest inicjator klasy.</exception>
        <exception cref="T:System.MissingFieldException">Nie można odnaleźć pola lub właściwości.</exception>
        <exception cref="T:System.MissingMethodException">Brak metody można znaleźć odpowiadającej argumentów <paramref name="args" />.  
  
—lub— 
Brak elementów członkowskich, można znaleźć zawierającej nazwy argumentów dostarczone w <paramref name="namedParameters" />.  
  
—lub— 
Bieżący <see cref="T:System.Type" /> obiekt reprezentuje typ, który zawiera parametry typu otwartego, czyli <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">Nie można wywołać określonego elementu członkowskiego <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Więcej niż jednej metody odpowiadającego kryteriom powiązania.</exception>
        <exception cref="T:System.InvalidOperationException">Metody reprezentowanej przez <paramref name="name" /> ma jeden lub więcej określonych parametrów typu rodzajowego. Oznacza to, że metody <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> właściwość zwraca <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">W celu uzyskiwania dostępu do elementów członkowskich niepublicznych, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby wywoływać kod niezarządzany. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest abstrakcyjny i musi zostać zastąpiona.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest abstrakcyjna; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAbstract%2A> Właściwość zwraca `true` w następujących przypadkach:  
  
-   Bieżącym typem jest abstrakcyjna; oznacza to, że ten nie można utworzyć wystąpienia, ale tylko może służyć jako klasa bazowa dla klas pochodnych. W języku C#, klasy abstrakcyjne są oznaczone [abstrakcyjne](~/docs/csharp/language-reference/keywords/abstract.md) słowo kluczowe w języku Visual Basic są oznaczone [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) — słowo kluczowe.  
  
-   Bieżący typ jest interfejsem.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę <xref:System.Type> obiekty reprezentujące następujących typów: zawiera zwraca typ `true` Jeśli określony obiekt jest `abstract`; w przeciwnym razie zwraca `false`.  
  
-   `AbstractClass`, klasa abstrakcyjna (klasa jest oznaczona jako `abstract` w języku C# i `MustInherit` w języku Visual Basic).  
  
-   `DerivedClass`, klasa, która dziedziczy `AbstractClass`.  
  
-   `SingleClass`,-dziedziczone klasy. Jest on zdefiniowany jako `sealed` w języku C# i `NotInheritable` w języku Visual Basic.  
  
-   `ITypeInfo`, interfejs.  
  
-   `ImplementingClass`, klasa, która implementuje `ITypeInfo` interfejsu.  
  
 Metoda ta zwraca `true` tylko w przypadku `AbstractClass`, klasa abstrakcyjna, i `ITypeInfo`, interfejs.  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy ciąg formatu atrybut <see langword="AnsiClass" /> wybrano <see cref="T:System.Type" />.</summary>
        <value><see langword="true" /> Jeśli ciąg formatu atrybut <see langword="AnsiClass" /> wybrano <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> Wybiera atrybuty format ciągu. Atrybuty formatu ciągu ulepszenia współdziałania, definiując, jak interpretować ciągów.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny, właściwość ta odnoszą się do definicji typu ogólnego, z którego skonstruowano. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca zawsze `false`.  
  
   
  
## Examples  
 Poniższy przykład pobiera informacje o polu i sprawdza, czy `AnsiClass` atrybutu.  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy typ jest tablicą.</summary>
        <value><see langword="true" /> Jeśli bieżący typ jest tablicą; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsArray%2A> Właściwość zwraca `false` dla <xref:System.Array> klasy. Również zwraca `false` Jeśli bieżące wystąpienie jest <xref:System.Type> obiekt, który reprezentuje typ kolekcji lub interfejs, zaprojektowane do pracy z kolekcjami, takich jak <xref:System.Collections.IEnumerable> lub <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Aby sprawdzić, czy tablica, należy użyć kodu takiego jak:  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 Jeśli bieżący typ reprezentuje typ ogólny lub parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie <xref:System.Type.IsArray%2A> właściwości.  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, implementuje <see cref="P:System.Type.IsArray" /> właściwości i określa, czy <see cref="T:System.Type" /> jest tablicą.</summary>
        <returns><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest tablicą, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie <xref:System.Array> klasy musi zwracać `false` , ponieważ jest to obiekt, nie tablica.  
  
   
  
## Examples  
 Poniższy przykład zastępuje `IsArrayImpl` method in Class metoda `MyTypeDelegator` klasy sprawdza, czy zmienna jest tablicą, a następnie wyświetla wynik.  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Typ do porównania z bieżącym typem.</param>
        <summary>Określa, czy wystąpienia określonego typu można przypisać do wystąpienia typu bieżącego.</summary>
        <returns><see langword="true" /> Jeśli dowolny z następujących warunków jest spełniony: 
-   <paramref name="c" /> i bieżące wystąpienie reprezentują tego samego typu.  
  
-   <paramref name="c" /> pochodzi bezpośrednio lub pośrednio od bieżącego wystąpienia. <paramref name="c" /> pochodzi bezpośrednio z bieżącym wystąpieniem dziedziczy bieżące wystąpienie; <paramref name="c" /> pochodzi pośrednio od bieżącego wystąpienia, jeśli jest dziedziczona z serii co najmniej jedną klasę, które dziedziczą z bieżącym wystąpieniem.  
  
-Bieżące wystąpienie jest interfejsem, który <paramref name="c" /> implementuje.  
  
-   <paramref name="c" /> jest parametr typu ogólnego, a bieżące wystąpienie reprezentuje jedną z ograniczeń <paramref name="c" />.  
  
W poniższym przykładzie bieżące wystąpienie jest <see cref="T:System.Type" /> obiekt, który reprezentuje <see cref="T:System.IO.Stream" /> klasy. <c>GenericWithConstraint</c> jest typem ogólnym, na której parametr typu ogólnego, musi być typu <see cref="T:System.IO.Stream" />. Przekazywanie jako parametr typu ogólnego <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> wskazuje, czy wystąpienie parametru typu generycznego można przypisać do <see cref="T:System.IO.Stream" /> obiektu.  
  
[! code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [! kodu vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)] 
-   <paramref name="c" /> Typ reprezentujący wartość, a bieżące wystąpienie reprezentuje <c>Nullable&lt;c&gt; </c> (<c>Nullable (Of c)</c> w języku Visual Basic).  
  
 <see langword="false" /> Jeśli żaden z tych warunków jest spełniony, lub jeśli <paramref name="c" /> jest <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAssignableFrom%2A> Metoda może służyć do określenia, czy wystąpienie `c` można przypisać z wystąpieniem bieżącego typu, metoda jest najbardziej przydatna podczas obsługi obiektów, których typy nie są znane w czasie projektowania i umożliwia warunkowe przypisanie w poniższym przykładzie pokazano.  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 Ta metoda ten sposób zapewnia, że wiersz kodu, takie jak następujące będą wykonywane w czasie wykonywania bez niepotrzebnego <xref:System.InvalidCastException> lub wyjątku podobnych wyjątek:  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
> [!NOTE]
>  Definicja typu ogólnego nie jest możliwy do przypisania z zamkniętej skonstruowanego typu. Oznacza to, że nie można przypisać zamknięte skonstruowanego typu `MyGenericList<int>` (`MyGenericList(Of Integer)` w języku Visual Basic) do zmiennej typu `MyGenericList<T>`.  
  
 Jeśli `c` parametr jest typu <xref:System.Reflection.Emit.TypeBuilder>, wynik jest oparty na typie, który ma zostać utworzony. Poniższy przykład kodu demonstruje, to przy użyciu wbudowanego typu o nazwie `B`.  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano `IsAssignableFrom` przy użyciu metody zdefiniowanych klas, tablic liczby całkowitej i typy ogólne.  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy ciąg formatu atrybut <see langword="AutoClass" /> wybrano <see cref="T:System.Type" />.</summary>
        <value><see langword="true" /> Jeśli ciąg formatu atrybut <see langword="AutoClass" /> wybrano <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> Wybiera atrybuty format ciągu. Atrybuty formatu ciągu ulepszenia współdziałania, definiując, jak interpretować ciągów.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca zawsze `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy pola bieżącego typu są ułożone automatycznie przez środowisko uruchomieniowe języka wspólnego.</summary>
        <value><see langword="true" /> Jeśli <see cref="P:System.Type.Attributes" /> zawiera właściwości bieżącego typu <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest udostępniana dla wygody. Alternatywnie, można użyć <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> wartości wyliczenia, aby wybrać atrybuty układu typu, a następnie w celu przetestowania, czy <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> jest ustawiona. <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, I <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> wartości wyliczenia wskazuje sposób pola tego typu są ułożone w pamięci.  
  
 W przypadku typów dynamicznych, możesz określić <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> podczas tworzenia tego typu. W kodzie, należy zastosować <xref:System.Runtime.InteropServices.StructLayoutAttribute> atrybutem <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> wartość wyliczenia do typu, aby określić odpowiedni sposób, aby zmienić układ klasy środowiska uruchomieniowego.  
  
> [!NOTE]
>  Nie można użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metodę pozwala ustalić czy <xref:System.Runtime.InteropServices.StructLayoutAttribute> zastosowano do typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>.`  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie tego typu i wyświetla <xref:System.Type.IsAutoLayout%2A> właściwości.  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">Składniki samoopisujące się i metadane</related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest przekazywany przez odwołanie.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest przekazywany przez odwołanie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby przejść do rzeczywistego typu, wyłuskania typ, który został przekazany przez odwołanie, a następnie wywołaj <xref:System.Type.GetElementType%2A> tego typu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie `IsByRef` właściwość do sprawdzenia, czy określony typ jest przekazywany przez odwołanie. W przykładzie zdefiniowano klasę `MyTypeDelegator`, co zastępuje `HasElementTypeImpl` metody. Sprawdza, czy główna klasa `HasElementType` właściwości i wyświetla typ elementu.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, implementuje <see cref="P:System.Type.IsByRef" /> właściwości i określa, czy <see cref="T:System.Type" /> jest przekazywany przez odwołanie.</summary>
        <returns><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest przekazywany przez odwołanie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> klasy lub delegata; oznacza to, nie jest typem wartości lub interfejs.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest klasą; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca `true` dla klasy, a także delegatów. Zwraca `false` dla typów wartości (w przypadku struktur i wyliczenia) nawet wtedy, gdy są one ramce.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `true`. Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta zwraca `true` Jeśli definicja typu ogólnego jest definicją klasy; oznacza to też nie definiuje interfejs lub typu wartościowego.  
  
> [!NOTE]
>  Ta właściwość zwraca `true` dla `Type` wystąpienia reprezentujące <xref:System.Enum> i <xref:System.ValueType> klasy. Te dwie klasy są typami podstawowymi dla wyliczeń i typy wartości, odpowiednio, ale nie są one wyliczenia ani typów wartości, samodzielnie. Aby uzyskać więcej informacji, zobacz <xref:System.Type.IsValueType%2A> i <xref:System.Type.IsEnum%2A> właściwości.  
  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> Wartość wyliczenia wyróżnia deklaracji typu klasy lub interfejsu. Jednak zarówno klasy i typy wartości są oznaczone <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> atrybutu. Jeśli pobieranie wartości właściwości atrybutów i użyj typu <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> wartość, aby określić, czy typ jest klasą zamiast typu wartości, musisz również wywołać <xref:System.Type.IsValueType%2A> właściwości. Przykład <xref:System.Reflection.TypeAttributes> wyliczenia zawiera dodatkowe informacje, a także anexample.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie typu i wskazuje, czy typ jest klasą.  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest obiektem COM.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest obiektem COM; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca `false` dla interfejsów COM, ponieważ nie są obiektami. Interfejsy modelu COM może być implementowany przez obiekty programu Microsoft .NET Framework.  
  
 Można również załadować klasy COM i uzyskać `Type` obiektu dla tej klasy COM za pomocą [Tlbimp.exe (Importer biblioteki typów)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) narzędzia.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int`> (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, implementuje <see cref="P:System.Type.IsCOMObject" /> właściwości i określa, czy <see cref="T:System.Type" /> jest obiektem COM.</summary>
        <returns><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest obiektem COM; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca `false` dla interfejsów COM, ponieważ nie są obiektami. Interfejsy modelu COM może być implementowany przez obiekty programu Microsoft .NET Framework.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten obiekt reprezentuje zbudowany typ ogólny. Można utworzyć wystąpienia elementu zbudowany typ ogólny.</summary>
        <value><see langword="true" /> Jeśli ten obiekt reprezentuje zbudowany typ ogólny; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skonstruowany typ rodzajowy miał jawnie typów dostarczonych dla wszystkich jego parametrów typu rodzajowego. Ona również jest określana jako zamknięty typ ogólny.  
  
 Gdy ta właściwość jest `true`, można utworzyć wystąpienia typu bieżącego; znajduje się w `false`, to nie jest możliwe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> może znajdować się w kontekście.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> może być hostowana w kontekście, w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontekst przechwytuje wywołania do składowych klasy i wymusza zasady, które są stosowane do klasy, takie jak synchronizacja. Aby uzyskać szczegółowe informacje o kontekstach komunikacji zdalnej, zobacz <xref:System.Runtime.Remoting.Contexts.Context>.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, i <xref:System.Type.IsPrimitive%2A> właściwości <xref:System.Type> klasy. Sprawdza, czy dany typ może być hostowana w kontekście, czy mogą być przekazywane przez odwołanie i zezwolić na określony typ jest typem danych pierwotnych.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementuje <see cref="P:System.Type.IsContextful" /> właściwości i określa, czy <see cref="T:System.Type" /> może znajdować się w kontekście.</summary>
        <returns><see langword="true" /> Jeśli <see cref="T:System.Type" /> może być hostowana w kontekście, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
 Kontekst przechwytuje wywołania do składowych klasy i wymuszać zasady, które są stosowane do klasy, takie jak synchronizacja.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie `IsContextfulImpl` metody.  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy bieżący <see cref="T:System.Type" /> reprezentuje wyliczenia.</summary>
        <value><see langword="true" /> Jeśli bieżący <see cref="T:System.Type" /> reprezentuje wyliczenia; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca `true` wyliczania, ale nie dla <xref:System.Enum> samego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia `IsEnum` właściwości.  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Wartość, która ma zostać przetestowana.</param>
        <summary>Zwraca wartość wskazującą, czy określona wartość istnieje w bieżącym typem wyliczenia.</summary>
        <returns><see langword="true" /> Jeśli określona wartość jest elementem członkowskim bieżącego typu wyliczenia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Bieżący typ nie jest wyliczeniem.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> jest typem, który nie może być podstawowym typem wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">Typ modelu COM, który jest testowany pod kątem równoważności z bieżącym typem.</param>
        <summary>Określa, czy dwa typy COM ma taką samą tożsamość i kwalifikują się do równoważeniu typu.</summary>
        <returns><see langword="true" /> Jeśli typy modelu COM są równoważne; w przeciwnym razie <see langword="false" />. Ta metoda zwraca też wartość <see langword="false" /> czy jeden typ w zestawie, który jest ładowany do wykonania, a drugi to w zestawie, który jest ładowany do kontekstu reflection-only.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], środowisko uruchomieniowe języka wspólnego obsługuje osadzanie informacji o typie dla typów modelu COM bezpośrednio do zestawów zarządzanych, zamiast zestawów zarządzanych uzyskać informacje o typie dla typów modelu COM z międzyoperacyjności zestawy. Informacje o typie osadzony zawiera tylko typy i elementy członkowskie, które są rzeczywiście używane przez zestaw zarządzany, dwóch zestawów zarządzanych, może być bardzo różne widoki tego samego typu COM. Każdy zestaw zarządzany ma inną <xref:System.Type> obiektu do reprezentowania jej widok typów modelu COM. Środowisko uruchomieniowe języka wspólnego obsługuje równoważności typu między te różne widoki dla interfejsy, struktury, wyliczenia i delegaty.  
  
 Równoważności typu oznacza o tym, że obiekt COM, który jest przekazywany z jednego zestawu zarządzanego do innego, mogą być rzutowane do odpowiedniego zarządzane typu w zestawie odbierania. <xref:System.Type.IsEquivalentTo%2A> Metoda umożliwia zestawu, aby ustalić, czy obiekt COM, uzyskany z innego zestawu ma taką samą tożsamość COM jako jeden z typów międzyoperacyjnych pierwszego zestawu własnych osadzone i dlatego mogą być rzutowane na tego typu.  
  
 Aby uzyskać więcej informacji, zobacz [równoważności typów i osadzone typy międzyoperacyjne](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy pola bieżącego typu są ułożone w jawnie określonych przesunięć.</summary>
        <value><see langword="true" /> Jeśli <see cref="P:System.Type.Attributes" /> zawiera właściwości bieżącego typu <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest udostępniana dla wygody. Alternatywnie, można użyć <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> wartości wyliczenia, aby wybrać atrybuty układu typu, a następnie w celu przetestowania, czy <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> jest ustawiona. <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, I <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> wartości wyliczenia wskazuje sposób pola tego typu są ułożone w pamięci.  
  
 W przypadku typów dynamicznych, możesz określić <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> podczas tworzenia tego typu. W kodzie, należy zastosować <xref:System.Runtime.InteropServices.StructLayoutAttribute> atrybutem <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> wartość wyliczenia do typu, aby określić przesunięcie, w których start pola zostaną wyraźnie wskazane.  
  
> [!NOTE]
>  Nie można użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metodę pozwala ustalić czy <xref:System.Runtime.InteropServices.StructLayoutAttribute> zastosowano do typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie typu i wyświetla wartość jego <xref:System.Type.IsExplicitLayout%2A> właściwości. Używa ona `MySystemTime` klasy, która jest również w przykładzie kodu dla <xref:System.Runtime.InteropServices.StructLayoutAttribute>.  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">Składniki samoopisujące się i metadane</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy bieżący <see cref="T:System.Type" /> reprezentuje parametr typu w definicji typu ogólnego lub metody.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> obiekt reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej definicję; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> obiekty, które reprezentują parametry typu ogólnego, można uzyskać przez wywołanie metody <xref:System.Type.GetGenericArguments%2A> metody <xref:System.Type> obiekt, który reprezentuje definicję typu ogólnego lub <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> metody <xref:System.Reflection.MethodInfo> obiekt, który reprezentuje metody ogólnej Definicja.  
  
-   Dla typu ogólnego lub definicję metody <xref:System.Type.IsGenericParameter%2A> właściwość zwraca `true` dla każdego elementu tablicy wynikowej.  
  
-   Zamknięte skonstruowanego typu lub metody <xref:System.Type.IsGenericParameter%2A> właściwość zwraca `false` dla każdego elementu w tablicy zwracanej przez <xref:System.Type.GetGenericArguments%2A> metody.  
  
-   Otwórz skonstruowanego typu lub metody niektóre elementy tablicy mogą być określone typy, a inne mogą mieć parametrów typu. <xref:System.Type.IsGenericParameter%2A> Zwraca `false` dla typów i `true` dla parametrów typu. Przykład kodu dla <xref:System.Type.ContainsGenericParameters%2A> właściwość pokazuje klasę ogólną za pomocą kombinacji typów parametrów typu.  
  
 Aby uzyskać listę niezmiennych warunków dla terminów używanych w odbiciu rodzajowym, zobacz <xref:System.Type.IsGenericType%2A> uwagi dotyczące właściwości.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Type.IsGenericParameter%2A> właściwość do badania parametrów typu rodzajowego w typie ogólnym.  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący typ jest typem ogólnym.</summary>
        <value><see langword="true" /> Jeśli bieżący typ jest typem podstawowym; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Type.IsGenericType%2A> właściwości, aby określić, czy <xref:System.Type> obiekt reprezentuje typ ogólny. Użyj <xref:System.Type.ContainsGenericParameters%2A> właściwości, aby określić, czy <xref:System.Type> obiekt reprezentuje skonstruowanego typu otwartego lub zamkniętych skonstruowanego typu.  
  
> [!NOTE]
>  <xref:System.Type.IsGenericType%2A> Właściwość zwraca `false` jeśli natychmiastowe nie jest to typ ogólny. Na przykład tablica, której elementy są typu `A<int>` (`A(Of Integer)` w języku Visual Basic) sam nie jest typem ogólnym.  
  
 Poniższa tabela zawiera podsumowanie niezmiennych warunków dla typowych terminów używanych w odbiciu rodzajowym.  
  
|Termin|Niezmiennej|  
|----------|---------------|  
|Definicja typu ogólnego|<xref:System.Type.IsGenericTypeDefinition%2A> Właściwość `true`.<br /><br /> Definiuje typ ogólny. Skonstruowany typ jest tworzony przez wywołanie <xref:System.Type.MakeGenericType%2A> metody <xref:System.Type> obiekt, który reprezentuje definicji typu ogólnego i określając tablicę argumentów typu.<br /><br /> <xref:System.Type.MakeGenericType%2A> można wywołać tylko w definicji typu ogólnego.<br /><br /> Dowolna definicja typu ogólnego jest typem ogólnym ( <xref:System.Type.IsGenericType%2A> właściwość `true`), ale nie jest to prawdą.|  
|Typ ogólny|<xref:System.Type.IsGenericType%2A> Właściwość `true`.<br /><br /> Może być definicji typu ogólnego, skonstruowanego typu otwartego lub zamkniętych skonstruowanego typu.<br /><br /> Należy pamiętać, że tablica typu którego typ elementu jest ogólny sam nie jest typem ogólnym. To samo dotyczy programu <xref:System.Type> obiekt reprezentujący wskaźnik do typu ogólnego.|  
|Otwórz skonstruowanego typu|<xref:System.Type.ContainsGenericParameters%2A> Właściwość `true`.<br /><br /> Przykłady to typ ogólny, który ma nieprzypisanych parametry typu, typ, który jest zagnieżdżony w definicji typu ogólnego lub skonstruowanego typu otwartego lub typ ogólny, który ma argument typu, dla którego <xref:System.Type.ContainsGenericParameters%2A> właściwość `true`.<br /><br /> Nie jest możliwe do utworzenia wystąpienia typu otwartego skonstruowany.<br /><br /> Należy pamiętać, że nie wszystkie otwarte typy utworzone są rodzajowe. Na przykład nie jest ogólna tablica, którego typ elementu jest definicja typu ogólnego i nie jest ogólna wskaźnik do skonstruowanego typu otwartego.|  
|skonstruowany typ zamknięty|<xref:System.Type.ContainsGenericParameters%2A> Właściwość `false`.<br /><br /> Gdy zbadane cyklicznie, typ nie ma nieprzypisane ogólnych parametrów.|  
|Parametr typu ogólnego|<xref:System.Type.IsGenericParameter%2A> Właściwość `true`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> Właściwość `true`.<br /><br /> W definicji typu ogólnego jest symbolem zastępczym dla typu, który zostanie przypisany później.|  
|argument typu ogólnego|Może być dowolnego typu, w tym parametr typu ogólnego.<br /><br /> Argumenty typu są określane jako tablicę <xref:System.Type> przekazywanym do <xref:System.Type.MakeGenericType%2A> metody podczas tworzenia zbudowany typ ogólny. W przypadku wystąpienia wynikowy typ ma zostać utworzony <xref:System.Type.ContainsGenericParameters%2A> właściwość musi być `false` dla wszystkich argumentów typu.|  
  
 Następujący przykładowy kod i tabeli przedstawiono niektóre z tych warunków i invariants. `Derived` Klasy ma szczególne znaczenie, ponieważ jego typ podstawowy jest typem stworzonego elementu, który zawiera kombinację typów parametrów typu w jego lista argumentów typu.  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 W poniższej tabeli przedstawiono przykłady, które oraz tworzyć dotyczące klas `Base`, `Derived`, i `G`. W przypadku kodu C++ i C# jest taka sama, jest wyświetlana tylko jedna pozycja.  
  
|Przykład|Invariants|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|Dla tego typu:<br /><br /> <xref:System.Type.IsGenericType%2A> jest `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> jest `true`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> jest `true`.|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|Dla tego typu:<br /><br /> <xref:System.Type.IsGenericType%2A> jest `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> jest `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> jest `true`.|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|Dla typu zmiennej `d`:<br /><br /> <xref:System.Type.IsGenericType%2A> jest `false` ponieważ `d` jest tablicą.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> jest `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> jest `false`.|  
|`T`, `U`, i `V` (wszędzie, gdzie są wyświetlane)|<xref:System.Type.IsGenericParameter%2A> jest `true`.<br /><br /> <xref:System.Type.IsGenericType%2A> jest `false` ponieważ nie istnieje żaden sposób ograniczyć parametr typu do typów ogólnych.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> jest `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> jest `true` ponieważ `T`, `U`, i `V` są same parametry typu ogólnego. To nie oznacza niczego o argumentach typu, które są przypisane do ich później.|  
|Typ pola `F`|<xref:System.Type.IsGenericType%2A> jest `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> jest `false` , ponieważ typ przypisany do typu parametru `G`. Należy pamiętać, że jest to równoważne wywołaniem <xref:System.Type.MakeGenericType%2A> metody.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> jest `true` ponieważ typ pola `F` ma argument typu, który jest typem otwartym skonstruowany. Skonstruowany typ jest otwarty ponieważ jej argument typu (czyli `Base`) jest definicja typu ogólnego. Obrazuje to cykliczne rodzaj <xref:System.Type.IsGenericType%2A> właściwości.|  
|Klasa zagnieżdżona `Nested`|<xref:System.Type.IsGenericType%2A> jest `true`, nawet jeśli `Nested` klasa ma żadnych parametrów typu rodzajowego, własnych, ponieważ jest zagnieżdżony w typie ogólnym.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> jest `true`. Oznacza to, można wywołać <xref:System.Type.MakeGenericType%2A> metody i dostarczyć parametr typu otaczającego `Derived`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> jest `true` ponieważ otaczający typ `Derived`, ma parametry typu ogólnego. Obrazuje to cykliczne rodzaj <xref:System.Type.ContainsGenericParameters%2A> właściwości.|  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, i <xref:System.Type.ContainsGenericParameters%2A> właściwości typów, opisanych w sekcji uwag. Objaśnienia dotyczące wartości właściwości Zobacz towarzyszący tabelę w uwagi.  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy bieżący <see cref="T:System.Type" /> reprezentuje definicji typu ogólnego, z którego można skonstruować innych typów ogólnych.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> obiekt reprezentuje definicji typu ogólnego; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definicja typu ogólnego jest szablonem, z którego można skonstruować innych typów. Na przykład z definicji typu ogólnego `G<T>` (wyrażony w języku C# składni; `G(Of T)` w języku Visual Basic lub `generic <typename T> ref class G` w języku C++) można utworzyć i utworzyć wystąpienie typu `G<int>` (`G(Of Integer)` w języku Visual Basic), przez wywołanie metody <xref:System.Type.MakeGenericType%2A> metody z argumentem ogólnym lista zawierająca <xref:System.Int32> typu. Biorąc pod uwagę <xref:System.Type> obiekt reprezentujący to skonstruowany typ <xref:System.Type.GetGenericTypeDefinition%2A> metoda otrzymuje w definicji typu ogólnego ponownie.  
  
 Użyj <xref:System.Type.IsGenericTypeDefinition%2A> właściwości w celu określenia, czy można utworzyć nowych typów z bieżącego typu. Jeśli <xref:System.Type.IsGenericTypeDefinition%2A> właściwość zwraca `true`, można wywołać <xref:System.Type.MakeGenericType%2A> metodę w celu utworzenia nowych typów rodzajowych.  
  
 Aby uzyskać listę niezmiennych warunków dla terminów używanych w odbiciu rodzajowym, zobacz <xref:System.Type.IsGenericType%2A> uwagi dotyczące właściwości.  
  
   
  
## Examples  
 Poniższy przykład wyświetla informacje o typie, w tym, czy jest definicja typu ogólnego. Skonstruowany typ, jego definicję typu ogólnego i typu zwykłego, zostaną wyświetlone informacje.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> ma <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> zastosowany, wskazujący, że został zaimportowany z biblioteki typów COM.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> ma <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>.`  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt do porównania z bieżącym typem.</param>
        <summary>Określa, czy określony obiekt jest wystąpieniem bieżącego <see cref="T:System.Type" />.</summary>
        <returns><see langword="true" /> Jeśli bieżący <see langword="Type" /> znajduje się w hierarchii dziedziczenia obiektu reprezentowanego przez <paramref name="o" />, lub, jeśli bieżący <see langword="Type" /> jest interfejsem, <paramref name="o" /> implementuje. <see langword="false" /> Jeśli żadna z tych warunków jest przypadek, gdy <paramref name="o" /> jest <see langword="null" />, lub, jeśli bieżący <see langword="Type" /> jest to otwarty typ ogólny (oznacza to, że <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
> [!NOTE]
>  Skonstruowany typ nie jest wystąpieniem jego definicji typu ogólnego. Oznacza to, że `MyGenericList<int>` (`MyGenericList(Of Integer)` w języku Visual Basic) nie jest wystąpieniem `MyGenericList<T>` (`MyGenericList(Of T)` w języku Visual Basic).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie `IsInstanceOfType` metody.  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> interfejsu; nie jest klasą lub typu wartości.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest interfejsem; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> Wyróżnia deklaracji typu jako typ klasy, interfejsu lub wartość.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład tworzy interfejs, sprawdza, czy typ interfejsu i wskazuje, czy klasa ma `IsInterface` zestawu właściwości.  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy pola bieżącego typu są ułożone sekwencyjnie w kolejności, że zostały zdefiniowane lub emitowany do metadanych.</summary>
        <value><see langword="true" /> Jeśli <see cref="P:System.Type.Attributes" /> zawiera właściwości bieżącego typu <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest udostępniana dla wygody. Alternatywnie, można użyć <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> wartości wyliczenia, aby wybrać atrybuty układu typu, a następnie w celu przetestowania, czy <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> jest ustawiona. <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, I <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> wartości wyliczenia wskazuje sposób pola tego typu są ułożone w pamięci.  
  
 W przypadku typów dynamicznych, możesz określić <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> podczas tworzenia tego typu. W kodzie, należy zastosować <xref:System.Runtime.InteropServices.StructLayoutAttribute> atrybutem <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> wartość wyliczenia do typu, aby określić, że układ jest sekwencyjny.  
  
> [!NOTE]
>  Nie można użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metodę pozwala ustalić czy <xref:System.Runtime.InteropServices.StructLayoutAttribute> zastosowano do typu.  
  
 Aby uzyskać więcej informacji, zobacz część 9.1.2 specyfikacja Common Language Infrastructure (CLI) dokumentacji dotyczącej, "partycja II: Definicja metadanych i semantyka". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) w witrynie Ecma International w sieci Web.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie klasy, dla którego <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> wartości wyliczenia w <xref:System.Runtime.InteropServices.StructLayoutAttribute> klasa została ustawiona, sprawdza, czy <xref:System.Type.IsLayoutSequential%2A> właściwości i wyświetla wynik.  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">Składniki samoopisujące się i metadane</related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest przekazywany przez odwołanie.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest organizowane przez odwołanie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, i <xref:System.Type.IsPrimitive%2A> właściwości <xref:System.Type> klasy. Sprawdza, czy dany typ może być hostowana w kontekście, czy mogą być przekazywane przez odwołanie i zezwolić na określony typ jest typem danych pierwotnych.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementuje <see cref="P:System.Type.IsMarshalByRef" /> właściwości i określa, czy <see cref="T:System.Type" /> jest przekazywany przez odwołanie.</summary>
        <returns><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest organizowane przez odwołanie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
   
  
## Examples  
 Poniższy przykład określa, czy dany typ jest przekazywany przez odwołanie, a następnie wyświetla wynik.  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy bieżący <see cref="T:System.Type" /> obiekt reprezentuje typ, którego definicja jest zagnieżdżona w definicji typu innego.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zagnieżdżone wewnątrz innego typu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsNested%2A> Właściwość zwraca `true` dla wszystkich zagnieżdżonych typów, niezależnie od tego, widoczność. Aby sprawdzić zagnieżdżanie i widoczność w tym samym czasie, należy użyć powiązane właściwości <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, lub <xref:System.Type.IsNestedPublic%2A>.  
  
> [!NOTE]
>  <xref:System.Reflection.TypeAttributes.VisibilityMask> Element członkowski wyliczenia wybiera atrybuty widoczności dla typu.  
  
   
  
## Examples  
 Poniższy przykład tworzy zewnętrznej klasy, wprowadzając szereg klas zagnieżdżonych, które mają różne rodzaje widoczności. Następnie pobiera wartość liczby związanych z widocznością <xref:System.Type> właściwości dla typu nadrzędnego, a każdy z jego typów zagnieżdżonych.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest zagnieżdżony i są widoczne tylko w ramach ich własnych zestawach.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zagnieżdżony i widoczne tylko w ramach ich własnych zestawach; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca zawsze `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wybiera atrybuty widoczności.  
  
   
  
## Examples  
 Poniższy przykład tworzy zewnętrznej klasy, wprowadzając szereg klas zagnieżdżonych, które mają różne rodzaje widoczności. Następnie pobiera wartość liczby związanych z widocznością <xref:System.Type> właściwości dla typu nadrzędnego, a każdy z jego typów zagnieżdżonych.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest zagnieżdżony i są widoczne tylko dla klas, które należą do jego własnej rodzinę i swój własny zestaw.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zagnieżdżony i widoczne tylko dla klas, które należą do jego własnej rodzinę i swój własny zestaw; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca zawsze `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wybiera atrybuty widoczności.  
  
> [!NOTE]
>  W językach C# i Visual Basic nie dołączaj semantykę, która zezwala na określanie typu zagnieżdżonego, która jest widoczna tylko dla typów chronionych w ich własnych zestawach. `protected internal` wgląd w języku C# i `Protected Friend` widoczność w języku Visual Basic określić typu zagnieżdżonego, który jest widoczny, chronione typy i typy w tym samym zestawie.  
  
 A <xref:System.Type> rodziny obiektu jest zdefiniowana jako wszystkich obiektów tego samego <xref:System.Type> i jego podtypów.  
  
   
  
## Examples  
 Poniższy przykład tworzy zewnętrznej klasy, wprowadzając szereg klas zagnieżdżonych, które mają różne rodzaje widoczności. Następnie pobiera wartość liczby związanych z widocznością <xref:System.Type> właściwości dla typu nadrzędnego, a każdy z jego typów zagnieżdżonych.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest zagnieżdżony i są widoczne tylko w obrębie własnej rodziny.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zagnieżdżony i widoczne tylko w obrębie własnej rodziny; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca zawsze `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wybiera atrybuty widoczności.  
  
 A <xref:System.Type> rodziny obiektu jest zdefiniowana jako wszystkich obiektów dokładnie tych samych <xref:System.Type> i jego podtypów.  
  
   
  
## Examples  
 Poniższy przykład tworzy zewnętrznej klasy, wprowadzając szereg klas zagnieżdżonych, które mają różne rodzaje widoczności. Następnie pobiera wartość liczby związanych z widocznością <xref:System.Type> właściwości dla typu nadrzędnego, a każdy z jego typów zagnieżdżonych.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest zagnieżdżony i są widoczne tylko dla klas, które należą do jednej swój własny rodziny i swój własny zestaw.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zagnieżdżony i widoczne tylko dla klas, które należą do jego własnej rodziny lub ich własnych zestawach; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku widoczności typu `protected internal` w języku C# lub `Protected Friend` w języku Visual Basic <xref:System.Type.IsNestedFamORAssem%2A> właściwość zwraca `true`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca zawsze `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wybiera atrybuty widoczności.  
  
 A <xref:System.Type> rodziny obiektu jest zdefiniowana jako wszystkich obiektów dokładnie tych samych <xref:System.Type> i jego podtypów.  
  
   
  
## Examples  
 Poniższy przykład tworzy zewnętrznej klasy, wprowadzając szereg klas zagnieżdżonych, które mają różne rodzaje widoczności. Następnie pobiera wartość liczby związanych z widocznością <xref:System.Type> właściwości dla typu nadrzędnego, a każdy z jego typów zagnieżdżonych.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest zagnieżdżony, a następnie deklarować prywatnych.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zagnieżdżony i zadeklarować prywatny; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca zawsze `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wybiera atrybuty widoczności.  
  
   
  
## Examples  
 Poniższy przykład tworzy zewnętrznej klasy, wprowadzając szereg klas zagnieżdżonych, które mają różne rodzaje widoczności. Następnie pobiera wartość liczby związanych z widocznością <xref:System.Type> właściwości dla typu nadrzędnego, a każdy z jego typów zagnieżdżonych.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy klasa jest zagnieżdżone i zadeklarowana publicznych.</summary>
        <value><see langword="true" /> Jeśli klasa jest publiczny zagnieżdżony i zadeklarowane; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca zawsze `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wybiera atrybuty widoczności.  
  
   
  
## Examples  
 Poniższy przykład tworzy zewnętrznej klasy, wprowadzając szereg klas zagnieżdżonych, które mają różne rodzaje widoczności. Następnie pobiera wartość liczby związanych z widocznością <xref:System.Type> właściwości dla typu nadrzędnego, a każdy z jego typów zagnieżdżonych.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> nie jest zadeklarowany jako publiczny.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> nie jest zadeklarowany jako publiczny i nie jest typem zagnieżdżonym; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy używać tej właściwości z typów zagnieżdżonych. Użyj <xref:System.Type.IsNestedPublic%2A> właściwości zamiast tego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca `false`.  
  
   
  
## Examples  
 Ten przykład usesthe `IsNotPublic` właściwości, aby uzyskać wgląd w tego typu.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 Poniższy przykład kodu pokazuje, dlaczego nie można użyć `IsPublic` i `IsNotPublic` dla klas zagnieżdżonych.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 Klasy zagnieżdżone, można zignorować w wynikach `IsPublic` i `IsNotPublic` i które należy zwrócić uwagę tylko wyniki `IsNestedPublic` i `IsNestedPrivate`. Dane wyjściowe odbicia dla fragmentu kodu będzie następujący:  
  
|Class|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|ELEMENT|FAŁSZ|WARTOŚĆ TRUE|FAŁSZ|FAŁSZ|  
|B|FAŁSZ|FAŁSZ|WARTOŚĆ TRUE|FAŁSZ|  
|C|FAŁSZ|FAŁSZ|FAŁSZ|WARTOŚĆ TRUE|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest wskaźnikiem.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest wskaźnikiem typu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny lub parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje wykorzystanie `IsPointer` właściwości.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, implementuje <see cref="P:System.Type.IsPointer" /> właściwości i określa, czy <see cref="T:System.Type" /> jest wskaźnikiem.</summary>
        <returns><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest wskaźnikiem typu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest jednym z typów pierwotnych.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest jednym z typów pierwotnych; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typy pierwotne są <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, i <xref:System.Single>.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny lub parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, i <xref:System.Type.IsPrimitive%2A> właściwości <xref:System.Type> klasy. Sprawdza, czy dany typ może być hostowana w kontekście, czy mogą być przekazywane przez odwołanie i zezwolić na określony typ jest typem danych pierwotnych.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, implementuje <see cref="P:System.Type.IsPrimitive" /> właściwości i określa, czy <see cref="T:System.Type" /> jest jednym z typów pierwotnych.</summary>
        <returns><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest jednym z typów pierwotnych; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typy pierwotne są <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, i <xref:System.Single>.  
  
   
  
## Examples  
 Poniższy przykład określa, czy dany typ jest typem pierwotnym i wyświetla wynik.  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest zadeklarowany jako publiczny.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zadeklarowany jako publiczny i nie jest typem zagnieżdżonym; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy używać z typów zagnieżdżonych. Użyj <xref:System.Type.IsNestedPublic%2A> zamiast tego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca `true`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wybiera atrybuty widoczności.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie `MyTestClass`, sprawdza, czy `IsPublic` właściwości i wyświetla wynik.  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 Klasy zagnieżdżone, można zignorować w wynikach `IsPublic` i `IsNotPublic` i które należy zwrócić uwagę tylko wyniki <xref:System.Type.IsNestedPublic%2A> i <xref:System.Type.IsNestedPrivate%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest zadeklarowany jako zapieczętowany.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zadeklarowany jako sealed; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca zawsze `true`.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie `sealed` klasy sprawdza, czy `IsSealed` właściwości i wyświetla wynik.  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący typ jest krytyczne dla bezpieczeństwa lub zabezpieczenia bezpieczny krytyczny na bieżącym poziomie zaufania i dlatego mogą wykonywać krytyczne operacje.</summary>
        <value><see langword="true" /> w przypadku bieżącego typu zabezpieczenia krytyczny lub zabezpieczenia bezpieczny krytyczny bieżącym poziomie zaufania. <see langword="false" /> , gdy jest za przezroczysty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, I <xref:System.Type.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości typu na jego bieżący poziom zaufania, zgodnie z ustaleniami środowisko uruchomieniowe języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Korzystanie z tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu i jego typów, sprawdzania bieżącego poziomu zaufania i próby zduplikowania reguł w środowisku uruchomieniowym.  
  
> [!IMPORTANT]
>  Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu. Jeżeli zestaw jest ładowany do domeny aplikacji częściowo zaufanej (na przykład w domenie aplikacji w trybie piaskownicy), środowisko wykonawcze ignoruje adnotacje zabezpieczeń zestawu. Zestaw i wszystkie jego typy są traktowane jako przezroczyste. Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu). Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany. Aktualne poziomy zaufania zestawów i domen aplikacji można określić za pomocą <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> i <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości.  
  
 Aby uzyskać więcej informacji dotyczących odbicia i przejrzystości, zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Aby uzyskać informacje o przezroczystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Zagadnienia dotyczące zabezpieczeń dla odbicia</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Zmiany zabezpieczeń w programie .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która wskazuje, czy bieżący typ zabezpieczenia bezpieczny krytyczny bieżącym poziomie zaufania. oznacza to, czy go może wykonywać krytyczne operacje i może zostać oceniony przez kod przezroczysty.</summary>
        <value><see langword="true" /> w przypadku bieżącego typu zabezpieczenia bezpieczny krytyczny bieżącym poziomie zaufania. <see langword="false" /> przypadku krytyczne dla bezpieczeństwa lub przezroczyste.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, I <xref:System.Type.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości typu na jego bieżący poziom zaufania, zgodnie z ustaleniami środowisko uruchomieniowe języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Korzystanie z tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu i jego typów, sprawdzania bieżącego poziomu zaufania i próby zduplikowania reguł w środowisku uruchomieniowym.  
  
> [!IMPORTANT]
>  Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu. Jeżeli zestaw jest ładowany do domeny aplikacji częściowo zaufanej (na przykład w domenie aplikacji w trybie piaskownicy), środowisko wykonawcze ignoruje adnotacje zabezpieczeń zestawu. Zestaw i wszystkie jego typy są traktowane jako przezroczyste. Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu). Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany. Aktualne poziomy zaufania zestawów i domen aplikacji można określić za pomocą <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> i <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości.  
  
 Aby uzyskać więcej informacji dotyczących odbicia i przejrzystości, zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Aby uzyskać informacje o przezroczystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Zagadnienia dotyczące zabezpieczeń dla odbicia</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Zmiany zabezpieczeń w programie .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący typ jest niewidoczne na bieżącym poziomie zaufania i dlatego nie można wykonać operacji krytycznych.</summary>
        <value><see langword="true" /> Jeśli typ jest przezroczyste dla zabezpieczeń na bieżącym poziomie zaufania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość zwraca `true`, <xref:System.Type.IsSecurityCritical%2A> i <xref:System.Type.IsSecuritySafeCritical%2A> return właściwości `false`.  
  
 <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, I <xref:System.Type.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości typu na jego bieżący poziom zaufania, zgodnie z ustaleniami środowisko uruchomieniowe języka wspólnego (CLR). Korzystanie z tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu i jego typów, sprawdzania bieżącego poziomu zaufania i próby zduplikowania reguł w środowisku uruchomieniowym.  
  
> [!IMPORTANT]
>  Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu. Jeżeli zestaw jest ładowany do domeny aplikacji częściowo zaufanej (na przykład w domenie aplikacji w trybie piaskownicy), środowisko wykonawcze ignoruje adnotacje zabezpieczeń zestawu. Zestaw i wszystkie jego typy są traktowane jako przezroczyste. Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu). Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany. Aktualne poziomy zaufania zestawów i domen aplikacji można określić za pomocą <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> i <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości.  
  
 Aby uzyskać więcej informacji dotyczących odbicia i przejrzystości, zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Aby uzyskać informacje o przezroczystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Zagadnienia dotyczące zabezpieczeń dla odbicia</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Zmiany zabezpieczeń w programie .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest możliwy do serializacji.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest możliwy do serializacji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Typy, które są zdefiniowane w programie .NET Standard nie są oznaczone <xref:System.SerializableAttribute>. Zamiast tego każda implementacja .NET określa, czy typ jest możliwy do serializacji. W czasie wykonywania, można użyć <xref:System.Type.IsSerializable%2A> właściwości w celu określenia, czy tę implementację obsługuje serializacji wystąpienia tego typu. Aby uzyskać więcej informacji i obejrzeć przykład, zobacz [sposobu ustalenia, czy obiekt standardowy .NET jest możliwy do serializacji](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie `MyTestClass` klasy, ustawia atrybut [Serializable] i sprawdza `IsSerializable` właściwość `true` lub `false`.  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy typ ma nazwę, która wymaga specjalnej obsługi.</summary>
        <value><see langword="true" /> Jeśli typ ma nazwę, która wymaga specjalnej obsługi; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwy, które zaczynają się od lub zawierać znaku podkreślenia (_), metod dostępu do właściwości i metod przeciążenia operatora to przykłady typów, które mogą wymagać specjalnego traktowania przez niektóre kompilatory.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Typ do porównania z bieżącym typem.</param>
        <summary>Określa, czy bieżący <see cref="T:System.Type" /> pochodzi z określonego <see cref="T:System.Type" />.</summary>
        <returns><see langword="true" /> Jeśli bieżący <see langword="Type" /> pochodzi od klasy <paramref name="c" />; w przeciwnym razie <see langword="false" />. Ta metoda zwraca też wartość <see langword="false" /> Jeśli <paramref name="c" /> i bieżący <see langword="Type" /> są takie same.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz wywołać <xref:System.Type.IsSubclassOf%2A> metodę, aby określić jedną z następujących czynności:  
  
-   Czy jedna klasa pochodzi z innego.  
  
-   Czy typ pochodzi od klasy <xref:System.ValueType>. Jednak <xref:System.Type.IsValueType%2A> jest bardziej efektywne sposobem ustalenia, czy typ jest typem wartości.  
  
-   Czy typ pochodzi od klasy <xref:System.Enum>. Jednak <xref:System.Type.IsEnum%2A> metoda jest bardziej efektywne sposobem ustalenia, czy typ jest wyliczeniem.  
  
-   Czy typ jest delegatem, oznacza to, czy wywodzi się z poziomu <xref:System.Delegate> lub <xref:System.MulticastDelegate>.  
  
 <xref:System.Type.IsSubclassOf%2A> Metoda nie może służyć do określenia, czy interfejs pochodzi z innego interfejsu lub tego, czy klasa implementuje interfejs. Użyj <xref:System.Type.IsAssignableFrom%2A> metody, w tym celu, co ilustruje poniższy przykład.  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, pochodzi z jej ograniczenia klasy lub <xref:System.Object?displayProperty=nameWithType> Jeśli go nie ma ograniczenia klasy.  
  
> [!NOTE]
>  Z wyjątkiem w przypadku korzystania z interfejsów, <xref:System.Type.IsSubclassOf%2A> jest przeciwny z <xref:System.Type.IsAssignableFrom%2A>. Oznacza to jeśli `t1.IsSubclassOf(t2)` jest `true`, następnie `t2.IsAssignableFrom(t1)` jest również `true`.  
  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę o nazwie `Class1` i Klasa pochodna o nazwie `DerivedC1`. Wywołuje <xref:System.Type.IsSubclassOf%2A> metodę, aby pokazać, że `DerivedC1` jest podklasą `Class1`.  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" /> jest <see langword="null" />.</exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy ciąg formatu atrybut <see langword="UnicodeClass" /> wybrano <see cref="T:System.Type" />.</summary>
        <value><see langword="true" /> Jeśli ciąg formatu atrybut <see langword="UnicodeClass" /> wybrano <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> Służy do wybierania atrybuty format ciągu. Atrybuty formatu ciągu ulepszenia współdziałania, definiując, jak interpretować ciągów.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest typem wartości.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest typem wartości; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typy wartości są typy, które są reprezentowane jako sekwencje bitów; typy wartości nie są klas lub interfejsów. Typy wartości są określane jako "struktur" w niektórych językach programowania. Typy wyliczeniowe są w wyjątkowym przypadku okna typów wartości.  
  
 Ta właściwość zwraca `false` dla <xref:System.ValueType> klasy, ponieważ <xref:System.ValueType> nie jest typem wartości, sam. Jest klasą bazową dla wszystkich typów wartości, a w związku z tym dowolny typ wartości można przypisać do niej. To nie jest możliwe Jeśli <xref:System.ValueType> sam był typem wartości. Typy wartości jest ramce, gdy są one przypisane do pola typu <xref:System.ValueType>.  
  
 Ta właściwość zwraca `true` wyliczenia, ale nie <xref:System.Enum> samego typu. Aby uzyskać przykład demonstrujący ten problem, zobacz <xref:System.Type.IsEnum%2A>.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład tworzy zmienną typu `MyEnum`, sprawdza, czy `IsValueType` właściwości i wyświetla wynik.  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementuje <see cref="P:System.Type.IsValueType" /> właściwości i określa, czy <see cref="T:System.Type" /> typu wartości; oznacza to, że nie jest klasą lub interfejs.</summary>
        <returns><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest typem wartości; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostarczana, aby umożliwić implementowania systemów alternatywnego typu. Ogólnie nieużywanych w kodzie aplikacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> może zostać oceniony przez kod poza zestawem.</summary>
        <value><see langword="true" /> Jeśli bieżący <see cref="T:System.Type" /> jest typ publiczny lub publiczny zagnieżdżony typ taki sposób, że wszystkie typy otaczającej są publiczne; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby ustalić, czy typ jest częścią interfejsu publicznego zestaw składników, należy użyć tej właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu sprawdza dwie klasy, tylko jeden z nich jest widoczna spoza zestawu.  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca <see cref="T:System.Type" /> obiekt, który reprezentuje tablicę bieżącego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Type" /> obiektów reprezentująca tablicę jednowymiarową bieżącego typu z dolną granicę równą zero.</summary>
        <returns>A <see cref="T:System.Type" /> obiektów reprezentująca tablicę jednowymiarową bieżącego typu z dolną granicę równą zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A> Metoda zapewnia sposób wygenerować typy tablic z typów elementów, których są obliczane w czasie wykonywania.  
  
 **Uwaga** środowiska uruchomieniowego języka wspólnego rozróżnia wektorów (oznacza to, że tablice jednowymiarowe, które są zawsze liczony od zera) i tablic wielowymiarowych. Wektor, który zawsze ma tylko jeden wymiar, nie jest taka sama jak tablicy wielowymiarowej, który ma miejsce tylko jeden wymiar. Tego przeciążenia metody należy używać tylko do utworzenia typy wektorów i jest jedynym sposobem, aby utworzyć typ wektora. Użyj <xref:System.Type.MakeArrayType%28System.Int32%29> przeciążenia metody, aby utworzyć typy tablic wielowymiarowych.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tablicę, `ref` (`ByRef` w języku Visual Basic) oraz typy wskaźników dla `Test` klasy.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej. Klasy pochodne muszą zapewniać implementację.</exception>
        <exception cref="T:System.TypeLoadException">Bieżącym typem jest <see cref="T:System.TypedReference" />.  
  
—lub— 
Bieżącym typem jest <see langword="ByRef" /> typu. Oznacza to, że <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">Liczba wymiarów tablicy. Ta liczba musi być mniejsza lub równa 32.</param>
        <summary>Zwraca <see cref="T:System.Type" /> obiekt reprezentujący bieżącego typu, o określoną liczbę wymiarów tablicy.</summary>
        <returns>Obiekt reprezentujący bieżącego typu, o określoną liczbę wymiarów tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A> Metoda zapewnia sposób wygenerować typy tablic z typów elementów, których są obliczane w czasie wykonywania.  
  
> [!NOTE]
>  Środowisko uruchomieniowe języka wspólnego rozróżnia wektorów (oznacza to, że tablice jednowymiarowe, które są zawsze liczony od zera) i tablic wielowymiarowych. Wektor, który zawsze ma tylko jeden wymiar, nie jest taka sama jak tablicy wielowymiarowej, który ma miejsce tylko jeden wymiar. Nie można użyć tego przeciążenia metody, aby utworzyć typ wektora; Jeśli `rank` wynosi 1, tego przeciążenia metody zwraca typ tablicy wielowymiarowej, która ma jeden wymiar. Użyj <xref:System.Type.MakeArrayType> przeciążenia metody, aby utworzyć typy wektorów.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tablicę, `ref` (`ByRef` w języku Visual Basic) oraz typy wskaźników dla `Test` klasy.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="rank" /> jest nieprawidłowy. Na przykład 0 ani ujemna.</exception>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</exception>
        <exception cref="T:System.TypeLoadException">Bieżącym typem jest <see cref="T:System.TypedReference" />.  
  
—lub— 
Bieżącym typem jest <see langword="ByRef" /> typu. Oznacza to, że <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.  
  
—lub— 
 <paramref name="rank" /> jest większe niż 32.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Type" /> obiekt, który reprezentuje bieżący typ, gdy dane są przekazywane jako <see langword="ref" /> parametru (<see langword="ByRef" /> parametru w języku Visual Basic).</summary>
        <returns>A <see cref="T:System.Type" /> obiekt, który reprezentuje bieżący typ, gdy dane są przekazywane jako <see langword="ref" /> parametru (<see langword="ByRef" /> parametru w języku Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeByRefType%2A> Metoda zapewnia sposób generowania `ref` typów (`ByRef` w języku Visual Basic) dla parametru listy.  
  
 Przy użyciu składni języka Microsoft intermediate language (MSIL), jeśli bieżący <xref:System.Type> obiekt reprezentuje <xref:System.Int32>, Metoda ta zwraca <xref:System.Type> obiekt reprezentujący `Int32&`.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tablicę, `ref` (`ByRef` w języku Visual Basic) oraz typy wskaźników dla `Test` klasy.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</exception>
        <exception cref="T:System.TypeLoadException">Bieżącym typem jest <see cref="T:System.TypedReference" />.  
  
—lub— 
Bieżącym typem jest <see langword="ByRef" /> typu. Oznacza to, że <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Tablica typów do podstawienia dla parametrów typu bieżącego typu ogólnego.</param>
        <summary>Zastępuje elementy tablicy, rodzajów bieżącej definicji typu ogólnego dla parametrów typu i zwraca <see cref="T:System.Type" /> obiekt reprezentujący wynikowy tworzony typu.</summary>
        <returns>A <see cref="T:System.Type" /> reprezentuje zbudowany typ sformułowany, zastępując elementy <paramref name="typeArguments" /> dla parametrów typu bieżącego typu ogólnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeGenericType%2A> Metoda umożliwia pisanie kodu, który przypisuje określone typy parametrów typu w definicji typu ogólnego, co powoduje utworzenie <xref:System.Type> obiekt, który reprezentuje zbudowany określonego typu. Możesz użyć tej funkcji <xref:System.Type> obiektu do utworzenia wystąpienia środowiska wykonawczego skonstruowanego typu.  
  
 Typy są konstruowane przy użyciu <xref:System.Type.MakeGenericType%2A> może być otwarty, oznacza to, że niektóre z ich argumentami typu może być otaczającej metody rodzajowe i typy parametrów typu. Można na przykład takie Otwórz typy utworzone podczas emitowanie dynamicznych zestawów. Rozważmy na przykład klasy `Base` i `Derived` w poniższym kodzie.  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 Aby wygenerować `Derived` w zestawie dynamicznym, należy go utworzyć jego typ podstawowy. Aby to zrobić, należy wywołać <xref:System.Type.MakeGenericType%2A> metody <xref:System.Type> obiekt reprezentujący klasę `Base`, za pomocą argumentów typu rodzajowego <xref:System.Int32> i parametr typu `V` z `Derived`. Ponieważ typy i parametry typu ogólnego są reprezentowane przez <xref:System.Type> obiektów, oba te elementy tablicy mogą być przekazywane do <xref:System.Type.MakeGenericType%2A> metody.  
  
> [!NOTE]
>  Skonstruowany typ takich jak `Base<int, V>` jest przydatne w przypadku gdy emitowanie kodu, ale nie można wywołać <xref:System.Type.MakeGenericType%2A> metody dla tego typu, ponieważ nie jest definicja typu ogólnego. Aby utworzyć zamknięte skonstruowanego typu, który może być utworzone, należy najpierw wywołać <xref:System.Type.GetGenericTypeDefinition%2A> metodę, aby uzyskać <xref:System.Type> obiekt reprezentujący definicji typu ogólnego, a następnie wywołać <xref:System.Type.MakeGenericType%2A> z argumentami odpowiedniego typu.  
  
 <xref:System.Type> Obiektu zwróconego przez <xref:System.Type.MakeGenericType%2A> jest taka sama jak <xref:System.Type> można uzyskać przez wywołanie <xref:System.Object.GetType%2A> metody wynikowy tworzony typ, lub <xref:System.Object.GetType%2A> metoda dowolnego skonstruowany typ, który został utworzony z tej samej ogólny Definicja typu przy użyciu tych samych argumentów typu.  
  
> [!NOTE]
>  Tablica typów ogólnych sam nie jest typem ogólnym. Nie można wywołać <xref:System.Type.MakeGenericType%2A> na tablicy wpisz na przykład `C<T>[]` (`Dim ac() As C(Of T)` w języku Visual Basic). Do konstruowania zamknięty typ ogólny z `C<T>[]`, wywołaj <xref:System.Type.GetElementType%2A> uzyskać definicji typu ogólnego `C<T>`; wywołania <xref:System.Type.MakeGenericType%2A> w definicji typu ogólnego do utworzenia skonstruowanego typu; i na koniec wywołania <xref:System.Type.MakeArrayType%2A> metody skonstruowany typ do utworzenia typu tablicy. To samo dotyczy typów wskaźnika i `ref` typów (`ByRef` w języku Visual Basic).  
  
 Aby uzyskać listę niezmiennych warunków dla terminów używanych w odbiciu rodzajowym, zobacz <xref:System.Type.IsGenericType%2A> uwagi dotyczące właściwości.  
  
## <a name="nested-types"></a>Zagnieżdżone typy  
 Jeśli nie zdefiniowano typu ogólnego przy użyciu języka C#, C++ lub Visual Basic, jego zagnieżdżone typy są rodzajowe. Ta zasada obowiązuje, nawet jeśli typy zagnieżdżone nie może mieć typu parametrów we własnym zakresie, ponieważ wszystkie trzy języki obejmują parametry typu otaczającej typów w liście parametrów typu w przypadku zagnieżdżonych typów. Należy wziąć pod uwagę następujące klasy:  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 Lista parametrów typu klasy zagnieżdżonej `Inner` ma dwa parametry typu `T` i `U`, pierwszy z nich jest parametr typu klasy otaczającej. Podobnie, lista parametrów typu klasy zagnieżdżonej `Innermost1` ma trzy parametry typu, `T`, `U`, i `V`, za pomocą `T` i `U` pochodzące z jej otaczającej klasy. Klasa zagnieżdżona `Innermost2` ma dwa parametry typu `T` i `U`, które pochodzą z jej otaczającej klasy.  
  
 Jeśli lista parametrów typu otaczającego ma więcej niż jeden parametr typu, wszystkie parametry typu w kolejności zostaną uwzględnione na liście parametrów typu typu zagnieżdżonego.  
  
 Aby skonstruować typu ogólnego z definicji typu ogólnego dla typu zagnieżdżonego, należy wywołać <xref:System.Type.MakeGenericType%2A> metody za pomocą tablicy utworzone przez złączenie tablicami argument typu wszystkich otaczający typów, począwszy od najbardziej zewnętrznego typu ogólnego, i kończącą Wpisz tablica argumentów typu zagnieżdżonego, ma parametry typu swój własny. Aby utworzyć wystąpienie `Innermost1`, wywołania <xref:System.Type.MakeGenericType%2A> metody z tablicę zawierającą trzy typy ma być przypisane do T, U i V. Aby utworzyć wystąpienie `Innermost2`, wywołanie <xref:System.Type.MakeGenericType%2A> metody z tablicę zawierającą dwa typy ma być przypisane do T i U.  
  
 Języki propagować parametrów typu w otaczającej typów w ten sposób, aby można było używać parametrów typu otaczającego typu do zdefiniowania pola zagnieżdżonych typów. W przeciwnym razie parametrów typu nie jest w zakresie, w ramach organów zagnieżdżone typy. Można zdefiniować typy zagnieżdżone bez propagowanie parametrów typu w otaczającej typów, emitowanie kodu w zestawach dynamicznych lub używając [Ilasm.exe (asembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md). Należy wziąć pod uwagę następujący kod MSIL assembler:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 W tym przykładzie nie jest możliwe zdefiniowanie pola typu `T` lub `U` w klasie `Innermost`, ponieważ te parametry typu nie są w zakresie. W poniższym kodzie asemblera zdefiniowano klasy zagnieżdżone, które zachowują się sposób, w jaki gdyby zdefiniowany w języku C++, Visual Basic i C#:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 Możesz użyć [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do zbadania zagnieżdżonych klas zdefiniowanych w językach wysokiego poziomu i sprawdź, czy ten schemat nazewnictwa.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Type.MakeGenericType%2A> metodę w celu utworzenia skonstruowanego typu w definicji typu ogólnego dla <xref:System.Collections.Generic.Dictionary%602> typu. Reprezentuje zbudowany typ <xref:System.Collections.Generic.Dictionary%602> z `Test` obiektów za pomocą kluczy ciągu.  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący typ nie reprezentuje definicji typu ogólnego. Oznacza to, że <see cref="P:System.Type.IsGenericTypeDefinition" /> zwraca <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeArguments" /> jest <see langword="null" />.  
  
—lub— 
Każdy z elementów <paramref name="typeArguments" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w <paramref name="typeArguments" /> nie jest taka sama jak liczba parametrów typu w bieżącej definicji typu ogólnego.  
  
—lub— 
Każdy z elementów <paramref name="typeArguments" /> nie spełnia warunków ograniczenia określone dla odpowiedniego parametru typu bieżącego typu ogólnego.  
  
—lub— 
 <paramref name="typeArguments" /> zawiera element, który jest typem wskaźnika (<see cref="P:System.Type.IsPointer" /> zwraca <see langword="true" />), typ przez odwołanie (<see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />), lub <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej. Klasy pochodne muszą zapewniać implementację.</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Type" /> obiekt, który reprezentuje wskaźnik do bieżącego typu.</summary>
        <returns>A <see cref="T:System.Type" /> obiekt, który reprezentuje wskaźnik do bieżącego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakePointerType%2A> Metoda zapewnia sposób generowania typów wskaźnika do listy parametrów.  
  
 Przy użyciu składni języka Microsoft intermediate language (MSIL), jeśli bieżący <xref:System.Type> obiekt reprezentuje <xref:System.Int32>, Metoda ta zwraca <xref:System.Type> obiekt reprezentujący `Int32*`.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tablicę, `ref` (`ByRef` w języku Visual Basic) oraz typy wskaźników dla `Test` klasy.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</exception>
        <exception cref="T:System.TypeLoadException">Bieżącym typem jest <see cref="T:System.TypedReference" />.  
  
—lub— 
Bieżącym typem jest <see langword="ByRef" /> typu. Oznacza to, że <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Reflection.MemberTypes" /> wartość wskazującą, czy ten element członkowski jest typem lub typu zagnieżdżonego.</summary>
        <value>A <see cref="T:System.Reflection.MemberTypes" /> wartość wskazującą, czy ten element członkowski jest typem lub typu zagnieżdżonego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zastępuje <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>. Dlatego podczas badania zbiór <xref:System.Reflection.MemberInfo> obiektów — na przykład tablica zwrócona przez <xref:System.Type.GetMembers%2A> — <xref:System.Reflection.MemberInfo.MemberType%2A> właściwość zwraca <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> kiedy dany element jest typu zagnieżdżonego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład `MemberType` pola jako parametr do `GetMember` metody:  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje wartość Brak w <see cref="T:System.Type" /> informacji. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `Missing` pola do wywoływania przez odbicie, aby uzyskać wartość domyślna parametru. Jeśli `Missing` pola są przekazywane do wartości parametru i nie ma wartości domyślnej dla tego parametru <xref:System.ArgumentException> zgłaszany.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie `Missing` pola, które można wywołać metody z jej argumentów domyślnych.  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 Ten kod generuje następujące dane wyjściowe:  
  
 = 10, b = 55.3 c = 12  
  
 = 10, b = 1,3 c = 1  
  
 = 10, b = 1.2 c = 1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł (DLL), w którym bieżącego <see cref="T:System.Type" /> jest zdefiniowana.</summary>
        <value>Moduł, w którym bieżącego <see cref="T:System.Type" /> jest zdefiniowana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta zwraca modułu, w którym zdefiniowano definicji typu ogólnego. Na przykład, jeśli utworzysz wystąpienie `MyGenericStack<int>`, <xref:System.Type.Module%2A> właściwość skonstruowanego typu zwraca modułu, w którym `MyGenericStack<T>` jest zdefiniowana.  
  
 Podobnie jeśli bieżący <xref:System.Type> reprezentuje parametr ogólny `T`, właściwość ta zwraca zestaw, który zawiera typ ogólny, który definiuje `T`.  
  
   
  
## Examples  
 Ten poniższy przykład demonstruje użycie <xref:System.Type.Namespace%2A> i `Module` właściwości i <xref:System.Type.ToString%2A> metody <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera nazwę bieżącego typu.</summary>
        <value>Nazwa bieżącego typu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obszar nazw <see cref="T:System.Type" />.</summary>
        <value>Przestrzeń nazw <see cref="T:System.Type" />; <see langword="null" /> czy bieżące wystąpienie nie ma obszaru nazw reprezentuje parametr ogólny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przestrzeń nazw jest logiczną projektowania nazewnictwa wygody używane głównie do zdefiniowania zakresu w aplikacji i organizowanie klasami i innymi typami w strukturze hierarchicznej jednego. Z punktu widzenia środowiska uruchomieniowego nie ma żadnych obszarów nazw.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny skonstruowany, właściwość ta zwraca przestrzeni nazw, który zawiera definicję typu ogólnego. Podobnie jeśli bieżący <xref:System.Type> reprezentuje parametr ogólny `T`, właściwość ta zwraca przestrzeni nazw, który zawiera definicję typu ogólnego, który definiuje `T`.  
  
 Jeśli bieżący <xref:System.Type> obiekt reprezentuje parametr ogólny, właściwość ta zwraca `null`.  
  
   
  
## Examples  
 Ten poniższy przykład demonstruje użycie `Namespace` i <xref:System.Type.Module%2A> właściwości i <xref:System.Type.ToString%2A> metody <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Określanie w pełni kwalifikowanych nazw typów</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="right">Drugi obiekt, który będzie porównywany.</param>
        <summary>Wskazuje, czy dwa <see cref="T:System.Type" /> obiekty są sobie równe.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="left" /> jest równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="right">Drugi obiekt, który będzie porównywany.</param>
        <summary>Wskazuje, czy dwa <see cref="T:System.Type" /> obiekty nie są równe.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="left" /> nie jest równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt klasy, który został użyty do uzyskania tego elementu członkowskiego.</summary>
        <value><see langword="Type" /> Obiektu za pomocą którego należy to <see cref="T:System.Type" /> obiekt został uzyskany.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać <xref:System.Type> obiektów, wartość tej właściwości jest zawsze taka sama jak wartość <xref:System.Type.DeclaringType%2A> właściwości.  
  
   
  
## Examples  
 W tym przykładzie jest wyświetlany odbitych typ klasy zagnieżdżonej.  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa kwalifikowanego dla zestawu <see cref="T:System.Type" /> można pobrać.</param>
        <param name="throwIfNotFound"><see langword="true" /> Aby zgłosić <see cref="T:System.TypeLoadException" /> Jeśli nie można odnaleźć typu; <see langword="false" /> do zwrócenia <see langword="null" /> Jeśli nie można odnaleźć typu. Określanie <see langword="false" /> powoduje również pominięcie niektórych warunków wyjątków, ale nie wszystkie z nich. Zobacz sekcję Wyjątki.</param>
        <param name="ignoreCase"><see langword="true" /> Aby wykonać wyszukiwanie bez uwzględniania wielkości liter dla <paramref name="typeName" />; <see langword="false" /> przeprowadzić wyszukiwanie dla <paramref name="typeName" />.</param>
        <summary>Pobiera <see cref="T:System.Type" /> o określonej nazwie określenie, czy przeprowadzić wyszukiwanie i czy chcesz zgłosić wyjątek, jeśli typ nie zostanie znaleziony. Typ jest ładowany w celu odbicia, nie do wykonania.</summary>
        <returns>Typ o określonej nazwie, jeśli znaleziono; w przeciwnym razie <see langword="null" />. Jeśli typ nie zostanie znaleziony, <paramref name="throwIfNotFound" /> parametr określa, czy <see langword="null" /> zwracany jest lub zostanie zgłoszony wyjątek. W niektórych przypadkach występuje wyjątek niezależnie od wartości <paramref name="throwIfNotFound" />. Zobacz sekcję Wyjątki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zestawu zawierającego typ nie jest już załadowane do kontekstu reflection-only, za pomocą <xref:System.Type.ReflectionOnlyGetType%2A> metodą jest odpowiednikiem pierwszego ładowania zestawu w celu odbicia tylko przy użyciu <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> metody, a następnie ładowania typu przez wywołanie metody zestawu <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> metody. Aby uzyskać informacji na temat nazw kwalifikowanych dla zestawu, zobacz <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> właściwości. Aby uzyskać więcej informacji na temat określania nazwy typów, zobacz <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenie metody.  
  
 Jeśli zestaw jest już załadowany w celu wykonywania, kolejną kopię są ładowane do kontekstu reflection-only.  
  
 `throwIfNotFound` Parametr określa, co się stanie, gdy typ nie zostanie znaleziony i powoduje również pominięcie niektórych warunków wyjątków, zgodnie z opisem w sekcji wyjątki. Niektóre wyjątki są zgłaszane niezależnie od wartości `throwIfNotFound`. Na przykład, jeśli zestaw nie jest prawidłowy <xref:System.BadImageFormatException> jest zgłaszany nawet wtedy, gdy `throwIfNotFound` jest `false`.  
  
 Aby uzyskać więcej informacji o korzystaniu z kontekstu reflection-only, zobacz [jak: Ładowanie zestawów do kontekstu Reflection-Only](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwIfNotFound" /> jest <see langword="true" /> i nie można odnaleźć typu.  
  
—lub— 
 <paramref name="throwIfNotFound" /> jest <see langword="true" /> i <paramref name="typeName" /> zawiera nieprawidłowe znaki, takie jak osadzona karta. 
—lub— 
 <paramref name="throwIfNotFound" /> jest <see langword="true" /> i <paramref name="typeName" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="throwIfNotFound" /> jest <see langword="true" /> i <paramref name="typeName" /> reprezentuje typ tablicy z nieprawidłowym rozmiarem.  
  
—lub— 
 <paramref name="typeName" /> reprezentuje tablicę <see cref="T:System.TypedReference" /> obiektów.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> nie ma nazwy zestawu.  
  
—lub— 
 <paramref name="throwIfNotFound" /> jest <see langword="true" /> i <paramref name="typeName" /> ma nieprawidłową składnię, na przykład "MyType [, *,]".  
  
—lub— 
 <paramref name="typeName" /> reprezentuje typ ogólny, który jest typem wskaźnika <see langword="ByRef" /> typu, lub <see cref="T:System.Void" /> jako jeden z argumentów typu.  
  
—lub— 
 <paramref name="typeName" /> reprezentuje typ ogólny, który ma niepoprawną liczbę argumentów typu.  
  
—lub— 
 <paramref name="typeName" /> reprezentuje typ ogólny i jeden z argumentów typu nie spełniają ograniczeń dla odpowiedniego parametru typu.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwIfNotFound" /> jest <see langword="true" /> i nie znaleziono zestawu lub jednej z jego zależności.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.  
  
—lub— 
Zestaw został skompilowany przy użyciu nowszej wersji aparatu plików wykonywalnych języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Określanie w pełni kwalifikowanych nazw typów</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md">Instrukcje: Ładowanie zestawów do kontekstu Reflection-Only</related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> układ bieżącego typu, który opisuje.</summary>
        <value>Pobiera <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> , który opisuje funkcje brutto układ bieżącego typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute> nie jest zwracana przez <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metody. Zamiast tego należy używać tej właściwości, aby z niej skorzystać.  
  
   
  
## Examples  
 Poniższy przykładowy kod najpierw definiuje klasy, struktury i struktury z atrybutami specjalnego układu (struktur są zagnieżdżone w obrębie klasy). Następnie w przykładzie <xref:System.Type.StructLayoutAttribute%2A> właściwości w celu uzyskania <xref:System.Runtime.InteropServices.StructLayoutAttribute> dla każdego typu i wyświetla właściwości atrybutów.  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="rgszNames">Przekazana tablica nazw ma być mapowana.</param>
        <param name="cNames">Liczba nazw, które mają być mapowane.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</param>
        <param name="rgDispId">Tablica przydzielana przez obiekt wywołujący, który otrzymuje numery identyfikacyjne odpowiadających nazw.</param>
        <summary>Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetIDsOfNames`, zobacz: Biblioteka MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informacje o typie, który będzie zwracany.</param>
        <param name="lcid">Identyfikator regionalny dla informacji o typie.</param>
        <param name="ppTInfo">Wskaźnik do obiektu informacji żądanego typu.</param>
        <summary>Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfo`, zobacz: Biblioteka MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Wskazuje lokalizację, która odbiera informację o liczbie typów dostarczanych przez obiekt.</param>
        <summary>Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfoCount`, zobacz: Biblioteka MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Określa element członkowski.</param>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</param>
        <param name="wFlags">Flagi opisujące kontekst wywołania.</param>
        <param name="pDispParams">Wskaźnik do struktury zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</param>
        <param name="pVarResult">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</param>
        <param name="pExcepInfo">Wskaźnik do struktury, która zawiera informacje o wyjątku.</param>
        <param name="puArgErr">Indeks pierwszego argumentu, który zawiera błąd.</param>
        <summary>Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::Invoke`, zobacz: Biblioteka MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see langword="String" /> reprezentujący nazwę bieżącego <see langword="Type" />.</summary>
        <returns>A <see cref="T:System.String" /> reprezentujący nazwę bieżącego <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca w pełni kwalifikowaną wspólnego języka środowiska uruchomieniowego przestrzeni nazw i nazwę dla wszystkich pierwotnych typów. Na przykład C# instrukcja, `(long)0.Type().ToString()` zwraca "System.Int64", a nie tylko "Int64".  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny, typ i argumentów typu są kwalifikowane według przestrzeni nazw i typ zagnieżdżony, ale nie przez zestaw. Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta zwraca niekwalifikowana nazwa parametru typu.  
  
   
  
## Examples  
 Ten poniższy przykład demonstruje użycie <xref:System.Type.Namespace%2A> i <xref:System.Type.Module%2A> właściwości i `ToString` metody <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 W poniższym przykładzie porównano ciągów zwracanych przez <xref:System.Type.ToString%2A> metody i `Name`, <xref:System.Type.FullName%2A>, i <xref:System.Type.AssemblyQualifiedName%2A> właściwości.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt dla bieżącego <see cref="T:System.Type" />.</summary>
        <value>Dojście do bieżącego <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle` hermetyzuje wskaźnik do struktury danych wewnętrznych, który reprezentuje typ. Tego dojścia jest unikatowa w okresie istnienia procesu. Uchwyt jest prawidłowy tylko w domenie aplikacji, w której zostały pobrane.  
  
   
  
## Examples  
 Poniższy przykład zwraca uchwyt danego typu i przechodzi uchwyt do metody, która pobiera typ dojścia i wyświetla go.  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework nie obsługuje obecnie tej właściwości.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera inicjator dla typu.</summary>
        <value>Obiekt, który zawiera nazwę Konstruktor klasy <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inicjatory klasy są również dostępne za pośrednictwem <xref:System.Type.FindMembers%2A> metodę, lub za pomocą przeciążenia <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, i <xref:System.Type.GetConstructors%2A> metod, które przyjmują <xref:System.Reflection.BindingFlags> jako parametr.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje typ dostarczane przez środowisko uruchomieniowe języka wspólnego reprezentujący tego typu.</summary>
        <value>Podstawowy typ systemu <see cref="T:System.Type" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>
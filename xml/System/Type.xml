<Type Name="Type" FullName="System.Type">
  <Metadata><Meta Name="ms.openlocfilehash" Value="95546fa79ae08611355fed8ec3d0e50effda67f2" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="59017632" /></Metadata><TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="9cc50-101">Reprezentuje typ deklaracji: klasy, typy, typy interfejsów, typy tablicowe, typy wartości, Typy wyliczeniowe, parametry typu, definicji typu ogólnego i otwarte lub zamknięte typy rodzajowe utworzone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-101">Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-102">`Type` jest katalogiem głównym <xref:System.Reflection> funkcji i jest to podstawowy sposób dostępu do metadanych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-102">`Type` is the root of the <xref:System.Reflection> functionality and is the primary way to access metadata.</span></span> <span data-ttu-id="9cc50-103">Użyj elementów członkowskich <xref:System.Type> Aby uzyskać informacje na temat deklaracji typu, na temat elementów członkowskich typu (na przykład konstruktorów, metody, pola, właściwości i zdarzenia w klasie), a także moduł i zestawu, w której jest wdrażany klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-103">Use the members of <xref:System.Type> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.</span></span>  
  
 <span data-ttu-id="9cc50-104">Nie uprawnienia są wymagane dla kodu używać odbicia, aby uzyskać informacje na temat typów i ich członków, niezależnie od ich poziomy dostępu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-104">No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels.</span></span> <span data-ttu-id="9cc50-105">Nie uprawnienia są wymagane dla kodu dostępu publiczne elementy Członkowskie lub innych członków, w których poziomy dostępu będzie stały się widoczne podczas normalnej kompilacji przy użyciu odbicia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-105">No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation.</span></span> <span data-ttu-id="9cc50-106">Jednak aby używać odbicia do dostępu do elementów członkowskich, które zwykle będzie niedostępny, takie jak metody prywatne lub wewnętrzne lub objęte ochroną pól typu kodu, klasa nie dziedziczy, kod musi mieć <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-106">However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="9cc50-107">Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="9cc50-107">See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span>  
  
 <span data-ttu-id="9cc50-108">`Type` jest abstrakcyjna klasa bazowa, która zezwala na wiele implementacji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-108">`Type` is an abstract base class that allows multiple implementations.</span></span> <span data-ttu-id="9cc50-109">System będzie zawsze podawać klasy pochodnej `RuntimeType`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-109">The system will always provide the derived class `RuntimeType`.</span></span> <span data-ttu-id="9cc50-110">W odbiciu wszystkie klasy, począwszy od programu word środowiska uruchomieniowego są tworzone tylko raz dla każdego obiektu w operacjach porównania systemu i pomocy technicznej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-110">In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-111">W scenariuszach wielowątkowość nie blokuj <xref:System.Type> obiektów w celu synchronizowania dostępu do `static` danych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-111">In multithreading scenarios, do not lock <xref:System.Type> objects in order to synchronize access to `static` data.</span></span> <span data-ttu-id="9cc50-112">Inny kod, nad którym masz żadnej kontroli, może również zablokować typu klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-112">Other code, over which you have no control, might also lock your class type.</span></span> <span data-ttu-id="9cc50-113">Może to spowodować zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-113">This might result in a deadlock.</span></span> <span data-ttu-id="9cc50-114">Zamiast tego należy zsynchronizować dostęp do danych statycznych blokując prywatnej `static` obiektu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-114">Instead, synchronize access to static data by locking a private `static` object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-115">Klasa pochodna mają dostęp do chronionych składowych klas bazowych kodu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-115">A derived class can access protected members of the calling code's base classes.</span></span> <span data-ttu-id="9cc50-116">Ponadto jest dozwolony dostęp do zestawu elementów członkowskich zestawu kodu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-116">Also, access is allowed to assembly members of the calling code's assembly.</span></span> <span data-ttu-id="9cc50-117">Zgodnie z zasadą Jeśli możesz uzyskać dostęp w kodzie z wczesnym wiązaniem, następnie również możesz dostęp w kodzie z późnym wiązaniem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-117">As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-118">Interfejsy, które rozszerzają inne interfejsy nie dziedziczą metody zdefiniowane w rozszerzonych interfejsów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-118">Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.</span></span>  
  
 <span data-ttu-id="9cc50-119">W tej sekcji:</span><span class="sxs-lookup"><span data-stu-id="9cc50-119">In this section:</span></span>  
  
 <span data-ttu-id="9cc50-120">[Jakie typy reprezentuje obiekt typu?](#WhatTypes) </span><span class="sxs-lookup"><span data-stu-id="9cc50-120">[What types does a Type object represent?](#WhatTypes) </span></span>  
 <span data-ttu-id="9cc50-121">[Pobieranie obiektu typu](#Retrieve) </span><span class="sxs-lookup"><span data-stu-id="9cc50-121">[Retrieving a Type object](#Retrieve) </span></span>  
 [<span data-ttu-id="9cc50-122">Porównywanie obiektów typu pod kątem równości</span><span class="sxs-lookup"><span data-stu-id="9cc50-122">Comparing type objects for equality</span></span>](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a><span data-ttu-id="9cc50-123">Jakie typy reprezentuje obiekt typu?</span><span class="sxs-lookup"><span data-stu-id="9cc50-123">What types does a Type object represent?</span></span>  
 <span data-ttu-id="9cc50-124">Ta klasa jest bezpieczny wątkowo; wiele wątków jednocześnie może odczytywać dane z wystąpienia tego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-124">This class is thread safe; multiple threads can concurrently read from an instance of this type.</span></span> <span data-ttu-id="9cc50-125">Wystąpienie <xref:System.Type> klasa może reprezentować dowolny z następujących typów:</span><span class="sxs-lookup"><span data-stu-id="9cc50-125">An instance of the <xref:System.Type> class can represent any of the following types:</span></span>  
  
-   <span data-ttu-id="9cc50-126">Klasy</span><span class="sxs-lookup"><span data-stu-id="9cc50-126">Classes</span></span>  
  
-   <span data-ttu-id="9cc50-127">Typy wartości</span><span class="sxs-lookup"><span data-stu-id="9cc50-127">Value types</span></span>  
  
-   <span data-ttu-id="9cc50-128">Tablice</span><span class="sxs-lookup"><span data-stu-id="9cc50-128">Arrays</span></span>  
  
-   <span data-ttu-id="9cc50-129">Interfejsy</span><span class="sxs-lookup"><span data-stu-id="9cc50-129">Interfaces</span></span>  
  
-   <span data-ttu-id="9cc50-130">Wyliczenia</span><span class="sxs-lookup"><span data-stu-id="9cc50-130">Enumerations</span></span>  
  
-   <span data-ttu-id="9cc50-131">Delegaty</span><span class="sxs-lookup"><span data-stu-id="9cc50-131">Delegates</span></span>  
  
-   <span data-ttu-id="9cc50-132">Zbudowany typy ogólne i definicji typu ogólnego</span><span class="sxs-lookup"><span data-stu-id="9cc50-132">Constructed generic types and generic type definitions</span></span>  
  
-   <span data-ttu-id="9cc50-133">Argumenty typu, a następnie wpisz parametry typów ogólnych skonstruowany, definicji typu ogólnego i definicji metody ogólnej</span><span class="sxs-lookup"><span data-stu-id="9cc50-133">Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</span></span>  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a><span data-ttu-id="9cc50-134">Pobieranie obiektu typu</span><span class="sxs-lookup"><span data-stu-id="9cc50-134">Retrieving a Type object</span></span>  
 <span data-ttu-id="9cc50-135"><xref:System.Type> Obiekt skojarzony z określonym typem można uzyskać w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="9cc50-135">The <xref:System.Type> object associated with a particular type can be obtained in the following ways:</span></span>  
  
-   <span data-ttu-id="9cc50-136">Wystąpienie <xref:System.Object.GetType%2A?displayProperty=nameWithType> metoda zwraca <xref:System.Type> obiekt, który reprezentuje typ wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-136">The instance <xref:System.Object.GetType%2A?displayProperty=nameWithType> method returns a <xref:System.Type> object that represents the type of an instance.</span></span> <span data-ttu-id="9cc50-137">Ponieważ wszystkie zarządzane typy wyprowadzono z klasy <xref:System.Object>, <xref:System.Object.GetType%2A> metoda może być wywołana w wystąpieniu dowolnego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-137">Because all managed types derive from <xref:System.Object>, the <xref:System.Object.GetType%2A> method can be called on an instance of any type.</span></span>  
  
     <span data-ttu-id="9cc50-138">Poniższy przykład wywołuje <xref:System.Object.GetType%2A?displayProperty=nameWithType> metodę pozwala ustalić typ środowiska uruchomieniowego dla poszczególnych obiektów w tablicy obiektu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-138">The following example calls the <xref:System.Object.GetType%2A?displayProperty=nameWithType> method to determine the runtime type of each object in an object array.</span></span>  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   <span data-ttu-id="9cc50-139">Statyczne <xref:System.Type.GetType%2A?displayProperty=nameWithType> metody zwracają <xref:System.Type> obiekt, który reprezentuje typ określony przez jego w pełni kwalifikowana nazwa.</span><span class="sxs-lookup"><span data-stu-id="9cc50-139">The static <xref:System.Type.GetType%2A?displayProperty=nameWithType> methods return a <xref:System.Type> object that represents a type specified by its fully qualified name.</span></span>  
  
-   <span data-ttu-id="9cc50-140"><xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, I <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> metody zwracają `Type` obiektami, które reprezentują typy zdefiniowane w module.</span><span class="sxs-lookup"><span data-stu-id="9cc50-140">The <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> methods return `Type` objects that represent the types defined in a module.</span></span> <span data-ttu-id="9cc50-141">Pierwsza metoda może służyć do uzyskiwania tablicę <xref:System.Type> obiektów dla wszystkich typów publicznych i prywatnych zdefiniowany w module.</span><span class="sxs-lookup"><span data-stu-id="9cc50-141">The first method can be used to obtain an array of <xref:System.Type> objects for all the public and private types defined in a module.</span></span> <span data-ttu-id="9cc50-142">(Można uzyskać wystąpienia `Module` za pośrednictwem <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> metodę, lub za pomocą <xref:System.Type.Module%2A?displayProperty=nameWithType> właściwości.)</span><span class="sxs-lookup"><span data-stu-id="9cc50-142">(You can obtain an instance of `Module` through the <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> method, or through the <xref:System.Type.Module%2A?displayProperty=nameWithType> property.)</span></span>  
  
-   <span data-ttu-id="9cc50-143"><xref:System.Reflection.Assembly?displayProperty=nameWithType> Obiekt zawiera wiele metod, które można pobrać klas zdefiniowanych w zestawie, w tym <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, i <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-143">The <xref:System.Reflection.Assembly?displayProperty=nameWithType> object contains a number of methods to retrieve the classes defined in an assembly, including <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="9cc50-144"><xref:System.Type.FindInterfaces%2A> Metoda zwraca filtrowana lista typów interfejsów, obsługiwany przez typ.</span><span class="sxs-lookup"><span data-stu-id="9cc50-144">The <xref:System.Type.FindInterfaces%2A> method returns a filtered list of interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="9cc50-145"><xref:System.Type.GetElementType%2A> Metoda zwraca `Type` obiekt, który reprezentuje element.</span><span class="sxs-lookup"><span data-stu-id="9cc50-145">The <xref:System.Type.GetElementType%2A> method returns a `Type` object that represents the element.</span></span>  
  
-   <span data-ttu-id="9cc50-146"><xref:System.Type.GetInterfaces%2A> i <xref:System.Type.GetInterface%2A> metody zwracają <xref:System.Type> obiektów reprezentujących typy interfejsów, obsługiwany przez typ.</span><span class="sxs-lookup"><span data-stu-id="9cc50-146">The <xref:System.Type.GetInterfaces%2A> and <xref:System.Type.GetInterface%2A> methods return <xref:System.Type> objects representing the interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="9cc50-147"><xref:System.Type.GetTypeArray%2A> Metoda zwraca tablicę <xref:System.Type> obiektów reprezentujących typy określone przez dowolny zestaw obiektów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-147">The <xref:System.Type.GetTypeArray%2A> method returns an array of <xref:System.Type> objects representing the types specified by an arbitrary set of objects.</span></span> <span data-ttu-id="9cc50-148">Obiekty są określane za pomocą tablicy typu <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-148">The objects are specified with an array of type <xref:System.Object>.</span></span>  
  
-   <span data-ttu-id="9cc50-149"><xref:System.Type.GetTypeFromProgID%2A> i <xref:System.Type.GetTypeFromCLSID%2A> metody są dostarczane dla współdziałania COM.</span><span class="sxs-lookup"><span data-stu-id="9cc50-149">The <xref:System.Type.GetTypeFromProgID%2A> and <xref:System.Type.GetTypeFromCLSID%2A> methods are provided for COM interoperability.</span></span> <span data-ttu-id="9cc50-150">Zwracają <xref:System.Type> obiekt, który reprezentuje typ określony przez `ProgID` lub `CLSID`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-150">They return a <xref:System.Type> object that represents the type specified by a `ProgID` or `CLSID`.</span></span>  
  
-   <span data-ttu-id="9cc50-151"><xref:System.Type.GetTypeFromHandle%2A> Metoda towarzyszy współdziałania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-151">The <xref:System.Type.GetTypeFromHandle%2A> method is provided for interoperability.</span></span> <span data-ttu-id="9cc50-152">Zwraca `Type` obiekt, który reprezentuje typu określonego przez dojście do klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-152">It returns a `Type` object that represents the type specified by a class handle.</span></span>  
  
-   <span data-ttu-id="9cc50-153">C# `typeof` operatora C++ `typeid` operator i Visual Basic `GetType` uzyskać operator `Type` obiektu dla typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-153">The C# `typeof` operator, the C++ `typeid` operator, and the Visual Basic `GetType` operator obtain the `Type` object for a type.</span></span>  
  
-   <span data-ttu-id="9cc50-154"><xref:System.Type.MakeGenericType%2A> Metoda zwraca <xref:System.Type> obiekt reprezentuje zbudowany typ ogólny, który jest zbudowany typu otwartego, jeśli jego <xref:System.Type.ContainsGenericParameters%2A> właściwość zwraca `true`, i zamkniętej skonstruowany typ inaczej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-154">The <xref:System.Type.MakeGenericType%2A> method returns a <xref:System.Type> object representing a constructed generic type, which is an open constructed type if its <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, and a closed constructed type otherwise.</span></span> <span data-ttu-id="9cc50-155">Mogą można utworzyć wystąpienia typu ogólnego, tylko wtedy, gdy jest ono zamknięte.</span><span class="sxs-lookup"><span data-stu-id="9cc50-155">A generic type can be instantiated only if it is closed.</span></span>  
  
-   <span data-ttu-id="9cc50-156"><xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, I <xref:System.Type.MakeByRefType%2A> metody zwracają <xref:System.Type> obiektami, które reprezentują odpowiednio tablicę określonego typu, wskaźnik do określonego typu, a typem parametru odwołania (`ref` w języku C# `ByRef`w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-156">The <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, and <xref:System.Type.MakeByRefType%2A> methods return <xref:System.Type> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (`ref` in C#, `ByRef` in Visual Basic).</span></span>  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a><span data-ttu-id="9cc50-157">Porównywanie obiektów typu pod kątem równości</span><span class="sxs-lookup"><span data-stu-id="9cc50-157">Comparing type objects for equality</span></span>  
 <span data-ttu-id="9cc50-158">A <xref:System.Type> obiekt reprezentuje typ to unikatowy, czyli dwa <xref:System.Type> odwołania do obiektu odnoszą się do tego samego obiektu, tylko wtedy, gdy reprezentują tego samego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-158">A <xref:System.Type> object that represents a type is unique; that is, two <xref:System.Type> object references refer to the same object if and only if they represent the same type.</span></span> <span data-ttu-id="9cc50-159">Dzięki temu porównanie <xref:System.Type> obiektów przy użyciu równości odwołań.</span><span class="sxs-lookup"><span data-stu-id="9cc50-159">This allows for comparison of <xref:System.Type> objects using reference equality.</span></span> <span data-ttu-id="9cc50-160">W poniższym przykładzie porównano <xref:System.Type> obiektami, które reprezentują liczbę liczb całkowitych, aby ustalić, czy są one tego samego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-160">The following example compares the <xref:System.Type> objects that represent a number of integer values to determine whether they are of the same type.</span></span>  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-161">W poniższym przykładzie pokazano kilka funkcji reprezentatywny <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-161">The following example shows a few representative features of <xref:System.Type>.</span></span> <span data-ttu-id="9cc50-162">C# `typeof` — Operator (`GetType` operatora w języku Visual Basic) jest używana do pobierania <xref:System.Type> obiekt reprezentujący <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-162">The C# `typeof` operator (`GetType` operator in Visual Basic) is used to get a <xref:System.Type> object representing <xref:System.String>.</span></span> <span data-ttu-id="9cc50-163">Z tego <xref:System.Type> obiektu <xref:System.Type.GetMethod%2A> metoda jest używana do pobierania <xref:System.Reflection.MethodInfo> reprezentujący <xref:System.String.Substring%2A?displayProperty=nameWithType> przeciążenia przyjmującego lokalizację początkową i długość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-163">From this <xref:System.Type> object, the <xref:System.Type.GetMethod%2A> method is used to get a <xref:System.Reflection.MethodInfo> representing the <xref:System.String.Substring%2A?displayProperty=nameWithType> overload that takes a starting location and a length.</span></span>
  
 <span data-ttu-id="9cc50-164">Aby zidentyfikować sygnatura przeciążenia, przykład kodu tworzy tablicę tymczasową, zawierający dwie <xref:System.Type> obiekty reprezentujące `int` (`Integer` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-164">To identify the overload signature, the code example creates a temporary array containing two <xref:System.Type> objects representing `int` (`Integer` in Visual Basic).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-165">Ściślej mówiąc, tablica zawiera dwa odwołania do wystąpienia <xref:System.Type> reprezentujący `int` w bieżącej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-165">To be precise, the array contains two references to the instance of <xref:System.Type> that represents `int` in the current application domain.</span></span> <span data-ttu-id="9cc50-166">Dla dowolnego typu, jest tylko jedno wystąpienie <xref:System.Type> dla domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-166">For any type, there is only one instance of <xref:System.Type> per application domain.</span></span>  
  
 <span data-ttu-id="9cc50-167">Przykład kodu wykorzystuje <xref:System.Reflection.MethodInfo> do wywołania <xref:System.String.Substring%2A> metody na ciąg "Hello, World!" i wyświetla wynik.</span><span class="sxs-lookup"><span data-stu-id="9cc50-167">The code example uses the <xref:System.Reflection.MethodInfo> to invoke the <xref:System.String.Substring%2A> method on the string "Hello, World!", and displays the result.</span></span>  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="9cc50-168">Ten typ jest bezpieczny wątkowo.</span><span class="sxs-lookup"><span data-stu-id="9cc50-168">This type is thread safe.</span></span></threadsafe>
    <block subset="none" type="overrides"><para><span data-ttu-id="9cc50-169">Przy dziedziczeniu z <see langword="Type" />, konieczne jest przesłonięcie następujących składowych:</span><span class="sxs-lookup"><span data-stu-id="9cc50-169">When you inherit from <see langword="Type" />, you must override the following members:</span></span> 
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para></block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="~/docs/framework/reflection-and-codedom/viewing-type-information.md"><span data-ttu-id="9cc50-170">Wyświetlanie informacji o typie</span><span class="sxs-lookup"><span data-stu-id="9cc50-170">Viewing Type Information</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-171">Inicjuje nowe wystąpienie klasy <see cref="T:System.Type" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-171">Initializes a new instance of the <see cref="T:System.Type" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-172">Ten konstruktor jest wywoływany przez klasy pochodne podczas konstruowania obiektów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-172">This constructor is invoked by derived classes during the construction of type objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-173">Pobiera <see cref="T:System.Reflection.Assembly" /> w którym zadeklarowano typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-173">Gets the <see cref="T:System.Reflection.Assembly" /> in which the type is declared.</span></span> <span data-ttu-id="9cc50-174">Dla typów ogólnych pobiera <see cref="T:System.Reflection.Assembly" /> w jest definicja typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-174">For generic types, gets the <see cref="T:System.Reflection.Assembly" /> in which the generic type is defined.</span></span></summary>
        <value><span data-ttu-id="9cc50-175"><see cref="T:System.Reflection.Assembly" /> Wystąpienia, który opisuje zestawu zawierającego bieżącego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-175">An <see cref="T:System.Reflection.Assembly" /> instance that describes the assembly containing the current type.</span></span> <span data-ttu-id="9cc50-176">Dla typów ogólnych wystąpienia w tym artykule opisano zestaw, który zawiera definicję typu ogólnego, nie zestawu, który tworzy i używa określonego skonstruowanego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-176">For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-177">Jeśli bieżący <xref:System.Type> obiekt reprezentuje zbudowany typ ogólny, właściwość ta zwraca zestaw, który zawiera definicję typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-177">If the current <xref:System.Type> object represents a constructed generic type, this property returns the assembly that contains the generic type definition.</span></span> <span data-ttu-id="9cc50-178">Załóżmy na przykład, możesz utworzyć zestaw o nazwie MyGenerics.dll, który zawiera definicję typu ogólnego `MyGenericStack<T>` (`MyGenericStack(Of T)` w języku Visual Basic `generic<T> ref class MyGenericStack` w języku C++).</span><span class="sxs-lookup"><span data-stu-id="9cc50-178">For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition `MyGenericStack<T>` (`MyGenericStack(Of T)` in Visual Basic, `generic<T> ref class MyGenericStack` in C++).</span></span> <span data-ttu-id="9cc50-179">Jeśli utworzysz wystąpienie `MyGenericStack<int>` (`MyGenericStack(Of Integer)` w języku Visual Basic) w innym zestawie <xref:System.Type.Assembly%2A> zwraca właściwości dla skonstruowanego typu <xref:System.Reflection.Assembly> obiekt, który reprezentuje MyGenerics.dll.</span><span class="sxs-lookup"><span data-stu-id="9cc50-179">If you create an instance of `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in another assembly, the <xref:System.Type.Assembly%2A> property for the constructed type returns an <xref:System.Reflection.Assembly> object that represents MyGenerics.dll.</span></span>  
  
 <span data-ttu-id="9cc50-180">Podobnie jeśli bieżący <xref:System.Type> obiekt reprezentuje nieprzypisanego parametru ogólnego `T`, właściwość ta zwraca zestaw, który zawiera typ ogólny, który definiuje `T`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-180">Similarly, if the current <xref:System.Type> object represents an unassigned generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
 <span data-ttu-id="9cc50-181">Jeśli <xref:System.Type.Assembly%2A?displayProperty=nameWithType> właściwość nie jest dostępna na określonej implementacji .NET, takich jak .NET Core i platformy uniwersalnej Windows, należy użyć <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> właściwości zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-181">If the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property is not available on a particular .NET implementation, such as .NET Core or the Universal Windows Platform, use the <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> property instead.</span></span>      
  
 <span data-ttu-id="9cc50-182">Ta właściwość jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-182">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-183">Poniższy przykład wyświetla nazwę zestawu, skojarzony z klasą i w pełni kwalifikowaną nazwę typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-183">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-184">Pobiera kwalifikowaną dla zestawu nazwę typu, który zawiera nazwę zestawu, z którego należy to <see cref="T:System.Type" /> obiekt został załadowany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-184">Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <see cref="T:System.Type" /> object was loaded.</span></span></summary>
        <value><span data-ttu-id="9cc50-185">Nazwa kwalifikowanego dla zestawu <see cref="T:System.Type" />, który zawiera nazwę zestawu, z którego <see cref="T:System.Type" /> został załadowany, lub <see langword="null" /> Jeśli bieżące wystąpienie reprezentuje parametr typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-185">The assembly-qualified name of the <see cref="T:System.Type" />, which includes the name of the assembly from which the <see cref="T:System.Type" /> was loaded, or <see langword="null" /> if the current instance represents a generic type parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-186">Nazwa kwalifikowanego dla zestawu typu składa się z nazwą typu, łącznie z jego przestrzeń nazw i przecinek, a następnie według nazwy wyświetlanej zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-186">The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly.</span></span> <span data-ttu-id="9cc50-187">Nazwa wyświetlana zestawu są uzyskiwane przy użyciu <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-187">The display name of an assembly is obtained using the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-188">W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-188">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="9cc50-189">Na przykład "ProcessorArchitecture = msil".</span><span class="sxs-lookup"><span data-stu-id="9cc50-189">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="9cc50-190">Jednak nie są uwzględnione w ciągu zwracanego przez <xref:System.Type.AssemblyQualifiedName%2A> właściwość ze względu na zgodność.</span><span class="sxs-lookup"><span data-stu-id="9cc50-190">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="9cc50-191">Zobacz <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-191">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="9cc50-192">Wszystkie kompilatory, które obsługują środowiska uruchomieniowego języka wspólnego emitować prostą nazwę klasy zagnieżdżonej, a odbicie zniekształcone nazwy, po otrzymaniu kwerendy, zgodnie z następujących konwencji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-192">All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
|<span data-ttu-id="9cc50-193">Ogranicznik</span><span class="sxs-lookup"><span data-stu-id="9cc50-193">Delimiter</span></span>|<span data-ttu-id="9cc50-194">Znaczenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-194">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="9cc50-195">Ukośnik odwrotny (\\)</span><span class="sxs-lookup"><span data-stu-id="9cc50-195">Backslash (\\)</span></span>|<span data-ttu-id="9cc50-196">Znak ucieczki.</span><span class="sxs-lookup"><span data-stu-id="9cc50-196">Escape character.</span></span>|  
|<span data-ttu-id="9cc50-197">Przecinek (,)</span><span class="sxs-lookup"><span data-stu-id="9cc50-197">Comma (,)</span></span>|<span data-ttu-id="9cc50-198">Poprzedza nazwę zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-198">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="9cc50-199">Znak plus (+)</span><span class="sxs-lookup"><span data-stu-id="9cc50-199">Plus sign (+)</span></span>|<span data-ttu-id="9cc50-200">Poprzedza klasę zagnieżdżoną.</span><span class="sxs-lookup"><span data-stu-id="9cc50-200">Precedes a nested class.</span></span>|  
|<span data-ttu-id="9cc50-201">Kropka (.)</span><span class="sxs-lookup"><span data-stu-id="9cc50-201">Period (.)</span></span>|<span data-ttu-id="9cc50-202">Wskazuje przestrzeń nazw identyfikatorów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-202">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="9cc50-203">Nawiasy kwadratowe ([])</span><span class="sxs-lookup"><span data-stu-id="9cc50-203">Brackets ([])</span></span>|<span data-ttu-id="9cc50-204">Po nazwie typu wskazuje, że tablicy tego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-204">After a type name, denotes an array of that type.</span></span><br /><br /> <span data-ttu-id="9cc50-205">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-205">-or-</span></span><br /><br /> <span data-ttu-id="9cc50-206">Dla typu ogólnego otacza listy argumentów typu rodzajowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-206">For a generic type, encloses the generic type argument list.</span></span><br /><br /> <span data-ttu-id="9cc50-207">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-207">-or-</span></span><br /><br /> <span data-ttu-id="9cc50-208">Na liście argumentów typu otacza typu kwalifikowanego zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-208">Within a type argument list, encloses an assembly-qualified type.</span></span>|  
  
 <span data-ttu-id="9cc50-209">Na przykład nazwa kwalifikowanego dla zestawu dla klasy może wyglądać następująco:</span><span class="sxs-lookup"><span data-stu-id="9cc50-209">For example, the assembly-qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 <span data-ttu-id="9cc50-210">Jeśli przestrzeń nazw zawiera znak plus, na przykład TopNamespace.Sub+Namespace, a następnie znak plus (+) może być poprzedzony znakiem ucieczki (\\), aby zapobiec interpretacji jako separator zagnieżdżenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-210">If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="9cc50-211">Ten ciąg będzie emisji odbicia w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="9cc50-211">Reflection would emit this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 <span data-ttu-id="9cc50-212">A "++" staje się "\\+\\+", a "\\"staje się"\\\\".</span><span class="sxs-lookup"><span data-stu-id="9cc50-212">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="9cc50-213">Ta nazwa kwalifikowana może utrwalona i później używana do ładowania <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-213">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="9cc50-214">Aby wyszukać i załadować <xref:System.Type>, użyj <xref:System.Type.GetType%2A> albo z typem nazwy tylko lub nazwą kwalifikowaną typu zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-214">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="9cc50-215"><xref:System.Type.GetType%2A> z typem nazwy tylko będzie szukać <xref:System.Type> w zestawie wywołującego, a następnie w zestawie systemowym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-215"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="9cc50-216"><xref:System.Type.GetType%2A> z zestawem kwalifikowanej nazwy typu będzie szukać <xref:System.Type> w każdym zestawie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-216"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="9cc50-217">Nazwy typów mogą obejmować końcowe znaki, które wyznaczają dodatkowe informacje dotyczące typu, na przykład to, czy typ jest typem odwołania, typem wskaźnika lub typem tablicowym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-217">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="9cc50-218">Aby pobrać, wpisz nazwę bez tych znaków końcowych, należy użyć `t.GetElementType().ToString()`, gdzie `t` jest typem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-218">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="9cc50-219">Spacje są istotne we wszystkich składnikach nazwy z wyjątkiem nazwy zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-219">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="9cc50-220">Spacje przed separatorem w nazwie zestawu ',' są istotne, ale spacje po separatorze ',' są ignorowane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-220">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="9cc50-221">Argumenty ogólne typów ogólnych są kwalifikowane przez nazwę zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-221">Generic arguments of generic types are themselves qualified by assembly name.</span></span> <span data-ttu-id="9cc50-222">Na przykład w nazwie typu kwalifikowanego zestawu `MyGenericClass<int>` (`MyGenericClass(Of Integer)` w języku Visual Basic), `int` podzielonego na nazwę typu kwalifikowanego zestawu <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-222">For example, in the assembly-qualified type name for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic), `int` is expanded to the assembly-qualified type name for <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="9cc50-223">Jeśli bieżący <xref:System.Type> obiekt reprezentuje parametr ogólny, właściwość ta zwraca `null`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-223">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-224">Poniższy przykład wyświetla nazwę zestawu, skojarzony z klasą i w pełni kwalifikowaną nazwę typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-224">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 <span data-ttu-id="9cc50-225">W poniższym przykładzie porównano ciągów zwracanych przez <xref:System.Type.ToString%2A> metody i `Name`, <xref:System.Type.FullName%2A>, i <xref:System.Type.AssemblyQualifiedName%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-225">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="9cc50-226">Określanie w pełni kwalifikowanych nazw typów</span><span class="sxs-lookup"><span data-stu-id="9cc50-226">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-227">Pobiera atrybuty skojarzone z <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-227">Gets the attributes associated with the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="9cc50-228">A <see cref="T:System.Reflection.TypeAttributes" /> obiekt reprezentujący zestaw atrybutów <see cref="T:System.Type" />, chyba że <see cref="T:System.Type" /> reprezentuje parametr typu ogólnego, w której wartość jest nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="9cc50-228">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />, unless the <see cref="T:System.Type" /> represents a generic type parameter, in which case the value is unspecified.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-229">Niektórzy członkowie <xref:System.Reflection.TypeAttributes> wyliczenia są masek, które reprezentują grupy wartości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-229">Some members of the <xref:System.Reflection.TypeAttributes> enumeration are masks that represent a group of values.</span></span> <span data-ttu-id="9cc50-230">Każda grupa zawiera jeden element członkowski, którego podstawową wartość wynosi zero.</span><span class="sxs-lookup"><span data-stu-id="9cc50-230">Each group includes one member whose underlying value is zero.</span></span> <span data-ttu-id="9cc50-231">Na przykład, podstawową wartość <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> elementu członkowskiego w <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> grupy wynosi zero, ponieważ jest <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> elementu członkowskiego w <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> grupy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-231">For example, the underlying value of the <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> group is zero, as is the <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> group.</span></span> <span data-ttu-id="9cc50-232">W związku z tym należy użyć maska przed testowaniem w przypadku tych wartości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-232">Because of this, you must use the mask before testing for those values.</span></span> <span data-ttu-id="9cc50-233">Przykład stanowi ilustrację.</span><span class="sxs-lookup"><span data-stu-id="9cc50-233">The example provides an illustration.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="9cc50-234">W większości przypadków, właściwości, takie jak <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, i <xref:System.Type.IsSpecialName%2A> są łatwiejsze w obsłudze niż atrybuty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-234">For most purposes, properties like <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, and <xref:System.Type.IsSpecialName%2A> are easier to use than type attributes.</span></span>  
  
 <span data-ttu-id="9cc50-235">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta zwraca atrybuty definicji typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-235">If the current <xref:System.Type> represents a constructed generic type, this property returns the attributes of the generic type definition.</span></span> <span data-ttu-id="9cc50-236">Na przykład, atrybutów, które są zwracane dla `MyGenericClass<int>` (`MyGenericClass(Of Integer)` w języku Visual Basic) są atrybuty `MyGenericClass<T>` (`MyGenericClass(Of T)` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-236">For example, the attributes returned for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) are the attributes of `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="9cc50-237">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego — oznacza to, jeśli <xref:System.Type.IsGenericParameter%2A> właściwość zwraca `true` — <xref:System.Reflection.TypeAttributes> wartość zwracana przez właściwość ta jest nieokreślony.</span><span class="sxs-lookup"><span data-stu-id="9cc50-237">If the current <xref:System.Type> represents a generic type parameter - that is, if the <xref:System.Type.IsGenericParameter%2A> property returns `true` - the <xref:System.Reflection.TypeAttributes> value returned by this property is unspecified.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-238">W poniższym przykładzie użyto <xref:System.Type.Attributes%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-238">The following example uses the <xref:System.Type.Attributes%2A> property.</span></span>  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-239">Pobiera typ, z którego bieżący <see cref="T:System.Type" /> dziedziczy bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="9cc50-239">Gets the type from which the current <see cref="T:System.Type" /> directly inherits.</span></span></summary>
        <value><span data-ttu-id="9cc50-240"><see cref="T:System.Type" /> z którego bieżący <see cref="T:System.Type" /> dziedziczy bezpośrednio, lub <see langword="null" /> Jeśli bieżące <see langword="Type" /> reprezentuje <see cref="T:System.Object" /> klasę lub interfejs.</span><span class="sxs-lookup"><span data-stu-id="9cc50-240">The <see cref="T:System.Type" /> from which the current <see cref="T:System.Type" /> directly inherits, or <see langword="null" /> if the current <see langword="Type" /> represents the <see cref="T:System.Object" /> class or an interface.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-241">Typ podstawowy jest typem, z której dziedziczy bezpośrednio bieżącego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-241">The base type is the type from which the current type directly inherits.</span></span> <span data-ttu-id="9cc50-242"><xref:System.Object> jest to jedyny typ, który nie ma typu podstawowego, w związku z tym `null` jest zwracana jako typ bazowy <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-242"><xref:System.Object> is the only type that does not have a base type, therefore `null` is returned as the base type of <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="9cc50-243">Interfejsy dziedziczyć zero lub więcej podstawowych interfejsów; Ta właściwość zwraca `null` Jeśli `Type` obiekt reprezentuje interfejs.</span><span class="sxs-lookup"><span data-stu-id="9cc50-243">Interfaces inherit from zero or more base interfaces; therefore, this property returns `null` if the `Type` object represents an interface.</span></span> <span data-ttu-id="9cc50-244">Interfejsy podstawowe można określić za pomocą <xref:System.Type.GetInterfaces%2A> lub <xref:System.Type.FindInterfaces%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-244">The base interfaces can be determined with <xref:System.Type.GetInterfaces%2A> or <xref:System.Type.FindInterfaces%2A>.</span></span>  
  
 <span data-ttu-id="9cc50-245">Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny skonstruowany, typ podstawowy odzwierciedla argumentów rodzajowych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-245">If the current <xref:System.Type> represents a constructed generic type, the base type reflects the generic arguments.</span></span> <span data-ttu-id="9cc50-246">Na przykład należy wziąć pod uwagę następujące deklaracje:</span><span class="sxs-lookup"><span data-stu-id="9cc50-246">For example, consider the following declarations:</span></span>  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="9cc50-247">Do skonstruowanego typu `C<int>` (`C(Of Integer)` w języku Visual Basic), <xref:System.Type.BaseType%2A> właściwość zwraca `B<int>`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-247">For the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the <xref:System.Type.BaseType%2A> property returns `B<int>`.</span></span>  
  
 <span data-ttu-id="9cc50-248">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego, <xref:System.Type.BaseType%2A> zwraca ograniczenia klasy, oznacza to, że parametr typu musi dziedziczyć klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-248">If the current <xref:System.Type> represents a type parameter of a generic type definition, <xref:System.Type.BaseType%2A> returns the class constraint, that is, the class the type parameter must inherit.</span></span> <span data-ttu-id="9cc50-249">Jeśli nie określono ograniczenia klasy <xref:System.Type.BaseType%2A> zwraca <xref:System.Object?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-249">If there is no class constraint, <xref:System.Type.BaseType%2A> returns <xref:System.Object?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="9cc50-250">Ta właściwość jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-250">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-251">Poniższy przykład demonstruje użycie <xref:System.Type.BaseType%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-251">The following example demonstrates using the <xref:System.Type.BaseType%2A> property.</span></span>  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 <span data-ttu-id="9cc50-252">W poniższym przykładzie użyto rekursji, aby wyświetlić listę hierarchii dziedziczenia pełną każda klasa odnaleźć w zestawie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-252">The following example uses recursion to list the complete inheritance hierarchy of each class found in an assembly.</span></span> <span data-ttu-id="9cc50-253">W przykładzie zdefiniowano klasę o nazwie `C` która jest pochodną klasę o nazwie `B`, która z kolei pochodzi od klasy o nazwie `A`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-253">The example defines a class named `C` that derives from a class named `B`, which, in turn, derives from a class named `A`.</span></span>  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="9cc50-254">Odbicie i typy ogólne</span><span class="sxs-lookup"><span data-stu-id="9cc50-254">Reflection and Generic Types</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-255">Pobiera wartość wskazującą czy bieżący <see cref="T:System.Type" /> obiekt ma parametry typu, które nie zostały zastąpione przez określone typy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-255">Gets a value indicating whether the current <see cref="T:System.Type" /> object has type parameters that have not been replaced by specific types.</span></span></summary>
        <value><span data-ttu-id="9cc50-256"><see langword="true" /> Jeśli <see cref="T:System.Type" /> sam parametr typu ogólnego lub obiektu ma parametry typu, dla których określonych typów nie zostały podane; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-256"><see langword="true" /> if the <see cref="T:System.Type" /> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-257">Aby można było utworzyć wystąpienia typu, musi być nie definicji typu ogólnego lub Otwórz typy utworzone w argumentach typu sam typ, w dowolnym otaczających typów ogólnych lub w dowolnych elementów tego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-257">In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type.</span></span> <span data-ttu-id="9cc50-258">Innym sposobem powiedzenia, to jest że w przypadku badania cyklicznie, typ musi zawierać żadnych parametrów typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-258">Another way of saying this is that when examined recursively, the type must contain no generic type parameters.</span></span>  
  
 <span data-ttu-id="9cc50-259">Ponieważ typy mogą być dowolnie złożone, dzięki czemu oznaczanie jest trudne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-259">Since types can be arbitrarily complex, making this determination is difficult.</span></span> <span data-ttu-id="9cc50-260">Dla wygody i zmniejszyć prawdopodobieństwo wystąpienia błędu <xref:System.Type.ContainsGenericParameters%2A> właściwość udostępnia standardowy sposób odróżnić zamknięte typy utworzone, które mogą być utworzone, i otwórz zbudowane typy, które nie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-260">For convenience and to reduce the chance of error, the <xref:System.Type.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot.</span></span> <span data-ttu-id="9cc50-261">Jeśli <xref:System.Type.ContainsGenericParameters%2A> właściwość zwraca `true`, nie można utworzyć wystąpienia typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-261">If the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, the type cannot be instantiated.</span></span>  
  
 <span data-ttu-id="9cc50-262"><xref:System.Type.ContainsGenericParameters%2A> Właściwość przeszukiwane rekursywnie dla parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-262">The <xref:System.Type.ContainsGenericParameters%2A> property searches recursively for type parameters.</span></span> <span data-ttu-id="9cc50-263">Na przykład zwraca `true` tablicy, której elementy są typu `A<T>` (`A(Of T)` w języku Visual Basic), nawet jeśli tablica nie jest sam ogólny.</span><span class="sxs-lookup"><span data-stu-id="9cc50-263">For example, it returns `true` for an array whose elements are type `A<T>` (`A(Of T)` in Visual Basic), even though the array is not itself generic.</span></span> <span data-ttu-id="9cc50-264">Natomiast to zachowanie <xref:System.Type.IsGenericType%2A> właściwość, która zwraca `false` dla tablic.</span><span class="sxs-lookup"><span data-stu-id="9cc50-264">Contrast this with the behavior of the <xref:System.Type.IsGenericType%2A> property, which returns `false` for arrays.</span></span>  
  
 <span data-ttu-id="9cc50-265">Zbiór przykład klasy i tabelę przedstawiającą wartości <xref:System.Type.ContainsGenericParameters%2A> właściwości, zobacz <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-265">For a set of example classes and a table showing the values of the <xref:System.Type.ContainsGenericParameters%2A> property, see <xref:System.Type.IsGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-266">Poniższy przykład definiuje klasę ogólną z dwoma parametrami typu i następnie definiuje klasę ogólną drugi wywodzi się z pierwszej klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-266">The following example defines a generic class with two type parameters and then defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="9cc50-267">Klasa podstawowa dla klasy pochodnej ma dwa argumenty typu: pierwszy to <xref:System.Int32> , a drugim parametrem typu w typie pochodnym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-267">The derived class's base class has two type arguments: the first is <xref:System.Int32> and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="9cc50-268">W przykładzie są wyświetlane informacje o tych klasach ogólnych, w tym pozycje raportowane przez <xref:System.Type.GenericParameterPosition%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-268">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="9cc50-269">Odbicie i typy ogólne</span><span class="sxs-lookup"><span data-stu-id="9cc50-269">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="9cc50-270">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</span><span class="sxs-lookup"><span data-stu-id="9cc50-270">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-271">Pobiera <see cref="T:System.Reflection.MethodBase" /> deklarującego metody reprezentująca Jeśli bieżące <see cref="T:System.Type" /> reprezentuje parametr typu metody ogólnej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-271">Gets a <see cref="T:System.Reflection.MethodBase" /> that represents the declaring method, if the current <see cref="T:System.Type" /> represents a type parameter of a generic method.</span></span></summary>
        <value><span data-ttu-id="9cc50-272">Jeśli bieżący <see cref="T:System.Type" /> reprezentuje parametr typu metody ogólnej <see cref="T:System.Reflection.MethodBase" /> reprezentująca deklarowania metody; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-272">If the current <see cref="T:System.Type" /> represents a type parameter of a generic method, a <see cref="T:System.Reflection.MethodBase" /> that represents declaring method; otherwise, <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-273">Metoda deklarujący jest definicję metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-273">The declaring method is a generic method definition.</span></span> <span data-ttu-id="9cc50-274">Oznacza to jeśli <xref:System.Type.DeclaringMethod%2A> nie zwraca `null`, następnie `DeclaringMethod.IsGenericMethodDefinition` zwraca `true`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-274">That is, if <xref:System.Type.DeclaringMethod%2A> does not return `null`, then `DeclaringMethod.IsGenericMethodDefinition` returns `true`.</span></span>  
  
 <span data-ttu-id="9cc50-275"><xref:System.Type.DeclaringType%2A> i <xref:System.Type.DeclaringMethod%2A> właściwości zidentyfikować definicji typu ogólnego lub definicję metody rodzajowej, w której została pierwotnie zdefiniowana parametru typu generycznego:</span><span class="sxs-lookup"><span data-stu-id="9cc50-275">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="9cc50-276">Jeśli <xref:System.Type.DeclaringMethod%2A> właściwość zwraca <xref:System.Reflection.MethodInfo>, które <xref:System.Reflection.MethodInfo> reprezentuje definicję metody rodzajowej, a bieżący <xref:System.Type> obiekt reprezentuje parametr typu tej definicji metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-276">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="9cc50-277">Jeśli <xref:System.Type.DeclaringMethod%2A> właściwość zwraca `null`, a następnie <xref:System.Type.DeclaringType%2A> właściwość zawsze zwraca <xref:System.Type> obiekt reprezentujący definicji typu ogólnego i bieżący <xref:System.Type> obiekt reprezentuje parametr typu ogólnego typu Definicja.</span><span class="sxs-lookup"><span data-stu-id="9cc50-277">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="9cc50-278">Wprowadzenie <xref:System.Type.DeclaringMethod%2A> właściwość typu którego <xref:System.Type.IsGenericParameter%2A> właściwość `false` zgłasza <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-278">Getting the <xref:System.Type.DeclaringMethod%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="9cc50-279"><xref:System.Reflection.MethodBase> Zwracanym przez <xref:System.Type.DeclaringMethod%2A> właściwości <xref:System.Reflection.MethodInfo> w przypadku metody rodzajowej, lub <xref:System.Reflection.ConstructorInfo> w przypadku ogólnych konstruktora.</span><span class="sxs-lookup"><span data-stu-id="9cc50-279">The <xref:System.Reflection.MethodBase> that is returned by the <xref:System.Type.DeclaringMethod%2A> property is either a <xref:System.Reflection.MethodInfo> in the case of a generic method, or a <xref:System.Reflection.ConstructorInfo> in the case of a generic constructor.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-280">Ogólny konstruktory nie są obsługiwane w .NET Framework w wersji 2.0.</span><span class="sxs-lookup"><span data-stu-id="9cc50-280">In the .NET Framework version 2.0, generic constructors are not supported.</span></span>  
  
 <span data-ttu-id="9cc50-281">Aby uzyskać listę niezmiennych warunków dla terminów używanych w odbiciu rodzajowym, zobacz <xref:System.Type.IsGenericType%2A> uwagi dotyczące właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-281">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-282">Poniższy kod definiuje klasę, która zawiera metody rodzajowej, przypisuje argument typu do metody i wywołuje wynikowego skonstruowanego metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-282">The following code example defines a class that has a generic method, assigns a type argument to the method, and invokes the resulting constructed generic method.</span></span> <span data-ttu-id="9cc50-283">Wyświetla informacje o definicji metody rodzajowej, a także metoda skonstruowany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-283">It also displays information about the generic method definition and the constructed method.</span></span> <span data-ttu-id="9cc50-284">Podczas wyświetlania informacji na temat parametrów typu definicji metody ogólnej w `DisplayGenericMethodInfo` metody, przykładowy kod pokazuje wartość <xref:System.Type.DeclaringMethod%2A> właściwość, parametru typu ogólnego metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-284">When displaying information about the type parameters of the generic method definition, in the `DisplayGenericMethodInfo` method, the example code shows the value of the <xref:System.Type.DeclaringMethod%2A> property for the method's generic type parameter.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="9cc50-285">Odbicie i typy ogólne</span><span class="sxs-lookup"><span data-stu-id="9cc50-285">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="9cc50-286">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</span><span class="sxs-lookup"><span data-stu-id="9cc50-286">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-287">Pobiera typ, który deklaruje bieżącego typu zagnieżdżonego lub parametr typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-287">Gets the type that declares the current nested type or generic type parameter.</span></span></summary>
        <value><span data-ttu-id="9cc50-288">A <see cref="T:System.Type" /> obiekt reprezentujący otaczający typ, jeśli bieżącym typem jest typ zagnieżdżony; lub definicji typu ogólnego, jeśli bieżącym typem jest parametr typu ogólnego; lub typ, który deklaruje metody rodzajowej, jeśli bieżącym typem jest parametr typu metody ogólnej; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-288">A <see cref="T:System.Type" /> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-289">Jeśli bieżący <xref:System.Type> obiekt reprezentuje parametr typu metody rodzajowej, właściwość ta zwraca definicji typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-289">If the current <xref:System.Type> object represents a type parameter of a generic type, this property returns the generic type definition.</span></span>  
  
 <span data-ttu-id="9cc50-290">Jeśli bieżący <xref:System.Type> obiekt reprezentuje parametr typu metody rodzajowej, właściwość ta zwraca typ, który zawiera definicję metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-290">If the current <xref:System.Type> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition.</span></span> <span data-ttu-id="9cc50-291">W przypadku typu ogólnego, definicja typu ogólnego jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-291">If the type is generic, the generic type definition is returned.</span></span> <span data-ttu-id="9cc50-292">Oznacza to, poniższy kod zwraca definicji typu rodzajowego <xref:System.Collections.Generic.List%601> klasy ogólnej, który zawiera <xref:System.Collections.Generic.List%601.ConvertAll%2A> metody ogólnej:</span><span class="sxs-lookup"><span data-stu-id="9cc50-292">That is, the following code returns the generic type definition of the <xref:System.Collections.Generic.List%601> generic class, which contains the <xref:System.Collections.Generic.List%601.ConvertAll%2A> generic method:</span></span>  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="9cc50-293">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, <xref:System.Type.DeclaringType%2A> i <xref:System.Type.DeclaringMethod%2A> zidentyfikować właściwości w definicji typu ogólnego lub metody rodzajowej definicji, gdzie parametr typu ogólnego została pierwotnie zdefiniowana:</span><span class="sxs-lookup"><span data-stu-id="9cc50-293">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, the <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="9cc50-294">Jeśli <xref:System.Type.DeclaringMethod%2A> właściwość zwraca <xref:System.Reflection.MethodInfo>, które <xref:System.Reflection.MethodInfo> reprezentuje definicję metody rodzajowej, a bieżący <xref:System.Type> obiekt reprezentuje parametr typu tej definicji metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-294">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="9cc50-295">Jeśli <xref:System.Type.DeclaringMethod%2A> właściwość zwraca `null`, a następnie <xref:System.Type.DeclaringType%2A> właściwość zawsze zwraca <xref:System.Type> obiekt reprezentujący definicji typu ogólnego i bieżący <xref:System.Type> obiekt reprezentuje parametr typu ogólnego typu Definicja.</span><span class="sxs-lookup"><span data-stu-id="9cc50-295">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="9cc50-296">Wprowadzenie <xref:System.Type.DeclaringType%2A> właściwość typu którego <xref:System.Type.IsGenericParameter%2A> właściwość `false` zgłasza <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-296">Getting the <xref:System.Type.DeclaringType%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-297">Ten przykład Wyświetla typ deklarujący metody w klasie pochodnej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-297">This example displays the declaring type of a method in a derived class.</span></span>  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-298">Pobiera odwołanie do domyślnego integratora, który implementuje wewnętrzne zasady dotyczące wybierania odpowiednich elementów członkowskich, które ma zostać wywołana przez <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-298">Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span></summary>
        <value><span data-ttu-id="9cc50-299">Odwołanie do domyślnego integratora używaną przez system.</span><span class="sxs-lookup"><span data-stu-id="9cc50-299">A reference to the default binder used by the system.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-300">Domyślny integrator dołączonym środowiska uruchomieniowego języka wspólnego jest stosowana we wszystkich oprócz najbardziej wyspecjalizowaną okoliczności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-300">The default binder provided with the common language runtime is applicable in all but the most specialized circumstances.</span></span> <span data-ttu-id="9cc50-301">Jeśli potrzebujesz integratora definiują reguły poniżej, które różnią się od skoroszytu domyślną dostarczony typ pochodzący od <xref:System.Reflection.Binder> klasy i przekaż wystąpienie tego typu za pomocą `binder` parametr jednego z <xref:System.Type.InvokeMember%2A> przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-301">If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <xref:System.Reflection.Binder> class and pass an instance of that type using the `binder` parameter of one of the <xref:System.Type.InvokeMember%2A> overloads.</span></span>  
  
 <span data-ttu-id="9cc50-302">Odbicie modeli reguły ułatwień dostępu wspólny system typów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-302">Reflection models the accessibility rules of the common type system.</span></span> <span data-ttu-id="9cc50-303">Na przykład jeśli obiekt wywołujący znajduje się w tym samym zestawie, obiekt wywołujący nie potrzebne żadne specjalne uprawnienia dla wewnętrznych składowych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-303">For example, if the caller is in the same assembly, the caller does not need special permissions for internal members.</span></span> <span data-ttu-id="9cc50-304">W przeciwnym razie wywołujący musi mieć <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-304">Otherwise, the caller needs <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="9cc50-305">Jest to zgodne z wyszukiwania elementów członkowskich, które są chronione, prywatne i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-305">This is consistent with lookup of members that are protected, private, and so on.</span></span>  
  
 <span data-ttu-id="9cc50-306">Ogólną zasadą jest fakt, że <xref:System.Reflection.Binder.ChangeType%2A> należy wykonać tylko do poszerzenia konwersje, które nigdy nie utracą danych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-306">The general principle is that <xref:System.Reflection.Binder.ChangeType%2A> should perform only widening conversions, which never lose data.</span></span> <span data-ttu-id="9cc50-307">Przykładem konwersję rozszerzającą konwertuje wartość całkowita 32-bitowa wartość całkowita 64-bitowych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-307">An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer.</span></span> <span data-ttu-id="9cc50-308">Jest to odróżnić od konwersją zawężającą może spowodować utratę danych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-308">This is distinguished from a narrowing conversion, which may lose data.</span></span> <span data-ttu-id="9cc50-309">Przykład konwersja zawężająca jest konwersja całkowita 64-bitowego na całkowita 32-bitowych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-309">An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.</span></span>  
  
 <span data-ttu-id="9cc50-310">W poniższej tabeli wymieniono konwersje obsługiwane przez domyślny integrator.</span><span class="sxs-lookup"><span data-stu-id="9cc50-310">The following table lists the conversions supported by the default binder.</span></span>  
  
|<span data-ttu-id="9cc50-311">Typ źródła</span><span class="sxs-lookup"><span data-stu-id="9cc50-311">Source Type</span></span>|<span data-ttu-id="9cc50-312">Typ docelowy</span><span class="sxs-lookup"><span data-stu-id="9cc50-312">Target Type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="9cc50-313">Dowolnego typu</span><span class="sxs-lookup"><span data-stu-id="9cc50-313">Any type</span></span>|<span data-ttu-id="9cc50-314">Jego typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-314">Its base type.</span></span>|  
|<span data-ttu-id="9cc50-315">Dowolnego typu</span><span class="sxs-lookup"><span data-stu-id="9cc50-315">Any type</span></span>|<span data-ttu-id="9cc50-316">Interfejs, który implementuje.</span><span class="sxs-lookup"><span data-stu-id="9cc50-316">The interface it implements.</span></span>|  
|<span data-ttu-id="9cc50-317">Char</span><span class="sxs-lookup"><span data-stu-id="9cc50-317">Char</span></span>|<span data-ttu-id="9cc50-318">Unt16, UInt32, Int32, UInt64, Int64, pojedynczy Double</span><span class="sxs-lookup"><span data-stu-id="9cc50-318">Unt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="9cc50-319">Byte</span><span class="sxs-lookup"><span data-stu-id="9cc50-319">Byte</span></span>|<span data-ttu-id="9cc50-320">Char, Unt16 Int16, UInt32, Int32, UInt64, Int64, pojedynczy Double</span><span class="sxs-lookup"><span data-stu-id="9cc50-320">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="9cc50-321">SByte</span><span class="sxs-lookup"><span data-stu-id="9cc50-321">SByte</span></span>|<span data-ttu-id="9cc50-322">Int16, Int32, Int64, pojedynczy Double</span><span class="sxs-lookup"><span data-stu-id="9cc50-322">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="9cc50-323">UInt16</span><span class="sxs-lookup"><span data-stu-id="9cc50-323">UInt16</span></span>|<span data-ttu-id="9cc50-324">UInt32, Int32, UInt64, Int64, pojedynczy Double</span><span class="sxs-lookup"><span data-stu-id="9cc50-324">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="9cc50-325">Int16</span><span class="sxs-lookup"><span data-stu-id="9cc50-325">Int16</span></span>|<span data-ttu-id="9cc50-326">Int32, Int64, pojedynczy Double</span><span class="sxs-lookup"><span data-stu-id="9cc50-326">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="9cc50-327">UInt32</span><span class="sxs-lookup"><span data-stu-id="9cc50-327">UInt32</span></span>|<span data-ttu-id="9cc50-328">UInt64, Int64, pojedynczy Double</span><span class="sxs-lookup"><span data-stu-id="9cc50-328">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="9cc50-329">Int32</span><span class="sxs-lookup"><span data-stu-id="9cc50-329">Int32</span></span>|<span data-ttu-id="9cc50-330">Int64, jeden dwukrotnie</span><span class="sxs-lookup"><span data-stu-id="9cc50-330">Int64, Single, Double</span></span>|  
|<span data-ttu-id="9cc50-331">UInt64</span><span class="sxs-lookup"><span data-stu-id="9cc50-331">UInt64</span></span>|<span data-ttu-id="9cc50-332">Pojedynczy Double</span><span class="sxs-lookup"><span data-stu-id="9cc50-332">Single, Double</span></span>|  
|<span data-ttu-id="9cc50-333">Int64</span><span class="sxs-lookup"><span data-stu-id="9cc50-333">Int64</span></span>|<span data-ttu-id="9cc50-334">Pojedynczy Double</span><span class="sxs-lookup"><span data-stu-id="9cc50-334">Single, Double</span></span>|  
|<span data-ttu-id="9cc50-335">Single</span><span class="sxs-lookup"><span data-stu-id="9cc50-335">Single</span></span>|<span data-ttu-id="9cc50-336">Double</span><span class="sxs-lookup"><span data-stu-id="9cc50-336">Double</span></span>|  
|<span data-ttu-id="9cc50-337">Non-reference</span><span class="sxs-lookup"><span data-stu-id="9cc50-337">Non-reference</span></span>|<span data-ttu-id="9cc50-338">Przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-338">By-reference.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-339">Poniższy przykład pobiera domyślnego integratora z `DefaultBinder` właściwości i wywołuje członka MyClass przez przekazanie `DefaultBinder` wartość jako parametr do <xref:System.Type.InvokeMember%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-339">The following example gets the default binder from the `DefaultBinder` property, and invokes a member of MyClass by passing the `DefaultBinder` value as a parameter to <xref:System.Type.InvokeMember%2A>.</span></span>  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-340">Oddziela nazwy w przestrzeni nazw <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-340">Separates names in the namespace of the <see cref="T:System.Type" />.</span></span> <span data-ttu-id="9cc50-341">To pole jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-341">This field is read-only.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-342">Reprezentuje pustą tablicę typu <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-342">Represents an empty array of type <see cref="T:System.Type" />.</span></span> <span data-ttu-id="9cc50-343">To pole jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-343">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="9cc50-344">Poniższy kod przedstawia przykład `EmptyTypes` pole używane w jednym z `GetConstructor` metody w celu uzyskania konstruktora, który nie przyjmuje żadnych parametrów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-344">The following code example shows the `EmptyTypes` field used in one of the `GetConstructor` methods to get a constructor that takes no parameters.</span></span>  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cc50-345">Określa, czy typ podstawowy system bieżącego <see cref="T:System.Type" /> jest taka sama jak system typem podstawowym określonego <see cref="T:System.Object" /> lub <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-345">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Object" /> or <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="9cc50-346">Obiektu, którego podstawowym typem systemu jest ma zostać porównane z podstawowym typem systemu bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-346">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span></span> <span data-ttu-id="9cc50-347">Porównanie zakończyło się sukcesem <paramref name="o" /> musi być w stanie rzutowania lub przekonwertować na obiekt typu <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-347">For the comparison to succeed, <paramref name="o" /> must be able to be cast or converted to an object of type   <see cref="T:System.Type" />.</span></span></param>
        <summary><span data-ttu-id="9cc50-348">Określa, czy typ podstawowy system bieżącego <see cref="T:System.Type" /> obiekt jest taki sam jak systemu typem podstawowym określonego <see cref="T:System.Object" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-348">Determines if the underlying system type of the current <see cref="T:System.Type" /> object is the same as the underlying system type of the specified <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="9cc50-349"><see langword="true" /> Jeśli typ podstawowy system <paramref name="o" /> jest taka sama jak podstawowym typem systemu bieżącego <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-349"><see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9cc50-350">Ta metoda zwraca też wartość <see langword="false" /> przypadku:.</span><span class="sxs-lookup"><span data-stu-id="9cc50-350">This method also returns <see langword="false" /> if: .</span></span>  
  <span data-ttu-id="9cc50-351">
-   <paramref name="o" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-351">
-   <paramref name="o" /> is <see langword="null" />.</span></span>  
  <span data-ttu-id="9cc50-352">
-   <paramref name="o" /> Nie można rzutować lub przekonwertowane na <see cref="T:System.Type" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-352">
-   <paramref name="o" /> cannot be cast or converted to a <see cref="T:System.Type" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-353">Ta metoda zastępuje <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-353">This method overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cc50-354">Rzuca `o` do obiektu typu <xref:System.Type> i wywołuje <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-354">It casts `o` to an object of type <xref:System.Type> and calls the <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-355">W poniższym przykładzie użyto <xref:System.Type.Equals%28System.Object%29> porównywanie różnych <xref:System.Type> obiektu wystąpień z różnymi <xref:System.Object> wystąpień.</span><span class="sxs-lookup"><span data-stu-id="9cc50-355">The following example uses <xref:System.Type.Equals%28System.Object%29> to compare various <xref:System.Type> object instances with various <xref:System.Object> instances.</span></span>  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 <span data-ttu-id="9cc50-356">Dwie rzeczy są szczególnie, warte odnotowania o w przykładzie:</span><span class="sxs-lookup"><span data-stu-id="9cc50-356">Two things are particularly worth noting about the example:</span></span>  
  
-   <span data-ttu-id="9cc50-357">Porównanie <xref:System.Type> obiekt, który reprezentuje liczbę całkowitą z <xref:System.Reflection.TypeInfo> obiekt, który reprezentuje liczbę całkowitą zwracany `true` ponieważ <xref:System.Reflection.TypeInfo> jest tworzony na podstawie <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-357">The comparison of a <xref:System.Type> object that represents an integer with a <xref:System.Reflection.TypeInfo> object that represents an integer return `true` because <xref:System.Reflection.TypeInfo> is derived from <xref:System.Type>.</span></span>  
  
-   <span data-ttu-id="9cc50-358">Porównanie <xref:System.Type> obiekt, który reprezentuje <xref:System.Collections.Generic.IList%601> obiektu (otwartym typem ogólnym) z `List(Of String)` (zamknięty typ rodzajowy) zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-358">The comparison of a  <xref:System.Type> object that represents a <xref:System.Collections.Generic.IList%601> object (an open generic type) with a `List(Of String)` object (a closed generic type) returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="9cc50-359">Obiektu, którego podstawowym typem systemu jest ma zostać porównane z podstawowym typem systemu bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-359">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span></span></param>
        <summary><span data-ttu-id="9cc50-360">Określa, czy typ podstawowy system bieżącego <see cref="T:System.Type" /> jest taka sama jak system typem podstawowym określonego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-360">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="9cc50-361"><see langword="true" /> Jeśli typ podstawowy system <paramref name="o" /> jest taka sama jak podstawowym typem systemu bieżącego <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-361"><see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="9cc50-362">W poniższym przykładzie użyto `Equals` do porównywania dwóch typów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-362">The following example uses `Equals` to compare two types.</span></span>  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-363">Reprezentuje filtr elementu członkowskiego, używane dla atrybutów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-363">Represents the member filter used on attributes.</span></span> <span data-ttu-id="9cc50-364">To pole jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-364">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-365">To pole zawiera odwołanie do delegata używany przez <xref:System.Type.FindMembers%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-365">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="9cc50-366">Metoda zamknięte przez ten delegat przyjmuje dwa parametry: pierwszy to <xref:System.Reflection.MemberInfo> obiektu, a drugi jest `Object`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-366">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="9cc50-367">Metoda określa, czy `MemberInfo` obiektu spełniający kryteria określone przez `Object`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-367">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="9cc50-368">`Object` Może mieć przypisaną taką wartość jednego pola na klasy <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, lub <xref:System.Reflection.MethodImplAttributes>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-368">The `Object` may be assigned the value of any one of the fields on the classes <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, or <xref:System.Reflection.MethodImplAttributes>.</span></span>  
  
 <span data-ttu-id="9cc50-369">Na przykład `Object` można przypisać wartości pola z `FieldAttributes` takim jak Public.</span><span class="sxs-lookup"><span data-stu-id="9cc50-369">For example, the `Object` can be assigned the value of a field from `FieldAttributes` such as Public.</span></span> <span data-ttu-id="9cc50-370">W takiej sytuacji, gdy `FilterAttribute` obiekt delegowany jest wywoływany, zwróci `true` tylko wtedy, gdy metoda jest reprezentowany przez `MemberInfo` obiektu zostanie nadany atrybut publiczne pole w metadanych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-370">In that case, when the `FilterAttribute` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object is decorated with the public field attribute in metadata.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-371">Poniższy przykład pobiera `FilterAttribute` delegować, przekazuje go jako parametr do <xref:System.Type.FindMembers%2A> metodę i wyświetla określonych elementów i ich atrybutów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-371">The following example gets the `FilterAttribute` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the specified members and their attributes.</span></span>  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-372">Reprezentuje filtr Członek uwzględniana wielkość liter, używane w nazwach.</span><span class="sxs-lookup"><span data-stu-id="9cc50-372">Represents the case-sensitive member filter used on names.</span></span> <span data-ttu-id="9cc50-373">To pole jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-373">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-374">To pole zawiera odwołanie do delegata używany przez <xref:System.Type.FindMembers%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-374">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="9cc50-375">Metoda zamknięte przez ten delegat przyjmuje dwa parametry: pierwszy to <xref:System.Reflection.MemberInfo> obiektu, a drugi jest `Object`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-375">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="9cc50-376">Metoda określa, czy `MemberInfo` obiektu spełniający kryteria określone przez `Object`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-376">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="9cc50-377">`Object` Jest przypisywana wartość ciągu, które mogą obejmować końcowe "\*" znak symbolu wieloznacznego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-377">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="9cc50-378">Tylko koniec ciągu dopasowanie z symbolami wieloznacznymi jest obsługiwany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-378">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="9cc50-379">Na przykład `Object` można przypisać wartości "Bajtów \*".</span><span class="sxs-lookup"><span data-stu-id="9cc50-379">For example, the `Object` may be assigned the value "Byte\*".</span></span> <span data-ttu-id="9cc50-380">W takiej sytuacji, gdy `FilterName` obiekt delegowany jest wywoływany, zwróci `true` tylko wtedy, gdy metoda jest reprezentowany przez `MemberInfo` obiekt ma nazwę rozpoczynającą się od "Bajtów".</span><span class="sxs-lookup"><span data-stu-id="9cc50-380">In that case, when the `FilterName` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object has a name that begins with "Byte".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-381">Poniższy przykładowy kod pobiera metody skojarzone z zdefiniowany przez użytkownika `Application` typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-381">The following code example gets the methods associated with the user-defined `Application` type.</span></span>  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-382">Reprezentuje filtr Członek bez uwzględniania wielkości liter, używane w nazwach.</span><span class="sxs-lookup"><span data-stu-id="9cc50-382">Represents the case-insensitive member filter used on names.</span></span> <span data-ttu-id="9cc50-383">To pole jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-383">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-384">To pole zawiera odwołanie do delegata używany przez <xref:System.Type.FindMembers%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-384">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="9cc50-385">Metoda zamknięte przez ten delegat przyjmuje dwa parametry: pierwszy to <xref:System.Reflection.MemberInfo> obiektu, a drugi jest `Object`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-385">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="9cc50-386">Metoda określa, czy `MemberInfo` obiektu spełniający kryteria określone przez `Object`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-386">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="9cc50-387">`Object` Jest przypisywana wartość ciągu, które mogą obejmować końcowe "\*" znak symbolu wieloznacznego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-387">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="9cc50-388">Tylko koniec ciągu dopasowanie z symbolami wieloznacznymi jest obsługiwany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-388">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="9cc50-389">Na przykład `Object` można przypisać wartości "Bajtów \*".</span><span class="sxs-lookup"><span data-stu-id="9cc50-389">For example, the `Object` may be assigned the value "ByTe\*".</span></span> <span data-ttu-id="9cc50-390">W takiej sytuacji, gdy `FilterName` obiekt delegowany jest wywoływany, zwróci wartość true, tylko jeśli metoda jest reprezentowany przez `MemberInfo` obiekt ma nazwę rozpoczynającą się od "bajtów", bez uwzględnienia wielkości liter.</span><span class="sxs-lookup"><span data-stu-id="9cc50-390">In that case, when the `FilterName` delegate is invoked, it will return true only if the method represented by the `MemberInfo` object has a name that begins with "byte", ignoring case.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-391">Poniższy przykład pobiera `MemberFilter` delegować, przekazuje go jako parametr do <xref:System.Type.FindMembers%2A> metodę i wyświetla metod i ich atrybuty `String` klasy, które zaczynają się od litera "c", nie biorąc pod uwagę w przypadku.</span><span class="sxs-lookup"><span data-stu-id="9cc50-391">The following example gets the `MemberFilter` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the methods and their attributes of the `String` class that begin with the letter "c", disregarding the case.</span></span>  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="filter"><span data-ttu-id="9cc50-392">Delegat, który porównuje interfejsów względem <paramref name="filterCriteria" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-392">The delegate that compares the interfaces against <paramref name="filterCriteria" />.</span></span></param>
        <param name="filterCriteria"><span data-ttu-id="9cc50-393">Kryteria wyszukiwania, które określa, czy interfejs powinny być objęte zwróconej tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-393">The search criteria that determines whether an interface should be included in the returned array.</span></span></param>
        <summary><span data-ttu-id="9cc50-394">Zwraca tablicę <see cref="T:System.Type" /> obiekty reprezentujące filtrowana lista interfejsy implementowane lub jest dziedziczona przez bieżący <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-394">Returns an array of <see cref="T:System.Type" /> objects representing a filtered list of interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="9cc50-395">Tablica <see cref="T:System.Type" /> obiekty reprezentujące filtrowana lista interfejsy implementowane lub jest dziedziczona przez bieżący <see cref="T:System.Type" />, lub pusta tablica typu <see cref="T:System.Type" /> Jeśli interfejsy nie jest zgodny z filtrem nie są implementowane lub dziedziczone przez bieżącą <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-395">An array of <see cref="T:System.Type" /> objects representing a filtered list of the interfaces implemented or inherited by the current <see cref="T:System.Type" />, or an empty array of type <see cref="T:System.Type" /> if no interfaces matching the filter are implemented or inherited by the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-396">Metoda ta może być zastąpiona przez klasę pochodną.</span><span class="sxs-lookup"><span data-stu-id="9cc50-396">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="9cc50-397"><xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> i <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegatów dostarczonych przez <xref:System.Reflection.Module?displayProperty=nameWithType> klasy może być również, w miejsce <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegować.</span><span class="sxs-lookup"><span data-stu-id="9cc50-397">The <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> and <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegates supplied by the <xref:System.Reflection.Module?displayProperty=nameWithType> class may also be used, in lieu of the <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegate.</span></span>  
  
 <span data-ttu-id="9cc50-398">Wszystkie interfejsy implementowane przez tę klasę są traktowane jako podczas wyszukiwania, czy podana przez klasę bazową lub tej samej klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-398">All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</span></span>  
  
 <span data-ttu-id="9cc50-399">Metoda ta wyszukuje w hierarchii klasy bazowej, zwracanie wszystkich zgodnych interfejsów, każda klasa implementuje, a także wszystkie zgodne każdego z tych interfejsów implementuje interfejsy (oznacza to, zwracana jest przechodnia zamknięcia zgodnych interfejsów).</span><span class="sxs-lookup"><span data-stu-id="9cc50-399">This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned).</span></span> <span data-ttu-id="9cc50-400">Brak interfejsów zduplikowane są zwracane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-400">No duplicate interfaces are returned.</span></span>  
  
 <span data-ttu-id="9cc50-401">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, <xref:System.Type.FindInterfaces%2A> wyszukiwanie wszystkich interfejsów zadeklarowanych w ograniczenia dla parametru typu, a wszystkie interfejsy dziedziczone za pośrednictwem interfejsów zadeklarowana w ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-401">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, <xref:System.Type.FindInterfaces%2A> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints.</span></span> <span data-ttu-id="9cc50-402">Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny, argument typu <xref:System.Type.FindInterfaces%2A> wyszukuje wszystkie interfejsy implementowane przez ten typ, czy też nie są zgodne z ograniczeniami.</span><span class="sxs-lookup"><span data-stu-id="9cc50-402">If the current <xref:System.Type> represents a type argument of a generic type, <xref:System.Type.FindInterfaces%2A> searches all the interfaces implemented by the type, whether or not they match constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-403"><xref:System.Type.FindInterfaces%2A> może zwracać interfejsów ogólnych, nawet w przypadku typów, które nie są rodzajowe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-403"><xref:System.Type.FindInterfaces%2A> can return generic interfaces, even on types that are not generic.</span></span> <span data-ttu-id="9cc50-404">Na przykład nierodzajowymi typ może implementować `IEnumerable<int>` (`IEnumerable(Of Integer)` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-404">For example, a nongeneric type might implement `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-405">Poniższy przykład umożliwia znalezienie określonego interfejsu implementowany lub dziedziczone przez określonego typu, a następnie wyświetla nazwy interfejsu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-405">The following example finds the specified interface implemented or inherited by the specified type, and then displays the interface names.</span></span>  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-406"><paramref name="filter" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-406"><paramref name="filter" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="9cc50-407">Statycznego inicjatora jest wywoływany i zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="9cc50-407">A static initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="memberType"><span data-ttu-id="9cc50-408">Obiekt, który określa typ elementu członkowskiego do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-408">An object that indicates the type of member to search for.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="9cc50-409">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-409">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-410">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-410">-or-</span></span> 
<span data-ttu-id="9cc50-411">Zero, aby zwrócić <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-411">Zero, to return <see langword="null" />.</span></span></param>
        <param name="filter"><span data-ttu-id="9cc50-412">Delegat, który wykonuje porównania, zwracając <see langword="true" /> elementu członkowskiego aktualnie inspekcji dopasowania <paramref name="filterCriteria" /> i <see langword="false" /> inaczej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-412">The delegate that does the comparisons, returning <see langword="true" /> if the member currently being inspected matches the <paramref name="filterCriteria" /> and <see langword="false" /> otherwise.</span></span> <span data-ttu-id="9cc50-413">Możesz użyć <see langword="FilterAttribute" />, <see langword="FilterName" />, i <see langword="FilterNameIgnoreCase" /> delegatów, dostarczone przez tę klasę.</span><span class="sxs-lookup"><span data-stu-id="9cc50-413">You can use the <see langword="FilterAttribute" />, <see langword="FilterName" />, and <see langword="FilterNameIgnoreCase" /> delegates supplied by this class.</span></span> <span data-ttu-id="9cc50-414">Pierwszy używa pól <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, i <see langword="MethodImplAttributes" /> jako kryteria wyszukiwania, a następnie użyj dwa delegaty <see langword="String" /> obiektów jako kryterium wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-414">The first uses the fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> as search criteria, and the other two delegates use <see langword="String" /> objects as the search criteria.</span></span></param>
        <param name="filterCriteria"><span data-ttu-id="9cc50-415">Kryteria wyszukiwania, które określa, czy członek jest zwracany w tablicy <see langword="MemberInfo" /> obiektów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-415">The search criteria that determines whether a member is returned in the array of <see langword="MemberInfo" /> objects.</span></span>  
  
<span data-ttu-id="9cc50-416">Pola <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, i <see langword="MethodImplAttributes" /> mogą być używane w połączeniu z <see langword="FilterAttribute" /> delegata dostarczonych przez tę klasę.</span><span class="sxs-lookup"><span data-stu-id="9cc50-416">The fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> can be used in conjunction with the <see langword="FilterAttribute" /> delegate supplied by this class.</span></span></param>
        <summary><span data-ttu-id="9cc50-417">Zwraca tablicę filtrowane <see cref="T:System.Reflection.MemberInfo" /> obiektów typu określonego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-417">Returns a filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span></span></summary>
        <returns><span data-ttu-id="9cc50-418">Filtrowane tablicę <see cref="T:System.Reflection.MemberInfo" /> obiektów typu określonego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-418">A filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span></span>  
  
<span data-ttu-id="9cc50-419">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-419">-or-</span></span> 
<span data-ttu-id="9cc50-420">Pusta tablica typu <see cref="T:System.Reflection.MemberInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma elementów członkowskich typu <paramref name="memberType" /> pasujących do kryteriów filtrowania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-420">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have members of type <paramref name="memberType" /> that match the filter criteria.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-421">Metoda ta może być zastąpiona przez klasę pochodną.</span><span class="sxs-lookup"><span data-stu-id="9cc50-421">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="9cc50-422">Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-422">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="9cc50-423">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania elementów członkowskich, które można uwzględnić w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-423">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-424">Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-424">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-425">Określ `BindingFlags.Instance` obejmujący składowych wystąpienia w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-425">Specify `BindingFlags.Instance` to include instance members in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-426">Określ `BindingFlags.Static` obejmujący statyczne elementy członkowskie w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-426">Specify `BindingFlags.Static` to include static members in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-427">Określ `BindingFlags.Public` obejmujący publiczne elementy członkowskie w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-427">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-428">Określ `BindingFlags.NonPublic` obejmujący elementów członkowskich niepublicznych (czyli prywatne, wewnętrzne i chronione elementy członkowskie) w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-428">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
 <span data-ttu-id="9cc50-429">Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:</span><span class="sxs-lookup"><span data-stu-id="9cc50-429">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="9cc50-430">`BindingFlags.DeclaredOnly` Aby wyszukać tylko do elementów członkowskich zadeklarowanych w <xref:System.Type>, nie elementów członkowskich, które zostały po prostu odziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-430">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="9cc50-431">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-431">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="9cc50-432">Prawidłowe wartości dla <xref:System.Type.MemberType%2A> są zdefiniowane w <xref:System.Reflection.MemberInfo>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-432">Valid values for <xref:System.Type.MemberType%2A> are defined in <xref:System.Reflection.MemberInfo>.</span></span> <span data-ttu-id="9cc50-433">Jeśli nie zostaną znalezione nie takich członków, zwracany jest pusta tablica.</span><span class="sxs-lookup"><span data-stu-id="9cc50-433">If no such members are found, an empty array is returned.</span></span>  
  
 <span data-ttu-id="9cc50-434">Aby uzyskać inicjatora klasy (.cctor), za pomocą tej metody, należy określić <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-434">To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="9cc50-435">Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-435">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="9cc50-436">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego lub metody rodzajowej, <xref:System.Type.FindMembers%2A> przetwarza wszystkie elementy członkowskie zadeklarowana przez ograniczenia klasy i ograniczenia interfejsu, parametru typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-436">If the current <xref:System.Type> represents a type parameter of a generic type or generic method, <xref:System.Type.FindMembers%2A> processes any members declared by the class constraint and the interface constraints of the type parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-437">Poniższy przykład umożliwia znalezienie wszystkich elementów członkowskich w klasie, spełniających określone kryteria wyszukiwania, a następnie wyświetla dopasowane elementy członkowskie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-437">The following example finds all the members in a class that match the specified search criteria, and then displays the matched members.</span></span>  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-438"><paramref name="filter" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-438"><paramref name="filter" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-439">Pobiera w pełni kwalifikowaną nazwę typu, łącznie z jego przestrzeń nazw, ale nie jej zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-439">Gets the fully qualified name of the type, including its namespace but not its assembly.</span></span></summary>
        <value><span data-ttu-id="9cc50-440">W pełni kwalifikowaną nazwę typu, łącznie z jego przestrzeń nazw, ale nie jej zestawu; lub <see langword="null" /> Jeśli bieżące wystąpienie reprezentuje parametr typu ogólnego, typ tablicy, typ wskaźnika lub <see langword="byref" /> typu na podstawie parametru typu lub typ ogólny, który nie jest definicja typu ogólnego, ale zawiera nierozpoznany typ parametrów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-440">The fully qualified name of the type, including its namespace but not its assembly; or <see langword="null" /> if the current instance represents a generic type parameter, an array type, pointer type, or <see langword="byref" /> type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-441">Na przykład w pełni kwalifikowanej nazwy <xref:System.String> typ jest `System.String`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-441">For example, the fully qualified name of the <xref:System.String> type is `System.String`.</span></span> <span data-ttu-id="9cc50-442">Natomiast to nazwą kwalifikowaną dla zestawu zwrócony przez <xref:System.Type.AssemblyQualifiedName%2A> właściwość, która składa się z pełną nazwę i nazwę pełnego zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-442">Contrast this with the assembly-qualified name returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, which consists of the full name plus the full assembly name.</span></span>  
  
 <span data-ttu-id="9cc50-443">Jeśli bieżący typ reprezentuje zamknięty typ ogólny, argumentów typu ciąg zwracany przez <xref:System.Type.FullName%2A> właściwości są kwalifikowane według nazwy pełnego zestawu nawet reprezentację ciągu typu ogólnego, sama nie kwalifikuje się przez jego pełnej Nazwa zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-443">If the current type represents a closed generic type, the type arguments in the string returned by the <xref:System.Type.FullName%2A> property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name.</span></span> <span data-ttu-id="9cc50-444">Poniższy przykład ilustruje tę różnicę we właściwości FullName dla typu, który reprezentuje definicji typu ogólnego i taki, który reprezentuje typ ogólny, zamknięte.</span><span class="sxs-lookup"><span data-stu-id="9cc50-444">The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.</span></span>  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 <span data-ttu-id="9cc50-445">Ta właściwość zwraca `null` jeśli:</span><span class="sxs-lookup"><span data-stu-id="9cc50-445">This property returns `null` if:</span></span>  
  
-   <span data-ttu-id="9cc50-446">Bieżący <xref:System.Type> obiekt reprezentuje parametr typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-446">The current <xref:System.Type> object represents a type parameter of a generic type.</span></span>  
  
     <span data-ttu-id="9cc50-447">Poniższy przykład pobiera parametr typu <xref:System.Nullable%601> typu i próbuje wyświetlić jego <xref:System.Type.FullName%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-447">The following example retrieves the type parameter of the <xref:System.Nullable%601> type and attempts to display its <xref:System.Type.FullName%2A> property.</span></span>  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   <span data-ttu-id="9cc50-448">Bieżący <xref:System.Type> obiekt reprezentuje typ tablicy, typem wskaźnika lub `byref` typ, który jest oparty na parametr typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-448">The current <xref:System.Type> object represents an array type, a pointer  type, or a `byref` type that is based on a generic type parameter.</span></span>  
  
     <span data-ttu-id="9cc50-449">W poniższym przykładzie zdefiniowano typ ogólny, `Generictype1<T>`, za pomocą trzech metod: `Display(T[])`, która jest przekazywana tablicę typu T; `HandleT(T)`, który jest przekazywany obiekt T; a `ChangeValue(ref T)`, który jest przekazywany obiekt T przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-449">The following example defines a generic type, `Generictype1<T>`, with three methods: `Display(T[])`, which is passed an array of type T; `HandleT(T)`, which is passed a T object; and `ChangeValue(ref T)`, which is passed a T object by reference.</span></span> <span data-ttu-id="9cc50-450">Ponieważ języka C# i Visual Basic nie pozwalają nam T jest definiowana jako wskaźnik w `HandleT` metody, konieczne jest wywołanie <xref:System.Type.MakePointerType%2A> metody <xref:System.Type> obiekt, który reprezentuje typ parametru metody, aby utworzyć wskaźnik do typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-450">Because C# and Visual Basic do not allow us to define T as a pointer in the `HandleT` method, we have to call the <xref:System.Type.MakePointerType%2A> method on the <xref:System.Type> object that represents the method's parameter type to create a pointer to a generic type.</span></span> <span data-ttu-id="9cc50-451">Dane wyjściowe z przykładu pokazuje, że we wszystkich trzech przypadkach <xref:System.Type.FullName%2A> właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-451">The output from the example shows that in all three cases, the <xref:System.Type.FullName%2A> property is `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   <span data-ttu-id="9cc50-452">Bieżący typ zawiera parametry typu ogólnego, które nie zostały zastąpione przez określone typy (oznacza to, <xref:System.Type.ContainsGenericParameters%2A> właściwość zwraca `true`), ale nie jest to typ definicji typu ogólnego (oznacza to, że <xref:System.Type.IsGenericTypeDefinition%2A> zwraca właściwości `false`</span><span class="sxs-lookup"><span data-stu-id="9cc50-452">The current type contains generic type parameters that have not been replaced by specific types (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`), but the type is not a generic type definition (that is, the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `false`</span></span>  
  
     <span data-ttu-id="9cc50-453">W poniższym przykładzie `Derived<T>` dziedziczy `Base<T>`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-453">In the following example, `Derived<T>` inherits from `Base<T>`.</span></span> <span data-ttu-id="9cc50-454"><xref:System.Type.BaseType%2A> Uzyskuje właściwość <xref:System.Type> obiekt, który reprezentuje typ podstawowy elementu `Derived<T>`, a jego <xref:System.Type.FullName%2A> właściwość zwraca `null`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-454">The <xref:System.Type.BaseType%2A> property obtains the  <xref:System.Type> object that represents the base type of `Derived<T>`, and its <xref:System.Type.FullName%2A> property returns `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     <span data-ttu-id="9cc50-455">Aby uzyskać <xref:System.Type.FullName%2A> , który nie jest `null`, możesz użyć <xref:System.Type.GetGenericTypeDefinition%2A> metodę, aby uzyskać definicji typu ogólnego, tak jak pokazano w przykładzie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-455">To get a <xref:System.Type.FullName%2A> that is not `null`, you can use the <xref:System.Type.GetGenericTypeDefinition%2A> method to get the generic type definition, as the example illustrates.</span></span>  
  
 <span data-ttu-id="9cc50-456">Ta właściwość jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-456">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-457">Poniższy przykład Wyświetla pełną nazwę określonego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-457">The following example displays the full name of the specified type.</span></span>  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 <span data-ttu-id="9cc50-458">W poniższym przykładzie porównano ciągów zwracanych przez <xref:System.Type.ToString%2A> metody i `Name`, <xref:System.Type.FullName%2A>, i <xref:System.Type.AssemblyQualifiedName%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-458">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="9cc50-459">Określanie w pełni kwalifikowanych nazw typów</span><span class="sxs-lookup"><span data-stu-id="9cc50-459">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-460">Pobiera kombinacji <see cref="T:System.Reflection.GenericParameterAttributes" /> flagi opisujące kowariancji i ograniczeń specjalnych bieżącego parametru typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-460">Gets a combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> flags that describe the covariance and special constraints of the current generic type parameter.</span></span></summary>
        <value><span data-ttu-id="9cc50-461">Bitowa kombinacja <see cref="T:System.Reflection.GenericParameterAttributes" /> wartości, które opisano kowariancji i ograniczeń specjalnych bieżącego parametru typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-461">A bitwise combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> values that describes the covariance and special constraints of the current generic type parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-462">Wartość tej właściwości zawiera flagi, które opisują, czy bieżący parametr typu ogólnego jest kowariantny i flagi opisujące żadnych szczególnych ograniczeń.</span><span class="sxs-lookup"><span data-stu-id="9cc50-462">The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints.</span></span> <span data-ttu-id="9cc50-463">Użyj <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> wartość, aby wybrać flagi Kowariancja, a następnie użyj <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> wartość, aby wybrać flagi ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-463">Use the <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> value to select the covariance flags, and use the <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> value to select the constraint flags.</span></span>  
  
 <span data-ttu-id="9cc50-464">Aby uzyskać listę niezmiennych warunków dla terminów używanych w odbiciu rodzajowym, zobacz <xref:System.Type.IsGenericType%2A> uwagi dotyczące właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-464">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-465">Poniższy kod definiuje typ ogólny `Test` z dwoma parametrami typu, które mają z nią związane inne ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-465">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="9cc50-466">Gdy program będzie działać, ograniczenia są sprawdzane przy użyciu <xref:System.Type.GenericParameterAttributes%2A> właściwości i <xref:System.Type.GetGenericParameterConstraints%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-466">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cc50-467">Bieżący <see cref="T:System.Type" /> obiektu nie jest parametrem typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-467">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span></span> <span data-ttu-id="9cc50-468">Oznacza to, że <see cref="P:System.Type.IsGenericParameter" /> właściwość zwraca <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-468">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cc50-469">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-469">The invoked method is not supported in the base class.</span></span></exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="9cc50-470">Odbicie i typy ogólne</span><span class="sxs-lookup"><span data-stu-id="9cc50-470">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="9cc50-471">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</span><span class="sxs-lookup"><span data-stu-id="9cc50-471">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-472">Pobiera pozycję parametr typu na liście parametrów typu ogólnego typu lub metody, który zadeklarowany parametr, gdy <see cref="T:System.Type" /> obiekt reprezentuje parametr typu ogólnego lub metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-472">Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <see cref="T:System.Type" /> object represents a type parameter of a generic type or a generic method.</span></span></summary>
        <value><span data-ttu-id="9cc50-473">Pozycja parametru typu na liście parametrów typu dla typu ogólnego lub metody, która definiuje parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-473">The position of a type parameter in the type parameter list of the generic type or method that defines the parameter.</span></span> <span data-ttu-id="9cc50-474">Rozpocznij Pozycja cyfry od 0.</span><span class="sxs-lookup"><span data-stu-id="9cc50-474">Position numbers begin at 0.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-475"><xref:System.Type.GenericParameterPosition%2A> Właściwość zwraca pozycja parametru typu na liście parametrów w definicji typu ogólnego lub metody rodzajowej definicji gdzie parametr typu została pierwotnie zdefiniowana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-475">The <xref:System.Type.GenericParameterPosition%2A> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined.</span></span> <span data-ttu-id="9cc50-476"><xref:System.Type.DeclaringType%2A> i <xref:System.Type.DeclaringMethod%2A> właściwości określania ogólnego definicji typu lub metody:</span><span class="sxs-lookup"><span data-stu-id="9cc50-476">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type or method definition:</span></span>  
  
-   <span data-ttu-id="9cc50-477">Jeśli <xref:System.Type.DeclaringMethod%2A> właściwość zwraca <xref:System.Reflection.MethodInfo>, które <xref:System.Reflection.MethodInfo> reprezentuje definicję metody rodzajowej, a bieżący <xref:System.Type> obiekt reprezentuje parametr typu tej definicji metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-477">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="9cc50-478">Jeśli <xref:System.Type.DeclaringMethod%2A> właściwość zwraca `null`, a następnie <xref:System.Type.DeclaringType%2A> właściwość zawsze zwraca <xref:System.Type> obiekt reprezentujący definicji typu ogólnego i bieżący <xref:System.Type> obiekt reprezentuje parametr typu ogólnego typu Definicja.</span><span class="sxs-lookup"><span data-stu-id="9cc50-478">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
 <span data-ttu-id="9cc50-479">Aby zapewnić poprawny kontekst dla wartości <xref:System.Type.GenericParameterPosition%2A> właściwości jest niezbędne do identyfikowania typu ogólnego lub metody z parametrem typu, o których należy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-479">To provide the correct context for the value of the <xref:System.Type.GenericParameterPosition%2A> property, it is necessary to identify the generic type or method a type parameter belongs to.</span></span> <span data-ttu-id="9cc50-480">Rozważmy na przykład wartość zwracaną metody ogólnej `GetSomething` w poniższym kodzie:</span><span class="sxs-lookup"><span data-stu-id="9cc50-480">For example, consider the return value of the generic method `GetSomething` in the following code:</span></span>  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 <span data-ttu-id="9cc50-481">Typ zwracany przez `GetSomething` zależy od argumentów typu przekazana do klasy `A` i `GetSomething` sam.</span><span class="sxs-lookup"><span data-stu-id="9cc50-481">The type returned by `GetSomething` depends on the type arguments supplied to class `A` and to `GetSomething` itself.</span></span> <span data-ttu-id="9cc50-482">Możesz uzyskać <xref:System.Reflection.MethodInfo> dla `GetSomething`, i przy jego użyciu można uzyskać typ zwracany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-482">You can obtain a <xref:System.Reflection.MethodInfo> for `GetSomething`, and from that you can obtain the return type.</span></span> <span data-ttu-id="9cc50-483">Podczas badania parametrów typu zwracanego typu <xref:System.Type.GenericParameterPosition%2A> zwraca wartość 0 dla obu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-483">When you examine the type parameters of the return type, <xref:System.Type.GenericParameterPosition%2A> returns 0 for both.</span></span> <span data-ttu-id="9cc50-484">Pozycja `V` wynosi 0, ponieważ `V` pierwszego parametru typu na liście parametrów typu dla klasy `A`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-484">The position of `V` is 0 because `V` is the first type parameter in the type parameter list for class `A`.</span></span> <span data-ttu-id="9cc50-485">Pozycja `X` wynosi 0, ponieważ `X` pierwszego parametru typu na liście parametrów typu dla `GetSomething`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-485">The position of `X` is 0 because `X` is the first type parameter in the type parameter list for `GetSomething`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-486">Wywoływanie <xref:System.Type.GenericParameterPosition%2A> właściwości powoduje wyjątek, jeśli bieżący <xref:System.Type> nie reprezentuje parametr typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-486">Calling the <xref:System.Type.GenericParameterPosition%2A> property causes an exception if the current <xref:System.Type> does not represent a type parameter.</span></span> <span data-ttu-id="9cc50-487">Podczas badania argumentów typu otwartego skonstruowanego typu użycia <xref:System.Type.IsGenericParameter%2A> właściwość stwierdzić, którego parametrów typu i typów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-487">When you examine the type arguments of an open constructed type, use the <xref:System.Type.IsGenericParameter%2A> property to tell which are type parameters and which are types.</span></span> <span data-ttu-id="9cc50-488"><xref:System.Type.IsGenericParameter%2A> Właściwość zwraca `true` dla parametru typu; można następnie użyć <xref:System.Type.GenericParameterPosition%2A> metodę, aby uzyskać jego położenie i użyj <xref:System.Type.DeclaringMethod%2A> i <xref:System.Type.DeclaringType%2A> właściwości, aby określić metodę rodzajową lub definicji, który go definiuje typu .</span><span class="sxs-lookup"><span data-stu-id="9cc50-488">The <xref:System.Type.IsGenericParameter%2A> property returns `true` for a type parameter; you can then use the <xref:System.Type.GenericParameterPosition%2A> method to obtain its position and use the <xref:System.Type.DeclaringMethod%2A> and <xref:System.Type.DeclaringType%2A> properties to determine the generic method or type definition that defines it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-489">Poniższy przykład definiuje klasę ogólną z dwoma parametrami typu i definiuje klasę ogólną drugi wywodzi się z pierwszej klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-489">The following example defines a generic class with two type parameters and defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="9cc50-490">Klasa podstawowa dla klasy pochodnej ma dwa argumenty typu: pierwszy to <xref:System.Int32>, a drugą jest parametrem typu w typie pochodnym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-490">The derived class's base class has two type arguments: the first is <xref:System.Int32>, and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="9cc50-491">W przykładzie są wyświetlane informacje o tych klasach ogólnych, w tym pozycje raportowane przez <xref:System.Type.GenericParameterPosition%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-491">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cc50-492">Bieżący typ nie reprezentuje parametr typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-492">The current type does not represent a type parameter.</span></span> <span data-ttu-id="9cc50-493">Oznacza to, że <see cref="P:System.Type.IsGenericParameter" /> zwraca <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-493">That is, <see cref="P:System.Type.IsGenericParameter" /> returns <see langword="false" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="9cc50-494">Odbicie i typy ogólne</span><span class="sxs-lookup"><span data-stu-id="9cc50-494">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="9cc50-495">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</span><span class="sxs-lookup"><span data-stu-id="9cc50-495">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-496">Pobiera tablicę argumentów typu ogólnego dla tego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-496">Gets an array of the generic type arguments for this type.</span></span></summary>
        <value><span data-ttu-id="9cc50-497">Tablica argumenty typu generycznego, dla tego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-497">An array of the generic type arguments for this type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-498">Tej właściwości pobiera tylko argumenty typu generycznego; oznacza to, że typy, które zostały określone dla parametrów typu ogólnego bieżącego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-498">This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type.</span></span> <span data-ttu-id="9cc50-499">Jeśli bieżący typ jest definicja typu ogólnego, właściwość ta zwraca pustą tablicę.</span><span class="sxs-lookup"><span data-stu-id="9cc50-499">If the current type is a generic type definition, this property returns an empty array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-500">Jeśli typ ogólny jest używany w metody ogólnej lub w innym typem ogólnym, niektóre argumenty typu ogólnego może być otaczającej metody lub typu parametrów typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-500">If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.</span></span>  
  
 <span data-ttu-id="9cc50-501">Aby uzyskać parametry typu ogólnego typu, który reprezentuje definicję typu ogólnego, użyj <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-501">To get the generic type parameters of a type that represents a generic type definition, use the <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="9cc50-502">Aby uzyskać <xref:System.Reflection.TypeInfo> obiektu dla bieżącego <xref:System.Type> obiektu, należy użyć <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> — metoda rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-502">To get a <xref:System.Reflection.TypeInfo> object for the current <xref:System.Type> object, use the <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> extension method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-503">Pobiera liczbę wymiarów w tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-503">Gets the number of dimensions in an array.</span></span></summary>
        <returns><span data-ttu-id="9cc50-504">Liczba całkowita, która zawiera liczbę wymiarów w bieżącym typem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-504">An integer that contains the number of dimensions in the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="9cc50-505">Poniższy przykład wyświetla liczbę wymiarów w tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-505">The following example displays the number of dimensions in an array.</span></span>  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cc50-506">Funkcjonalność ta metoda nie jest obsługiwana w klasie bazowej i muszą być zaimplementowane w klasie pochodnej zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-506">The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-507">Bieżący typ nie jest tablicą.</span><span class="sxs-lookup"><span data-stu-id="9cc50-507">The current type is not an array.</span></span></exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-508">W przypadku przesłonięcia w klasie pochodnej, implementuje <see cref="P:System.Type.Attributes" /> właściwość i pobiera maskę bitów wskazującą atrybuty skojarzone z <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-508">When overridden in a derived class, implements the <see cref="P:System.Type.Attributes" /> property and gets a bitmask indicating the attributes associated with the <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="9cc50-509">A <see cref="T:System.Reflection.TypeAttributes" /> obiekt reprezentujący zestaw atrybutów <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-509">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cc50-510">Pobiera konstruktora określonego bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-510">Gets a specific constructor of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="types"><span data-ttu-id="9cc50-511">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla żądanego konstruktora.</span><span class="sxs-lookup"><span data-stu-id="9cc50-511">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the desired constructor.</span></span>  
  
<span data-ttu-id="9cc50-512">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-512">-or-</span></span> 
<span data-ttu-id="9cc50-513">Pusta tablica <see cref="T:System.Type" /> obiektów, można pobrać konstruktora, który nie przyjmuje żadnych parametrów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-513">An empty array of <see cref="T:System.Type" /> objects, to get a constructor that takes no parameters.</span></span> <span data-ttu-id="9cc50-514">Pusta tablica jest dostarczany przez <see langword="static" /> pola <see cref="F:System.Type.EmptyTypes" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-514">Such an empty array is provided by the <see langword="static" /> field <see cref="F:System.Type.EmptyTypes" />.</span></span></param>
        <summary><span data-ttu-id="9cc50-515">Wyszukiwanie konstruktora wystąpienia publicznego, w której parametry pasują do typów w określonej tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-515">Searches for a public instance constructor whose parameters match the types in the specified array.</span></span></summary>
        <returns><span data-ttu-id="9cc50-516">Reprezentuje obiekt konstruktora wystąpienia publicznego, w której parametry pasują do typów w tablicy typu parametru, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-516">An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-517">Tego przeciążenia metody szuka konstruktory publiczne wystąpienia i nie można uzyskać inicjatora klasy (.cctor).</span><span class="sxs-lookup"><span data-stu-id="9cc50-517">This method overload looks for public instance constructors and cannot be used to obtain a class initializer (.cctor).</span></span> <span data-ttu-id="9cc50-518">Aby uzyskać inicjatora klasy, użyj przeciążenia, które przyjmuje <xref:System.Reflection.BindingFlags>, a następnie określ <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-518">To get a class initializer, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="9cc50-519">Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-519">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="9cc50-520">Jeśli żądana Konstruktor jest niepublicznych, Metoda ta zwraca `null`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-520">If the requested constructor is non-public, this method returns `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-521">Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod.</span><span class="sxs-lookup"><span data-stu-id="9cc50-521">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="9cc50-522">Parametry można pominąć jedynie podczas wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-522">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="9cc50-523">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.ConstructorInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-523">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="9cc50-524">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta zwraca zawsze `null`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-524">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-525">W poniższym przykładzie uzyskano typ `MyClass`, pobiera <xref:System.Reflection.ConstructorInfo> obiektu, a następnie wyświetla sygnatury konstruktora.</span><span class="sxs-lookup"><span data-stu-id="9cc50-525">The following example obtains the type of `MyClass`, gets the <xref:System.Reflection.ConstructorInfo> object, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-526"><paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-526"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cc50-527">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-527">-or-</span></span> 
<span data-ttu-id="9cc50-528">Jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-528">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-529"><paramref name="types" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-529"><paramref name="types" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="9cc50-530">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-530">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-531">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-531">-or-</span></span> 
<span data-ttu-id="9cc50-532">Zero, aby zwrócić <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-532">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="9cc50-533">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-533">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="9cc50-534">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-534">-or-</span></span> 
<span data-ttu-id="9cc50-535">Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-535">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="types"><span data-ttu-id="9cc50-536">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla konstruktora, aby uzyskać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-536">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span></span>  
  
<span data-ttu-id="9cc50-537">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-537">-or-</span></span> 
<span data-ttu-id="9cc50-538">Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie konstruktora, który nie przyjmuje żadnych parametrów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-538">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span></span>  
  
<span data-ttu-id="9cc50-539">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-539">-or-</span></span> 
 <span data-ttu-id="9cc50-540"><see cref="F:System.Type.EmptyTypes" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-540"><see cref="F:System.Type.EmptyTypes" />.</span></span></param>
        <param name="modifiers"><span data-ttu-id="9cc50-541">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w tablicy typu parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-541">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the parameter type array.</span></span> <span data-ttu-id="9cc50-542">Domyślny konsolidator nie przetwarza tego parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-542">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="9cc50-543">Wyszukiwanie konstruktora, w której parametry odpowiadają określone typy argumentów i modyfikatorów, za pomocą ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-543">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="9cc50-544">A <see cref="T:System.Reflection.ConstructorInfo" /> obiekt reprezentujący Konstruktor, który spełnia określone wymagania, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-544">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-545">Jeśli nie istnieje dokładne dopasowanie, `binder` będzie próbował przekształcić typy parametrów określonych w `types` tablicy w celu wybrania dopasowania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-545">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="9cc50-546">Jeśli `binder` nie może wybrać dopasowania, następnie `null` jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-546">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="9cc50-547">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania, które z konstruktorów do uwzględnienia w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-547">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-548">Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-548">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-549">Określ `BindingFlags.Public` obejmujący konstruktorów publicznych w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-549">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-550">Określ `BindingFlags.NonPublic` obejmujący w w wyszukiwaniu konstruktory niepubliczne (czyli prywatne, wewnętrzne i chronione konstruktory).</span><span class="sxs-lookup"><span data-stu-id="9cc50-550">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="9cc50-551">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-551">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="9cc50-552">Aby uzyskać inicjatora klasy (.cctor), za pomocą tego przeciążenia metody, należy określić <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-552">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="9cc50-553">Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-553">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-554">Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod.</span><span class="sxs-lookup"><span data-stu-id="9cc50-554">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="9cc50-555">Parametry można pominąć jedynie podczas wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-555">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="9cc50-556">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.ConstructorInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-556">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="9cc50-557">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta zwraca zawsze `null`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-557">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-558">Następujący program uzyskuje typ `MyClass1` klasy pobiera <xref:System.Reflection.ConstructorInfo> obiektu dopasowania flagi określonego powiązania, a następnie wyświetla podpis konstruktora.</span><span class="sxs-lookup"><span data-stu-id="9cc50-558">The following program obtains the type of `MyClass1` class, gets the <xref:System.Reflection.ConstructorInfo> object matching the specified binding flags, and displays the signature of the constructor.</span></span>  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-559"><paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-559"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cc50-560">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-560">-or-</span></span> 
<span data-ttu-id="9cc50-561">Jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-561">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-562"><paramref name="types" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-562"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="9cc50-563">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-563">-or-</span></span> 
 <span data-ttu-id="9cc50-564"><paramref name="modifiers" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-564"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="9cc50-565">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-565">-or-</span></span> 
 <span data-ttu-id="9cc50-566"><paramref name="types" /> i <paramref name="modifiers" /> nie mają tę samą długość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-566"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="9cc50-567">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-567">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-568">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-568">-or-</span></span> 
<span data-ttu-id="9cc50-569">Zero, aby zwrócić <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-569">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="9cc50-570">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-570">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="9cc50-571">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-571">-or-</span></span> 
<span data-ttu-id="9cc50-572">Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-572">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="9cc50-573">Obiekt, który określa zestaw reguł dotyczących kolejności i układ argumentów, jak wartość zwracana jest przekazywany, jakie rejestrów są używane dla argumentów i stos jest czyszczony.</span><span class="sxs-lookup"><span data-stu-id="9cc50-573">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="9cc50-574">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla konstruktora, aby uzyskać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-574">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span></span>  
  
<span data-ttu-id="9cc50-575">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-575">-or-</span></span> 
<span data-ttu-id="9cc50-576">Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie konstruktora, który nie przyjmuje żadnych parametrów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-576">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="9cc50-577">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <paramref name="types" /> tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-577">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="9cc50-578">Domyślny konsolidator nie przetwarza tego parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-578">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="9cc50-579">Wyszukiwanie konstruktora, w której parametry odpowiadają określone typy argumentów i modyfikatorów, za pomocą ograniczeń w określonym powiązaniu i określonej konwencji wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-579">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="9cc50-580">Obiekt reprezentujący Konstruktor, który spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-580">An object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-581">Mimo że domyślny integrator nie przetwarza <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-581">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="9cc50-582">`ParameterModifier` jest używana tylko podczas wywoływania przez współdziałania z modelem COM i są obsługiwane tylko w przypadku parametrów, które są przekazywane przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-582">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="9cc50-583">Jeśli nie istnieje dokładne dopasowanie, `binder` będzie próbował przekształcić typy parametrów określonych w `types` tablicy w celu wybrania dopasowania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-583">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="9cc50-584">Jeśli `binder` nie może wybrać dopasowania, następnie `null` jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-584">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="9cc50-585">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania, które z konstruktorów do uwzględnienia w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-585">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-586">Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-586">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-587">Określ `BindingFlags.Public` obejmujący konstruktorów publicznych w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-587">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-588">Określ `BindingFlags.NonPublic` obejmujący w w wyszukiwaniu konstruktory niepubliczne (czyli prywatne, wewnętrzne i chronione konstruktory).</span><span class="sxs-lookup"><span data-stu-id="9cc50-588">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="9cc50-589">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-589">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="9cc50-590">Aby uzyskać inicjatora klasy (.cctor), za pomocą tej metody, należy określić <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-590">To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="9cc50-591">Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-591">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="9cc50-592">W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-592">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="9cc50-593">Typ elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="9cc50-593">Member Type</span></span>|<span data-ttu-id="9cc50-594">Static</span><span class="sxs-lookup"><span data-stu-id="9cc50-594">Static</span></span>|<span data-ttu-id="9cc50-595">Niestatyczna</span><span class="sxs-lookup"><span data-stu-id="9cc50-595">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="9cc50-596">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="9cc50-596">Constructor</span></span>|<span data-ttu-id="9cc50-597">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-597">No</span></span>|<span data-ttu-id="9cc50-598">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-598">No</span></span>|  
|<span data-ttu-id="9cc50-599">Pole</span><span class="sxs-lookup"><span data-stu-id="9cc50-599">Field</span></span>|<span data-ttu-id="9cc50-600">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-600">No</span></span>|<span data-ttu-id="9cc50-601">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-601">Yes.</span></span> <span data-ttu-id="9cc50-602">Pole jest zawsze ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-602">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-603">Zdarzenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-603">Event</span></span>|<span data-ttu-id="9cc50-604">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-604">Not applicable</span></span>|<span data-ttu-id="9cc50-605">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-605">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-606">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-606">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-607">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-607">See note 2 below.</span></span>|  
|<span data-ttu-id="9cc50-608">Metoda</span><span class="sxs-lookup"><span data-stu-id="9cc50-608">Method</span></span>|<span data-ttu-id="9cc50-609">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-609">No</span></span>|<span data-ttu-id="9cc50-610">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-610">Yes.</span></span> <span data-ttu-id="9cc50-611">Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-611">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-612">Typu zagnieżdżony</span><span class="sxs-lookup"><span data-stu-id="9cc50-612">Nested Type</span></span>|<span data-ttu-id="9cc50-613">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-613">No</span></span>|<span data-ttu-id="9cc50-614">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-614">No</span></span>|  
|<span data-ttu-id="9cc50-615">Właściwość</span><span class="sxs-lookup"><span data-stu-id="9cc50-615">Property</span></span>|<span data-ttu-id="9cc50-616">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-616">Not applicable</span></span>|<span data-ttu-id="9cc50-617">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-617">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-618">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-618">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-619">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-619">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="9cc50-620">Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-620">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="9cc50-621">To jest porównanie binarne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-621">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="9cc50-622">W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-622">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-623">Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-623">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="9cc50-624">Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-624">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-625">Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod.</span><span class="sxs-lookup"><span data-stu-id="9cc50-625">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="9cc50-626">Parametry można pominąć jedynie podczas wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-626">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="9cc50-627">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.ConstructorInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-627">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="9cc50-628">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta zwraca zawsze `null`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-628">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-629">W poniższym przykładzie uzyskano typ `MyClass1`, pobiera <xref:System.Reflection.ConstructorInfo> obiekt, który odpowiada flagi określonego powiązania, a następnie wyświetla sygnatury konstruktora.</span><span class="sxs-lookup"><span data-stu-id="9cc50-629">The following example obtains the type of `MyClass1`, gets the <xref:System.Reflection.ConstructorInfo> object that matches the specified binding flags, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-630"><paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-630"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cc50-631">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-631">-or-</span></span> 
<span data-ttu-id="9cc50-632">Jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-632">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-633"><paramref name="types" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-633"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="9cc50-634">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-634">-or-</span></span> 
 <span data-ttu-id="9cc50-635"><paramref name="modifiers" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-635"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="9cc50-636">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-636">-or-</span></span> 
 <span data-ttu-id="9cc50-637"><paramref name="types" /> i <paramref name="modifiers" /> nie mają tę samą długość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-637"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="9cc50-638">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-638">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-639">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-639">-or-</span></span> 
<span data-ttu-id="9cc50-640">Zero, aby zwrócić <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-640">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="9cc50-641">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-641">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="9cc50-642">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-642">-or-</span></span> 
<span data-ttu-id="9cc50-643">Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-643">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="9cc50-644">Obiekt, który określa zestaw reguł dotyczących kolejności i układ argumentów, jak wartość zwracana jest przekazywany, jakie rejestrów są używane dla argumentów i stos jest czyszczony.</span><span class="sxs-lookup"><span data-stu-id="9cc50-644">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="9cc50-645">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla konstruktora, aby uzyskać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-645">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span></span>  
  
<span data-ttu-id="9cc50-646">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-646">-or-</span></span> 
<span data-ttu-id="9cc50-647">Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie konstruktora, który nie przyjmuje żadnych parametrów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-647">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="9cc50-648">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <paramref name="types" /> tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-648">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="9cc50-649">Domyślny konsolidator nie przetwarza tego parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-649">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="9cc50-650">W przypadku przesłonięcia w klasie pochodnej, wyszukuje konstruktora, w której parametry odpowiadają określone typy argumentów i modyfikatorów, korzystając z ograniczeń w określonym powiązaniu i określonej konwencji wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-650">When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="9cc50-651">A <see cref="T:System.Reflection.ConstructorInfo" /> obiekt reprezentujący Konstruktor, który spełnia określone wymagania, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-651">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-652">Mimo że domyślny integrator nie przetwarza <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-652">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="9cc50-653">`ParameterModifier` jest używana tylko podczas wywoływania przez współdziałania z modelem COM i są obsługiwane tylko w przypadku parametrów, które są przekazywane przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-653">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="9cc50-654">Jeśli nie istnieje dokładne dopasowanie, `binder` będzie próbował przekształcić typy parametrów określonych w `types` tablicy w celu wybrania dopasowania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-654">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="9cc50-655">Jeśli `binder` nie może wybrać dopasowania, następnie `null` jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-655">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="9cc50-656">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania, które z konstruktorów do uwzględnienia w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-656">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-657">Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-657">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-658">Określ `BindingFlags.Public` obejmujący konstruktorów publicznych w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-658">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-659">Określ `BindingFlags.NonPublic` obejmujący w w wyszukiwaniu konstruktory niepubliczne (czyli prywatne, wewnętrzne i chronione konstruktory).</span><span class="sxs-lookup"><span data-stu-id="9cc50-659">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="9cc50-660">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-660">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="9cc50-661">Ta metoda implementuje <xref:System.Type.GetConstructor%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-661">This method implements <xref:System.Type.GetConstructor%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-662"><paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-662"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cc50-663">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-663">-or-</span></span> 
<span data-ttu-id="9cc50-664">Jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-664">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-665"><paramref name="types" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-665"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="9cc50-666">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-666">-or-</span></span> 
 <span data-ttu-id="9cc50-667"><paramref name="modifiers" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-667"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="9cc50-668">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-668">-or-</span></span> 
 <span data-ttu-id="9cc50-669"><paramref name="types" /> i <paramref name="modifiers" /> nie mają tę samą długość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-669"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cc50-670">Bieżącym typem jest <see cref="T:System.Reflection.Emit.TypeBuilder" /> lub <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-670">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cc50-671">Pobiera konstruktory bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-671">Gets the constructors of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-672">Zwraca wszystkie publiczne konstruktory zdefiniowane dla bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-672">Returns all the public constructors defined for the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="9cc50-673">Tablica <see cref="T:System.Reflection.ConstructorInfo" /> obiekty reprezentujące wszystkie konstruktory publiczne wystąpienia zdefiniowane dla bieżącego <see cref="T:System.Type" />, z wyjątkiem typu inicjatora (Konstruktor statyczny).</span><span class="sxs-lookup"><span data-stu-id="9cc50-673">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all the public instance constructors defined for the current <see cref="T:System.Type" />, but not including the type initializer (static constructor).</span></span> <span data-ttu-id="9cc50-674">Jeśli nie konstruktory publiczne wystąpienia są zdefiniowane dla bieżącego <see cref="T:System.Type" />, lub, jeśli bieżący <see cref="T:System.Type" /> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, pusta tablica typu <see cref="T:System.Reflection.ConstructorInfo" /> jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-674">If no public instance constructors are defined for the current <see cref="T:System.Type" />, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-675"><xref:System.Type.GetConstructors%2A> Metoda nie zwraca konstruktorów w określonej kolejności, takie jak kolejność zgłoszenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-675">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="9cc50-676">Twój kod nie może zależeć od kolejności, w której zwracane są konstruktory, ponieważ kolejność się zmienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-676">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="9cc50-677">W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-677">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="9cc50-678">Typ elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="9cc50-678">Member Type</span></span>|<span data-ttu-id="9cc50-679">Static</span><span class="sxs-lookup"><span data-stu-id="9cc50-679">Static</span></span>|<span data-ttu-id="9cc50-680">Niestatyczna</span><span class="sxs-lookup"><span data-stu-id="9cc50-680">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="9cc50-681">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="9cc50-681">Constructor</span></span>|<span data-ttu-id="9cc50-682">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-682">No</span></span>|<span data-ttu-id="9cc50-683">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-683">No</span></span>|  
|<span data-ttu-id="9cc50-684">Pole</span><span class="sxs-lookup"><span data-stu-id="9cc50-684">Field</span></span>|<span data-ttu-id="9cc50-685">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-685">No</span></span>|<span data-ttu-id="9cc50-686">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-686">Yes.</span></span> <span data-ttu-id="9cc50-687">Pole jest zawsze ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-687">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-688">Zdarzenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-688">Event</span></span>|<span data-ttu-id="9cc50-689">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-689">Not applicable</span></span>|<span data-ttu-id="9cc50-690">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-690">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-691">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-691">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-692">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-692">See note 2 below.</span></span>|  
|<span data-ttu-id="9cc50-693">Metoda</span><span class="sxs-lookup"><span data-stu-id="9cc50-693">Method</span></span>|<span data-ttu-id="9cc50-694">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-694">No</span></span>|<span data-ttu-id="9cc50-695">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-695">Yes.</span></span> <span data-ttu-id="9cc50-696">Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-696">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-697">Typu zagnieżdżony</span><span class="sxs-lookup"><span data-stu-id="9cc50-697">Nested Type</span></span>|<span data-ttu-id="9cc50-698">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-698">No</span></span>|<span data-ttu-id="9cc50-699">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-699">No</span></span>|  
|<span data-ttu-id="9cc50-700">Właściwość</span><span class="sxs-lookup"><span data-stu-id="9cc50-700">Property</span></span>|<span data-ttu-id="9cc50-701">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-701">Not applicable</span></span>|<span data-ttu-id="9cc50-702">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-702">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-703">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-703">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-704">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-704">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="9cc50-705">Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-705">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="9cc50-706">To jest porównanie binarne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-706">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="9cc50-707">W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-707">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-708">Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-708">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="9cc50-709">Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-709">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="9cc50-710">Tego przeciążenia metody wywołuje <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> przeciążenie metody z <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-710">This method overload calls the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="9cc50-711">Inicjatory klasy (.cctor) nie zostanie odnaleziony.</span><span class="sxs-lookup"><span data-stu-id="9cc50-711">It will not find class initializers (.cctor).</span></span> <span data-ttu-id="9cc50-712">Aby znaleźć klasy inicjatory, użyj przeciążenia, które przyjmuje <xref:System.Reflection.BindingFlags>, a następnie określ <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-712">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="9cc50-713">Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-713">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="9cc50-714">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.ConstructorInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-714">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="9cc50-715">Na przykład jeśli klasa `C<T>` ma Konstruktor `C(T t1)` (`Sub New(ByVal t1 As T)` w języku Visual Basic), wywoływania <xref:System.Type.GetConstructors%2A> na `C<int>` zwraca <xref:System.Reflection.ConstructorInfo> reprezentujący `C(int t1)` w języku C# (`Sub New(ByVal t1 As Integer)` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-715">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="9cc50-716">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, <xref:System.Type.GetConstructors%2A> metoda zwraca pustą tablicę.</span><span class="sxs-lookup"><span data-stu-id="9cc50-716">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-717">Ten przykład przedstawia dane wyjściowe <xref:System.Type.GetConstructors%2A> przeciążenia z klasy, która ma dwa konstruktory wystąpień i jeden konstruktor statyczny.</span><span class="sxs-lookup"><span data-stu-id="9cc50-717">This example shows the output of the <xref:System.Type.GetConstructors%2A> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="9cc50-718">Wynik tego kodu jest:</span><span class="sxs-lookup"><span data-stu-id="9cc50-718">The output of this code is:</span></span>  
  
 <span data-ttu-id="9cc50-719">2</span><span class="sxs-lookup"><span data-stu-id="9cc50-719">2</span></span>  
  
 <span data-ttu-id="9cc50-720">False</span><span class="sxs-lookup"><span data-stu-id="9cc50-720">False</span></span>  
  
 <span data-ttu-id="9cc50-721">False</span><span class="sxs-lookup"><span data-stu-id="9cc50-721">False</span></span>  
  
 <span data-ttu-id="9cc50-722">Ponieważ <xref:System.Type.GetConstructors> przeciążenia używa tylko <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> i <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, statyczny Konstruktor nie jest traktowana przez `for` wyrażeń ani oceniany przez `IsStatic`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-722">Because the <xref:System.Type.GetConstructors> overload uses only <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="9cc50-723">Aby znaleźć konstruktorów statycznych, użyj <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> przeciążenia i przekazywać połączenie (logiczne `OR`) z <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, jak pokazano w poniższym przykładzie kodu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-723">To find static constructors, use the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> overload, and pass the combination (logical `OR`) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="9cc50-724">Teraz dane wyjściowe to:</span><span class="sxs-lookup"><span data-stu-id="9cc50-724">Now the output is:</span></span>  
  
 <span data-ttu-id="9cc50-725">3</span><span class="sxs-lookup"><span data-stu-id="9cc50-725">3</span></span>  
  
 <span data-ttu-id="9cc50-726">False</span><span class="sxs-lookup"><span data-stu-id="9cc50-726">False</span></span>  
  
 <span data-ttu-id="9cc50-727">Prawda</span><span class="sxs-lookup"><span data-stu-id="9cc50-727">True</span></span>  
  
 <span data-ttu-id="9cc50-728">False</span><span class="sxs-lookup"><span data-stu-id="9cc50-728">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="9cc50-729">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-729">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-730">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-730">-or-</span></span> 
<span data-ttu-id="9cc50-731">Zero, aby zwrócić <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-731">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="9cc50-732">W przypadku przesłonięcia w klasie pochodnej, wyszukuje konstruktorów, zdefiniowanych dla bieżącej <see cref="T:System.Type" />, przy użyciu określonego <see langword="BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-732">When overridden in a derived class, searches for the constructors defined for the current <see cref="T:System.Type" />, using the specified <see langword="BindingFlags" />.</span></span></summary>
        <returns><span data-ttu-id="9cc50-733">Tablica <see cref="T:System.Reflection.ConstructorInfo" /> obiekty reprezentujące wszystkie konstruktory zdefiniowane dla bieżącego <see cref="T:System.Type" /> zgodnych ograniczeń w określonym powiązaniu, w tym inicjatora typu, jeśli jest on zdefiniowany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-733">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all constructors defined for the current <see cref="T:System.Type" /> that match the specified binding constraints, including the type initializer if it is defined.</span></span> <span data-ttu-id="9cc50-734">Zwraca pustą tablicę typu <see cref="T:System.Reflection.ConstructorInfo" /> Jeśli konstruktory nie są zdefiniowane dla bieżącego <see cref="T:System.Type" />, czy żaden z konstruktorów zdefiniowanych być zgodne z ograniczeniami powiązania, czy bieżący <see cref="T:System.Type" /> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-734">Returns an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> if no constructors are defined for the current <see cref="T:System.Type" />, if none of the defined constructors match the binding constraints, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-735"><xref:System.Type.GetConstructors%2A> Metoda nie zwraca konstruktorów w określonej kolejności, takie jak kolejność zgłoszenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-735">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="9cc50-736">Twój kod nie może zależeć od kolejności, w której zwracane są konstruktory, ponieważ kolejność się zmienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-736">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="9cc50-737">`bindingAttr` może służyć do określenia, czy należy zwrócić tylko konstruktory publiczne lub konstruktorów publicznych i niepublicznych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-737">`bindingAttr` can be used to specify whether to return only public constructors or both public and non-public constructors.</span></span>  
  
 <span data-ttu-id="9cc50-738">Jeśli nie istnieje dokładne dopasowanie, `binder` będzie próbował przekształcić typy parametrów określonych w `types` tablicy w celu wybrania dopasowania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-738">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="9cc50-739">Jeśli `binder` nie może wybrać dopasowania, następnie `null` jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-739">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="9cc50-740">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania, które z konstruktorów do uwzględnienia w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-740">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-741">Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-741">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-742">Określ `BindingFlags.Public` obejmujący konstruktorów publicznych w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-742">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-743">Określ `BindingFlags.NonPublic` obejmujący w w wyszukiwaniu konstruktory niepubliczne (czyli prywatne, wewnętrzne i chronione konstruktory).</span><span class="sxs-lookup"><span data-stu-id="9cc50-743">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span> <span data-ttu-id="9cc50-744">Konstruktory klas bazowych nie są zwracane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-744">Constructors of base classes are not returned.</span></span>  
  
 <span data-ttu-id="9cc50-745">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-745">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="9cc50-746">Aby uzyskać inicjatora klasy (.cctor), za pomocą tego przeciążenia metody, należy określić <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-746">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="9cc50-747">Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-747">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="9cc50-748">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.ConstructorInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-748">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="9cc50-749">Na przykład jeśli klasa `C<T>` ma Konstruktor `C(T t1)` (`Sub New(ByVal t1 As T)` w języku Visual Basic), wywoływania <xref:System.Type.GetConstructors%2A> na `C<int>` zwraca <xref:System.Reflection.ConstructorInfo> reprezentujący `C(int t1)` w języku C# (`Sub New(ByVal t1 As Integer)` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-749">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="9cc50-750">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, <xref:System.Type.GetConstructors%2A> metoda zwraca pustą tablicę.</span><span class="sxs-lookup"><span data-stu-id="9cc50-750">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-751">Ten przykład przedstawia dane wyjściowe <xref:System.Type.GetConstructors> przeciążenia z klasy, która ma dwa konstruktory wystąpień i jeden konstruktor statyczny.</span><span class="sxs-lookup"><span data-stu-id="9cc50-751">This example shows the output of the <xref:System.Type.GetConstructors> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="9cc50-752">Wynik tego kodu jest:</span><span class="sxs-lookup"><span data-stu-id="9cc50-752">The output of this code is:</span></span>  
  
 <span data-ttu-id="9cc50-753">2</span><span class="sxs-lookup"><span data-stu-id="9cc50-753">2</span></span>  
  
 <span data-ttu-id="9cc50-754">False</span><span class="sxs-lookup"><span data-stu-id="9cc50-754">False</span></span>  
  
 <span data-ttu-id="9cc50-755">False</span><span class="sxs-lookup"><span data-stu-id="9cc50-755">False</span></span>  
  
 <span data-ttu-id="9cc50-756">Ponieważ <xref:System.Type.GetConstructors%2A> przeciążenia używa tylko <xref:System.Reflection.BindingFlags.Public> i <xref:System.Reflection.BindingFlags.Instance>, statyczny Konstruktor nie jest traktowana przez `for` wyrażeń ani oceniany przez `IsStatic`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-756">Because the <xref:System.Type.GetConstructors%2A> overload uses only <xref:System.Reflection.BindingFlags.Public> and <xref:System.Reflection.BindingFlags.Instance>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="9cc50-757">Aby znaleźć konstruktorów statycznych, użyj <xref:System.Type.GetConstructors%2A> przeciążenia i przekazywać je kombinacja (operator logiczny lub) <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, jak pokazano w poniższym przykładzie kodu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-757">To find static constructors, use the <xref:System.Type.GetConstructors%2A> overload, and pass it the combination (logical OR) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="9cc50-758">Teraz dane wyjściowe to:</span><span class="sxs-lookup"><span data-stu-id="9cc50-758">Now the output is:</span></span>  
  
 <span data-ttu-id="9cc50-759">3</span><span class="sxs-lookup"><span data-stu-id="9cc50-759">3</span></span>  
  
 <span data-ttu-id="9cc50-760">False</span><span class="sxs-lookup"><span data-stu-id="9cc50-760">False</span></span>  
  
 <span data-ttu-id="9cc50-761">Prawda</span><span class="sxs-lookup"><span data-stu-id="9cc50-761">True</span></span>  
  
 <span data-ttu-id="9cc50-762">False</span><span class="sxs-lookup"><span data-stu-id="9cc50-762">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-763">Wyszukuje elementy członkowskie zdefiniowane dla bieżącego <see cref="T:System.Type" /> którego <see cref="T:System.Reflection.DefaultMemberAttribute" /> jest ustawiona.</span><span class="sxs-lookup"><span data-stu-id="9cc50-763">Searches for the members defined for the current <see cref="T:System.Type" /> whose <see cref="T:System.Reflection.DefaultMemberAttribute" /> is set.</span></span></summary>
        <returns><span data-ttu-id="9cc50-764">Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące wszystkie domyślne elementy członkowskie bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-764">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all default members of the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="9cc50-765">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-765">-or-</span></span> 
<span data-ttu-id="9cc50-766">Pusta tablica typu <see cref="T:System.Reflection.MemberInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma domyślne elementy członkowskie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-766">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have default members.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-767"><xref:System.Type.GetDefaultMembers%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-767">The <xref:System.Type.GetDefaultMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="9cc50-768">Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-768">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="9cc50-769">Metoda ta może być zastąpiona przez klasę pochodną.</span><span class="sxs-lookup"><span data-stu-id="9cc50-769">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="9cc50-770">Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-770">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="9cc50-771">W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-771">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="9cc50-772">Typ elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="9cc50-772">Member Type</span></span>|<span data-ttu-id="9cc50-773">Static</span><span class="sxs-lookup"><span data-stu-id="9cc50-773">Static</span></span>|<span data-ttu-id="9cc50-774">Niestatyczna</span><span class="sxs-lookup"><span data-stu-id="9cc50-774">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="9cc50-775">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="9cc50-775">Constructor</span></span>|<span data-ttu-id="9cc50-776">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-776">No</span></span>|<span data-ttu-id="9cc50-777">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-777">No</span></span>|  
|<span data-ttu-id="9cc50-778">Pole</span><span class="sxs-lookup"><span data-stu-id="9cc50-778">Field</span></span>|<span data-ttu-id="9cc50-779">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-779">No</span></span>|<span data-ttu-id="9cc50-780">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-780">Yes.</span></span> <span data-ttu-id="9cc50-781">Pole jest zawsze ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-781">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-782">Zdarzenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-782">Event</span></span>|<span data-ttu-id="9cc50-783">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-783">Not applicable</span></span>|<span data-ttu-id="9cc50-784">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-784">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-785">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-785">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-786">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-786">See note 2 below.</span></span>|  
|<span data-ttu-id="9cc50-787">Metoda</span><span class="sxs-lookup"><span data-stu-id="9cc50-787">Method</span></span>|<span data-ttu-id="9cc50-788">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-788">No</span></span>|<span data-ttu-id="9cc50-789">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-789">Yes.</span></span> <span data-ttu-id="9cc50-790">Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-790">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-791">Typu zagnieżdżony</span><span class="sxs-lookup"><span data-stu-id="9cc50-791">Nested Type</span></span>|<span data-ttu-id="9cc50-792">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-792">No</span></span>|<span data-ttu-id="9cc50-793">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-793">No</span></span>|  
|<span data-ttu-id="9cc50-794">Właściwość</span><span class="sxs-lookup"><span data-stu-id="9cc50-794">Property</span></span>|<span data-ttu-id="9cc50-795">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-795">Not applicable</span></span>|<span data-ttu-id="9cc50-796">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-796">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-797">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-797">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-798">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-798">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="9cc50-799">Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-799">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="9cc50-800">To jest porównanie binarne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-800">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="9cc50-801">W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-801">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-802">Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-802">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="9cc50-803">Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-803">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="9cc50-804">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MemberInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-804">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="9cc50-805">Na przykład jeśli klasa `C<T>` ma właściwość `P` zwracającego `T`, wywoływania <xref:System.Type.GetDefaultMembers%2A> na `C<int>` zwraca `int P` w języku C# (`Property P As Integer` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-805">For example, if class `C<T>` has a property `P` that returns `T`, calling <xref:System.Type.GetDefaultMembers%2A> on `C<int>` returns `int P` in C# (`Property P As Integer` in Visual Basic).</span></span>  
  
 <span data-ttu-id="9cc50-806">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje składowe ograniczenia klasy lub elementów członkowskich <xref:System.Object> przypadku bez ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-806">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-807">W poniższym przykładzie uzyskano informacje o członkach domyślne z `MyClass` i wyświetla domyślne elementy członkowskie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-807">The following example obtains the default member information of `MyClass` and displays the default members.</span></span>  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-808">Po przesłonięciu w klasie pochodnej zwraca <see cref="T:System.Type" /> obiektu wchodzących w skład lub określone przez bieżący typ tablicy, wskaźnika lub odwołania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-808">When overridden in a derived class, returns the <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer or reference type.</span></span></summary>
        <returns><span data-ttu-id="9cc50-809"><see cref="T:System.Type" /> Obiektu wchodzących w skład lub odwołuje się bieżącej tablicy, wskaźnika lub typ referencyjny lub <see langword="null" /> Jeśli bieżące <see cref="T:System.Type" /> nie jest tablicą ani wskaźnikiem, nie jest przekazywany przez odwołanie lub reprezentuje typ ogólny lub parametr typu w Definicja typu ogólnego lub metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-809">The <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer, or reference type, or <see langword="null" /> if the current <see cref="T:System.Type" /> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-810">Ta metoda zwraca `null` dla <xref:System.Array> klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-810">This method returns `null` for the <xref:System.Array> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-811">Poniższy przykład demonstruje użycie `GetElementType` metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-811">The following example demonstrates using the `GetElementType` method.</span></span>  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="9cc50-812">Wartość, której nazwa to do pobrania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-812">The value whose name is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="9cc50-813">Zwraca nazwę stałą, która ma określoną wartość, dla bieżącego typu wyliczeniowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-813">Returns the name of the constant that has the specified value, for the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="9cc50-814">Nazwa elementu członkowskiego bieżący typ wyliczeniowy, który ma określoną wartość lub <see langword="null" /> Jeśli zostanie znaleziony taki stałej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-814">The name of the member of the current enumeration type that has the specified value, or <see langword="null" /> if no such constant is found.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-815">Bieżący typ nie jest wyliczeniem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-815">The current type is not an enumeration.</span></span>  
  
<span data-ttu-id="9cc50-816">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-816">-or-</span></span> 
 <span data-ttu-id="9cc50-817"><paramref name="value" /> nie jest ani bieżącego typu ani nie ma ten sam typ podstawowy jako bieżącego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-817"><paramref name="value" /> is neither of the current type nor does it have the same underlying type as the current type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-818"><paramref name="value" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-818"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-819">Zwraca nazwy elementów członkowskich bieżącego typu wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-819">Returns the names of the members of the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="9cc50-820">Tablica, która zawiera nazwy elementów członkowskich wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-820">An array that contains the names of the members of the enumeration.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-821">Elementy w tablicy zwracanej wartości są sortowane według wartości binarnych (czyli wartości bez znaku) stałych wyliczeniowych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-821">The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants.</span></span> <span data-ttu-id="9cc50-822">Jeśli tablica zawiera stałych wyliczeniowych z taką samą wartość, kolejność odpowiadających im nazw jest nieokreślona.</span><span class="sxs-lookup"><span data-stu-id="9cc50-822">If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-823">Bieżący typ nie jest wyliczeniem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-823">The current type is not an enumeration.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-824">Zwraca typ podstawowy elementu bieżącego typu wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-824">Returns the underlying type of the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="9cc50-825">Podstawowy typ bieżącym wyliczeniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-825">The underlying type of the current enumeration.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-826">Domyślnie jest podstawowym typem wyliczenia w języku C# i Visual Basic <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-826">By default, the underlying type of an enumeration in C# and Visual Basic is <xref:System.Int32>.</span></span> <span data-ttu-id="9cc50-827">Można określić innych typów całkowitych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-827">Other integer types can be specified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-828">Bieżący typ nie jest wyliczeniem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-828">The current type is not an enumeration.</span></span>  
  
<span data-ttu-id="9cc50-829">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-829">-or-</span></span> 
<span data-ttu-id="9cc50-830">Typ wyliczeniowy nie jest prawidłowy, ponieważ zawiera ona co najmniej jedno pole wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-830">The enumeration type is not valid, because it contains more than one instance field.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-831">Zwraca tablicę wartości stałych do bieżącego typu wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-831">Returns an array of the values of the constants in the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="9cc50-832">Tablica, która zawiera wartości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-832">An array that contains the values.</span></span> <span data-ttu-id="9cc50-833">Elementy tablicy są sortowane według wartości binarnych (czyli wartości bez znaku) stałe wyliczeń.</span><span class="sxs-lookup"><span data-stu-id="9cc50-833">The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-834">Bieżący typ nie jest wyliczeniem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-834">The current type is not an enumeration.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cc50-835">Pobiera określone zdarzenie zadeklarowane lub dziedziczone przez bieżącą <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-835">Gets a specific event declared or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-836">Ciąg zawierający nazwę zdarzenia, które jest zadeklarowany lub jest dziedziczona przez bieżący <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-836">The string containing the name of an event that is declared or inherited by the current <see cref="T:System.Type" />.</span></span></param>
        <summary><span data-ttu-id="9cc50-837">Zwraca <see cref="T:System.Reflection.EventInfo" /> obiekt reprezentujący określonego zdarzenia publiczne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-837">Returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified public event.</span></span></summary>
        <returns><span data-ttu-id="9cc50-838">Obiekt reprezentujący określonego zdarzenia publiczne, zadeklarowany lub dziedziczone przez bieżącą <see cref="T:System.Type" />, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-838">The object representing the specified public event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-839">Zdarzenie jest uważane za publiczne odbicie, jeżeli ma co najmniej jedną metodę lub metodę dostępu, która jest publiczna.</span><span class="sxs-lookup"><span data-stu-id="9cc50-839">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="9cc50-840">W przeciwnym razie zdarzenie jest traktowane jako prywatne i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-840">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="9cc50-841">Wyszukaj `name` jest uwzględniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="9cc50-841">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="9cc50-842">Wyszukiwanie uwzględnia publiczne static i public wystąpienia zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-842">The search includes public static and public instance events.</span></span>  
  
 <span data-ttu-id="9cc50-843">W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-843">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="9cc50-844">Typ elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="9cc50-844">Member Type</span></span>|<span data-ttu-id="9cc50-845">Static</span><span class="sxs-lookup"><span data-stu-id="9cc50-845">Static</span></span>|<span data-ttu-id="9cc50-846">Niestatyczna</span><span class="sxs-lookup"><span data-stu-id="9cc50-846">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="9cc50-847">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="9cc50-847">Constructor</span></span>|<span data-ttu-id="9cc50-848">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-848">No</span></span>|<span data-ttu-id="9cc50-849">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-849">No</span></span>|  
|<span data-ttu-id="9cc50-850">Pole</span><span class="sxs-lookup"><span data-stu-id="9cc50-850">Field</span></span>|<span data-ttu-id="9cc50-851">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-851">No</span></span>|<span data-ttu-id="9cc50-852">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-852">Yes.</span></span> <span data-ttu-id="9cc50-853">Pole jest zawsze ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-853">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-854">Zdarzenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-854">Event</span></span>|<span data-ttu-id="9cc50-855">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-855">Not applicable</span></span>|<span data-ttu-id="9cc50-856">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-856">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-857">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-857">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-858">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-858">See note 2 below.</span></span>|  
|<span data-ttu-id="9cc50-859">Metoda</span><span class="sxs-lookup"><span data-stu-id="9cc50-859">Method</span></span>|<span data-ttu-id="9cc50-860">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-860">No</span></span>|<span data-ttu-id="9cc50-861">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-861">Yes.</span></span> <span data-ttu-id="9cc50-862">Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-862">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-863">Typu zagnieżdżony</span><span class="sxs-lookup"><span data-stu-id="9cc50-863">Nested Type</span></span>|<span data-ttu-id="9cc50-864">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-864">No</span></span>|<span data-ttu-id="9cc50-865">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-865">No</span></span>|  
|<span data-ttu-id="9cc50-866">Właściwość</span><span class="sxs-lookup"><span data-stu-id="9cc50-866">Property</span></span>|<span data-ttu-id="9cc50-867">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-867">Not applicable</span></span>|<span data-ttu-id="9cc50-868">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-868">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-869">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-869">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-870">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-870">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="9cc50-871">Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-871">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="9cc50-872">To jest porównanie binarne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-872">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="9cc50-873">W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-873">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-874">Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-874">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="9cc50-875">Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-875">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="9cc50-876">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.EventInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-876">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-877">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje zdarzenia ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-877">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-878">Poniższy przykład tworzy <xref:System.Reflection.EventInfo> obiektu i pobiera zdarzenia dla klasy przycisku dla określonego zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-878">The following example creates an <xref:System.Reflection.EventInfo> object and gets the event for a button class for the specified event.</span></span>  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-879"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-879"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-880">Ciąg zawierający nazwę zdarzenia, które jest zadeklarowany lub jest dziedziczona przez bieżący <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-880">The string containing the name of an event which is declared or inherited by the current <see cref="T:System.Type" />.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="9cc50-881">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-881">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-882">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-882">-or-</span></span> 
<span data-ttu-id="9cc50-883">Zero, aby zwrócić <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-883">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="9cc50-884">Po przesłonięciu w klasie pochodnej zwraca <see cref="T:System.Reflection.EventInfo" /> obiekt reprezentujący określonych zdarzeń, za pomocą ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-884">When overridden in a derived class, returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified event, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="9cc50-885">Obiekt reprezentujący określonego zdarzenia, które jest zadeklarowany lub jest dziedziczona przez bieżący <see cref="T:System.Type" />, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-885">The object representing the specified event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-886">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania zdarzeń do uwzględnienia w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-886">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-887">Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-887">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-888">Określ `BindingFlags.Public` obejmujący publicznych zdarzeń w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-888">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-889">Określ `BindingFlags.NonPublic` obejmujący zdarzenia niepubliczne (czyli prywatne, wewnętrzne i chronione zdarzenia) w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-889">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-890">Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-890">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="9cc50-891">Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:</span><span class="sxs-lookup"><span data-stu-id="9cc50-891">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="9cc50-892">`BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-892">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="9cc50-893">`BindingFlags.DeclaredOnly` Aby wyszukać tylko zdarzenia, które są zadeklarowane w <xref:System.Type>, nie te zdarzenia, które zostały po prostu odziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-893">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="9cc50-894">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-894">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="9cc50-895">Zdarzenie jest uważane za publiczne odbicie, jeżeli ma co najmniej jedną metodę lub metodę dostępu, która jest publiczna.</span><span class="sxs-lookup"><span data-stu-id="9cc50-895">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="9cc50-896">W przeciwnym razie zdarzenie jest traktowane jako prywatne i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-896">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="9cc50-897">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.EventInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-897">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-898">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje zdarzenia ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-898">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-899">Poniższy przykład kodu wykorzystuje <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> metody do wyszukiwania typu publiczne lub niepubliczna zdarzenie o nazwie "Kliknij" który nie jest `static` (`Shared` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-899">The following code example uses the <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> method to search a type for a public or non-public event named "Click" that is not `static` (`Shared` in Visual Basic).</span></span>  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-900"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-900"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cc50-901">Pobiera zdarzenia, które są zadeklarowane lub dziedziczone przez bieżącą <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-901">Gets the events that are declared or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-902">Zwraca wszystkie publiczne zdarzenia, które są zadeklarowane lub dziedziczone przez bieżącą <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-902">Returns all the public events that are declared or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="9cc50-903">Tablica <see cref="T:System.Reflection.EventInfo" /> obiekty reprezentujące wszystkie zdarzenia publiczne, które są zadeklarowane lub dziedziczone przez bieżącą <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-903">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all the public events which are declared or inherited by the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="9cc50-904">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-904">-or-</span></span> 
<span data-ttu-id="9cc50-905">Pusta tablica typu <see cref="T:System.Reflection.EventInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma publicznych zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="9cc50-905">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have public events.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-906">Zdarzenie jest uważane za publiczne odbicie, jeżeli ma co najmniej jedną metodę lub metodę dostępu, która jest publiczna.</span><span class="sxs-lookup"><span data-stu-id="9cc50-906">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="9cc50-907">W przeciwnym razie zdarzenie jest traktowane jako prywatne i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-907">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="9cc50-908"><xref:System.Type.GetEvents%2A> Metoda nie zwraca zdarzeń w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-908">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="9cc50-909">Twój kod nie może zależeć od kolejności, w której zwracane są zdarzenia, ponieważ kolejność się zmienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-909">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="9cc50-910">Metoda ta może być zastąpiona przez klasę pochodną.</span><span class="sxs-lookup"><span data-stu-id="9cc50-910">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="9cc50-911">W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-911">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="9cc50-912">Typ elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="9cc50-912">Member Type</span></span>|<span data-ttu-id="9cc50-913">Static</span><span class="sxs-lookup"><span data-stu-id="9cc50-913">Static</span></span>|<span data-ttu-id="9cc50-914">Niestatyczna</span><span class="sxs-lookup"><span data-stu-id="9cc50-914">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="9cc50-915">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="9cc50-915">Constructor</span></span>|<span data-ttu-id="9cc50-916">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-916">No</span></span>|<span data-ttu-id="9cc50-917">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-917">No</span></span>|  
|<span data-ttu-id="9cc50-918">Pole</span><span class="sxs-lookup"><span data-stu-id="9cc50-918">Field</span></span>|<span data-ttu-id="9cc50-919">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-919">No</span></span>|<span data-ttu-id="9cc50-920">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-920">Yes.</span></span> <span data-ttu-id="9cc50-921">Pole jest zawsze ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-921">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-922">Zdarzenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-922">Event</span></span>|<span data-ttu-id="9cc50-923">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-923">Not applicable</span></span>|<span data-ttu-id="9cc50-924">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-924">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-925">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-925">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-926">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-926">See note 2 below.</span></span>|  
|<span data-ttu-id="9cc50-927">Metoda</span><span class="sxs-lookup"><span data-stu-id="9cc50-927">Method</span></span>|<span data-ttu-id="9cc50-928">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-928">No</span></span>|<span data-ttu-id="9cc50-929">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-929">Yes.</span></span> <span data-ttu-id="9cc50-930">Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-930">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-931">Typu zagnieżdżony</span><span class="sxs-lookup"><span data-stu-id="9cc50-931">Nested Type</span></span>|<span data-ttu-id="9cc50-932">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-932">No</span></span>|<span data-ttu-id="9cc50-933">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-933">No</span></span>|  
|<span data-ttu-id="9cc50-934">Właściwość</span><span class="sxs-lookup"><span data-stu-id="9cc50-934">Property</span></span>|<span data-ttu-id="9cc50-935">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-935">Not applicable</span></span>|<span data-ttu-id="9cc50-936">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-936">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-937">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-937">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-938">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-938">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="9cc50-939">Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-939">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="9cc50-940">To jest porównanie binarne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-940">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="9cc50-941">W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-941">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-942">Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-942">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="9cc50-943">Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-943">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="9cc50-944">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.EventInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-944">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-945">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje zdarzenia ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-945">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-946">W poniższym przykładzie uzyskano tablicę <xref:System.Reflection.EventInfo> obiektów, pobiera wszystkie zdarzenia dla `Button` klasy, a następnie wyświetla nazwy zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-946">The following example obtains an array of <xref:System.Reflection.EventInfo> objects, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="9cc50-947">Aby skompilować przykład Visual Basic, użyj następującego polecenia:</span><span class="sxs-lookup"><span data-stu-id="9cc50-947">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="9cc50-948">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-948">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-949">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-949">-or-</span></span> 
<span data-ttu-id="9cc50-950">Zero, aby zwrócić <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-950">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="9cc50-951">W przypadku przesłonięcia w klasie pochodnej, wyszukuje zdarzenia, które są zadeklarowane lub dziedziczone przez bieżącą <see cref="T:System.Type" />, za pomocą ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-951">When overridden in a derived class, searches for events that are declared or inherited by the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="9cc50-952">Tablica <see cref="T:System.Reflection.EventInfo" /> obiekty reprezentujące wszystkie zdarzenia, które są zadeklarowane lub dziedziczone przez bieżącą <see cref="T:System.Type" /> zgodnych ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-952">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all events that are declared or inherited by the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="9cc50-953">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-953">-or-</span></span> 
<span data-ttu-id="9cc50-954">Pusta tablica typu <see cref="T:System.Reflection.EventInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma zdarzenia, lub jeśli żadna z tych zdarzeń ograniczenia wiązania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-954">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have events, or if none of the events match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-955"><xref:System.Type.GetEvents%2A> Metoda nie zwraca zdarzeń w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-955">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="9cc50-956">Twój kod nie może zależeć od kolejności, w której zwracane są zdarzenia, ponieważ kolejność się zmienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-956">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="9cc50-957">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania zdarzeń do uwzględnienia w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-957">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-958">Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-958">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-959">Określ `BindingFlags.Public` obejmujący publicznych zdarzeń w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-959">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-960">Określ `BindingFlags.NonPublic` obejmujący zdarzenia niepubliczne (czyli prywatne, wewnętrzne i chronione zdarzenia) w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-960">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span> <span data-ttu-id="9cc50-961">Tylko chroniony i zwracane są wewnętrzne zdarzenia w klasach bazowych; prywatne zdarzeń w klasach bazowych nie są zwracane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-961">Only protected and internal events on base classes are returned; private events on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="9cc50-962">Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-962">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="9cc50-963">Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:</span><span class="sxs-lookup"><span data-stu-id="9cc50-963">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="9cc50-964">`BindingFlags.DeclaredOnly` Aby wyszukać tylko zdarzenia, które są zadeklarowane w <xref:System.Type>, nie te zdarzenia, które zostały po prostu odziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-964">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="9cc50-965">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-965">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="9cc50-966">Zdarzenie jest uważane za publiczne odbicie, jeżeli ma co najmniej jedną metodę lub metodę dostępu, która jest publiczna.</span><span class="sxs-lookup"><span data-stu-id="9cc50-966">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="9cc50-967">W przeciwnym razie zdarzenie jest traktowane jako prywatne i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-967">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="9cc50-968">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.EventInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-968">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-969">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje zdarzenia ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-969">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-970">W poniższym przykładzie uzyskano tablicę <xref:System.Reflection.EventInfo> obiektami spełniającymi podane flagi określone powiązanie pobiera wszystkie zdarzenia dla `Button` klasy, a następnie wyświetla nazwy zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-970">The following example obtains an array of <xref:System.Reflection.EventInfo> objects that match the specified binding flags, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="9cc50-971">Aby skompilować przykład Visual Basic, użyj następującego polecenia:</span><span class="sxs-lookup"><span data-stu-id="9cc50-971">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cc50-972">Pobiera określonego pola bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-972">Gets a specific field of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-973">Ciąg zawierający nazwę pola danych można pobrać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-973">The string containing the name of the data field to get.</span></span></param>
        <summary><span data-ttu-id="9cc50-974">Wyszukuje pole publiczne o określonej nazwie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-974">Searches for the public field with the specified name.</span></span></summary>
        <returns><span data-ttu-id="9cc50-975">Obiekt reprezentujący publiczne pole o określonej nazwie, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-975">An object representing the public field with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-976">Wyszukaj `name` jest uwzględniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="9cc50-976">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="9cc50-977">Wyszukiwanie uwzględnia publiczne statyczne i publiczne pola wystąpień.</span><span class="sxs-lookup"><span data-stu-id="9cc50-977">The search includes public static and public instance fields.</span></span>  
  
 <span data-ttu-id="9cc50-978">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.FieldInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-978">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-979">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje pola ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-979">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-980">Poniższy przykład pobiera `Type` dla określonej klasy obiektu, uzyskuje <xref:System.Reflection.FieldInfo> obiektu dla pola i wyświetla wartość pola.</span><span class="sxs-lookup"><span data-stu-id="9cc50-980">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-981"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-981"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cc50-982">To <see cref="T:System.Type" /> obiekt jest <see cref="T:System.Reflection.Emit.TypeBuilder" /> którego <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> nie została jeszcze wywołana metoda.</span><span class="sxs-lookup"><span data-stu-id="9cc50-982">This <see cref="T:System.Type" /> object is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> whose <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method has not yet been called.</span></span></exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-983">Ciąg zawierający nazwę pola danych można pobrać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-983">The string containing the name of the data field to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="9cc50-984">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-984">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-985">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-985">-or-</span></span> 
<span data-ttu-id="9cc50-986">Zero, aby zwrócić <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-986">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="9cc50-987">Wyszukuje określonego pola, za pomocą ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-987">Searches for the specified field, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="9cc50-988">Obiekt reprezentujący pola, które spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-988">An object representing the field that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-989">W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-989">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="9cc50-990">Typ elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="9cc50-990">Member Type</span></span>|<span data-ttu-id="9cc50-991">Static</span><span class="sxs-lookup"><span data-stu-id="9cc50-991">Static</span></span>|<span data-ttu-id="9cc50-992">Niestatyczna</span><span class="sxs-lookup"><span data-stu-id="9cc50-992">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="9cc50-993">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="9cc50-993">Constructor</span></span>|<span data-ttu-id="9cc50-994">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-994">No</span></span>|<span data-ttu-id="9cc50-995">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-995">No</span></span>|  
|<span data-ttu-id="9cc50-996">Pole</span><span class="sxs-lookup"><span data-stu-id="9cc50-996">Field</span></span>|<span data-ttu-id="9cc50-997">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-997">No</span></span>|<span data-ttu-id="9cc50-998">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-998">Yes.</span></span> <span data-ttu-id="9cc50-999">Pole jest zawsze ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-999">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-1000">Zdarzenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1000">Event</span></span>|<span data-ttu-id="9cc50-1001">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-1001">Not applicable</span></span>|<span data-ttu-id="9cc50-1002">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1002">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-1003">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1003">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1004">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1004">See note 2 below.</span></span>|  
|<span data-ttu-id="9cc50-1005">Metoda</span><span class="sxs-lookup"><span data-stu-id="9cc50-1005">Method</span></span>|<span data-ttu-id="9cc50-1006">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1006">No</span></span>|<span data-ttu-id="9cc50-1007">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1007">Yes.</span></span> <span data-ttu-id="9cc50-1008">Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1008">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-1009">Typu zagnieżdżony</span><span class="sxs-lookup"><span data-stu-id="9cc50-1009">Nested Type</span></span>|<span data-ttu-id="9cc50-1010">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1010">No</span></span>|<span data-ttu-id="9cc50-1011">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1011">No</span></span>|  
|<span data-ttu-id="9cc50-1012">Właściwość</span><span class="sxs-lookup"><span data-stu-id="9cc50-1012">Property</span></span>|<span data-ttu-id="9cc50-1013">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-1013">Not applicable</span></span>|<span data-ttu-id="9cc50-1014">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1014">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-1015">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1015">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1016">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1016">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="9cc50-1017">Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1017">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="9cc50-1018">To jest porównanie binarne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1018">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="9cc50-1019">W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1019">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1020">Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1020">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="9cc50-1021">Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1021">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="9cc50-1022">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania pola do uwzględnienia w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1022">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-1023">Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1023">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-1024">Określ `BindingFlags.Public` obejmujący pola publiczne w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1024">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1025">Określ `BindingFlags.NonPublic` obejmujący niepubliczne (czyli prywatne, wewnętrzne i chronione, pola) w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1025">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1026">Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1026">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="9cc50-1027">Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1027">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="9cc50-1028">`BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1028">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="9cc50-1029">`BindingFlags.DeclaredOnly` Aby wyszukać tylko te pola, które są zadeklarowane w <xref:System.Type>, nie w przypadku pól, które zostały po prostu odziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1029">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
 <span data-ttu-id="9cc50-1030">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1030">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="9cc50-1031">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.FieldInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1031">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1032">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje pola ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1032">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1033">Poniższy przykład pobiera `Type` dla określonej klasy obiektu, uzyskuje <xref:System.Reflection.FieldInfo> obiektu dla pola, które odpowiada flagi określone powiązanie i wyświetla wartość pola.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1033">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field that matches the specified binding flags, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-1034"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1034"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cc50-1035">Pobiera pola bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1035">Gets the fields of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-1036">Zwraca wszystkie publiczne pola bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1036">Returns all the public fields of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1037">Tablica <see cref="T:System.Reflection.FieldInfo" /> obiektów reprezentujących pola publiczne zdefiniowane dla bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1037">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all the public fields defined for the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="9cc50-1038">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1038">-or-</span></span> 
<span data-ttu-id="9cc50-1039">Pusta tablica typu <see cref="T:System.Reflection.FieldInfo" />, jeśli nie ma publicznej pól zdefiniowanych dla bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1039">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no public fields are defined for the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1040"><xref:System.Type.GetFields%2A> Metoda nie zwraca pola w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1040">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="9cc50-1041">Twój kod nie może zależeć od kolejności, w której zwracane są pola, ponieważ kolejność się zmienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1041">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="9cc50-1042">W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1042">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="9cc50-1043">Typ elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="9cc50-1043">Member Type</span></span>|<span data-ttu-id="9cc50-1044">Static</span><span class="sxs-lookup"><span data-stu-id="9cc50-1044">Static</span></span>|<span data-ttu-id="9cc50-1045">Niestatyczna</span><span class="sxs-lookup"><span data-stu-id="9cc50-1045">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="9cc50-1046">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="9cc50-1046">Constructor</span></span>|<span data-ttu-id="9cc50-1047">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1047">No</span></span>|<span data-ttu-id="9cc50-1048">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1048">No</span></span>|  
|<span data-ttu-id="9cc50-1049">Pole</span><span class="sxs-lookup"><span data-stu-id="9cc50-1049">Field</span></span>|<span data-ttu-id="9cc50-1050">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1050">No</span></span>|<span data-ttu-id="9cc50-1051">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1051">Yes.</span></span> <span data-ttu-id="9cc50-1052">Pole jest zawsze ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1052">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-1053">Zdarzenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1053">Event</span></span>|<span data-ttu-id="9cc50-1054">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-1054">Not applicable</span></span>|<span data-ttu-id="9cc50-1055">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1055">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-1056">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1056">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1057">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1057">See note 2 below.</span></span>|  
|<span data-ttu-id="9cc50-1058">Metoda</span><span class="sxs-lookup"><span data-stu-id="9cc50-1058">Method</span></span>|<span data-ttu-id="9cc50-1059">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1059">No</span></span>|<span data-ttu-id="9cc50-1060">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1060">Yes.</span></span> <span data-ttu-id="9cc50-1061">Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1061">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-1062">Typu zagnieżdżony</span><span class="sxs-lookup"><span data-stu-id="9cc50-1062">Nested Type</span></span>|<span data-ttu-id="9cc50-1063">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1063">No</span></span>|<span data-ttu-id="9cc50-1064">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1064">No</span></span>|  
|<span data-ttu-id="9cc50-1065">Właściwość</span><span class="sxs-lookup"><span data-stu-id="9cc50-1065">Property</span></span>|<span data-ttu-id="9cc50-1066">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-1066">Not applicable</span></span>|<span data-ttu-id="9cc50-1067">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1067">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-1068">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1068">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1069">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1069">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="9cc50-1070">Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1070">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="9cc50-1071">To jest porównanie binarne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1071">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="9cc50-1072">W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1072">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1073">Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1073">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="9cc50-1074">Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1074">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="9cc50-1075">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.FieldInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1075">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1076">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje pola publiczne ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1076">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1077">Poniższy przykład pokazuje wykorzystanie `GetFields()` metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1077">The following example shows a use of the `GetFields()` method.</span></span>  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="9cc50-1078">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1078">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-1079">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1079">-or-</span></span> 
<span data-ttu-id="9cc50-1080">Zero, aby zwrócić <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1080">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="9cc50-1081">W przypadku przesłonięcia w klasie pochodnej, wyszukuje pól zdefiniowanych dla bieżącego <see cref="T:System.Type" />, za pomocą ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1081">When overridden in a derived class, searches for the fields defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1082">Tablica <see cref="T:System.Reflection.FieldInfo" /> obiekty reprezentujące wszystkie pola zdefiniowane dla bieżącego <see cref="T:System.Type" /> zgodnych ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1082">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all fields defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="9cc50-1083">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1083">-or-</span></span> 
<span data-ttu-id="9cc50-1084">Pusta tablica typu <see cref="T:System.Reflection.FieldInfo" />, jeśli nie ma pól zdefiniowanych dla bieżącego <see cref="T:System.Type" />, lub jeśli żadne z pól zdefiniowanych być zgodne z ograniczeniami powiązania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1084">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no fields are defined for the current <see cref="T:System.Type" />, or if none of the defined fields match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1085"><xref:System.Type.GetFields%2A> Metoda nie zwraca pola w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1085">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="9cc50-1086">Twój kod nie może zależeć od kolejności, w której zwracane są pola, ponieważ kolejność się zmienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1086">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="9cc50-1087">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania pola do uwzględnienia w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1087">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-1088">Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1088">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-1089">Określ `BindingFlags.Public` obejmujący pola publiczne w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1089">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1090">Określ `BindingFlags.NonPublic` obejmujący niepubliczne (czyli prywatne, wewnętrzne i chronione, pola) w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1090">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span> <span data-ttu-id="9cc50-1091">Tylko chronionych i wewnętrznych pól klasy bazowe są zwracane; pola prywatne na klasach bazowych nie są zwracane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1091">Only protected and internal fields on base classes are returned; private fields on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="9cc50-1092">Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1092">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="9cc50-1093">Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1093">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="9cc50-1094">`BindingFlags.DeclaredOnly` Aby wyszukać tylko te pola, które są zadeklarowane w <xref:System.Type>, nie w przypadku pól, które zostały po prostu odziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1094">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
 <span data-ttu-id="9cc50-1095">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1095">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="9cc50-1096">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.FieldInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1096">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1097">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje pola publiczne ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1097">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1098">Poniższy przykład pokazuje wykorzystanie `GetFields(BindingFlags)` metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1098">The following example shows a use of the `GetFields(BindingFlags)` method.</span></span>  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-1099">Zwraca tablicę <see cref="T:System.Type" /> obiekty reprezentujące argumentów typu zamkniętego typu ogólnego lub parametrów typu w definicji typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1099">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1100">Tablica <see cref="T:System.Type" /> obiekty reprezentujące argumenty typu ogólnego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1100">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic type.</span></span> <span data-ttu-id="9cc50-1101">Zwraca pustą tablicę, jeśli bieżący typ nie jest typem ogólnym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1101">Returns an empty array if the current type is not a generic type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1102">Elementy tablicy są zwracane w kolejności, w jakiej są wyświetlane na liście argumentów typu dla typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1102">The array elements are returned in the order in which they appear in the list of type arguments for the generic type.</span></span>  
  
-   <span data-ttu-id="9cc50-1103">Jeśli bieżącym typem jest zamknięty skonstruowanego typu (oznacza to, że <xref:System.Type.ContainsGenericParameters%2A> właściwość zwraca `false`), tablica zwrócona przez <xref:System.Type.GetGenericArguments%2A> metoda zawiera typy, które zostały przypisane do parametrów typu ogólnego definicji typu ogólnego .</span><span class="sxs-lookup"><span data-stu-id="9cc50-1103">If the current type is a closed constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Type.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic type definition.</span></span>  
  
-   <span data-ttu-id="9cc50-1104">Jeśli bieżący typ jest definicja typu ogólnego, tablica zawiera parametry typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1104">If the current type is a generic type definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="9cc50-1105">Jeśli bieżący typ jest typem otwartym skonstruowany (oznacza to, <xref:System.Type.ContainsGenericParameters%2A> właściwość zwraca `true`), w których określonych typów nie zostały przypisane do wszystkich parametrów typu i parametrów typu w otaczającej typów ani metod ogólnych, tablica zawiera typy i parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1105">If the current type is an open constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters.</span></span> <span data-ttu-id="9cc50-1106">Użyj <xref:System.Type.IsGenericParameter%2A> właściwości, aby poinformować ich od siebie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1106">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="9cc50-1107">Do pokazania w tym scenariuszu, zobacz przykład kodu dla <xref:System.Type.ContainsGenericParameters%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1107">For a demonstration of this scenario, see the code example for the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="9cc50-1108">Aby uzyskać listę niezmiennych warunków dla terminów używanych w odbiciu rodzajowym, zobacz <xref:System.Type.IsGenericType%2A> uwagi dotyczące właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1108">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1109">Poniższy przykład kodu wykorzystuje <xref:System.Type.GetGenericArguments%2A> metodę w celu wyświetlenia argumentów typu skonstruowanego typu i parametry typu jego definicję typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1109">The following code example uses the <xref:System.Type.GetGenericArguments%2A> method to display the type arguments of a constructed type and the type parameters of its generic type definition.</span></span>  
  
 <span data-ttu-id="9cc50-1110">Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Type.IsGenericTypeDefinition%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1110">This code example is part of a larger example provided for the <xref:System.Type.IsGenericTypeDefinition%2A> property.</span></span> <span data-ttu-id="9cc50-1111">Zobacz większego przykładu, aby uzyskać przykładowe dane wyjściowe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1111">See the larger example for sample output.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cc50-1112">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1112">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="9cc50-1113">Klasy pochodne muszą zapewniać implementację.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1113">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="9cc50-1114">Odbicie i typy ogólne</span><span class="sxs-lookup"><span data-stu-id="9cc50-1114">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="9cc50-1115">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</span><span class="sxs-lookup"><span data-stu-id="9cc50-1115">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-1116">Zwraca tablicę <see cref="T:System.Type" /> obiekty reprezentujące ograniczenia bieżącego ogólnego, parametr typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1116">Returns an array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1117">Tablica <see cref="T:System.Type" /> obiekty reprezentujące ograniczenia bieżącego ogólnego, parametr typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1117">An array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1118">Każde ograniczenie parametru typu ogólnego jest wyrażona jako <xref:System.Type> obiektu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1118">Each constraint on a generic type parameter is expressed as a <xref:System.Type> object.</span></span> <span data-ttu-id="9cc50-1119">Użyj <xref:System.Type.IsClass%2A> właściwości w celu określenia, czy ograniczenie jest ograniczenie klasy bazowej; Jeśli właściwość ta zwraca `false`, ograniczenie jest ograniczenie interfejsu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1119">Use the <xref:System.Type.IsClass%2A> property to determine whether a constraint is the base class constraint; if the property returns `false`, the constraint is an interface constraint.</span></span> <span data-ttu-id="9cc50-1120">Jeśli parametrem typu bez ograniczenia klasy i bez ograniczeń interfejsu, zwracana jest pusta tablica.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1120">If a type parameter has no class constraint and no interface constraints, an empty array is returned.</span></span>  
  
 <span data-ttu-id="9cc50-1121">Aby uzyskać listę niezmiennych warunków dla terminów używanych w odbiciu rodzajowym, zobacz <xref:System.Type.IsGenericType%2A> uwagi dotyczące właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1121">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1122">Poniższy kod definiuje typ ogólny `Test` z dwoma parametrami typu, które mają z nią związane inne ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1122">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="9cc50-1123">Gdy program będzie działać, ograniczenia są sprawdzane przy użyciu <xref:System.Type.GenericParameterAttributes%2A> właściwości i <xref:System.Type.GetGenericParameterConstraints%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1123">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cc50-1124">Bieżący <see cref="T:System.Type" /> obiektu nie jest parametrem typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1124">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span></span> <span data-ttu-id="9cc50-1125">Oznacza to, że <see cref="P:System.Type.IsGenericParameter" /> właściwość zwraca <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1125">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span></span></exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="9cc50-1126">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</span><span class="sxs-lookup"><span data-stu-id="9cc50-1126">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-1127">Zwraca <see cref="T:System.Type" /> obiekt, który reprezentuje definicji typu ogólnego, z którego można skonstruować bieżącego typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1127">Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current generic type can be constructed.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1128">A <see cref="T:System.Type" /> obiekt reprezentujący typ ogólny, z którego można skonstruować bieżącego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1128">A <see cref="T:System.Type" /> object representing a generic type from which the current type can be constructed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1129">Definicja typu ogólnego jest szablonem, z którego można skonstruować innych typów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1129">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="9cc50-1130">Na przykład z definicji typu ogólnego `G<T>` (wyrażony w języku C# składni; `G(Of T)` w języku Visual Basic lub `generic <typename T> ref class G` w języku C++) można utworzyć i utworzyć wystąpienie typu `G<int>` (`G(Of Integer)` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-1130">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic).</span></span> <span data-ttu-id="9cc50-1131">Biorąc pod uwagę <xref:System.Type> obiekt reprezentujący to skonstruowany typ <xref:System.Type.GetGenericTypeDefinition%2A> metoda zwraca definicji typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1131">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the generic type definition.</span></span>  
  
 <span data-ttu-id="9cc50-1132">Jeśli dwa typy utworzone są tworzone na podstawie jednej definicji typu ogólnego, przy użyciu tych samych argumentów typu <xref:System.Type.GetGenericTypeDefinition%2A> metoda zwróci wartość taka sama <xref:System.Type> obiektu dla obu typów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1132">If two constructed types are created from the same generic type definition, using the same type arguments, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the same <xref:System.Type> object for both types.</span></span>  
  
 <span data-ttu-id="9cc50-1133">Jeśli wywołasz <xref:System.Type.GetGenericTypeDefinition%2A> metody <xref:System.Type> obiekt, który reprezentuje już definicji typu ogólnego, funkcja zwraca bieżący <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1133">If you call the <xref:System.Type.GetGenericTypeDefinition%2A> method on a <xref:System.Type> object that already represents a generic type definition, it returns the current <xref:System.Type>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="9cc50-1134">Tablica typów ogólnych nie jest sam ogólny.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1134">An array of generic types is not itself generic.</span></span> <span data-ttu-id="9cc50-1135">W kodzie języka C# `A<int>[] v;` lub kod języka Visual Basic `Dim v() As A(Of Integer)`, typ zmiennej `v` nie jest ogólna.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1135">In the C# code `A<int>[] v;` or the Visual Basic code `Dim v() As A(Of Integer)`, the type of variable `v` is not generic.</span></span> <span data-ttu-id="9cc50-1136">Użyj <xref:System.Type.IsGenericType%2A> do ustalenia, czy typ jest ogólny przed wywołaniem <xref:System.Type.GetGenericTypeDefinition%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1136">Use <xref:System.Type.IsGenericType%2A> to determine whether a type is generic before calling <xref:System.Type.GetGenericTypeDefinition%2A>.</span></span>  
  
 <span data-ttu-id="9cc50-1137">Aby uzyskać listę niezmiennych warunków dla terminów używanych w odbiciu rodzajowym, zobacz <xref:System.Type.IsGenericType%2A> uwagi dotyczące właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1137">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1138">Poniższy przykład kodu tworzy wystąpienie skonstruowanego typu za pomocą tworzenia zwykłego wystąpienia, a następnie używa <xref:System.Type.GetType%2A> i <xref:System.Type.GetGenericTypeDefinition%2A> metody, aby pobrać skonstruowanego typu i definicji typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1138">The following code example creates an instance of a constructed type by using ordinary instance creation and then uses the <xref:System.Type.GetType%2A> and <xref:System.Type.GetGenericTypeDefinition%2A> methods to retrieve the constructed type and the generic type definition.</span></span> <span data-ttu-id="9cc50-1139">W tym przykładzie użyto ogólnego <xref:System.Collections.Generic.Dictionary%602> typ; reprezentuje zbudowany typ <xref:System.Collections.Generic.Dictionary%602> z `Test` obiektów za pomocą kluczy ciągu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1139">This example uses the generic <xref:System.Collections.Generic.Dictionary%602> type; the constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cc50-1140">Bieżący typ nie jest typem ogólnym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1140">The current type is not a generic type.</span></span>  <span data-ttu-id="9cc50-1141">Oznacza to, że <see cref="P:System.Type.IsGenericType" /> zwraca <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1141">That is, <see cref="P:System.Type.IsGenericType" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cc50-1142">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1142">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="9cc50-1143">Klasy pochodne muszą zapewniać implementację.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1143">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="9cc50-1144">Odbicie i typy ogólne</span><span class="sxs-lookup"><span data-stu-id="9cc50-1144">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="9cc50-1145">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</span><span class="sxs-lookup"><span data-stu-id="9cc50-1145">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-1146">Zwraca kod skrótu dla tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1146">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1147">Kod skrótu dla tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1147">The hash code for this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1148">Ta metoda zastępuje <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1148">This method overrides <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1149">Poniższy przykład wyświetla skrótu `System.Windows.Forms.Button` klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1149">The following example displays the hash code of the `System.Windows.Forms.Button` class.</span></span>  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cc50-1150">Pobiera określony interfejs implementowany lub jest dziedziczona przez bieżący <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1150">Gets a specific interface implemented or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-1151">Ciąg zawierający nazwę interfejsu można pobrać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1151">The string containing the name of the interface to get.</span></span> <span data-ttu-id="9cc50-1152">Interfejsy ogólne to zniekształcone nazwy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1152">For generic interfaces, this is the mangled name.</span></span></param>
        <summary><span data-ttu-id="9cc50-1153">Wyszukuje interfejsu o określonej nazwie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1153">Searches for the interface with the specified name.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1154">Obiekt reprezentujący interfejs o określonej nazwie zaimplementować lub dziedziczone przez bieżącą <see cref="T:System.Type" />, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1154">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1155">Wyszukaj `name` jest uwzględniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1155">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="9cc50-1156">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Type> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1156">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1157">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje ograniczenia interfejsu i wszelkie interfejsy odziedziczone ograniczenia klasy lub interfejsu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1157">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1158">W przypadku ogólnych interfejsów `name` parametr jest zniekształcone nazwy, kończąc akcent (\`) i liczbę parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1158">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="9cc50-1159">Dotyczy to zarówno dla definicji interfejsów ogólnych i skonstruowany interfejsów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1159">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="9cc50-1160">Na przykład, aby znaleźć `IExample<T>` (`IExample(Of T)` w języku Visual Basic) lub `IExample<string>` (`IExample(Of String)` w języku Visual Basic), wyszukaj ``"IExample`1"``.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1160">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for ``"IExample`1"``.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1161">Poniższy przykład kodu wykorzystuje <xref:System.Type.GetInterface%28System.String%29> metodę wyszukiwania <xref:System.Collections.Hashtable> klasy dla <xref:System.Runtime.Serialization.IDeserializationCallback> interfejsu list i metody interfejsu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1161">The following code example uses the <xref:System.Type.GetInterface%28System.String%29> method to search the <xref:System.Collections.Hashtable> class for the <xref:System.Runtime.Serialization.IDeserializationCallback> interface, and lists the methods of the interface.</span></span>  
  
 <span data-ttu-id="9cc50-1162">Przykład kodu ilustruje też <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> przeciążenie metody i <xref:System.Type.GetInterfaceMap%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1162">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-1163"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1163"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="9cc50-1164">Bieżący <see cref="T:System.Type" /> reprezentuje typ, który implementuje ten interfejs ogólny z argumentami innego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1164">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-1165">Ciąg zawierający nazwę interfejsu można pobrać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1165">The string containing the name of the interface to get.</span></span> <span data-ttu-id="9cc50-1166">Interfejsy ogólne to zniekształcone nazwy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1166">For generic interfaces, this is the mangled name.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="9cc50-1167"><see langword="true" /> ignorowanie wielkości liter w tej części <paramref name="name" /> , który określa nazwę prosty interfejs (part, który określa przestrzeń nazw musi być poprawnie z uwzględnieniem wielkości liter).</span><span class="sxs-lookup"><span data-stu-id="9cc50-1167"><see langword="true" /> to ignore the case of that part of <paramref name="name" /> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).</span></span>  
  
<span data-ttu-id="9cc50-1168">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1168">-or-</span></span> 
 <span data-ttu-id="9cc50-1169"><see langword="false" /> Aby wykonać wyszukiwanie dla wszystkich części <paramref name="name" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1169"><see langword="false" /> to perform a case-sensitive search for all parts of <paramref name="name" />.</span></span></param>
        <summary><span data-ttu-id="9cc50-1170">W przypadku przesłonięcia w klasie pochodnej, wyszukuje określonego interfejsu, określająca, czy wykonać wyszukiwanie bez uwzględniania wielkości liter z nazwą interfejsu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1170">When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1171">Obiekt reprezentujący interfejs o określonej nazwie zaimplementować lub dziedziczone przez bieżącą <see cref="T:System.Type" />, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1171">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1172">`ignoreCase` Parametr dotyczy tylko nazwę prosty interfejs, a nie do przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1172">The `ignoreCase` parameter applies only to the simple interface name, not to the namespace.</span></span> <span data-ttu-id="9cc50-1173">Część `name` , który określa przestrzeń nazw musi mieć poprawną wielkość lub interfejsu nie zostanie znaleziony.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1173">The portion of `name` that specifies the namespace must have the correct case, or the interface will not be found.</span></span> <span data-ttu-id="9cc50-1174">Na przykład ciąg "System.icomparable" znajdzie <xref:System.IComparable> interfejsu, lecz ciąg "system.icomparable" nie ma.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1174">For example, the string "System.icomparable" finds the <xref:System.IComparable> interface, but the string "system.icomparable" does not.</span></span>  
  
 <span data-ttu-id="9cc50-1175">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Type> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1175">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1176">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje ograniczenia interfejsu i wszelkie interfejsy odziedziczone ograniczenia klasy lub interfejsu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1176">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1177">W przypadku ogólnych interfejsów `name` parametr jest zniekształcone nazwy, kończąc akcent (\`) i liczbę parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1177">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="9cc50-1178">Dotyczy to zarówno dla definicji interfejsów ogólnych i skonstruowany interfejsów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1178">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="9cc50-1179">Na przykład, aby znaleźć `IExample<T>` (`IExample(Of T)` w języku Visual Basic) lub `IExample<string>` (`IExample(Of String)` w języku Visual Basic), wyszukaj `"IExample`1"".</span><span class="sxs-lookup"><span data-stu-id="9cc50-1179">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for `"IExample`1"\`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1180">Poniższy przykład kodu wykorzystuje <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> metodę, aby wykonać wyszukiwanie bez uwzględniania wielkości liter z <xref:System.Collections.Hashtable> klasy dla <xref:System.Collections.IEnumerable> interfejsu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1180">The following code example uses the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method to perform a case-insensitive search of the <xref:System.Collections.Hashtable> class for the <xref:System.Collections.IEnumerable> interface.</span></span>  
  
 <span data-ttu-id="9cc50-1181">Przykład kodu ilustruje też <xref:System.Type.GetInterface%28System.String%29> przeciążenie metody i <xref:System.Type.GetInterfaceMap%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1181">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-1182"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1182"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="9cc50-1183">Bieżący <see cref="T:System.Type" /> reprezentuje typ, który implementuje ten interfejs ogólny z argumentami innego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1183">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="interfaceType"><span data-ttu-id="9cc50-1184">Typ interfejsu, który można pobrać mapowanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1184">The interface type to retrieve a mapping for.</span></span></param>
        <summary><span data-ttu-id="9cc50-1185">Zwraca mapowania interfejsu dla typu określonego interfejsu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1185">Returns an interface mapping for the specified interface type.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1186">Obiekt, który reprezentuje mapowania interfejsu dla <paramref name="interfaceType" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1186">An object that represents the interface mapping for <paramref name="interfaceType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1187">Mapę interfejsu wskazuje, jak interfejs jest mapowany do rzeczywiste elementy członkowskie dla klasy, która implementuje ten interfejs.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1187">The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.</span></span>  
  
 <span data-ttu-id="9cc50-1188">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, parametry są zastępowane przez odpowiednie argumenty typu w elementach typu <xref:System.Reflection.InterfaceMapping> zwracanego przez tę metodę.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1188">If the current <xref:System.Type> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <xref:System.Reflection.InterfaceMapping> returned by this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1189">Poniższy przykład wywołuje <xref:System.Type.GetInterfaceMap%2A> metodę pozwala ustalić jak <xref:System.IFormatProvider> mapuje interfejsu <xref:System.Globalization.CultureInfo> metod i sposób, w jaki <xref:System.IAppDomainSetup> mapuje interfejsu <xref:System.AppDomainSetup> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1189">The following example calls the <xref:System.Type.GetInterfaceMap%2A> method to determine how the <xref:System.IFormatProvider> interface maps to <xref:System.Globalization.CultureInfo> methods, and how the <xref:System.IAppDomainSetup> interface maps to <xref:System.AppDomainSetup> properties.</span></span> <span data-ttu-id="9cc50-1190">Należy zauważyć, że ponieważ <xref:System.IAppDomainSetup> interfejs definiuje zestaw właściwości zwracanego <xref:System.Reflection.InterfaceMapping> obiekt zawiera osobne <xref:System.Reflection.MethodInfo> obiektów dla właściwości get i set metod dostępu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1190">Note that, because the <xref:System.IAppDomainSetup> interface defines a set of properties, the returned <xref:System.Reflection.InterfaceMapping> object includes separate <xref:System.Reflection.MethodInfo> objects for a property's get and set accessors.</span></span>  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-1191"><paramref name="interfaceType" /> nie jest zaimplementowana przez bieżący typ.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1191"><paramref name="interfaceType" /> is not implemented by the current type.</span></span>  
  
<span data-ttu-id="9cc50-1192">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1192">-or-</span></span> 
<span data-ttu-id="9cc50-1193"><paramref name="interfaceType" /> Argumentu nie odwołuje się do interfejsu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1193">The <paramref name="interfaceType" /> argument does not refer to an interface.</span></span>  
  
<span data-ttu-id="9cc50-1194">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1194">-or-</span></span>

<span data-ttu-id="9cc50-1195">Bieżące wystąpienie lub <paramref name="interfaceType" /> argument jest to otwarty typ ogólny; czyli, <see cref="P:System.Type.ContainsGenericParameters" /> właściwość zwraca <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1195">The current instance or <paramref name="interfaceType" /> argument is an open generic type; that is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span>

<span data-ttu-id="9cc50-1196">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1196">-or-</span></span>


 <span data-ttu-id="9cc50-1197"><paramref name="interfaceType" /> jest to interfejs generyczny i bieżącym typem jest typem tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1197"><paramref name="interfaceType" /> is a generic interface, and the current type is an array type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-1198"><paramref name="interfaceType" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1198"><paramref name="interfaceType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cc50-1199">Bieżący <see cref="T:System.Type" /> reprezentuje parametr typu ogólnego; czyli <see cref="P:System.Type.IsGenericParameter" /> jest <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1199">The current <see cref="T:System.Type" /> represents a generic type parameter; that is, <see cref="P:System.Type.IsGenericParameter" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cc50-1200">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1200">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="9cc50-1201">Klasy pochodne muszą zapewniać implementację.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1201">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-1202">W przypadku przesłonięcia w klasie pochodnej pobiera wszystkie interfejsy implementowane lub dziedziczone przez bieżącą <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1202">When overridden in a derived class, gets all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1203">Tablica <see cref="T:System.Type" /> obiekty reprezentujące wszystkie interfejsy implementowane lub jest dziedziczona przez bieżący <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1203">An array of <see cref="T:System.Type" /> objects representing all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="9cc50-1204">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1204">-or-</span></span> 
<span data-ttu-id="9cc50-1205">Pusta tablica typu <see cref="T:System.Type" />, jeśli interfejsy nie są implementowane lub dziedziczone przez bieżącą <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1205">An empty array of type <see cref="T:System.Type" />, if no interfaces are implemented or inherited by the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1206"><xref:System.Type.GetInterfaces%2A> Metoda nie zwraca interfejsów w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1206">The <xref:System.Type.GetInterfaces%2A> method does not return interfaces in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="9cc50-1207">Twój kod nie może zależeć od kolejności, w której zwracane są interfejsy, ponieważ kolejność się zmienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1207">Your code must not depend on the order in which interfaces are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="9cc50-1208">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Type> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1208">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1209">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje ograniczenia interfejsu i wszelkie interfejsy odziedziczone ograniczenia klasy lub interfejsu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1209">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1210">Poniższy przykład pobiera typ określonej klasy i wyświetla wszystkie interfejsy, które typ implementuje lub dziedziczy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1210">The following example gets the type of the specified class and displays all the interfaces that the type implements or inherits.</span></span> <span data-ttu-id="9cc50-1211">Aby skompilować przykład Visual Basic, użyj następujących poleceń kompilatora:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1211">To compile the Visual Basic example, use the following compiler commands:</span></span>  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="9cc50-1212">Statycznego inicjatora jest wywoływany i zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1212">A static initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cc50-1213">Pobiera określony członków bieżącej <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1213">Gets the specified members of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-1214">Ciąg zawierający nazwę publiczne elementy członkowskie można pobrać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1214">The string containing the name of the public members to get.</span></span></param>
        <summary><span data-ttu-id="9cc50-1215">Wyszukuje publiczne elementy członkowskie o określonej nazwie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1215">Searches for the public members with the specified name.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1216">Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące publiczne elementy członkowskie o określonej nazwie, jeśli je znaleziono; w przeciwnym razie, pusta tablica.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1216">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1217">Wyszukaj `name` jest uwzględniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1217">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="9cc50-1218">Wyszukiwanie zawiera elementy publiczne wystąpienia static i public.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1218">The search includes public static and public instance members.</span></span>  
  
 <span data-ttu-id="9cc50-1219">Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1219">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="9cc50-1220"><xref:System.Type.GetMember%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1220">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="9cc50-1221">Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1221">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="9cc50-1222">Tego przeciążenia metody nie znajdzie inicjatory klasy (.cctor).</span><span class="sxs-lookup"><span data-stu-id="9cc50-1222">This method overload will not find class initializers (.cctor).</span></span> <span data-ttu-id="9cc50-1223">Aby znaleźć klasy inicjatory, użyj przeciążenia, które przyjmuje <xref:System.Reflection.BindingFlags>, a następnie określ <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-1223">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="9cc50-1224">Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1224">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="9cc50-1225">W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1225">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="9cc50-1226">Typ elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="9cc50-1226">Member Type</span></span>|<span data-ttu-id="9cc50-1227">Static</span><span class="sxs-lookup"><span data-stu-id="9cc50-1227">Static</span></span>|<span data-ttu-id="9cc50-1228">Niestatyczna</span><span class="sxs-lookup"><span data-stu-id="9cc50-1228">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="9cc50-1229">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="9cc50-1229">Constructor</span></span>|<span data-ttu-id="9cc50-1230">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1230">No</span></span>|<span data-ttu-id="9cc50-1231">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1231">No</span></span>|  
|<span data-ttu-id="9cc50-1232">Pole</span><span class="sxs-lookup"><span data-stu-id="9cc50-1232">Field</span></span>|<span data-ttu-id="9cc50-1233">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1233">No</span></span>|<span data-ttu-id="9cc50-1234">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1234">Yes.</span></span> <span data-ttu-id="9cc50-1235">Pole jest zawsze ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1235">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-1236">Zdarzenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1236">Event</span></span>|<span data-ttu-id="9cc50-1237">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-1237">Not applicable</span></span>|<span data-ttu-id="9cc50-1238">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1238">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-1239">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1239">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1240">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1240">See note 2 below.</span></span>|  
|<span data-ttu-id="9cc50-1241">Metoda</span><span class="sxs-lookup"><span data-stu-id="9cc50-1241">Method</span></span>|<span data-ttu-id="9cc50-1242">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1242">No</span></span>|<span data-ttu-id="9cc50-1243">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1243">Yes.</span></span> <span data-ttu-id="9cc50-1244">Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1244">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-1245">Typu zagnieżdżony</span><span class="sxs-lookup"><span data-stu-id="9cc50-1245">Nested Type</span></span>|<span data-ttu-id="9cc50-1246">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1246">No</span></span>|<span data-ttu-id="9cc50-1247">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1247">No</span></span>|  
|<span data-ttu-id="9cc50-1248">Właściwość</span><span class="sxs-lookup"><span data-stu-id="9cc50-1248">Property</span></span>|<span data-ttu-id="9cc50-1249">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-1249">Not applicable</span></span>|<span data-ttu-id="9cc50-1250">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1250">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-1251">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1251">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1252">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1252">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="9cc50-1253">Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1253">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="9cc50-1254">To jest porównanie binarne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1254">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="9cc50-1255">W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1255">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1256">Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1256">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="9cc50-1257">Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1257">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="9cc50-1258">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MemberInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1258">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1259">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje składowe ograniczenia klasy lub elementów członkowskich <xref:System.Object> przypadku bez ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1259">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1260">Dla metod rodzajowych nie ma argumentów typu w parametrze `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1260">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="9cc50-1261">Na przykład, kod C# `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` ma jeden argument rodzajowy typu `int`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1261">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1262">Poniższy przykład wyświetla wszystkie elementy członkowskie `String` klasy, które zaczynają się na literę C.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1262">The following example displays all the members of the `String` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-1263"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1263"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-1264">Ciąg zawierający nazwę elementy członkowskie można pobrać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1264">The string containing the name of the members to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="9cc50-1265">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1265">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-1266">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1266">-or-</span></span> 
<span data-ttu-id="9cc50-1267">Zero, aby zwrócić pustą tablicę.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1267">Zero, to return an empty array.</span></span></param>
        <summary><span data-ttu-id="9cc50-1268">Wyszukuje określony elementów członkowskich za pomocą ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1268">Searches for the specified members, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1269">Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące publiczne elementy członkowskie o określonej nazwie, jeśli je znaleziono; w przeciwnym razie, pusta tablica.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1269">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1270">Metoda ta może być zastąpiona przez klasę pochodną.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1270">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="9cc50-1271">Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1271">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="9cc50-1272"><xref:System.Type.GetMember%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1272">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="9cc50-1273">Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1273">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="9cc50-1274">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania elementów członkowskich, które można uwzględnić w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1274">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-1275">Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1275">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-1276">Określ `BindingFlags.Public` obejmujący publiczne elementy członkowskie w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1276">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1277">Określ `BindingFlags.NonPublic` obejmujący elementów członkowskich niepublicznych (czyli prywatne, wewnętrzne i chronione elementy członkowskie) w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1277">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1278">Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1278">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="9cc50-1279">Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1279">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="9cc50-1280">`BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1280">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="9cc50-1281">`BindingFlags.DeclaredOnly` Aby wyszukać tylko do elementów członkowskich zadeklarowanych w <xref:System.Type>, nie elementów członkowskich, które zostały po prostu odziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1281">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="9cc50-1282">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1282">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="9cc50-1283">Aby uzyskać inicjatora klasy (.cctor), za pomocą tego przeciążenia metody, należy określić ".cctor" dla `name`, i <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic) dla `bindingAttr`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1283">To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for `name`, and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="9cc50-1284">Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1284">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="9cc50-1285">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MemberInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1285">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1286">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje składowe ograniczenia klasy lub elementów członkowskich <xref:System.Object> przypadku bez ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1286">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1287">Dla metod rodzajowych nie ma argumentów typu w parametrze `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1287">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="9cc50-1288">Na przykład, kod C# `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` ma jeden argument rodzajowy typu `int`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1288">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1289">Poniższy przykład wyświetla wszystkie publiczne statyczne elementy członkowskie `myString` klasy, które zaczynają się na literę C.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1289">The following example displays all the public static members of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-1290"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1290"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-1291">Ciąg zawierający nazwę elementy członkowskie można pobrać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1291">The string containing the name of the members to get.</span></span></param>
        <param name="type"><span data-ttu-id="9cc50-1292">Wartość do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1292">The value to search for.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="9cc50-1293">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1293">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-1294">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1294">-or-</span></span> 
<span data-ttu-id="9cc50-1295">Zero, aby zwrócić pustą tablicę.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1295">Zero, to return an empty array.</span></span></param>
        <summary><span data-ttu-id="9cc50-1296">Wyszukuje określony elementy członkowskie typu określonego elementu członkowskiego, za pomocą ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1296">Searches for the specified members of the specified member type, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1297">Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące publiczne elementy członkowskie o określonej nazwie, jeśli je znaleziono; w przeciwnym razie, pusta tablica.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1297">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1298">Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1298">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="9cc50-1299"><xref:System.Type.GetMember%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1299">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="9cc50-1300">Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1300">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="9cc50-1301">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania elementów członkowskich, które można uwzględnić w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1301">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-1302">Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1302">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-1303">Określ `BindingFlags.Public` obejmujący publiczne elementy członkowskie w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1303">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1304">Określ `BindingFlags.NonPublic` obejmujący elementów członkowskich niepublicznych (czyli prywatne, wewnętrzne i chronione elementy członkowskie) w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1304">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1305">Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1305">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="9cc50-1306">Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1306">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="9cc50-1307">`BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1307">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="9cc50-1308">`BindingFlags.DeclaredOnly` Aby wyszukać tylko do elementów członkowskich zadeklarowanych w <xref:System.Type>, nie elementów członkowskich, które zostały po prostu odziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1308">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="9cc50-1309">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1309">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="9cc50-1310">Aby uzyskać inicjatora klasy (.cctor), za pomocą tego przeciążenia metody, należy określić ".cctor" dla `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> dla `type`, i <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w Visual Basic) dla `bindingAttr`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1310">To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> for `type`, and  <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="9cc50-1311">Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1311">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="9cc50-1312">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MemberInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1312">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1313">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje składowe ograniczenia klasy lub elementów członkowskich <xref:System.Object> przypadku bez ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1313">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1314">Dla metod rodzajowych nie ma argumentów typu w parametrze `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1314">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="9cc50-1315">Na przykład, kod C# `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` ma jeden argument rodzajowy typu `int`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1315">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1316">Poniższy przykład wyświetla wszystkie metody `myString` klasy, które zaczynają się na literę C.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1316">The following example displays all the methods of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-1317"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1317"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cc50-1318">Klasy pochodnej musi zapewniać implementację.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1318">A derived class must provide an implementation.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cc50-1319">Pobiera elementy członkowskie (właściwości, metody, pola, zdarzenia i tak dalej) bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1319">Gets the members (properties, methods, fields, events, and so on) of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-1320">Zwraca wszystkie publiczne elementy członkowskie bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1320">Returns all the public members of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1321">Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące wszystkie publiczne elementy członkowskie bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1321">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all the public members of the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="9cc50-1322">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1322">-or-</span></span> 
<span data-ttu-id="9cc50-1323">Pusta tablica typu <see cref="T:System.Reflection.MemberInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma publicznych elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1323">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have public members.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1324">Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1324">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="9cc50-1325"><xref:System.Type.GetMembers%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1325">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="9cc50-1326">Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1326">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="9cc50-1327">Tego przeciążenia metody wywołuje <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> przeciążenie metody z <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-1327">This method overload calls the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="9cc50-1328">Inicjatory klasy (.cctor) nie zostanie odnaleziony.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1328">It will not find class initializers (.cctor).</span></span> <span data-ttu-id="9cc50-1329">Aby znaleźć klasy inicjatory, użyj przeciążenia, które przyjmuje <xref:System.Reflection.BindingFlags>, a następnie określ <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-1329">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="9cc50-1330">Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1330">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="9cc50-1331">W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1331">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="9cc50-1332">Typ elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="9cc50-1332">Member Type</span></span>|<span data-ttu-id="9cc50-1333">Static</span><span class="sxs-lookup"><span data-stu-id="9cc50-1333">Static</span></span>|<span data-ttu-id="9cc50-1334">Niestatyczna</span><span class="sxs-lookup"><span data-stu-id="9cc50-1334">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="9cc50-1335">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="9cc50-1335">Constructor</span></span>|<span data-ttu-id="9cc50-1336">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1336">No</span></span>|<span data-ttu-id="9cc50-1337">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1337">No</span></span>|  
|<span data-ttu-id="9cc50-1338">Pole</span><span class="sxs-lookup"><span data-stu-id="9cc50-1338">Field</span></span>|<span data-ttu-id="9cc50-1339">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1339">No</span></span>|<span data-ttu-id="9cc50-1340">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1340">Yes.</span></span> <span data-ttu-id="9cc50-1341">Pole jest zawsze ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1341">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-1342">Zdarzenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1342">Event</span></span>|<span data-ttu-id="9cc50-1343">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-1343">Not applicable</span></span>|<span data-ttu-id="9cc50-1344">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1344">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-1345">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1345">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1346">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1346">See note 2 below.</span></span>|  
|<span data-ttu-id="9cc50-1347">Metoda</span><span class="sxs-lookup"><span data-stu-id="9cc50-1347">Method</span></span>|<span data-ttu-id="9cc50-1348">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1348">No</span></span>|<span data-ttu-id="9cc50-1349">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1349">Yes.</span></span> <span data-ttu-id="9cc50-1350">Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1350">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-1351">Typu zagnieżdżony</span><span class="sxs-lookup"><span data-stu-id="9cc50-1351">Nested Type</span></span>|<span data-ttu-id="9cc50-1352">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1352">No</span></span>|<span data-ttu-id="9cc50-1353">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1353">No</span></span>|  
|<span data-ttu-id="9cc50-1354">Właściwość</span><span class="sxs-lookup"><span data-stu-id="9cc50-1354">Property</span></span>|<span data-ttu-id="9cc50-1355">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-1355">Not applicable</span></span>|<span data-ttu-id="9cc50-1356">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1356">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-1357">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1357">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1358">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1358">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="9cc50-1359">Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1359">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="9cc50-1360">To jest porównanie binarne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1360">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="9cc50-1361">W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1361">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1362">Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1362">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="9cc50-1363">Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1363">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="9cc50-1364">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MemberInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1364">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1365">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje składowe ograniczenia klasy lub elementów członkowskich <xref:System.Object> przypadku bez ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1365">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1366">Poniższy przykład kodu demonstruje sposób używania <xref:System.Type.GetMembers> przeciążenia metody, aby zbierać informacje o wszystkich publicznych elementów członkowskich określonej klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1366">The following code example demonstrates how to use the <xref:System.Type.GetMembers> method overload to collect information about all public members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="9cc50-1367">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1367">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-1368">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1368">-or-</span></span> 
<span data-ttu-id="9cc50-1369">Zero (<see cref="F:System.Reflection.BindingFlags.Default" />), aby zwrócić pustą tablicę.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1369">Zero (<see cref="F:System.Reflection.BindingFlags.Default" />), to return an empty array.</span></span></param>
        <summary><span data-ttu-id="9cc50-1370">W przypadku przesłonięcia w klasie pochodnej, wyszukuje elementy członkowskie zdefiniowane dla bieżącego <see cref="T:System.Type" />, za pomocą ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1370">When overridden in a derived class, searches for the members defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1371">Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące wszystkie elementy członkowskie zdefiniowane dla bieżącego <see cref="T:System.Type" /> zgodnych ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1371">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all members defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="9cc50-1372">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1372">-or-</span></span> 
<span data-ttu-id="9cc50-1373">Pusta tablica typu <see cref="T:System.Reflection.MemberInfo" />, jeśli żadne składowe są zdefiniowane dla bieżącego <see cref="T:System.Type" />, lub jeśli żadna z określonych elementów członkowskich ograniczenia wiązania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1373">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if no members are defined for the current <see cref="T:System.Type" />, or if none of the defined members match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1374">Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1374">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="9cc50-1375"><xref:System.Type.GetMembers%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1375">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="9cc50-1376">Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1376">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="9cc50-1377">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania elementów członkowskich, które można uwzględnić w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1377">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-1378">Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1378">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-1379">Określ `BindingFlags.Public` obejmujący publiczne elementy członkowskie w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1379">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1380">Określ `BindingFlags.NonPublic` obejmujący elementów członkowskich niepublicznych (czyli prywatne, wewnętrzne i chronione elementy członkowskie) w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1380">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span> <span data-ttu-id="9cc50-1381">Tylko chronionych i wewnętrznych składowych w klasach bazowych są zwracane; prywatne elementy członkowskie na klasach bazowych nie są zwracane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1381">Only protected and internal members on base classes are returned; private members on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="9cc50-1382">Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1382">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="9cc50-1383">Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1383">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="9cc50-1384">`BindingFlags.DeclaredOnly` Aby wyszukać tylko do elementów członkowskich zadeklarowanych w <xref:System.Type>, nie elementów członkowskich, które zostały po prostu odziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1384">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="9cc50-1385">Wywołanie tej metody tylko z `Public` flagi lub tylko `NonPublic` flagi zwróci określone elementy członkowskie i nie wymaga inne flagi.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1385">Calling this method with only the `Public` flag or only the `NonPublic` flag will return the specified members and does not require any other flags.</span></span>  
  
 <span data-ttu-id="9cc50-1386">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1386">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="9cc50-1387">Aby uzyskać inicjatora klasy (.cctor), za pomocą tego przeciążenia metody, należy określić <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-1387">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="9cc50-1388">Można również uzyskać inicjatora klasy za pomocą <xref:System.Type.TypeInitializer%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1388">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="9cc50-1389">Jeśli bieżący element T:System.Type reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MemberInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1389">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1390">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje składowe ograniczenia klasy lub elementów członkowskich <xref:System.Object> przypadku bez ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1390">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1391">Poniższy przykład kodu demonstruje sposób używania <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> przeciążenia metody, aby zbierać informacje o wszystkich członków publiczne wystąpienia określonej klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1391">The following code example demonstrates how to use the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload to collect information about all public instance members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cc50-1392">Pobiera określonej metody bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1392">Gets a specific method of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-1393">Ciąg zawierający nazwę publicznej metody pobierania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1393">The string containing the name of the public method to get.</span></span></param>
        <summary><span data-ttu-id="9cc50-1394">Wyszukuje publicznej metody o określonej nazwie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1394">Searches for the public method with the specified name.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1395">Obiekt, który reprezentuje publicznej metody o określonej nazwie, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1395">An object that represents the public method with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1396">Wyszukaj `name` jest uwzględniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1396">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="9cc50-1397">Wyszukiwanie obejmuje metody publiczne wystąpienia static i public.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1397">The search includes public static and public instance methods.</span></span>  
  
 <span data-ttu-id="9cc50-1398">Jeśli metoda jest przeciążona i ma więcej niż jednej metody publiczne, <xref:System.Type.GetMethod%28System.String%29> metoda zgłasza wyjątek <xref:System.Reflection.AmbiguousMatchException> wyjątku.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1398">If a method is overloaded and has more than one public method, the <xref:System.Type.GetMethod%28System.String%29> method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="9cc50-1399">W poniższym przykładzie, jest zgłaszany wyjątek, ponieważ ma więcej niż jednego przeciążenia publicznych <xref:System.Int32.ToString%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1399">In the following example, an exception is thrown because there is more than one public overload of the <xref:System.Int32.ToString%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="9cc50-1400">Z drugiej strony ponieważ `Person.ToString` zastąpienia metody <xref:System.Object.ToString%2A?displayProperty=nameWithType> i dlatego nie jest przeciążona, <xref:System.Type.GetMethod%28System.String%29> metoda jest w stanie pobrać <xref:System.Reflection.MethodInfo> obiektu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1400">On the other hand, because the `Person.ToString` method overrides  <xref:System.Object.ToString%2A?displayProperty=nameWithType> and therefore is not overloaded, the <xref:System.Type.GetMethod%28System.String%29> method is able to retrieve the <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 <span data-ttu-id="9cc50-1401">Możesz wykonać jedną z następujących czynności, aby pobrać określonej metody:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1401">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="9cc50-1402">Wywołaj <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> metodę i określić `bindingAttr` argument, który unikatowo identyfikuje metodę.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1402">Call the <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> method and specify a `bindingAttr` argument that uniquely identifies the method.</span></span> <span data-ttu-id="9cc50-1403">Na przykład, jeśli wyjątek jest zgłaszany, ponieważ typ ma statycznych i przeciążenie wystąpienia, można określić `bindingAttr` argument <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1403">For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  `bindingAttr` argument  of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="9cc50-1404">Wywołanie przeciążenia <xref:System.Type.GetMethod%2A> metodę, która obejmuje `types` parametr, który definiuje typy parametrów metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1404">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="9cc50-1405">Wywołaj <xref:System.Type.GetMethods> metodę, która pobierze tablicę zawierającą wszystkie metody publiczne, należącymi do typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1405">Call the <xref:System.Type.GetMethods> method to retrieve an array containing all of the public methods belonging to a type.</span></span> <span data-ttu-id="9cc50-1406">Można następnie wykonać iterację do identyfikowania zduplikowanych metody o nazwie `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1406">You can then iterate it to identify the duplicate methods named `name`.</span></span>  
  
 <span data-ttu-id="9cc50-1407">Jeśli bieżący element T:System.Type reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MethodInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1407">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1408">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje metody ograniczenia klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1408">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1409">Dla metod rodzajowych nie ma argumentów typu w parametrze `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1409">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="9cc50-1410">Na przykład, kod C# `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` ma jeden argument rodzajowy typu `int`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1410">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1411">Poniższy przykład pobiera metodę o nazwie `MethodA`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1411">The following example gets a method named `MethodA`.</span></span>  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="9cc50-1412">Znaleziono więcej niż jednej metody o określonej nazwie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1412">More than one method is found with the specified name.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-1413"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1413"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-1414">Ciąg zawierający nazwę metody pobierania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1414">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="9cc50-1415">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1415">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-1416">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1416">-or-</span></span> 
<span data-ttu-id="9cc50-1417">Zero, aby zwrócić <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1417">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="9cc50-1418">Wyszukiwanie określonej metody, za pomocą ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1418">Searches for the specified method, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1419">Obiekt reprezentujący metodę, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1419">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1420">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania metod do uwzględnienia w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1420">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-1421">Należy określić <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> lub <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> w celu uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1421">You must specify either <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in order to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-1422">Określ <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> obejmujący metod publicznych w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1422">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1423">Określ <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> obejmujący metod niepublicznych (czyli prywatne, wewnętrzne i chronione metody) do wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1423">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1424">Określ <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1424">Specify <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="9cc50-1425">Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1425">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="9cc50-1426"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> Aby zignorować wielkość liter `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1426"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="9cc50-1427"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> Aby wyszukać tylko metod zadeklarowanych w <xref:System.Type>, nie metod, które zostały po prostu odziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1427"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="9cc50-1428">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1428">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="9cc50-1429">Jeśli metoda jest przeciążona i więcej niż jednego przeciążenia spełnia ograniczenia określone przez `bindingAttr` argument, metoda zgłasza <xref:System.Reflection.AmbiguousMatchException> wyjątku.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1429">If a method is overloaded and more than one overload meets the constraints specified by the `bindingAttr` argument, the method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="9cc50-1430">W poniższym przykładzie jest zgłaszany wyjątek, ponieważ:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1430">In the following example, an exception is thrown because:</span></span>  
  
-   <span data-ttu-id="9cc50-1431">`TestClass` Typ ma dwa przeciążenia publiczne wystąpienia `DisplayValue` metody `DisplayValue(String)` i `DisplayValue(String, Object[])`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1431">The `TestClass` type has two public instance overloads of the `DisplayValue` method, `DisplayValue(String)` and `DisplayValue(String, Object[])`.</span></span>  
  
-   <span data-ttu-id="9cc50-1432">`TestClass` Typ ma dwa przeciążenia publiczne wystąpienia `Equals` metody, z których jeden jest dziedziczony z <xref:System.Object>: `Equals(TestClass)` i `Equals(Object)`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1432">The `TestClass` type has two public instance overloads of the `Equals` method,  one of which is inherited from <xref:System.Object>: `Equals(TestClass)` and `Equals(Object)`.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 <span data-ttu-id="9cc50-1433">Możesz wykonać jedną z następujących czynności, aby pobrać określonej metody:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1433">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="9cc50-1434">Zmienić ograniczenia wiązania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1434">Change the binding constraints.</span></span> <span data-ttu-id="9cc50-1435">W poprzednim przykładzie próby pobrania publiczne wystąpienia `Equals` pobiera metodę, która jest deklarowana przez typ i nie są dziedziczone pomyślnie `Equals(TestClass)`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1435">In the previous example, attempting to retrieve a public instance `Equals` method that is declared by the type and not inherited successfully retrieves `Equals(TestClass)`.</span></span>  
  
-   <span data-ttu-id="9cc50-1436">Wywołanie przeciążenia <xref:System.Type.GetMethod%2A> metodę, która obejmuje `types` parametr, który definiuje typy parametrów metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1436">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="9cc50-1437">Wywołaj <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> metodę, która pobierze tablicę zawierającą wszystkie metody należące do typu, które mają atrybuty określonego powiązania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1437">Call the <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes.</span></span> <span data-ttu-id="9cc50-1438">Można następnie wykonać iterację do identyfikowania zduplikowanych metody o nazwie `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1438">You can then iterate it to identify the duplicate methods named `name`.</span></span> <span data-ttu-id="9cc50-1439">Podejście to zostało zilustrowane w poprzednim przykładzie obsługa <xref:System.Reflection.AmbiguousMatchException> wyjątku.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1439">This approach is illustrated in the previous example's handler for the <xref:System.Reflection.AmbiguousMatchException> exception.</span></span>  
  
 <span data-ttu-id="9cc50-1440">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MethodInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1440">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1441">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje metody ograniczenia klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1441">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1442">Dla metod rodzajowych nie ma argumentów typu w parametrze `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1442">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="9cc50-1443">Na przykład, kod C# `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` ma jeden argument rodzajowy typu `int`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1443">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1444">Poniższy przykład pobiera metodę, która spełnia określone powiązanie flag.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1444">The following example gets the method that matches the specified binding flags.</span></span>  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="9cc50-1445">Znaleziono więcej niż jedną metodę o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1445">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-1446"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1446"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-1447">Ciąg zawierający nazwę publicznej metody pobierania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1447">The string containing the name of the public method to get.</span></span></param>
        <param name="types"><span data-ttu-id="9cc50-1448">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla metody, aby uzyskać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1448">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="9cc50-1449">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1449">-or-</span></span> 
<span data-ttu-id="9cc50-1450">Pusta tablica <see cref="T:System.Type" /> obiektów (zgodnie z informacjami od <see cref="F:System.Type.EmptyTypes" /> pole) do uzyskania metody, która nie przyjmuje żadnych parametrów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1450">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <summary><span data-ttu-id="9cc50-1451">Wyszukiwanie określonej metody publiczne, której parametry pasuje określone typy argumentów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1451">Searches for the specified public method whose parameters match the specified argument types.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1452">Obiekt reprezentujący publicznej metody, której parametry pasuje określone typy argumentów, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1452">An object representing the public method whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1453">Wyszukaj `name` jest uwzględniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1453">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="9cc50-1454">Wyszukiwanie obejmuje metody publiczne wystąpienia static i public.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1454">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1455">Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1455">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="9cc50-1456">Parametry można pominąć jedynie podczas wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1456">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="9cc50-1457">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MethodInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1457">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1458">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje metody ograniczenia klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1458">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1459">`name` Parametru nie może zawierać argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1459">The `name` parameter cannot include type arguments.</span></span> <span data-ttu-id="9cc50-1460">Na przykład, kod C# `GetMethod("MyGenericMethod<int>")` wyszukuje metody o nazwie tekst "`MyGenericMethod<int>`", a nie dla metodę o nazwie `MyGenericMethod` ma jeden argument rodzajowy typu `int`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1460">For example, the C# code `GetMethod("MyGenericMethod<int>")` searches for a method with the text name "`MyGenericMethod<int>`", rather than for a method named `MyGenericMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="9cc50-1461">Zamiast tego należy użyć `GetMethod("MyGenericMethod")` za pomocą odpowiednich parametrów w `types` tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1461">Instead, use `GetMethod("MyGenericMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1462">Poniższy przykład umożliwia znalezienie określonego przeciążenia `MethodA`, określając różne typy argumentów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1462">The following example finds specific overloads of `MethodA`, specifying a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1463">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Przykład wymaga `/unsafe` — opcja kompilatora.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1463">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 <span data-ttu-id="9cc50-1464">Poniższy przykład pobiera <xref:System.Reflection.MethodInfo> obiekty reprezentujące `Add` metod typu nieogólnego ( <xref:System.Collections.ArrayList> klasy), to otwarty typ ogólny ( <xref:System.Collections.Generic.List%601> klasy), a typem ogólnym zamknięte ( `List(Of String)` typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1464">The following example retrieves <xref:System.Reflection.MethodInfo> objects that represent the `Add` methods  of a non-generic type (the <xref:System.Collections.ArrayList> class), an open generic type (the <xref:System.Collections.Generic.List%601> class), and a closed generic type (the `List(Of String)` type.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 <span data-ttu-id="9cc50-1465">W przykładzie zdefiniowano `GetAddMethod` metodę, która pobiera odpowiednie <xref:System.Reflection.MethodInfo> obiektu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1465">The example defines a `GetAddMethod` method that retrieves the appropriate <xref:System.Reflection.MethodInfo> object.</span></span> <span data-ttu-id="9cc50-1466">Aby zapewnić `types` argument to otwarty typ ogólny, wywoływanych przez nią <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1466">To provide the `types` argument for an open generic type, it calls the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="9cc50-1467">Aby zapewnić `types` argument zamknięty typ ogólny, pobiera wartość <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1467">To provide the `types` argument for a closed generic type, it retrieves the value of the <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="9cc50-1468">Więcej niż jednej metody znajduje się o określonej nazwie i określić parametry.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1468">More than one method is found with the specified name and specified parameters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-1469"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1469"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cc50-1470">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1470">-or-</span></span> 
 <span data-ttu-id="9cc50-1471"><paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1471"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cc50-1472">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1472">-or-</span></span> 
<span data-ttu-id="9cc50-1473">Jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1473">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-1474"><paramref name="types" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1474"><paramref name="types" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-1475">Ciąg zawierający nazwę publicznej metody pobierania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1475">The string containing the name of the public method to get.</span></span></param>
        <param name="types"><span data-ttu-id="9cc50-1476">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla metody, aby uzyskać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1476">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="9cc50-1477">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1477">-or-</span></span> 
<span data-ttu-id="9cc50-1478">Pusta tablica <see cref="T:System.Type" /> obiektów (zgodnie z informacjami od <see cref="F:System.Type.EmptyTypes" /> pole) do uzyskania metody, która nie przyjmuje żadnych parametrów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1478">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="9cc50-1479">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <paramref name="types" /> tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1479">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="9cc50-1480">Można używać tylko podczas wywoływania przez parametry międzyoperacyjności i tylko wtedy COM, które są przekazywane przez odwołanie, są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1480">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="9cc50-1481">Domyślny konsolidator nie przetwarza tego parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1481">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="9cc50-1482">Wyszukiwanie określonej metody publiczne, której parametry odpowiadają określone typy argumentów i modyfikatorów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1482">Searches for the specified public method whose parameters match the specified argument types and modifiers.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1483">Obiekt reprezentujący metodę publiczną, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1483">An object representing the public method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1484">Mimo że domyślny integrator nie przetwarza <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1484">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="9cc50-1485">`ParameterModifier` jest używana tylko podczas wywoływania przez współdziałania z modelem COM i są obsługiwane tylko w przypadku parametrów, które są przekazywane przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1485">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="9cc50-1486">Wyszukaj `name` jest uwzględniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1486">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="9cc50-1487">Wyszukiwanie obejmuje metody publiczne wystąpienia static i public.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1487">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1488">Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1488">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="9cc50-1489">Parametry można pominąć jedynie podczas wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1489">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="9cc50-1490">Jeśli bieżący element T:System.Type reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MethodInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1490">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1491">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje metody ograniczenia klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1491">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1492">Dla metod rodzajowych nie ma argumentów typu w parametrze `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1492">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="9cc50-1493">Na przykład, kod C# `GetMethod("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` ma jeden argument rodzajowy typu `int`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1493">For example, the C# code `GetMethod("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="9cc50-1494">Zamiast tego należy użyć `GetMethod("MyMethod")` za pomocą odpowiednich parametrów w `types` tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1494">Instead, use `GetMethod("MyMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="9cc50-1495">Więcej niż jednej metody znajduje się o określonej nazwie i określić parametry.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1495">More than one method is found with the specified name and specified parameters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-1496"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1496"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cc50-1497">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1497">-or-</span></span> 
 <span data-ttu-id="9cc50-1498"><paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1498"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cc50-1499">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1499">-or-</span></span> 
<span data-ttu-id="9cc50-1500">Jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1500">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-1501"><paramref name="types" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1501"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="9cc50-1502">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1502">-or-</span></span> 
 <span data-ttu-id="9cc50-1503"><paramref name="modifiers" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1503"><paramref name="modifiers" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-1504">Ciąg zawierający nazwę metody pobierania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1504">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="9cc50-1505">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1505">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-1506">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1506">-or-</span></span> 
<span data-ttu-id="9cc50-1507">Zero, aby zwrócić <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1507">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="9cc50-1508">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1508">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="9cc50-1509">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1509">-or-</span></span> 
<span data-ttu-id="9cc50-1510">Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1510">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="types"><span data-ttu-id="9cc50-1511">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla metody, aby uzyskać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1511">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="9cc50-1512">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1512">-or-</span></span> 
<span data-ttu-id="9cc50-1513">Pusta tablica <see cref="T:System.Type" /> obiektów (zgodnie z informacjami od <see cref="F:System.Type.EmptyTypes" /> pole) do uzyskania metody, która nie przyjmuje żadnych parametrów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1513">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="9cc50-1514">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <paramref name="types" /> tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1514">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="9cc50-1515">Można używać tylko podczas wywoływania przez parametry międzyoperacyjności i tylko wtedy COM, które są przekazywane przez odwołanie, są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1515">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="9cc50-1516">Domyślny konsolidator nie przetwarza tego parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1516">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="9cc50-1517">Wyszukuje określoną metodę, której parametry odpowiadają określone typy argumentów i modyfikatorów, za pomocą ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1517">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1518">Obiekt reprezentujący metodę, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1518">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1519">Mimo że domyślny integrator nie przetwarza <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1519">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="9cc50-1520">`ParameterModifier` jest używana tylko podczas wywoływania przez współdziałania z modelem COM i są obsługiwane tylko w przypadku parametrów, które są przekazywane przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1520">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="9cc50-1521">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania metod do uwzględnienia w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1521">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-1522">Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1522">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-1523">Określ `BindingFlags.Public` obejmujący metod publicznych w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1523">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1524">Określ `BindingFlags.NonPublic` obejmujący metod niepublicznych (czyli prywatne, wewnętrzne i chronione metody) do wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1524">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1525">Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1525">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="9cc50-1526">Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1526">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="9cc50-1527">`BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1527">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="9cc50-1528">`BindingFlags.DeclaredOnly` Aby wyszukać tylko metod zadeklarowanych w <xref:System.Type>, nie metod, które zostały po prostu odziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1528">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="9cc50-1529">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1529">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1530">Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1530">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="9cc50-1531">Parametry można pominąć jedynie podczas wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1531">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="9cc50-1532">Jeśli bieżący element T:System.Type reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MethodInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1532">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1533">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje metody ograniczenia klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1533">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1534">Dla metod rodzajowych nie ma argumentów typu w parametrze `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1534">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="9cc50-1535">Na przykład, kod C# `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` ma jeden argument rodzajowy typu `int`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1535">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1536">Poniższy przykład umożliwia znalezienie określonego przeciążenia `MethodA`, określając ograniczenia wiązania i różne typy argumentów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1536">The following example finds specific overloads of `MethodA`, specifying binding constraints and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1537">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Przykład wymaga `/unsafe` — opcja kompilatora.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1537">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="9cc50-1538">Znaleziono więcej niż jedną metodę o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1538">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-1539"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1539"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cc50-1540">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1540">-or-</span></span> 
 <span data-ttu-id="9cc50-1541"><paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1541"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cc50-1542">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1542">-or-</span></span> 
<span data-ttu-id="9cc50-1543">Jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1543">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-1544"><paramref name="types" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1544"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="9cc50-1545">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1545">-or-</span></span> 
 <span data-ttu-id="9cc50-1546"><paramref name="modifiers" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1546"><paramref name="modifiers" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-1547">Ciąg zawierający nazwę metody pobierania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1547">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="9cc50-1548">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1548">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-1549">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1549">-or-</span></span> 
<span data-ttu-id="9cc50-1550">Zero, aby zwrócić <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1550">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="9cc50-1551">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1551">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="9cc50-1552">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1552">-or-</span></span> 
<span data-ttu-id="9cc50-1553">Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1553">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="9cc50-1554">Obiekt, który określa zestaw reguł dotyczących kolejności i układ argumentów, jak wartość zwracana jest przekazywana, jakie rejestrów są używane dla argumentów i jak stos jest czyszczony.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1554">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="9cc50-1555">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla metody, aby uzyskać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1555">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="9cc50-1556">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1556">-or-</span></span> 
<span data-ttu-id="9cc50-1557">Pusta tablica <see cref="T:System.Type" /> obiektów (zgodnie z informacjami od <see cref="F:System.Type.EmptyTypes" /> pole) do uzyskania metody, która nie przyjmuje żadnych parametrów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1557">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="9cc50-1558">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <paramref name="types" /> tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1558">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="9cc50-1559">Można używać tylko podczas wywoływania przez parametry międzyoperacyjności i tylko wtedy COM, które są przekazywane przez odwołanie, są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1559">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="9cc50-1560">Domyślny konsolidator nie przetwarza tego parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1560">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="9cc50-1561">Wyszukuje określoną metodę, której parametry odpowiadają określone typy argumentów i modyfikatorów, za pomocą ograniczeń w określonym powiązaniu i określonej konwencji wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1561">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1562">Obiekt reprezentujący metodę, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1562">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1563">Mimo że domyślny integrator nie przetwarza <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1563">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="9cc50-1564">`ParameterModifier` jest używana tylko podczas wywoływania przez współdziałania z modelem COM i są obsługiwane tylko w przypadku parametrów, które są przekazywane przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1564">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="9cc50-1565">W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `GetXXX` metody uwzględnianiem typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1565">The following table shows what members of a base class are returned by the `GetXXX` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="9cc50-1566">Typ elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="9cc50-1566">Member Type</span></span>|<span data-ttu-id="9cc50-1567">Static</span><span class="sxs-lookup"><span data-stu-id="9cc50-1567">Static</span></span>|<span data-ttu-id="9cc50-1568">Niestatyczna</span><span class="sxs-lookup"><span data-stu-id="9cc50-1568">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="9cc50-1569">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="9cc50-1569">Constructor</span></span>|<span data-ttu-id="9cc50-1570">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1570">No</span></span>|<span data-ttu-id="9cc50-1571">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1571">No</span></span>|  
|<span data-ttu-id="9cc50-1572">Pole</span><span class="sxs-lookup"><span data-stu-id="9cc50-1572">Field</span></span>|<span data-ttu-id="9cc50-1573">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1573">No</span></span>|<span data-ttu-id="9cc50-1574">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1574">Yes.</span></span> <span data-ttu-id="9cc50-1575">Pole jest zawsze ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1575">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-1576">Zdarzenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1576">Event</span></span>|<span data-ttu-id="9cc50-1577">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-1577">Not applicable</span></span>|<span data-ttu-id="9cc50-1578">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1578">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-1579">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1579">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1580">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1580">See note 2 below.</span></span>|  
|<span data-ttu-id="9cc50-1581">Metoda</span><span class="sxs-lookup"><span data-stu-id="9cc50-1581">Method</span></span>|<span data-ttu-id="9cc50-1582">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1582">No</span></span>|<span data-ttu-id="9cc50-1583">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1583">Yes.</span></span> <span data-ttu-id="9cc50-1584">Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1584">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-1585">Typu zagnieżdżony</span><span class="sxs-lookup"><span data-stu-id="9cc50-1585">Nested Type</span></span>|<span data-ttu-id="9cc50-1586">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1586">No</span></span>|<span data-ttu-id="9cc50-1587">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1587">No</span></span>|  
|<span data-ttu-id="9cc50-1588">Właściwość</span><span class="sxs-lookup"><span data-stu-id="9cc50-1588">Property</span></span>|<span data-ttu-id="9cc50-1589">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-1589">Not applicable</span></span>|<span data-ttu-id="9cc50-1590">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1590">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-1591">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1591">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1592">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1592">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="9cc50-1593">Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1593">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="9cc50-1594">To jest porównanie binarne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1594">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="9cc50-1595">W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1595">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1596">Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1596">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="9cc50-1597">Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1597">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="9cc50-1598">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania metod do uwzględnienia w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1598">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-1599">Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1599">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-1600">Określ `BindingFlags.Public` obejmujący metod publicznych w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1600">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1601">Określ `BindingFlags.NonPublic` obejmujący metod niepublicznych (czyli prywatne, wewnętrzne i chronione metody) do wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1601">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1602">Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1602">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="9cc50-1603">Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1603">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="9cc50-1604">`BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1604">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="9cc50-1605">`BindingFlags.DeclaredOnly` Aby wyszukać tylko metod zadeklarowanych w <xref:System.Type>, nie metod, które zostały po prostu odziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1605">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="9cc50-1606">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1606">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1607">Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1607">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="9cc50-1608">Parametry można pominąć jedynie podczas wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1608">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="9cc50-1609">Jeśli bieżący element T:System.Type reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MethodInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1609">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1610">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje metody ograniczenia klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1610">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1611">Dla metod rodzajowych nie ma argumentów typu w parametrze `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1611">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="9cc50-1612">Na przykład, kod C# `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` ma jeden argument rodzajowy typu `int`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1612">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1613">Poniższy przykład umożliwia znalezienie określonego przeciążenia `MethodA`, określając ograniczenia wiązania, Konwencje wywoływania oraz różne typy argumentów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1613">The following example finds specific overloads of `MethodA`, specifying binding constraints, calling conventions, and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1614">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Przykład wymaga `/unsafe` — opcja kompilatora.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1614">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="9cc50-1615">Znaleziono więcej niż jedną metodę o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1615">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-1616"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1616"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cc50-1617">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1617">-or-</span></span> 
 <span data-ttu-id="9cc50-1618"><paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1618"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cc50-1619">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1619">-or-</span></span> 
<span data-ttu-id="9cc50-1620">Jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1620">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-1621"><paramref name="types" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1621"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="9cc50-1622">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1622">-or-</span></span> 
 <span data-ttu-id="9cc50-1623"><paramref name="modifiers" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1623"><paramref name="modifiers" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-1624">Ciąg zawierający nazwę metody pobierania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1624">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="9cc50-1625">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1625">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-1626">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1626">-or-</span></span> 
<span data-ttu-id="9cc50-1627">Zero, aby zwrócić <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1627">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="9cc50-1628">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1628">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="9cc50-1629">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1629">-or-</span></span> 
<span data-ttu-id="9cc50-1630">Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1630">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="9cc50-1631">Obiekt, który określa zestaw reguł dotyczących kolejności i układu argumentów, jak wartość zwracana jest przekazywana, jakie rejestrów są używane dla argumentów i jakie procesy czyści stos.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1631">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</span></span></param>
        <param name="types"><span data-ttu-id="9cc50-1632">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla metody, aby uzyskać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1632">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="9cc50-1633">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1633">-or-</span></span> 
<span data-ttu-id="9cc50-1634">Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie metodę, która nie przyjmuje żadnych parametrów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1634">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</span></span>  
  
<span data-ttu-id="9cc50-1635">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1635">-or-</span></span> 
 <span data-ttu-id="9cc50-1636"><see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1636"><see langword="null" />.</span></span> <span data-ttu-id="9cc50-1637">Jeśli <paramref name="types" /> jest <see langword="null" />, argumenty nie zostały dopasowane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1637">If <paramref name="types" /> is <see langword="null" />, arguments are not matched.</span></span></param>
        <param name="modifiers"><span data-ttu-id="9cc50-1638">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <paramref name="types" /> tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1638">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="9cc50-1639">Domyślny konsolidator nie przetwarza tego parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1639">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="9cc50-1640">W przypadku przesłonięcia w klasie pochodnej, wyszukuje określoną metodę, której parametry odpowiadają określone typy argumentów i modyfikatorów, korzystając z ograniczeń w określonym powiązaniu i określonej konwencji wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1640">When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1641">Obiekt reprezentujący metodę, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1641">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1642">Mimo że domyślny integrator nie przetwarza <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1642">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="9cc50-1643">`ParameterModifier` jest używana tylko podczas wywoływania przez współdziałania z modelem COM i są obsługiwane tylko w przypadku parametrów, które są przekazywane przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1643">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="9cc50-1644">Jeśli `types` jest `null`, argumenty nie zostały dopasowane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1644">If `types` is `null`, arguments are not matched.</span></span>  
  
 <span data-ttu-id="9cc50-1645">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania metod do uwzględnienia w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1645">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-1646">Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1646">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-1647">Określ `BindingFlags.Public` obejmujący metod publicznych w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1647">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1648">Określ `BindingFlags.NonPublic` obejmujący metod niepublicznych (czyli prywatne, wewnętrzne i chronione metody) do wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1648">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1649">Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1649">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="9cc50-1650">Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1650">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="9cc50-1651">`BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1651">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="9cc50-1652">`BindingFlags.DeclaredOnly` Aby wyszukać tylko metod zadeklarowanych w <xref:System.Type>, nie metod, które zostały po prostu odziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1652">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="9cc50-1653">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1653">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="9cc50-1654">Znaleziono więcej niż jedną metodę o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1654">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-1655"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1655"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-1656"><paramref name="types" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1656"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="9cc50-1657">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1657">-or-</span></span> 
 <span data-ttu-id="9cc50-1658"><paramref name="modifiers" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1658"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="9cc50-1659">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1659">-or-</span></span> 
 <span data-ttu-id="9cc50-1660"><paramref name="types" /> i <paramref name="modifiers" /> nie mają tę samą długość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1660"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cc50-1661">Bieżącym typem jest <see cref="T:System.Reflection.Emit.TypeBuilder" /> lub <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1661">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cc50-1662">Pobiera metody bieżący <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1662">Gets the methods of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-1663">Zwraca wszystkie metody publiczne bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1663">Returns all the public methods of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1664">Tablica <see cref="T:System.Reflection.MethodInfo" /> obiekty reprezentujące wszystkie metody publiczne zdefiniowane dla bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1664">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the public methods defined for the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="9cc50-1665">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1665">-or-</span></span> 
<span data-ttu-id="9cc50-1666">Pusta tablica typu <see cref="T:System.Reflection.MethodInfo" />, jeśli nie metody publiczne są zdefiniowane dla bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1666">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no public methods are defined for the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1667"><xref:System.Type.GetMethods%2A> Metoda nie zwraca metod w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1667">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="9cc50-1668">Twój kod nie może zależeć od kolejności, w której zwracane są metody, ponieważ kolejność się zmienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1668">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="9cc50-1669">Konstruktory nie są uwzględnione w tablicy zwrócony przez wywołanie tej metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1669">Constructors are not included in the array of methods returned by this call.</span></span> <span data-ttu-id="9cc50-1670">Wywołania oddzielnych `GetConstructors()` można pobrać metody konstruktora.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1670">Make a separate call to `GetConstructors()` to get the constructor methods.</span></span>  
  
 <span data-ttu-id="9cc50-1671">W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1671">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="9cc50-1672">Typ elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="9cc50-1672">Member Type</span></span>|<span data-ttu-id="9cc50-1673">Static</span><span class="sxs-lookup"><span data-stu-id="9cc50-1673">Static</span></span>|<span data-ttu-id="9cc50-1674">Niestatyczna</span><span class="sxs-lookup"><span data-stu-id="9cc50-1674">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="9cc50-1675">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="9cc50-1675">Constructor</span></span>|<span data-ttu-id="9cc50-1676">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1676">No</span></span>|<span data-ttu-id="9cc50-1677">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1677">No</span></span>|  
|<span data-ttu-id="9cc50-1678">Pole</span><span class="sxs-lookup"><span data-stu-id="9cc50-1678">Field</span></span>|<span data-ttu-id="9cc50-1679">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1679">No</span></span>|<span data-ttu-id="9cc50-1680">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1680">Yes.</span></span> <span data-ttu-id="9cc50-1681">Pole jest zawsze ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1681">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-1682">Zdarzenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1682">Event</span></span>|<span data-ttu-id="9cc50-1683">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-1683">Not applicable</span></span>|<span data-ttu-id="9cc50-1684">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1684">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-1685">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1685">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1686">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1686">See note 2 below.</span></span>|  
|<span data-ttu-id="9cc50-1687">Metoda</span><span class="sxs-lookup"><span data-stu-id="9cc50-1687">Method</span></span>|<span data-ttu-id="9cc50-1688">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1688">No</span></span>|<span data-ttu-id="9cc50-1689">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1689">Yes.</span></span> <span data-ttu-id="9cc50-1690">Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1690">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-1691">Typu zagnieżdżony</span><span class="sxs-lookup"><span data-stu-id="9cc50-1691">Nested Type</span></span>|<span data-ttu-id="9cc50-1692">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1692">No</span></span>|<span data-ttu-id="9cc50-1693">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1693">No</span></span>|  
|<span data-ttu-id="9cc50-1694">Właściwość</span><span class="sxs-lookup"><span data-stu-id="9cc50-1694">Property</span></span>|<span data-ttu-id="9cc50-1695">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-1695">Not applicable</span></span>|<span data-ttu-id="9cc50-1696">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1696">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-1697">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1697">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1698">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1698">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="9cc50-1699">Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1699">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="9cc50-1700">To jest porównanie binarne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1700">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="9cc50-1701">W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1701">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1702">Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1702">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="9cc50-1703">Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1703">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1704">Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1704">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="9cc50-1705">Parametry można pominąć jedynie podczas wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1705">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="9cc50-1706">Jeśli bieżący element T:System.Type reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MethodInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1706">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1707">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje metody ograniczenia klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1707">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="9cc50-1708">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1708">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-1709">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1709">-or-</span></span> 
<span data-ttu-id="9cc50-1710">Zero, aby zwrócić <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1710">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="9cc50-1711">W przypadku przesłonięcia w klasie pochodnej, wyszukuje metody zdefiniowane dla bieżącego <see cref="T:System.Type" />, za pomocą ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1711">When overridden in a derived class, searches for the methods defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1712">Tablica <see cref="T:System.Reflection.MethodInfo" /> obiekty reprezentujące wszystkie metody zdefiniowane dla bieżącego <see cref="T:System.Type" /> zgodnych ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1712">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all methods defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="9cc50-1713">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1713">-or-</span></span> 
<span data-ttu-id="9cc50-1714">Pusta tablica typu <see cref="T:System.Reflection.MethodInfo" />, jeśli nie metody są zdefiniowane dla bieżącego <see cref="T:System.Type" />, lub jeśli żadna z metody zdefiniowane ograniczenia wiązania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1714">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no methods are defined for the current <see cref="T:System.Type" />, or if none of the defined methods match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1715"><xref:System.Type.GetMethods%2A> Metoda nie zwraca metod w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1715">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="9cc50-1716">Twój kod nie może zależeć od kolejności, w której zwracane są metody, ponieważ kolejność się zmienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1716">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="9cc50-1717">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania metod do uwzględnienia w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1717">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-1718">Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1718">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-1719">Określ `BindingFlags.Public` obejmujący metod publicznych w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1719">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1720">Określ `BindingFlags.NonPublic` obejmujący metod niepublicznych (czyli prywatne, wewnętrzne i chronione metody) do wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1720">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span> <span data-ttu-id="9cc50-1721">Tylko chronionych i wewnętrznych metod w klasach bazowych są zwracane; metody prywatne na klasach bazowych nie są zwracane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1721">Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="9cc50-1722">Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1722">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="9cc50-1723">Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1723">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="9cc50-1724">`BindingFlags.DeclaredOnly` Aby wyszukać tylko metod zadeklarowanych w <xref:System.Type>, nie metod, które zostały po prostu odziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1724">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="9cc50-1725">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1725">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1726">Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1726">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="9cc50-1727">Parametry można pominąć jedynie podczas wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1727">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="9cc50-1728">Jeśli bieżący element T:System.Type reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.MethodInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1728">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1729">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje metody ograniczenia klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1729">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1730">Poniższy przykład tworzy klasę za pomocą dwóch metod publicznych i jedną metodę chronionych, tworzy `Type` obiekt odpowiadający `MyTypeClass`wszystkich metod publicznych i niepublicznych pobiera i wyświetla ich nazwy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1730">The following example creates a class with two public methods and one protected method, creates a `Type` object corresponding to `MyTypeClass`, gets all public and non-public methods, and displays their names.</span></span>  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cc50-1731">Pobiera określonego typu zagnieżdżone w obrębie bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1731">Gets a specific type nested within the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-1732">Ciąg zawierający nazwę typu zagnieżdżonego, aby uzyskać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1732">The string containing the name of the nested type to get.</span></span></param>
        <summary><span data-ttu-id="9cc50-1733">Wyszukuje publicznego typu zagnieżdżonego o określonej nazwie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1733">Searches for the public nested type with the specified name.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1734">Obiekt reprezentujący publicznego typu zagnieżdżonego o określonej nazwie, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1734">An object representing the public nested type with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1735">Wyszukaj `name` jest uwzględniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1735">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="9cc50-1736">Użyj prostych nazwy klasy zagnieżdżonej dla `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1736">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="9cc50-1737">Nie kwalifikuje się on z nazwą klasy zewnętrznej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1737">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="9cc50-1738">Ogólne klasy zagnieżdżonej Użyj zniekształcone nazwy — to znaczy, Dołącz akcent i liczby argumentów rodzajowych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1738">For a generic nested class, use the mangled name - that is, append a grave accent and the number of generic arguments.</span></span> <span data-ttu-id="9cc50-1739">Na przykład użyć ciągu "wewnętrzny\`1" Aby uzyskać ogólny klasy zagnieżdżonej `Inner<T>` (`Inner(Of T)` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-1739">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="9cc50-1740">Nie dołączaj parametrów typu składnia specyficzny dla języka.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1740">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="9cc50-1741">W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1741">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="9cc50-1742">Typ elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="9cc50-1742">Member Type</span></span>|<span data-ttu-id="9cc50-1743">Static</span><span class="sxs-lookup"><span data-stu-id="9cc50-1743">Static</span></span>|<span data-ttu-id="9cc50-1744">Niestatyczna</span><span class="sxs-lookup"><span data-stu-id="9cc50-1744">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="9cc50-1745">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="9cc50-1745">Constructor</span></span>|<span data-ttu-id="9cc50-1746">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1746">No</span></span>|<span data-ttu-id="9cc50-1747">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1747">No</span></span>|  
|<span data-ttu-id="9cc50-1748">Pole</span><span class="sxs-lookup"><span data-stu-id="9cc50-1748">Field</span></span>|<span data-ttu-id="9cc50-1749">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1749">No</span></span>|<span data-ttu-id="9cc50-1750">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1750">Yes.</span></span> <span data-ttu-id="9cc50-1751">Pole jest zawsze ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1751">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-1752">Zdarzenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1752">Event</span></span>|<span data-ttu-id="9cc50-1753">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-1753">Not applicable</span></span>|<span data-ttu-id="9cc50-1754">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1754">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-1755">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1755">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1756">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1756">See note 2 below.</span></span>|  
|<span data-ttu-id="9cc50-1757">Metoda</span><span class="sxs-lookup"><span data-stu-id="9cc50-1757">Method</span></span>|<span data-ttu-id="9cc50-1758">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1758">No</span></span>|<span data-ttu-id="9cc50-1759">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1759">Yes.</span></span> <span data-ttu-id="9cc50-1760">Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1760">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-1761">Typu zagnieżdżony</span><span class="sxs-lookup"><span data-stu-id="9cc50-1761">Nested Type</span></span>|<span data-ttu-id="9cc50-1762">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1762">No</span></span>|<span data-ttu-id="9cc50-1763">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1763">No</span></span>|  
|<span data-ttu-id="9cc50-1764">Właściwość</span><span class="sxs-lookup"><span data-stu-id="9cc50-1764">Property</span></span>|<span data-ttu-id="9cc50-1765">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-1765">Not applicable</span></span>|<span data-ttu-id="9cc50-1766">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1766">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-1767">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1767">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1768">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1768">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="9cc50-1769">Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1769">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="9cc50-1770">To jest porównanie binarne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1770">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="9cc50-1771">W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1771">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1772">Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1772">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="9cc50-1773">Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1773">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="9cc50-1774">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje zagnieżdżone typy ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1774">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="9cc50-1775">Jeśli zagnieżdżony jest typ ogólny , metoda ta zwraca jego definicję typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1775">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="9cc50-1776">Ta zasada obowiązuje, nawet jeśli otaczający typ ogólny jest skonstruowany jako zamknięty.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1776">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1777">Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny zdefiniowany w języku C#, Visual Basic lub C++, jego zagnieżdżone typy są rodzajowe, nawet jeśli mają one nie parametrów ogólnych swoich własnych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1777">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="9cc50-1778">To nie jest konieczne zagnieżdżonych typów zdefiniowanych w zestawach dynamicznych lub skompilowanych z [Ilasm.exe (asembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="9cc50-1778">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="9cc50-1779">Aby uzyskać informacje o zagnieżdżonych typach rodzajowych oraz o konstruowaniu zagnieżdżonych typów rodzajowych z definicjami typu ogólnego, zobacz <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1779">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-1780"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1780"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-1781">Ciąg zawierający nazwę typu zagnieżdżonego, aby uzyskać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1781">The string containing the name of the nested type to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="9cc50-1782">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1782">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-1783">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1783">-or-</span></span> 
<span data-ttu-id="9cc50-1784">Zero, aby zwrócić <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1784">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="9cc50-1785">W przypadku przesłonięcia w klasie pochodnej, wyszukuje określonego typu zagnieżdżonego, za pomocą ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1785">When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1786">Obiekt reprezentujący typ zagnieżdżony, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1786">An object representing the nested type that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1787">Użyj prostych nazwy klasy zagnieżdżonej dla `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1787">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="9cc50-1788">Nie kwalifikuje się on z nazwą klasy zewnętrznej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1788">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="9cc50-1789">Ogólne klasy zagnieżdżonej Użyj zniekształcone nazwy — to znaczy, Dołącz akcent i liczby parametrów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1789">For a generic nested class, use the mangled name - that is, append a grave accent and the number of generic parameters.</span></span> <span data-ttu-id="9cc50-1790">Na przykład użyć ciągu "wewnętrzny\`1" Aby uzyskać ogólny klasy zagnieżdżonej `Inner<T>` (`Inner(Of T)` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-1790">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="9cc50-1791">Nie dołączaj parametrów typu składnia specyficzny dla języka.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1791">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="9cc50-1792">Następujące <xref:System.Reflection.BindingFlags> filtr flagi może służyć do definiowania, które zagnieżdżonych typów do uwzględnienia w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1792">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-1793">Należy określić <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> lub <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> do uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1793">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-1794">Określ <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> obejmujący publiczne typy zagnieżdżone w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1794">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1795">Określ <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> obejmujący zagnieżdżonych typów niepublicznych (czyli prywatne, wewnętrzne i chronione typy zagnieżdżone) do wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1795">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="9cc50-1796">Ta metoda zwraca zagnieżdżone typy bieżącego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1796">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="9cc50-1797">Wyszukiwanie klas bazowych bieżącego typu nie jest.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1797">It does not search the base classes of the current type.</span></span> <span data-ttu-id="9cc50-1798">Aby znaleźć typy, które są zagnieżdżone w klasach bazowych, musi zaprezentuje hierarchii dziedziczenia wywoływania <xref:System.Type.GetNestedType%2A> na każdym poziomie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1798">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedType%2A> at each level.</span></span>  
  
 <span data-ttu-id="9cc50-1799"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> i <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> są ignorowane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1799"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="9cc50-1800">Wywołanie tej metody tylko z <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flagi lub tylko <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flagi zwróci określoną zagnieżdżonych typów i nie wymaga inne flagi.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1800">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="9cc50-1801">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1801">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="9cc50-1802">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje zagnieżdżone typy ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1802">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="9cc50-1803">Jeśli zagnieżdżony jest typ ogólny , metoda ta zwraca jego definicję typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1803">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="9cc50-1804">Ta zasada obowiązuje, nawet jeśli otaczający typ ogólny jest skonstruowany jako zamknięty.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1804">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1805">Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny zdefiniowany w języku C#, Visual Basic lub C++, jego zagnieżdżone typy są rodzajowe, nawet jeśli mają one nie parametrów ogólnych swoich własnych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1805">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="9cc50-1806">To nie jest konieczne zagnieżdżonych typów zdefiniowanych w zestawach dynamicznych lub skompilowanych z [Ilasm.exe (asembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="9cc50-1806">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="9cc50-1807">Aby uzyskać informacje o zagnieżdżonych typach rodzajowych oraz o konstruowaniu zagnieżdżonych typów rodzajowych z definicjami typu ogólnego, zobacz <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1807">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-1808"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1808"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cc50-1809">Pobiera typy zagnieżdżone w obrębie bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1809">Gets the types nested within the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-1810">Zwraca typy publiczne zagnieżdżone w bieżącym <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1810">Returns the public types nested in the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1811">Tablica <see cref="T:System.Type" /> obiektów reprezentujących typy publiczne zagnieżdżone w bieżącym <see cref="T:System.Type" /> (wyszukiwanie nie jest cykliczna), lub pusta tablica typu <see cref="T:System.Type" /> Jeśli nie typy publiczne są zagnieżdżone w bieżącym <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1811">An array of <see cref="T:System.Type" /> objects representing the public types nested in the current <see cref="T:System.Type" /> (the search is not recursive), or an empty array of type <see cref="T:System.Type" /> if no public types are nested in the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1812"><xref:System.Type.GetNestedTypes%2A> Metoda nie zwraca typów w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1812">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="9cc50-1813">Twój kod nie może zależeć od kolejności, w której są zwracane typy, ponieważ kolejność się zmienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1813">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="9cc50-1814">Zwracane są tylko typy publiczne bezpośrednio zagnieżdżona w bieżącym typem; w wyszukiwaniu nie jest cykliczna.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1814">Only the public types immediately nested in the current type are returned; the search is not recursive.</span></span>  
  
 <span data-ttu-id="9cc50-1815">W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1815">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="9cc50-1816">Typ elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="9cc50-1816">Member Type</span></span>|<span data-ttu-id="9cc50-1817">Static</span><span class="sxs-lookup"><span data-stu-id="9cc50-1817">Static</span></span>|<span data-ttu-id="9cc50-1818">Niestatyczna</span><span class="sxs-lookup"><span data-stu-id="9cc50-1818">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="9cc50-1819">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="9cc50-1819">Constructor</span></span>|<span data-ttu-id="9cc50-1820">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1820">No</span></span>|<span data-ttu-id="9cc50-1821">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1821">No</span></span>|  
|<span data-ttu-id="9cc50-1822">Pole</span><span class="sxs-lookup"><span data-stu-id="9cc50-1822">Field</span></span>|<span data-ttu-id="9cc50-1823">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1823">No</span></span>|<span data-ttu-id="9cc50-1824">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1824">Yes.</span></span> <span data-ttu-id="9cc50-1825">Pole jest zawsze ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1825">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-1826">Zdarzenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1826">Event</span></span>|<span data-ttu-id="9cc50-1827">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-1827">Not applicable</span></span>|<span data-ttu-id="9cc50-1828">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1828">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-1829">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1829">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1830">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1830">See note 2 below.</span></span>|  
|<span data-ttu-id="9cc50-1831">Metoda</span><span class="sxs-lookup"><span data-stu-id="9cc50-1831">Method</span></span>|<span data-ttu-id="9cc50-1832">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1832">No</span></span>|<span data-ttu-id="9cc50-1833">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1833">Yes.</span></span> <span data-ttu-id="9cc50-1834">Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1834">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-1835">Typu zagnieżdżony</span><span class="sxs-lookup"><span data-stu-id="9cc50-1835">Nested Type</span></span>|<span data-ttu-id="9cc50-1836">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1836">No</span></span>|<span data-ttu-id="9cc50-1837">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1837">No</span></span>|  
|<span data-ttu-id="9cc50-1838">Właściwość</span><span class="sxs-lookup"><span data-stu-id="9cc50-1838">Property</span></span>|<span data-ttu-id="9cc50-1839">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-1839">Not applicable</span></span>|<span data-ttu-id="9cc50-1840">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1840">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-1841">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1841">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1842">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1842">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="9cc50-1843">Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1843">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="9cc50-1844">To jest porównanie binarne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1844">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="9cc50-1845">W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1845">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1846">Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1846">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="9cc50-1847">Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1847">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="9cc50-1848">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje zagnieżdżone typy ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1848">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="9cc50-1849">Jeśli zagnieżdżony jest typ ogólny , metoda ta zwraca jego definicję typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1849">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="9cc50-1850">Ta zasada obowiązuje, nawet jeśli otaczający typ ogólny jest skonstruowany jako zamknięty.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1850">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1851">Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny zdefiniowany w języku C#, Visual Basic lub C++, jego zagnieżdżone typy są rodzajowe, nawet jeśli mają one nie parametrów ogólnych swoich własnych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1851">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="9cc50-1852">To nie jest konieczne zagnieżdżonych typów zdefiniowanych w zestawach dynamicznych lub skompilowanych z [Ilasm.exe (asembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="9cc50-1852">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="9cc50-1853">Aby uzyskać informacje o zagnieżdżonych typach rodzajowych oraz o konstruowaniu zagnieżdżonych typów rodzajowych z definicjami typu ogólnego, zobacz <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1853">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1854">W poniższym przykładzie zdefiniowano klasę zagnieżdżoną i `struct` w `MyClass`, a następnie uzyskuje obiektów zagnieżdżonych typów, przy użyciu typu `MyClass`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1854">The following example defines a nested class and a `struct` in `MyClass`, and then obtains objects of the nested types using the type of `MyClass`.</span></span>  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="9cc50-1855">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1855">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-1856">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1856">-or-</span></span> 
<span data-ttu-id="9cc50-1857">Zero, aby zwrócić <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1857">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="9cc50-1858">W przypadku przesłonięcia w klasie pochodnej, wyszukuje typy zagnieżdżone w bieżącym <see cref="T:System.Type" />, za pomocą ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1858">When overridden in a derived class, searches for the types nested in the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1859">Tablica <see cref="T:System.Type" /> obiekty reprezentujące wszystkie typy zagnieżdżone w bieżącym <see cref="T:System.Type" /> zgodnych ograniczenia określone powiązanie (wyszukiwanie nie jest cykliczna), lub pusta tablica typu <see cref="T:System.Type" />, jeśli nie typy zagnieżdżone nie zostaną znalezione zgodnych ograniczenia wiązania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1859">An array of <see cref="T:System.Type" /> objects representing all the types nested in the current <see cref="T:System.Type" /> that match the specified binding constraints (the search is not recursive), or an empty array of type <see cref="T:System.Type" />, if no nested types are found that match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1860">Wyszukaj typy zagnieżdżone nie jest cykliczna.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1860">The search for nested types is not recursive.</span></span>  
  
 <span data-ttu-id="9cc50-1861"><xref:System.Type.GetNestedTypes%2A> Metoda nie zwraca typów w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1861">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="9cc50-1862">Twój kod nie może zależeć od kolejności, w której są zwracane typy, ponieważ kolejność się zmienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1862">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="9cc50-1863">Następujące <xref:System.Reflection.BindingFlags> filtr flagi może służyć do definiowania, które zagnieżdżonych typów do uwzględnienia w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1863">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-1864">Należy określić <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> lub <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> do uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1864">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-1865">Określ <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> obejmujący publiczne typy zagnieżdżone w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1865">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1866">Określ <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> obejmujący zagnieżdżonych typów niepublicznych (czyli prywatne, wewnętrzne i chronione typy zagnieżdżone) do wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1866">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="9cc50-1867">Ta metoda zwraca zagnieżdżone typy bieżącego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1867">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="9cc50-1868">Wyszukiwanie klas bazowych bieżącego typu nie jest.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1868">It does not search the base classes of the current type.</span></span> <span data-ttu-id="9cc50-1869">Aby znaleźć typy, które są zagnieżdżone w klasach bazowych, musi zaprezentuje hierarchii dziedziczenia wywoływania <xref:System.Type.GetNestedTypes%2A> na każdym poziomie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1869">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedTypes%2A> at each level.</span></span>  
  
 <span data-ttu-id="9cc50-1870"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> i <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> są ignorowane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1870"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="9cc50-1871">Wywołanie tej metody tylko z <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flagi lub tylko <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flagi zwróci określoną zagnieżdżonych typów i nie wymaga inne flagi.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1871">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="9cc50-1872">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1872">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="9cc50-1873">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta wyszukuje zagnieżdżone typy ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1873">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="9cc50-1874">Jeśli zagnieżdżony jest typ ogólny , metoda ta zwraca jego definicję typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1874">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="9cc50-1875">Ta zasada obowiązuje, nawet jeśli otaczający typ ogólny jest skonstruowany jako zamknięty.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1875">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-1876">Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny zdefiniowany w języku C#, Visual Basic lub C++, jego zagnieżdżone typy są rodzajowe, nawet jeśli mają one nie parametrów ogólnych swoich własnych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1876">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="9cc50-1877">To nie jest konieczne zagnieżdżonych typów zdefiniowanych w zestawach dynamicznych lub skompilowanych z [Ilasm.exe (asembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="9cc50-1877">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="9cc50-1878">Aby uzyskać informacje o zagnieżdżonych typach rodzajowych oraz o konstruowaniu zagnieżdżonych typów rodzajowych z definicjami typu ogólnego, zobacz <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1878">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1879">Poniższy przykład tworzy dwie klasy publiczne zagnieżdżonych i dwie klasy chronionych zagnieżdżonych i wyświetla informacje dotyczące klas, które odpowiadają ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1879">The following example creates two nested public classes and two nested protected classes, and displays information for classes that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cc50-1880">Pobiera właściwości bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1880">Gets the properties of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-1881">Zwraca wszystkie publiczne właściwości bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1881">Returns all the public properties of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1882">Tablica <see cref="T:System.Reflection.PropertyInfo" /> obiekty reprezentujące wszystkie publiczne właściwości bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1882">An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all public properties of the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="9cc50-1883">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1883">-or-</span></span> 
<span data-ttu-id="9cc50-1884">Pusta tablica typu <see cref="T:System.Reflection.PropertyInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma właściwości publiczne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1884">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have public properties.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1885">To przeciążenie wywołanie jest równoważne z wywoływaniem <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> przeciążenia z `bindingAttr` argument równa `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` w języku C# i `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1885">Calling this overload is equivalent to calling the <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> overload with a `bindingAttr` argument equal to `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in C# and  `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic.</span></span> <span data-ttu-id="9cc50-1886">Zwraca wszystkie publiczne wystąpienia i statycznej właściwości, z których oba te są definiowane przez typ reprezentowany przez bieżącą <xref:System.Type> obiektu, a także tych dziedziczone z jej typów podstawowych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1886">It returns all public instance and static properties, both those defined by the type represented by the current <xref:System.Type> object as well as those inherited from its base types.</span></span>  
  
 <span data-ttu-id="9cc50-1887">Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1887">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="9cc50-1888">W przeciwnym razie właściwość jest traktowana jako prywatna i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1888">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="9cc50-1889"><xref:System.Type.GetProperties%2A> Metoda nie zwraca właściwości w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1889">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="9cc50-1890">Twój kod nie może zależeć od kolejności, w której zwracane są właściwości, ponieważ kolejność się zmienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1890">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="9cc50-1891">W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1891">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="9cc50-1892">Typ elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="9cc50-1892">Member Type</span></span>|<span data-ttu-id="9cc50-1893">Static</span><span class="sxs-lookup"><span data-stu-id="9cc50-1893">Static</span></span>|<span data-ttu-id="9cc50-1894">Niestatyczna</span><span class="sxs-lookup"><span data-stu-id="9cc50-1894">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="9cc50-1895">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="9cc50-1895">Constructor</span></span>|<span data-ttu-id="9cc50-1896">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1896">No</span></span>|<span data-ttu-id="9cc50-1897">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1897">No</span></span>|  
|<span data-ttu-id="9cc50-1898">Pole</span><span class="sxs-lookup"><span data-stu-id="9cc50-1898">Field</span></span>|<span data-ttu-id="9cc50-1899">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1899">No</span></span>|<span data-ttu-id="9cc50-1900">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1900">Yes.</span></span> <span data-ttu-id="9cc50-1901">Pole jest zawsze ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1901">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-1902">Zdarzenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1902">Event</span></span>|<span data-ttu-id="9cc50-1903">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-1903">Not applicable</span></span>|<span data-ttu-id="9cc50-1904">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1904">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-1905">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1905">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1906">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1906">See note 2 below.</span></span>|  
|<span data-ttu-id="9cc50-1907">Metoda</span><span class="sxs-lookup"><span data-stu-id="9cc50-1907">Method</span></span>|<span data-ttu-id="9cc50-1908">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1908">No</span></span>|<span data-ttu-id="9cc50-1909">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1909">Yes.</span></span> <span data-ttu-id="9cc50-1910">Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1910">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-1911">Typu zagnieżdżony</span><span class="sxs-lookup"><span data-stu-id="9cc50-1911">Nested Type</span></span>|<span data-ttu-id="9cc50-1912">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1912">No</span></span>|<span data-ttu-id="9cc50-1913">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-1913">No</span></span>|  
|<span data-ttu-id="9cc50-1914">Właściwość</span><span class="sxs-lookup"><span data-stu-id="9cc50-1914">Property</span></span>|<span data-ttu-id="9cc50-1915">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-1915">Not applicable</span></span>|<span data-ttu-id="9cc50-1916">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1916">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-1917">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1917">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1918">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1918">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="9cc50-1919">Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1919">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="9cc50-1920">To jest porównanie binarne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1920">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="9cc50-1921">W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1921">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-1922">Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1922">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="9cc50-1923">Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1923">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="9cc50-1924">Jeśli bieżący element T:System.Type reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.PropertyInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1924">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1925">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta przeszukuje właściwości ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1925">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1926">W poniższym przykładzie pokazano użycie `GetProperties` metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1926">The following example demonstrates the use of the `GetProperties` method.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="9cc50-1927">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1927">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-1928">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1928">-or-</span></span> 
<span data-ttu-id="9cc50-1929">Zero, aby zwrócić <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1929">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="9cc50-1930">W przypadku przesłonięcia w klasie pochodnej, wyszukuje właściwości bieżącego <see cref="T:System.Type" />, za pomocą ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1930">When overridden in a derived class, searches for the properties of the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1931">Tablica <see cref="T:System.Reflection.PropertyInfo" /> obiekty reprezentujące wszystkie właściwości bieżącego <see cref="T:System.Type" /> zgodnych ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1931">An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all properties of the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="9cc50-1932">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1932">-or-</span></span> 
<span data-ttu-id="9cc50-1933">Pusta tablica typu <see cref="T:System.Reflection.PropertyInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma właściwości, lub jeśli żadna z właściwości ograniczenia wiązania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1933">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have properties, or if none of the properties match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1934">Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1934">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="9cc50-1935">W przeciwnym razie właściwość jest traktowana jako prywatna i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1935">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="9cc50-1936"><xref:System.Type.GetProperties%2A> Metoda nie zwraca właściwości w określonej kolejności, takie jak alfabetycznej lub kolejności deklaracji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1936">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="9cc50-1937">Twój kod nie może zależeć od kolejności, w której zwracane są właściwości, ponieważ kolejność się zmienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1937">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="9cc50-1938">Następujące <xref:System.Reflection.BindingFlags> filtr flagi może służyć do definiowania, które zagnieżdżonych typów do uwzględnienia w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1938">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-1939">Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1939">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-1940">Określ `BindingFlags.Public` obejmujący właściwości publiczne w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1940">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1941">Określ `BindingFlags.NonPublic` obejmujący w w wyszukiwaniu właściwości niepubliczne (czyli prywatne, wewnętrzne i chronione właściwości).</span><span class="sxs-lookup"><span data-stu-id="9cc50-1941">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span> <span data-ttu-id="9cc50-1942">Tylko chronionych i wewnętrznych właściwości klasy bazowe są zwracane; właściwości prywatnych na klasach bazowych nie są zwracane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1942">Only protected and internal properties on base classes are returned; private properties on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="9cc50-1943">Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1943">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="9cc50-1944">Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1944">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="9cc50-1945">`BindingFlags.DeclaredOnly` Aby wyszukać tylko właściwości zadeklarowanych w <xref:System.Type>, nie właściwości, które zostały po prostu odziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1945">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="9cc50-1946">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1946">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="9cc50-1947">Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1947">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="9cc50-1948">W przeciwnym razie właściwość jest traktowana jako prywatna i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1948">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="9cc50-1949">Jeśli bieżący element T:System.Type reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.PropertyInfo> obiektów z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1949">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1950">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta przeszukuje właściwości ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1950">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1951">W poniższym przykładzie zdefiniowano klasę o nazwie `PropertyClass` zawierającej sześć właściwości: dwa są publiczne, jeden jest prywatny, jeden jest chroniony, jest jeden wewnętrzny (`Friend` w języku Visual Basic), i jest chronionych wewnętrznych (`Protected Friend` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-1951">The following example defines a class named `PropertyClass` that includes six properties: two are public, one is private, one is protected, one is internal (`Friend` in Visual Basic), and one is protected internal (`Protected Friend` in Visual Basic).</span></span> <span data-ttu-id="9cc50-1952">Następnie wyświetla informacje o niektórych właściwości podstawowe (nazwę właściwości i typ, czy jest ona odczytu/zapisu, a widoczność jego `get` i `set` metod dostępu) dla właściwości, które odpowiadają ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1952">It then displays some basic property information (the property name and type, whether it is read/write, and the visibility of its `get` and `set` accessors) for the properties that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cc50-1953">Pobiera określoną właściwość bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1953">Gets a specific property of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-1954">Ciąg zawierający nazwę właściwości publicznej do pobrania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1954">The string containing the name of the public property to get.</span></span></param>
        <summary><span data-ttu-id="9cc50-1955">Wyszukiwanie właściwości publicznej przy użyciu określonej nazwy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1955">Searches for the public property with the specified name.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1956">Obiekt reprezentujący właściwość publiczną o określonej nazwie, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1956">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1957">Wyszukaj `name` jest uwzględniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1957">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="9cc50-1958">Wyszukiwanie uwzględnia właściwości wystąpienia statycznego publicznego i publicznego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1958">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="9cc50-1959">Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1959">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="9cc50-1960">W przeciwnym razie właściwość jest traktowana jako prywatna i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1960">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="9cc50-1961">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.PropertyInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1961">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-1962">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta przeszukuje właściwości ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1962">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="9cc50-1963">Sytuacje, w których <xref:System.Reflection.AmbiguousMatchException> występuje obejmują następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1963">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="9cc50-1964">Typ zawiera dwa indeksowanej właściwości, które mają taką samą nazwę, ale o innej liczby parametrów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1964">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="9cc50-1965">Aby rozstrzygnąć niejednoznaczność, użyj przeciążenia <xref:System.Type.GetProperty%2A> metody, która określa typy parametrów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1965">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="9cc50-1966">Typ pochodny deklaruje właściwość, która ukrywa to właściwość dziedziczona z taką samą nazwę, za pomocą `new` modyfikator (`Shadows` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-1966">A derived type declares a property that hides an inherited property with the same name, by using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="9cc50-1967">Aby rozstrzygnąć niejednoznaczność, użyj <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> metoda przeciążenia i Dodaj <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> flagę, aby ograniczyć wyszukiwanie do elementów członkowskich, które nie są dziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1967">To resolve the ambiguity, use the <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> method overload and add the <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> flag to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="9cc50-1968">Indeksatory i domyślne właściwości</span><span class="sxs-lookup"><span data-stu-id="9cc50-1968">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="9cc50-1969">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], i [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczoną składnię do uzyskiwania dostępu do właściwości indeksowanych i zezwolić na jedną z indeksowanych właściwości jako domyślną dla tego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1969">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="9cc50-1970">Na przykład jeśli zmienna `myList` odwołuje się do <xref:System.Collections.ArrayList>, składnia `myList[3]` (`myList(3)` w języku Visual Basic) pobiera element z indeksem 3.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1970">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="9cc50-1971">Można doprowadzić do przeciążenia właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1971">You can overload the property.</span></span>  
  
 <span data-ttu-id="9cc50-1972">W C#, ta funkcja nosi nazwę indeksatora i nie mogą być przywoływane przez nazwę.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1972">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="9cc50-1973">Domyślnie indeksatora języka C# pojawia się w metadanych jako indeksowana właściwość o nazwie "Item".</span><span class="sxs-lookup"><span data-stu-id="9cc50-1973">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="9cc50-1974">Jednak Deweloper biblioteki klas można używać <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atrybutu, aby zmienić nazwę indeksatora w metadanych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1974">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="9cc50-1975">Na przykład <xref:System.String> klasa ma indeksatora o nazwie <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1975">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="9cc50-1976">Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1976">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="9cc50-1977">Aby określić, czy typ ma właściwość domyślną, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metoda do testowania <xref:System.Reflection.DefaultMemberAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1977">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="9cc50-1978">Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> właściwość zwraca nazwę właściwości domyślnej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1978">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-1979">Poniższy przykład pobiera `Type` obiekt klasy zdefiniowane przez użytkownika, pobiera właściwości tej klasy i wyświetla nazwę właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1979">The following example retrieves the `Type` object of a user-defined class, retrieves a property of that class, and displays the property name.</span></span>  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 <span data-ttu-id="9cc50-1980">Wewnętrznie ta właściwość jest określany w metadanych o nazwie "Item".</span><span class="sxs-lookup"><span data-stu-id="9cc50-1980">Internally, this property is referred to in the metadata by the name "Item."</span></span> <span data-ttu-id="9cc50-1981">Dowolne próba uzyskania `PropertyInfo` przy użyciu odbicia należy określić to wewnętrzna nazwa celu zwrócenie poprawnie `PropertyInfo` właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1981">Any attempt to get `PropertyInfo` using reflection must specify this internal name in order to correctly return the `PropertyInfo` property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="9cc50-1982">Znaleziono więcej niż jedną właściwość o określonej nazwie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1982">More than one property is found with the specified name.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-1983"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1983"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-1984">Ciąg zawierający nazwę właściwości do pobrania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1984">The string containing the name of the property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="9cc50-1985">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1985">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-1986">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-1986">-or-</span></span> 
<span data-ttu-id="9cc50-1987">Zero, aby zwrócić <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1987">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="9cc50-1988">Wyszukuje dla określonej właściwości, za pomocą ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1988">Searches for the specified property, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="9cc50-1989">Obiekt reprezentujący właściwość, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1989">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-1990">Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1990">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="9cc50-1991">W przeciwnym razie właściwość jest traktowana jako prywatna i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1991">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="9cc50-1992">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania właściwości, które można uwzględnić w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1992">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-1993">Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1993">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-1994">Określ `BindingFlags.Public` obejmujący właściwości publiczne w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1994">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1995">Określ `BindingFlags.NonPublic` obejmujący w w wyszukiwaniu właściwości niepubliczne (czyli prywatne, wewnętrzne i chronione właściwości).</span><span class="sxs-lookup"><span data-stu-id="9cc50-1995">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-1996">Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1996">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="9cc50-1997">Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:</span><span class="sxs-lookup"><span data-stu-id="9cc50-1997">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="9cc50-1998">`BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1998">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="9cc50-1999">`BindingFlags.DeclaredOnly` Aby wyszukać tylko właściwości zadeklarowanych w <xref:System.Type>, nie właściwości, które zostały po prostu odziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-1999">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="9cc50-2000">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2000">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="9cc50-2001">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.PropertyInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2001">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-2002">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta przeszukuje właściwości ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2002">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="9cc50-2003">Sytuacje, w których <xref:System.Reflection.AmbiguousMatchException> występuje obejmują następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2003">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="9cc50-2004">Typ zawiera dwa indeksowanej właściwości, które mają taką samą nazwę, ale o innej liczby parametrów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2004">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="9cc50-2005">Aby rozstrzygnąć niejednoznaczność, użyj przeciążenia <xref:System.Type.GetProperty%2A> metody, która określa typy parametrów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2005">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="9cc50-2006">Typ pochodny deklaruje właściwość, która ukrywa to właściwość dziedziczona z taką samą nazwę, za pomocą `new` modyfikator (`Shadows` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-2006">A derived type declares a property that hides an inherited property with the same name, using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="9cc50-2007">Aby rozstrzygnąć niejednoznaczność, obejmują <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> ograniczyć wyszukiwanie do elementów członkowskich, które nie są dziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2007">To resolve the ambiguity, include <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="9cc50-2008">Indeksatory i domyślne właściwości</span><span class="sxs-lookup"><span data-stu-id="9cc50-2008">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="9cc50-2009">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], i [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczoną składnię do uzyskiwania dostępu do właściwości indeksowanych i zezwolić na jedną z indeksowanych właściwości jako domyślną dla tego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2009">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="9cc50-2010">Na przykład jeśli zmienna `myList` odwołuje się do <xref:System.Collections.ArrayList>, składnia `myList[3]` (`myList(3)` w języku Visual Basic) pobiera element z indeksem 3.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2010">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="9cc50-2011">Można doprowadzić do przeciążenia właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2011">You can overload the property.</span></span>  
  
 <span data-ttu-id="9cc50-2012">W C#, ta funkcja nosi nazwę indeksatora i nie mogą być przywoływane przez nazwę.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2012">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="9cc50-2013">Domyślnie indeksatora języka C# pojawia się w metadanych jako indeksowana właściwość o nazwie "Item".</span><span class="sxs-lookup"><span data-stu-id="9cc50-2013">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="9cc50-2014">Jednak Deweloper biblioteki klas można używać <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atrybutu, aby zmienić nazwę indeksatora w metadanych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2014">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="9cc50-2015">Na przykład <xref:System.String> klasa ma indeksatora o nazwie <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2015">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="9cc50-2016">Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2016">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="9cc50-2017">Aby określić, czy typ ma właściwość domyślną, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metoda do testowania <xref:System.Reflection.DefaultMemberAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2017">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="9cc50-2018">Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> właściwość zwraca nazwę właściwości domyślnej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2018">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-2019">Poniższy przykład pobiera typ klasy zdefiniowane przez użytkownika, pobiera właściwości tej klasy i wyświetla nazwę właściwości, zgodnie z ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2019">The following example retrieves the type of a user-defined class, retrieves a property of that class and displays the property name in accordance with the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="9cc50-2020">Odnaleziono więcej niż jedną właściwość o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2020">More than one property is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-2021"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2021"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-2022">Ciąg zawierający nazwę właściwości publicznej do pobrania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2022">The string containing the name of the public property to get.</span></span></param>
        <param name="returnType"><span data-ttu-id="9cc50-2023">Zwracany typ właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2023">The return type of the property.</span></span></param>
        <summary><span data-ttu-id="9cc50-2024">Wyszukiwanie właściwości publicznej o określonej nazwie i typ zwracany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2024">Searches for the public property with the specified name and return type.</span></span></summary>
        <returns><span data-ttu-id="9cc50-2025">Obiekt reprezentujący właściwość publiczną o określonej nazwie, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2025">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-2026">Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2026">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="9cc50-2027">W przeciwnym razie właściwość jest traktowana jako prywatna i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2027">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="9cc50-2028">Wyszukaj `name` jest uwzględniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2028">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="9cc50-2029">Wyszukiwanie uwzględnia właściwości wystąpienia statycznego publicznego i publicznego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2029">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="9cc50-2030">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.PropertyInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2030">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-2031">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta przeszukuje właściwości ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2031">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="9cc50-2032">Indeksatory i domyślne właściwości</span><span class="sxs-lookup"><span data-stu-id="9cc50-2032">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="9cc50-2033">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], i [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczoną składnię do uzyskiwania dostępu do właściwości indeksowanych i zezwolić na jedną z indeksowanych właściwości jako domyślną dla tego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2033">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="9cc50-2034">Na przykład jeśli zmienna `myList` odwołuje się do <xref:System.Collections.ArrayList>, składnia `myList[3]` (`myList(3)` w języku Visual Basic) pobiera element z indeksem 3.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2034">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="9cc50-2035">Można doprowadzić do przeciążenia właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2035">You can overload the property.</span></span>  
  
 <span data-ttu-id="9cc50-2036">W C#, ta funkcja nosi nazwę indeksatora i nie mogą być przywoływane przez nazwę.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2036">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="9cc50-2037">Domyślnie indeksatora języka C# pojawia się w metadanych jako indeksowana właściwość o nazwie "Item".</span><span class="sxs-lookup"><span data-stu-id="9cc50-2037">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="9cc50-2038">Jednak Deweloper biblioteki klas można używać <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atrybutu, aby zmienić nazwę indeksatora w metadanych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2038">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="9cc50-2039">Na przykład <xref:System.String> klasa ma indeksatora o nazwie <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2039">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="9cc50-2040">Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2040">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="9cc50-2041">Aby określić, czy typ ma właściwość domyślną, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metoda do testowania <xref:System.Reflection.DefaultMemberAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2041">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="9cc50-2042">Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> właściwość zwraca nazwę właściwości domyślnej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2042">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-2043">Poniższy przykład definiuje klasę z jedną właściwością i pobiera nazwę i typ właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2043">The following example defines a class with one property and retrieves the name and type of the property.</span></span>  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="9cc50-2044">Znaleziono więcej niż jedną właściwość o określonej nazwie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2044">More than one property is found with the specified name.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-2045"><paramref name="name" /> jest <see langword="null" />, lub <paramref name="returnType" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2045"><paramref name="name" /> is <see langword="null" />, or <paramref name="returnType" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-2046">Ciąg zawierający nazwę właściwości publicznej do pobrania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2046">The string containing the name of the public property to get.</span></span></param>
        <param name="types"><span data-ttu-id="9cc50-2047">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów właściwości indeksowanej, aby uzyskać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2047">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="9cc50-2048">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2048">-or-</span></span> 
<span data-ttu-id="9cc50-2049">Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie właściwości, która nie jest indeksowana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2049">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <summary><span data-ttu-id="9cc50-2050">Wyszukuje określony właściwość publiczną, której parametry pasuje określone typy argumentów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2050">Searches for the specified public property whose parameters match the specified argument types.</span></span></summary>
        <returns><span data-ttu-id="9cc50-2051">Obiekt reprezentujący właściwość publiczną, której parametry pasuje określone typy argumentów, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2051">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-2052">Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2052">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="9cc50-2053">W przeciwnym razie właściwość jest traktowana jako prywatna i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2053">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="9cc50-2054">Wyszukaj `name` jest uwzględniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2054">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="9cc50-2055">Wyszukiwanie uwzględnia właściwości wystąpienia statycznego publicznego i publicznego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2055">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="9cc50-2056">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.PropertyInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2056">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-2057">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta przeszukuje właściwości ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2057">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="9cc50-2058">Indeksatory i domyślne właściwości</span><span class="sxs-lookup"><span data-stu-id="9cc50-2058">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="9cc50-2059">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], i [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczoną składnię do uzyskiwania dostępu do właściwości indeksowanych i zezwolić na jedną z indeksowanych właściwości jako domyślną dla tego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2059">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="9cc50-2060">Na przykład jeśli zmienna `myList` odwołuje się do <xref:System.Collections.ArrayList>, składnia `myList[3]` (`myList(3)` w języku Visual Basic) pobiera element z indeksem 3.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2060">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="9cc50-2061">Można doprowadzić do przeciążenia właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2061">You can overload the property.</span></span>  
  
 <span data-ttu-id="9cc50-2062">W C#, ta funkcja nosi nazwę indeksatora i nie mogą być przywoływane przez nazwę.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2062">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="9cc50-2063">Domyślnie indeksatora języka C# pojawia się w metadanych jako indeksowana właściwość o nazwie "Item".</span><span class="sxs-lookup"><span data-stu-id="9cc50-2063">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="9cc50-2064">Jednak Deweloper biblioteki klas można używać <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atrybutu, aby zmienić nazwę indeksatora w metadanych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2064">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="9cc50-2065">Na przykład <xref:System.String> klasa ma indeksatora o nazwie <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2065">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="9cc50-2066">Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2066">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="9cc50-2067">Aby określić, czy typ ma właściwość domyślną, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metoda do testowania <xref:System.Reflection.DefaultMemberAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2067">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="9cc50-2068">Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> właściwość zwraca nazwę właściwości domyślnej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2068">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-2069">Poniższy przykład pobiera `Type` obiekt klasy zdefiniowane przez użytkownika, pobiera właściwości tej klasy i wyświetla nazwę właściwości i typ właściwości zgodnie z argumentów przekazanych do `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2069">The following example retrieves the `Type` object of a user-defined class, retrieves the property of that class, and displays the property name and type of the property as specified by the arguments passed to `GetProperty`.</span></span>  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="9cc50-2070">Odnaleziono więcej niż jedną właściwość o określonej nazwie i pasującą określone typy argumentów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2070">More than one property is found with the specified name and matching the specified argument types.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-2071"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2071"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cc50-2072">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2072">-or-</span></span> 
 <span data-ttu-id="9cc50-2073"><paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2073"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-2074"><paramref name="types" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2074"><paramref name="types" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="9cc50-2075">Element <paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2075">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-2076">Ciąg zawierający nazwę właściwości publicznej do pobrania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2076">The string containing the name of the public property to get.</span></span></param>
        <param name="returnType"><span data-ttu-id="9cc50-2077">Zwracany typ właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2077">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="9cc50-2078">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów właściwości indeksowanej, aby uzyskać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2078">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="9cc50-2079">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2079">-or-</span></span> 
<span data-ttu-id="9cc50-2080">Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie właściwości, która nie jest indeksowana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2080">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <summary><span data-ttu-id="9cc50-2081">Wyszukuje określony właściwość publiczną, której parametry pasuje określone typy argumentów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2081">Searches for the specified public property whose parameters match the specified argument types.</span></span></summary>
        <returns><span data-ttu-id="9cc50-2082">Obiekt reprezentujący właściwość publiczną, której parametry pasuje określone typy argumentów, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2082">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-2083">Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2083">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="9cc50-2084">W przeciwnym razie właściwość jest traktowana jako prywatna i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2084">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="9cc50-2085">Wyszukaj `name` jest uwzględniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2085">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="9cc50-2086">Wyszukiwanie uwzględnia właściwości wystąpienia statycznego publicznego i publicznego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2086">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="9cc50-2087">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.PropertyInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2087">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-2088">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta przeszukuje właściwości ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2088">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="9cc50-2089">Indeksatory i domyślne właściwości</span><span class="sxs-lookup"><span data-stu-id="9cc50-2089">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="9cc50-2090">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], i [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczoną składnię do uzyskiwania dostępu do właściwości indeksowanych i zezwolić na jedną z indeksowanych właściwości jako domyślną dla tego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2090">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="9cc50-2091">Na przykład jeśli zmienna `myList` odwołuje się do <xref:System.Collections.ArrayList>, składnia `myList[3]` (`myList(3)` w języku Visual Basic) pobiera element z indeksem 3.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2091">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="9cc50-2092">Można doprowadzić do przeciążenia właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2092">You can overload the property.</span></span>  
  
 <span data-ttu-id="9cc50-2093">W C#, ta funkcja nosi nazwę indeksatora i nie mogą być przywoływane przez nazwę.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2093">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="9cc50-2094">Domyślnie indeksatora języka C# pojawia się w metadanych jako indeksowana właściwość o nazwie "Item".</span><span class="sxs-lookup"><span data-stu-id="9cc50-2094">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="9cc50-2095">Jednak Deweloper biblioteki klas można używać <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atrybutu, aby zmienić nazwę indeksatora w metadanych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2095">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="9cc50-2096">Na przykład <xref:System.String> klasa ma indeksatora o nazwie <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2096">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="9cc50-2097">Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2097">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="9cc50-2098">Aby określić, czy typ ma właściwość domyślną, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metoda do testowania <xref:System.Reflection.DefaultMemberAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2098">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="9cc50-2099">Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> właściwość zwraca nazwę właściwości domyślnej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2099">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="9cc50-2100">Odnaleziono więcej niż jedną właściwość o określonej nazwie i pasującą określone typy argumentów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2100">More than one property is found with the specified name and matching the specified argument types.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-2101"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2101"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cc50-2102">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2102">-or-</span></span> 
 <span data-ttu-id="9cc50-2103"><paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2103"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-2104"><paramref name="types" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2104"><paramref name="types" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="9cc50-2105">Element <paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2105">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-2106">Ciąg zawierający nazwę właściwości publicznej do pobrania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2106">The string containing the name of the public property to get.</span></span></param>
        <param name="returnType"><span data-ttu-id="9cc50-2107">Zwracany typ właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2107">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="9cc50-2108">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów właściwości indeksowanej, aby uzyskać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2108">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="9cc50-2109">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2109">-or-</span></span> 
<span data-ttu-id="9cc50-2110">Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie właściwości, która nie jest indeksowana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2110">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <param name="modifiers"><span data-ttu-id="9cc50-2111">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <paramref name="types" /> tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2111">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="9cc50-2112">Domyślny konsolidator nie przetwarza tego parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2112">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="9cc50-2113">Wyszukuje określony właściwość publiczną, której parametry odpowiadają określone typy argumentów i modyfikatorów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2113">Searches for the specified public property whose parameters match the specified argument types and modifiers.</span></span></summary>
        <returns><span data-ttu-id="9cc50-2114">Obiekt reprezentujący właściwość publiczną, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2114">An object representing the public property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-2115">Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2115">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="9cc50-2116">W przeciwnym razie właściwość jest traktowana jako prywatna i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2116">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="9cc50-2117">Mimo że domyślny integrator nie przetwarza <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2117">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="9cc50-2118">`ParameterModifier` jest używana tylko podczas wywoływania przez współdziałania z modelem COM i są obsługiwane tylko w przypadku parametrów, które są przekazywane przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2118">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="9cc50-2119">Wyszukaj `name` jest uwzględniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2119">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="9cc50-2120">Wyszukiwanie uwzględnia właściwości wystąpienia statycznego publicznego i publicznego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2120">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="9cc50-2121">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.PropertyInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2121">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-2122">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta przeszukuje właściwości ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2122">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="9cc50-2123">Indeksatory i domyślne właściwości</span><span class="sxs-lookup"><span data-stu-id="9cc50-2123">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="9cc50-2124">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], i [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczoną składnię do uzyskiwania dostępu do właściwości indeksowanych i zezwolić na jedną z indeksowanych właściwości jako domyślną dla tego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2124">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="9cc50-2125">Na przykład jeśli zmienna `myList` odwołuje się do <xref:System.Collections.ArrayList>, składnia `myList[3]` (`myList(3)` w języku Visual Basic) pobiera element z indeksem 3.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2125">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="9cc50-2126">Można doprowadzić do przeciążenia właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2126">You can overload the property.</span></span>  
  
 <span data-ttu-id="9cc50-2127">W C#, ta funkcja nosi nazwę indeksatora i nie mogą być przywoływane przez nazwę.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2127">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="9cc50-2128">Domyślnie indeksatora języka C# pojawia się w metadanych jako indeksowana właściwość o nazwie "Item".</span><span class="sxs-lookup"><span data-stu-id="9cc50-2128">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="9cc50-2129">Jednak Deweloper biblioteki klas można używać <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atrybutu, aby zmienić nazwę indeksatora w metadanych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2129">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="9cc50-2130">Na przykład <xref:System.String> klasa ma indeksatora o nazwie <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2130">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="9cc50-2131">Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2131">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="9cc50-2132">Aby określić, czy typ ma właściwość domyślną, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metoda do testowania <xref:System.Reflection.DefaultMemberAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2132">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="9cc50-2133">Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> właściwość zwraca nazwę właściwości domyślnej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2133">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-2134">W poniższym przykładzie uzyskano `Type` obiekt odpowiadający `MyPropertyClass`, i indeksowanej właściwości tej klasy są pobierane przy użyciu argumentów przekazanych do `GetProperty` metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2134">The following example obtains a `Type` object corresponding to `MyPropertyClass`, and the indexed property of this class is retrieved using the arguments passed to the `GetProperty` method.</span></span>  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="9cc50-2135">Odnaleziono więcej niż jedną właściwość o określonej nazwie i pasującą określone typy argumentów i modyfikatorów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2135">More than one property is found with the specified name and matching the specified argument types and modifiers.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-2136"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2136"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cc50-2137">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2137">-or-</span></span> 
 <span data-ttu-id="9cc50-2138"><paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2138"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-2139"><paramref name="types" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2139"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="9cc50-2140">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2140">-or-</span></span> 
 <span data-ttu-id="9cc50-2141"><paramref name="modifiers" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2141"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="9cc50-2142">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2142">-or-</span></span> 
 <span data-ttu-id="9cc50-2143"><paramref name="types" /> i <paramref name="modifiers" /> nie mają tę samą długość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2143"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="9cc50-2144">Element <paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2144">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-2145">Ciąg zawierający nazwę właściwości do pobrania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2145">The string containing the name of the property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="9cc50-2146">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2146">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-2147">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2147">-or-</span></span> 
<span data-ttu-id="9cc50-2148">Zero, aby zwrócić <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2148">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="9cc50-2149">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2149">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="9cc50-2150">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2150">-or-</span></span> 
<span data-ttu-id="9cc50-2151">Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2151">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="9cc50-2152">Zwracany typ właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2152">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="9cc50-2153">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów właściwości indeksowanej, aby uzyskać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2153">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="9cc50-2154">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2154">-or-</span></span> 
<span data-ttu-id="9cc50-2155">Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie właściwości, która nie jest indeksowana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2155">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <param name="modifiers"><span data-ttu-id="9cc50-2156">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <paramref name="types" /> tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2156">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="9cc50-2157">Domyślny konsolidator nie przetwarza tego parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2157">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="9cc50-2158">Wyszukuje określoną właściwość, której parametry odpowiadają określone typy argumentów i modyfikatorów, za pomocą ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2158">Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="9cc50-2159">Obiekt reprezentujący właściwość, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2159">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-2160">Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2160">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="9cc50-2161">W przeciwnym razie właściwość jest traktowana jako prywatna i trzeba użyć <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic należy połączyć wartości za pomocą `Or`) aby z niej skorzystać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2161">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="9cc50-2162">Mimo że domyślny integrator nie przetwarza <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2162">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="9cc50-2163">`ParameterModifier` jest używana tylko podczas wywoływania przez współdziałania z modelem COM i są obsługiwane tylko w przypadku parametrów, które są przekazywane przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2163">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="9cc50-2164">W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2164">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="9cc50-2165">Typ elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="9cc50-2165">Member Type</span></span>|<span data-ttu-id="9cc50-2166">Static</span><span class="sxs-lookup"><span data-stu-id="9cc50-2166">Static</span></span>|<span data-ttu-id="9cc50-2167">Niestatyczna</span><span class="sxs-lookup"><span data-stu-id="9cc50-2167">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="9cc50-2168">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="9cc50-2168">Constructor</span></span>|<span data-ttu-id="9cc50-2169">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2169">No</span></span>|<span data-ttu-id="9cc50-2170">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2170">No</span></span>|  
|<span data-ttu-id="9cc50-2171">Pole</span><span class="sxs-lookup"><span data-stu-id="9cc50-2171">Field</span></span>|<span data-ttu-id="9cc50-2172">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2172">No</span></span>|<span data-ttu-id="9cc50-2173">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2173">Yes.</span></span> <span data-ttu-id="9cc50-2174">Pole jest zawsze ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2174">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-2175">Zdarzenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2175">Event</span></span>|<span data-ttu-id="9cc50-2176">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-2176">Not applicable</span></span>|<span data-ttu-id="9cc50-2177">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2177">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-2178">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2178">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-2179">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2179">See note 2 below.</span></span>|  
|<span data-ttu-id="9cc50-2180">Metoda</span><span class="sxs-lookup"><span data-stu-id="9cc50-2180">Method</span></span>|<span data-ttu-id="9cc50-2181">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2181">No</span></span>|<span data-ttu-id="9cc50-2182">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2182">Yes.</span></span> <span data-ttu-id="9cc50-2183">Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2183">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-2184">Typu zagnieżdżony</span><span class="sxs-lookup"><span data-stu-id="9cc50-2184">Nested Type</span></span>|<span data-ttu-id="9cc50-2185">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2185">No</span></span>|<span data-ttu-id="9cc50-2186">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2186">No</span></span>|  
|<span data-ttu-id="9cc50-2187">Właściwość</span><span class="sxs-lookup"><span data-stu-id="9cc50-2187">Property</span></span>|<span data-ttu-id="9cc50-2188">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-2188">Not applicable</span></span>|<span data-ttu-id="9cc50-2189">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2189">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-2190">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2190">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-2191">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2191">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="9cc50-2192">Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2192">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="9cc50-2193">To jest porównanie binarne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2193">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="9cc50-2194">W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2194">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-2195">Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2195">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="9cc50-2196">Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2196">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="9cc50-2197">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania właściwości, które można uwzględnić w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2197">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-2198">Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2198">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-2199">Określ `BindingFlags.Public` obejmujący właściwości publiczne w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2199">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-2200">Określ `BindingFlags.NonPublic` obejmujący w w wyszukiwaniu właściwości niepubliczne (czyli prywatne, wewnętrzne i chronione właściwości).</span><span class="sxs-lookup"><span data-stu-id="9cc50-2200">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-2201">Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2201">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="9cc50-2202">Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2202">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="9cc50-2203">`BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2203">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="9cc50-2204">`BindingFlags.DeclaredOnly` Aby wyszukać tylko właściwości zadeklarowanych w <xref:System.Type>, nie właściwości, które zostały po prostu odziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2204">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="9cc50-2205">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2205">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="9cc50-2206">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, Metoda ta zwraca <xref:System.Reflection.PropertyInfo> z parametrami typu zastąpionymi przez odpowiednie argumenty typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2206">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-2207">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta przeszukuje właściwości ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2207">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="9cc50-2208">Indeksatory i domyślne właściwości</span><span class="sxs-lookup"><span data-stu-id="9cc50-2208">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="9cc50-2209">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], i [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczoną składnię do uzyskiwania dostępu do właściwości indeksowanych i zezwolić na jedną z indeksowanych właściwości jako domyślną dla tego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2209">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="9cc50-2210">Na przykład jeśli zmienna `myList` odwołuje się do <xref:System.Collections.ArrayList>, składnia `myList[3]` (`myList(3)` w języku Visual Basic) pobiera element z indeksem 3.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2210">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="9cc50-2211">Można doprowadzić do przeciążenia właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2211">You can overload the property.</span></span>  
  
 <span data-ttu-id="9cc50-2212">W C#, ta funkcja nosi nazwę indeksatora i nie mogą być przywoływane przez nazwę.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2212">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="9cc50-2213">Domyślnie indeksatora języka C# pojawia się w metadanych jako indeksowana właściwość o nazwie "Item".</span><span class="sxs-lookup"><span data-stu-id="9cc50-2213">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="9cc50-2214">Jednak Deweloper biblioteki klas można używać <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atrybutu, aby zmienić nazwę indeksatora w metadanych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2214">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="9cc50-2215">Na przykład <xref:System.String> klasa ma indeksatora o nazwie <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2215">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="9cc50-2216">Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2216">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="9cc50-2217">Aby określić, czy typ ma właściwość domyślną, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metoda do testowania <xref:System.Reflection.DefaultMemberAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2217">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="9cc50-2218">Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> właściwość zwraca nazwę właściwości domyślnej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2218">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="9cc50-2219">Odnaleziono więcej niż jedną właściwość o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2219">More than one property is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-2220"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2220"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cc50-2221">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2221">-or-</span></span> 
 <span data-ttu-id="9cc50-2222"><paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2222"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-2223"><paramref name="types" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2223"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="9cc50-2224">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2224">-or-</span></span> 
 <span data-ttu-id="9cc50-2225"><paramref name="modifiers" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2225"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="9cc50-2226">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2226">-or-</span></span> 
 <span data-ttu-id="9cc50-2227"><paramref name="types" /> i <paramref name="modifiers" /> nie mają tę samą długość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2227"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="9cc50-2228">Element <paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2228">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-2229">Ciąg zawierający nazwę właściwości do pobrania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2229">The string containing the name of the property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="9cc50-2230">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2230">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="9cc50-2231">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2231">-or-</span></span> 
<span data-ttu-id="9cc50-2232">Zero, aby zwrócić <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2232">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="9cc50-2233">Obiekt, który definiuje zestaw właściwości i umożliwia powiązanie, które może obejmować Wybór elementu członkowskiego przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2233">An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="9cc50-2234">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2234">-or-</span></span> 
<span data-ttu-id="9cc50-2235">Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2235">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="9cc50-2236">Zwracany typ właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2236">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="9cc50-2237">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów właściwości indeksowanej, aby uzyskać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2237">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="9cc50-2238">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2238">-or-</span></span> 
<span data-ttu-id="9cc50-2239">Pusta tablica typu <see cref="T:System.Type" /> (Type [] types = new Type[0]) umożliwia pobranie właściwości, która nie jest indeksowana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2239">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <param name="modifiers"><span data-ttu-id="9cc50-2240">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <paramref name="types" /> tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2240">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="9cc50-2241">Domyślny konsolidator nie przetwarza tego parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2241">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="9cc50-2242">W przypadku przesłonięcia w klasie pochodnej, wyszukuje określoną właściwość, której parametry odpowiadają określone typy argumentów i modyfikatorów, za pomocą ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2242">When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="9cc50-2243">Obiekt reprezentujący właściwość, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2243">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-2244">Mimo że domyślny integrator nie przetwarza <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2244">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="9cc50-2245">`ParameterModifier` jest używana tylko podczas wywoływania przez współdziałania z modelem COM i są obsługiwane tylko w przypadku parametrów, które są przekazywane przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2245">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="9cc50-2246">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania właściwości, które można uwzględnić w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2246">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-2247">Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` w celu uzyskania zwrotu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2247">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="9cc50-2248">Określ `BindingFlags.Public` obejmujący właściwości publiczne w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2248">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-2249">Określ `BindingFlags.NonPublic` obejmujący w w wyszukiwaniu właściwości niepubliczne (czyli prywatne, wewnętrzne i chronione właściwości).</span><span class="sxs-lookup"><span data-stu-id="9cc50-2249">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-2250">Określ `BindingFlags.FlattenHierarchy` obejmujący `public` i `protected` statyczne elementy członkowskie w hierarchii; `private` statyczne elementy członkowskie w klasie dziedziczonej nie są uwzględniane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2250">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="9cc50-2251">Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2251">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="9cc50-2252">`BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2252">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="9cc50-2253">`BindingFlags.DeclaredOnly` Aby wyszukać tylko właściwości zadeklarowanych w <xref:System.Type>, nie właściwości, które zostały po prostu odziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2253">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="9cc50-2254">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2254">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="9cc50-2255">Odnaleziono więcej niż jedną właściwość o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2255">More than one property is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-2256"><paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2256"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cc50-2257">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2257">-or-</span></span> 
 <span data-ttu-id="9cc50-2258"><paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2258"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cc50-2259">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2259">-or-</span></span> 
<span data-ttu-id="9cc50-2260">Jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2260">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-2261"><paramref name="types" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2261"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="9cc50-2262">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2262">-or-</span></span> 
 <span data-ttu-id="9cc50-2263"><paramref name="modifiers" /> ma charakter wielowymiarowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2263"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="9cc50-2264">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2264">-or-</span></span> 
 <span data-ttu-id="9cc50-2265"><paramref name="types" /> i <paramref name="modifiers" /> nie mają tę samą długość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2265"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cc50-2266">Bieżącym typem jest <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" />, lub <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2266">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" />, or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cc50-2267">Pobiera <see cref="T:System.Type" /> obiekt, który reprezentuje określonego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2267">Gets a <see cref="T:System.Type" /> object that represents the specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-2268">Pobiera bieżący <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2268">Gets the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="9cc50-2269">Bieżący <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2269">The current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="9cc50-2270">Inicjator klasy jest wywoływany i zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2270">A class initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="9cc50-2271">Określanie w pełni kwalifikowanych nazw typów</span><span class="sxs-lookup"><span data-stu-id="9cc50-2271">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="9cc50-2272">Nazwa kwalifikowanego dla zestawu typu można pobrać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2272">The assembly-qualified name of the type to get.</span></span> <span data-ttu-id="9cc50-2273">Zobacz <see cref="P:System.Type.AssemblyQualifiedName" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2273">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span></span> <span data-ttu-id="9cc50-2274">Jeśli typ jest zawierający obecnie wykonywany zestaw lub biblioteki Mscorlib.dll, wystarczy podać nazwę typu kwalifikowana przez jego przestrzeń nazw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2274">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <summary><span data-ttu-id="9cc50-2275">Pobiera <see cref="T:System.Type" /> o określonej nazwie, wyszukując uwzględniana wielkość liter.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2275">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="9cc50-2276">Typ o określonej nazwie, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2276">The type with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-2277">Możesz użyć <xref:System.Type.GetType%2A> metodę, aby uzyskać <xref:System.Type> obiektu dla typu w innym zestawie, jeśli znasz jego nazwę kwalifikowaną dla zestawu, który można uzyskać z <xref:System.Type.AssemblyQualifiedName>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2277">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly if you know its assembly-qualified name, which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="9cc50-2278"><xref:System.Type.GetType%2A> powoduje, że ładowanie zestawu określonego w `typeName`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2278"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="9cc50-2279">Można również załadować zestawu przy użyciu <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metody, a następnie użyj <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> metodę, aby uzyskać <xref:System.Type> obiektów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2279">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method, and then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method to get <xref:System.Type> objects.</span></span> <span data-ttu-id="9cc50-2280">Jeśli typ znajduje się w zestawie znane w czasie kompilacji program, jest bardziej wydajne, aby użyć `typeof` w C# lub `GetType` operatora w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2280">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C# or the `GetType` operator in Visual Basic.</span></span>
  
> [!NOTE]
>  <span data-ttu-id="9cc50-2281">Jeśli `typeName` nie można znaleźć, wywołanie <xref:System.Type.GetType%28System.String%29> metoda zwraca `null`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2281">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%29> method returns `null`.</span></span> <span data-ttu-id="9cc50-2282">Nie zostanie zgłoszony wyjątek.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2282">It does not throw an exception.</span></span> <span data-ttu-id="9cc50-2283">Do kontrolowania tego, czy wyjątek jest generowany, wywołania przeciążenia <xref:System.Type.GetType%2A> metody, która ma `throwOnError` parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2283">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="9cc50-2284"><xref:System.Type.GetType%2A> działa tylko na zestawy, ładowane z dysku.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2284"><xref:System.Type.GetType%2A> only works on assemblies loaded from disk.</span></span> <span data-ttu-id="9cc50-2285">Jeśli wywołasz <xref:System.Type.GetType%2A> do wyszukania w typ zdefiniowany w zestawie dynamicznym zdefiniowane przy użyciu <xref:System.Reflection.Emit> usług, możesz otrzymać niespójne zachowanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2285">If you call <xref:System.Type.GetType%2A> to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="9cc50-2286">Zachowanie zależy od tego, czy zestaw dynamiczny jest trwała, oznacza to, utworzony za pomocą `RunAndSave` lub `Save` dostępu tryby <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2286">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="9cc50-2287">Jeśli zestaw dynamiczny jest trwały i został zapisany na dysku przed `GetType` jest wywoływana, moduł ładujący wyszukuje zestaw zapisane na dysku, ładuje tego zestawu i pobiera typ z tego zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2287">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="9cc50-2288">Jeśli zestaw nie został zapisany na dysku po `GetType` jest wywoływana metoda zwraca `null`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2288">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="9cc50-2289">`GetType` nie rozpoznaje przejściowy dynamicznych zestawów; Dlatego wywołanie `GetType` można pobrać typu na przejściowy zwraca zestaw dynamiczny `null`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2289">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="9cc50-2290">Aby użyć `GetType` na modułu dynamicznego subskrybować <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> zdarzenia i wywołania `GetType` przed zapisaniem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2290">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="9cc50-2291">W przeciwnym razie otrzymasz dwie kopie zestawu w pamięci.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2291">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="9cc50-2292">W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2292">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="9cc50-2293">Typ elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="9cc50-2293">Member Type</span></span>|<span data-ttu-id="9cc50-2294">Static</span><span class="sxs-lookup"><span data-stu-id="9cc50-2294">Static</span></span>|<span data-ttu-id="9cc50-2295">Niestatyczna</span><span class="sxs-lookup"><span data-stu-id="9cc50-2295">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="9cc50-2296">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="9cc50-2296">Constructor</span></span>|<span data-ttu-id="9cc50-2297">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2297">No</span></span>|<span data-ttu-id="9cc50-2298">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2298">No</span></span>|  
|<span data-ttu-id="9cc50-2299">Pole</span><span class="sxs-lookup"><span data-stu-id="9cc50-2299">Field</span></span>|<span data-ttu-id="9cc50-2300">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2300">No</span></span>|<span data-ttu-id="9cc50-2301">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2301">Yes.</span></span> <span data-ttu-id="9cc50-2302">Pole jest zawsze ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2302">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-2303">Zdarzenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2303">Event</span></span>|<span data-ttu-id="9cc50-2304">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-2304">Not applicable</span></span>|<span data-ttu-id="9cc50-2305">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2305">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-2306">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2306">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-2307">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2307">See note 2 below.</span></span>|  
|<span data-ttu-id="9cc50-2308">Metoda</span><span class="sxs-lookup"><span data-stu-id="9cc50-2308">Method</span></span>|<span data-ttu-id="9cc50-2309">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2309">No</span></span>|<span data-ttu-id="9cc50-2310">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2310">Yes.</span></span> <span data-ttu-id="9cc50-2311">Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2311">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-2312">Typu zagnieżdżony</span><span class="sxs-lookup"><span data-stu-id="9cc50-2312">Nested Type</span></span>|<span data-ttu-id="9cc50-2313">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2313">No</span></span>|<span data-ttu-id="9cc50-2314">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2314">No</span></span>|  
|<span data-ttu-id="9cc50-2315">Właściwość</span><span class="sxs-lookup"><span data-stu-id="9cc50-2315">Property</span></span>|<span data-ttu-id="9cc50-2316">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-2316">Not applicable</span></span>|<span data-ttu-id="9cc50-2317">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2317">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-2318">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2318">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-2319">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2319">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="9cc50-2320">Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2320">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="9cc50-2321">To jest porównanie binarne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2321">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="9cc50-2322">W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2322">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-2323">Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2323">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="9cc50-2324">Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2324">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="9cc50-2325">Tablic lub typów modelu COM nie są wyszukiwane chyba, że już zostały załadowane do tabeli dostępnych klas.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2325">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="9cc50-2326">`typeName` może być nazwa typu kwalifikowana przez jego przestrzeń nazw lub kwalifikowaną dla zestawu, która zawiera nazwę specyfikacja nazwy zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2326">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="9cc50-2327">Zobacz <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2327">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="9cc50-2328">Jeśli `typeName` obejmuje przestrzeń nazw, ale nie nazwę zestawu, Metoda ta wyszukuje tylko do obiektu wywołującego zestawu i Mscorlib.dll, w tej kolejności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2328">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="9cc50-2329">Jeśli typeName jest w pełni kwalifikowaną nazwą zestawu częściowego lub pełny, Metoda ta wyszukuje w określonym zestawie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2329">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="9cc50-2330">Jeśli zestaw ma silną nazwą, wymagana jest nazwa kompletny zestaw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2330">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="9cc50-2331"><xref:System.Type.AssemblyQualifiedName%2A> Właściwość zwraca w pełni kwalifikowaną nazwę typu w tym typów zagnieżdżonych, nazwa zestawu i argumenty typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2331">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments.</span></span> <span data-ttu-id="9cc50-2332">Wszystkie kompilatory, które obsługują aparat plików wykonywalnych języka wspólnego, w trakcie wykonania wyemitują prostą nazwę klasy zagnieżdżonej, a odbicie podczas kwerendy stworzy zniekształcone nazwy zgodnie z następującymi konwencjami.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2332">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-2333">W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2333">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="9cc50-2334">Na przykład "ProcessorArchitecture = msil".</span><span class="sxs-lookup"><span data-stu-id="9cc50-2334">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="9cc50-2335">Jednak nie są uwzględnione w ciągu zwracanego przez <xref:System.Type.AssemblyQualifiedName%2A> właściwość ze względu na zgodność.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2335">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="9cc50-2336">Można również załadować typów, tworząc <xref:System.Reflection.AssemblyName> obiektu i przekazywania go do odpowiedniego przeciążenia <xref:System.Reflection.Assembly.Load%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2336">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="9cc50-2337">Następnie można użyć <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> metodę, aby załadować typów z zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2337">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="9cc50-2338">Zobacz też <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2338">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="9cc50-2339">Ogranicznik</span><span class="sxs-lookup"><span data-stu-id="9cc50-2339">Delimiter</span></span>|<span data-ttu-id="9cc50-2340">Znaczenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2340">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="9cc50-2341">Ukośnik odwrotny (\\)</span><span class="sxs-lookup"><span data-stu-id="9cc50-2341">Backslash (\\)</span></span>|<span data-ttu-id="9cc50-2342">Znak ucieczki.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2342">Escape character.</span></span>|  
|<span data-ttu-id="9cc50-2343">Początkowych (') | Poprzedza co najmniej jedną cyfrę reprezentującą liczbę parametrów typu, znajduje się na końcu nazwy typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2343">Backtick (\`)|Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="9cc50-2344">Nawiasy kwadratowe ([])</span><span class="sxs-lookup"><span data-stu-id="9cc50-2344">Brackets ([])</span></span>|<span data-ttu-id="9cc50-2345">Ujmij listy argumentów typu rodzajowego, aby uzyskać skonstruowany typ rodzajowy; na liście argumentów typu należy ująć typu kwalifikowanego zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2345">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="9cc50-2346">Przecinek (,)</span><span class="sxs-lookup"><span data-stu-id="9cc50-2346">Comma (,)</span></span>|<span data-ttu-id="9cc50-2347">Poprzedza nazwę zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2347">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="9cc50-2348">Kropka (.)</span><span class="sxs-lookup"><span data-stu-id="9cc50-2348">Period (.)</span></span>|<span data-ttu-id="9cc50-2349">Wskazuje przestrzeń nazw identyfikatorów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2349">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="9cc50-2350">Znak plus (+)</span><span class="sxs-lookup"><span data-stu-id="9cc50-2350">Plus sign (+)</span></span>|<span data-ttu-id="9cc50-2351">Poprzedza klasę zagnieżdżoną.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2351">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="9cc50-2352">Na przykład w pełni kwalifikowana nazwa klasy może wyglądać następująco:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2352">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="9cc50-2353">Jeśli przestrzeń nazw zostały TopNamespace.Sub+Namespace, a następnie ciąg musi poprzedzać znak plus (+) przy użyciu znaku ucieczki (\\), aby zapobiec interpretacji jako separator zagnieżdżenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2353">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="9cc50-2354">Odbicie emituje tego ciągu w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2354">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="9cc50-2355">A "++" staje się "\\+\\+", a "\\"staje się"\\\\".</span><span class="sxs-lookup"><span data-stu-id="9cc50-2355">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="9cc50-2356">Ta nazwa kwalifikowana może utrwalona i później używana do ładowania <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2356">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="9cc50-2357">Aby wyszukać i załadować <xref:System.Type>, użyj <xref:System.Type.GetType%2A> albo z typem nazwy tylko lub nazwą kwalifikowaną typu zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2357">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="9cc50-2358"><xref:System.Type.GetType%2A> z typem nazwy tylko będzie szukać <xref:System.Type> w zestawie wywołującego, a następnie w zestawie systemowym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2358"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="9cc50-2359"><xref:System.Type.GetType%2A> z zestawem kwalifikowanej nazwy typu będzie szukać <xref:System.Type> w każdym zestawie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2359"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="9cc50-2360">Nazwy typów mogą obejmować końcowe znaki, które wyznaczają dodatkowe informacje dotyczące typu, na przykład to, czy typ jest typem odwołania, typem wskaźnika lub typem tablicowym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2360">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="9cc50-2361">Aby pobrać, wpisz nazwę bez tych znaków końcowych, należy użyć `t.GetElementType().ToString()`, gdzie `t` jest typem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2361">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="9cc50-2362">Spacje są istotne we wszystkich składnikach nazwy z wyjątkiem nazwy zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2362">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="9cc50-2363">Spacje przed separatorem w nazwie zestawu ',' są istotne, ale spacje po separatorze ',' są ignorowane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2363">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="9cc50-2364">Nazwa typu ogólnego kończy się ciągiem początkowych (\`) następują cyfry reprezentujący liczbę wszystkich argumentów typu rodzajowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2364">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="9cc50-2365">Celem tego przekręcaniu nazwy jest umożliwienie kompilatory do obsługi typów ogólnych o takiej samej nazwie, ale z różną liczbę parametrów typu, w tym samym zakresie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2365">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="9cc50-2366">Na przykład odbicia zwraca zniekształcone nazwy `Tuple`1` and `krotki`2` z metod ogólnych `Tuple(Of T)` i `Tuple(Of T0, T1)` w języku Visual Basic lub `Tuple<T>` i krotki`\<T0, T1>` w języku Visual C#.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2366">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="9cc50-2367">Dla typów ogólnych lista argumentów typu jest ujęty w nawiasy i argumenty typu są oddzielone przecinkami.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2367">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="9cc50-2368">Na przykład ogólny <xref:System.Collections.Generic.Dictionary%602> ma dwa parametry typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2368">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="9cc50-2369">A <xref:System.Collections.Generic.Dictionary%602> z `MyType` przy użyciu kluczy typu <xref:System.String> może być reprezentowany w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2369">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="9cc50-2370">Aby określić typu kwalifikowanego zestawu w obrębie listy argumentów typu, należy ująć typu kwalifikowanego zestawu w nawiasy kwadratowe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2370">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="9cc50-2371">W przeciwnym razie przecinki oddzielające części nazwy kwalifikowanej zestawu są interpretowane jako rozdzielający argumentów typu dodatkowe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2371">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="9cc50-2372">Na przykład <xref:System.Collections.Generic.Dictionary%602> z `MyType` fromMyAssembly.dll przy użyciu kluczy typu <xref:System.String>, może być następujący:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2372">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` fromMyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-2373">Typu kwalifikowanego zestawu mogą być ujęte w nawiasy kwadratowe, tylko wtedy, gdy pojawia się on w obrębie lista parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2373">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="9cc50-2374">Reguły dotyczące wyszukiwania zestawów dla typów kwalifikowana i niekwalifikowanej w liście parametrów typu są takie same jak reguły dla typów nierodzajowymi kwalifikowana i niekwalifikowane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2374">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="9cc50-2375">Typy dopuszczające wartości zerowe są w wyjątkowym przypadku okna typów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2375">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="9cc50-2376">Na przykład dopuszczający wartości null <xref:System.Int32> jest reprezentowany przez ciąg "System.Nullable'1[System.Int32]".</span><span class="sxs-lookup"><span data-stu-id="9cc50-2376">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-2377">W języku C#, C++ i Visual Basic można również uzyskać przy użyciu operatorów typu typy dopuszczające wartości null.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2377">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="9cc50-2378">Na przykład nullable <xref:System.Boolean> typ zwracany przez `typeof(Nullable<bool>)` w języku C#, `Nullable<Boolean>::typeid` w języku C++ i przez `GetType(Nullable(Of Boolean))` w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2378">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="9cc50-2379">W poniższej tabeli przedstawiono składnię, możesz za pomocą `GetType` dla różnych typów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2379">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="9cc50-2380">Aby uzyskać</span><span class="sxs-lookup"><span data-stu-id="9cc50-2380">To Get</span></span>|<span data-ttu-id="9cc50-2381">Zastosowanie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2381">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="9cc50-2382">Dopuszczający wartości null <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="9cc50-2382">A nullable <xref:System.Int32></span></span>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|<span data-ttu-id="9cc50-2383">Niezarządzany wskaźnik do `MyType`</span><span class="sxs-lookup"><span data-stu-id="9cc50-2383">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="9cc50-2384">Niezarządzany wskaźnik do wskaźnika do `MyType`</span><span class="sxs-lookup"><span data-stu-id="9cc50-2384">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="9cc50-2385">Zarządzane wskaźnik lub odwołanie do `MyType`</span><span class="sxs-lookup"><span data-stu-id="9cc50-2385">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="9cc50-2386">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2386">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="9cc50-2387">Należy pamiętać, że w przeciwieństwie do wskaźników, odwołań są ograniczone do jednego poziomu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2387">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="9cc50-2388">Klasy nadrzędnej i zagnieżdżone klasy</span><span class="sxs-lookup"><span data-stu-id="9cc50-2388">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="9cc50-2389">Jednowymiarowa tablica dolną granicę równą 0</span><span class="sxs-lookup"><span data-stu-id="9cc50-2389">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyType[]")`|  
|<span data-ttu-id="9cc50-2390">Jednowymiarowa tablica o nieznanych dolna granica</span><span class="sxs-lookup"><span data-stu-id="9cc50-2390">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyType[*]")`|  
|<span data-ttu-id="9cc50-2391">N wymiarową tablicą</span><span class="sxs-lookup"><span data-stu-id="9cc50-2391">An n-dimensional array</span></span>|<span data-ttu-id="9cc50-2392">Przecinek (,) znajduje się wewnątrz nawiasów w sumie n-1 razy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2392">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="9cc50-2393">Na przykład `System.Object[,,]` reprezentuje trójwymiarowym `Object` tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2393">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="9cc50-2394">Tablica tablice jednowymiarowe</span><span class="sxs-lookup"><span data-stu-id="9cc50-2394">An array of one-dimensional arrays</span></span>|`Type.GetType("MyType[][]")`|  
|<span data-ttu-id="9cc50-2395">Prostokątnej dwuwymiarowej tablicy przy użyciu nieznanego dolne granice</span><span class="sxs-lookup"><span data-stu-id="9cc50-2395">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyType[,]")`|  
|<span data-ttu-id="9cc50-2396">Typ ogólny z jednego typu argumentu</span><span class="sxs-lookup"><span data-stu-id="9cc50-2396">A generic type with one type argument</span></span>|``Type.GetType("MyGenericType`1[MyType]")``|  
|<span data-ttu-id="9cc50-2397">Typ ogólny z dwoma argumentami typu</span><span class="sxs-lookup"><span data-stu-id="9cc50-2397">A generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|<span data-ttu-id="9cc50-2398">Typ ogólny z dwóch argumentów typu kwalifikowanego zestawu</span><span class="sxs-lookup"><span data-stu-id="9cc50-2398">A generic type with two assembly-qualified type arguments</span></span>|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|<span data-ttu-id="9cc50-2399">Kwalifikowanych dla zestawu typu ogólnego z nieprawidłowym argumentem typu kwalifikowanego zestawu</span><span class="sxs-lookup"><span data-stu-id="9cc50-2399">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|<span data-ttu-id="9cc50-2400">Typ ogólny, którego argument typu jest typ ogólny z dwoma argumentami typu</span><span class="sxs-lookup"><span data-stu-id="9cc50-2400">A generic type whose type argument is a generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-2401">Poniższy przykład pobiera typ `System.Int32` i używa tego typu obiektu do wyświetlenia <xref:System.Type.FullName%2A> właściwość `System.Int32`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2401">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-2402"><paramref name="typeName" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2402"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="9cc50-2403">Inicjator klasy jest wywoływany i zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2403">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-2404"><paramref name="typeName" /> reprezentuje typ ogólny, który jest typem wskaźnika <see langword="ByRef" /> typu, lub <see cref="T:System.Void" /> jako jeden z argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2404"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="9cc50-2405">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2405">-or-</span></span> 
 <span data-ttu-id="9cc50-2406"><paramref name="typeName" /> reprezentuje typ ogólny, który ma niepoprawną liczbę argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2406"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="9cc50-2407">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2407">-or-</span></span> 
 <span data-ttu-id="9cc50-2408"><paramref name="typeName" /> reprezentuje typ ogólny i jeden z argumentów typu nie spełniają ograniczeń dla odpowiedniego parametru typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2408"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="9cc50-2409"><paramref name="typeName" /> reprezentuje tablicę <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2409"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="9cc50-2410">W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.IO.IOException" />, a zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2410">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="9cc50-2411">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2411">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="9cc50-2412">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2412">The assembly or one of its dependencies is not valid.</span></span>  
  
<span data-ttu-id="9cc50-2413">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2413">-or-</span></span> 
<span data-ttu-id="9cc50-2414">W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana, a zestaw został skompilowany przy użyciu nowszej wersji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2414">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="9cc50-2415">Określanie w pełni kwalifikowanych nazw typów</span><span class="sxs-lookup"><span data-stu-id="9cc50-2415">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="9cc50-2416">Nazwa kwalifikowanego dla zestawu typu można pobrać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2416">The assembly-qualified name of the type to get.</span></span> <span data-ttu-id="9cc50-2417">Zobacz <see cref="P:System.Type.AssemblyQualifiedName" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2417">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span></span> <span data-ttu-id="9cc50-2418">Jeśli typ jest zawierający obecnie wykonywany zestaw lub biblioteki Mscorlib.dll, wystarczy podać nazwę typu kwalifikowana przez jego przestrzeń nazw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2418">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="9cc50-2419"><see langword="true" /> Aby zgłosić wyjątek, jeśli nie można odnaleźć typu; <see langword="false" /> do zwrócenia <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2419"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="9cc50-2420">Określanie <see langword="false" /> powoduje również pominięcie niektórych warunków wyjątków, ale nie wszystkie z nich.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2420">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="9cc50-2421">Zobacz sekcję Wyjątki.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2421">See the Exceptions section.</span></span></param>
        <summary><span data-ttu-id="9cc50-2422">Pobiera <see cref="T:System.Type" /> o określonej nazwie, wykonując wyszukiwanie i określeniu, czy zgłosić wyjątek, jeśli typ nie zostanie znaleziony.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2422">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</span></span></summary>
        <returns><span data-ttu-id="9cc50-2423">Typ o określonej nazwie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2423">The type with the specified name.</span></span> <span data-ttu-id="9cc50-2424">Jeśli typ nie zostanie znaleziony, <paramref name="throwOnError" /> parametr określa, czy <see langword="null" /> zwracany jest lub zostanie zgłoszony wyjątek.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2424">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="9cc50-2425">W niektórych przypadkach występuje wyjątek niezależnie od wartości <paramref name="throwOnError" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2425">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="9cc50-2426">Zobacz sekcję Wyjątki.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2426">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-2427">Możesz użyć <xref:System.Type.GetType%2A> metodę, aby uzyskać <xref:System.Type> obiektu dla typu w innym zestawie, jeśli znasz jego nazwę kwalifikowaną dla zestawu, który można uzyskać z <xref:System.Type.AssemblyQualifiedName>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2427">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly if you know its assembly-qualified name, which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="9cc50-2428"><xref:System.Type.GetType%2A> powoduje, że ładowanie zestawu określonego w `typeName`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2428"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="9cc50-2429">Można również załadować zestawu przy użyciu <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metody, a następnie użyj <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> metodę, aby uzyskać <xref:System.Type> obiektów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2429">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method, and then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method to get <xref:System.Type> objects.</span></span> <span data-ttu-id="9cc50-2430">Jeśli typ znajduje się w zestawie znane w czasie kompilacji program, jest bardziej wydajne, aby użyć `typeof` w C# lub `GetType` operatora w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2430">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C# or the `GetType` operator in Visual Basic.</span></span>
  
 <span data-ttu-id="9cc50-2431">`GetType` działa tylko na zestawy, ładowane z dysku.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2431">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="9cc50-2432">Jeśli wywołasz `GetType` do wyszukania w typ zdefiniowany w zestawie dynamicznym zdefiniowane przy użyciu <xref:System.Reflection.Emit> usług, możesz otrzymać niespójne zachowanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2432">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="9cc50-2433">Zachowanie zależy od tego, czy zestaw dynamiczny jest trwała, oznacza to, utworzony za pomocą `RunAndSave` lub `Save` dostępu tryby <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2433">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="9cc50-2434">Jeśli zestaw dynamiczny jest trwały i został zapisany na dysku przed `GetType` jest wywoływana, moduł ładujący wyszukuje zestaw zapisane na dysku, ładuje tego zestawu i pobiera typ z tego zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2434">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="9cc50-2435">Jeśli zestaw nie został zapisany na dysku po `GetType` jest wywoływana metoda zwraca `null`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2435">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="9cc50-2436">`GetType` nie rozpoznaje przejściowy dynamicznych zestawów; Dlatego wywołanie `GetType` można pobrać typu na przejściowy zwraca zestaw dynamiczny `null`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2436">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="9cc50-2437">Aby użyć `GetType` na modułu dynamicznego subskrybować <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> zdarzenia i wywołania `GetType` przed zapisaniem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2437">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="9cc50-2438">W przeciwnym razie otrzymasz dwie kopie zestawu w pamięci.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2438">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="9cc50-2439">`throwOnError` Parametr określa, co się stanie, gdy typ nie zostanie znaleziony i powoduje również pominięcie niektórych warunków wyjątków, zgodnie z opisem w sekcji wyjątki.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2439">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="9cc50-2440">Niektóre wyjątki są zgłaszane niezależnie od wartości `throwOnError`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2440">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="9cc50-2441">Na przykład, jeśli typ zostanie znaleziony, ale nie może zostać załadowany <xref:System.TypeLoadException> jest zgłaszany nawet wtedy, gdy `throwOnError` jest `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2441">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="9cc50-2442">W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2442">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="9cc50-2443">Typ elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="9cc50-2443">Member Type</span></span>|<span data-ttu-id="9cc50-2444">Static</span><span class="sxs-lookup"><span data-stu-id="9cc50-2444">Static</span></span>|<span data-ttu-id="9cc50-2445">Niestatyczna</span><span class="sxs-lookup"><span data-stu-id="9cc50-2445">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="9cc50-2446">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="9cc50-2446">Constructor</span></span>|<span data-ttu-id="9cc50-2447">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2447">No</span></span>|<span data-ttu-id="9cc50-2448">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2448">No</span></span>|  
|<span data-ttu-id="9cc50-2449">Pole</span><span class="sxs-lookup"><span data-stu-id="9cc50-2449">Field</span></span>|<span data-ttu-id="9cc50-2450">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2450">No</span></span>|<span data-ttu-id="9cc50-2451">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2451">Yes.</span></span> <span data-ttu-id="9cc50-2452">Pole jest zawsze ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2452">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-2453">Zdarzenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2453">Event</span></span>|<span data-ttu-id="9cc50-2454">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-2454">Not applicable</span></span>|<span data-ttu-id="9cc50-2455">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2455">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-2456">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2456">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-2457">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2457">See note 2 below.</span></span>|  
|<span data-ttu-id="9cc50-2458">Metoda</span><span class="sxs-lookup"><span data-stu-id="9cc50-2458">Method</span></span>|<span data-ttu-id="9cc50-2459">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2459">No</span></span>|<span data-ttu-id="9cc50-2460">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2460">Yes.</span></span> <span data-ttu-id="9cc50-2461">Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2461">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-2462">Typu zagnieżdżony</span><span class="sxs-lookup"><span data-stu-id="9cc50-2462">Nested Type</span></span>|<span data-ttu-id="9cc50-2463">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2463">No</span></span>|<span data-ttu-id="9cc50-2464">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2464">No</span></span>|  
|<span data-ttu-id="9cc50-2465">Właściwość</span><span class="sxs-lookup"><span data-stu-id="9cc50-2465">Property</span></span>|<span data-ttu-id="9cc50-2466">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-2466">Not applicable</span></span>|<span data-ttu-id="9cc50-2467">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2467">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-2468">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2468">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-2469">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2469">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="9cc50-2470">Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2470">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="9cc50-2471">To jest porównanie binarne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2471">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="9cc50-2472">W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2472">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-2473">Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2473">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="9cc50-2474">Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2474">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="9cc50-2475">Tablic lub typów modelu COM nie są wyszukiwane chyba, że już zostały załadowane do tabeli dostępnych klas.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2475">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="9cc50-2476">`typeName` może być nazwa typu kwalifikowana przez jego przestrzeń nazw lub kwalifikowaną dla zestawu, która zawiera nazwę specyfikacja nazwy zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2476">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="9cc50-2477">Zobacz <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2477">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="9cc50-2478">Jeśli `typeName` obejmuje przestrzeń nazw, ale nie nazwę zestawu, Metoda ta wyszukuje tylko do obiektu wywołującego zestawu i Mscorlib.dll, w tej kolejności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2478">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="9cc50-2479">Jeśli typeName jest w pełni kwalifikowaną nazwą zestawu częściowego lub pełny, Metoda ta wyszukuje w określonym zestawie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2479">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="9cc50-2480">Jeśli zestaw ma silną nazwą, wymagana jest nazwa kompletny zestaw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2480">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="9cc50-2481"><xref:System.Type.AssemblyQualifiedName%2A> Właściwość zwraca w pełni kwalifikowaną nazwę typu w tym typów zagnieżdżonych, nazwa zestawu i argumenty ogólne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2481">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic arguments.</span></span> <span data-ttu-id="9cc50-2482">Wszystkie kompilatory, które obsługują aparat plików wykonywalnych języka wspólnego, w trakcie wykonania wyemitują prostą nazwę klasy zagnieżdżonej, a odbicie podczas kwerendy stworzy zniekształcone nazwy zgodnie z następującymi konwencjami.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2482">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-2483">W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2483">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="9cc50-2484">Na przykład "ProcessorArchitecture = msil".</span><span class="sxs-lookup"><span data-stu-id="9cc50-2484">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="9cc50-2485">Jednak nie są uwzględnione w ciągu zwracanego przez <xref:System.Type.AssemblyQualifiedName%2A> właściwość ze względu na zgodność.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2485">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="9cc50-2486">Można również załadować typów, tworząc <xref:System.Reflection.AssemblyName> obiektu i przekazywania go do odpowiedniego przeciążenia <xref:System.Reflection.Assembly.Load%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2486">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="9cc50-2487">Następnie można użyć <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> metodę, aby załadować typów z zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2487">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="9cc50-2488">Zobacz też <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2488">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="9cc50-2489">Ogranicznik</span><span class="sxs-lookup"><span data-stu-id="9cc50-2489">Delimiter</span></span>|<span data-ttu-id="9cc50-2490">Znaczenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2490">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="9cc50-2491">Ukośnik odwrotny (\\)</span><span class="sxs-lookup"><span data-stu-id="9cc50-2491">Backslash (\\)</span></span>|<span data-ttu-id="9cc50-2492">Znak ucieczki.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2492">Escape character.</span></span>|  
|<span data-ttu-id="9cc50-2493">Początkowych (') | Poprzedza co najmniej jedną cyfrę reprezentującą liczbę parametrów typu, znajduje się na końcu nazwy typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2493">Backtick (\`)|Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="9cc50-2494">Nawiasy kwadratowe ([])</span><span class="sxs-lookup"><span data-stu-id="9cc50-2494">Brackets ([])</span></span>|<span data-ttu-id="9cc50-2495">Ujmij listy argumentów typu rodzajowego, aby uzyskać skonstruowany typ rodzajowy; na liście argumentów typu należy ująć typu kwalifikowanego zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2495">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="9cc50-2496">Przecinek (,)</span><span class="sxs-lookup"><span data-stu-id="9cc50-2496">Comma (,)</span></span>|<span data-ttu-id="9cc50-2497">Poprzedza nazwę zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2497">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="9cc50-2498">Kropka (.)</span><span class="sxs-lookup"><span data-stu-id="9cc50-2498">Period (.)</span></span>|<span data-ttu-id="9cc50-2499">Wskazuje przestrzeń nazw identyfikatorów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2499">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="9cc50-2500">Znak plus (+)</span><span class="sxs-lookup"><span data-stu-id="9cc50-2500">Plus sign (+)</span></span>|<span data-ttu-id="9cc50-2501">Poprzedza klasę zagnieżdżoną.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2501">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="9cc50-2502">Na przykład w pełni kwalifikowana nazwa klasy może wyglądać następująco:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2502">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="9cc50-2503">Jeśli przestrzeń nazw zostały TopNamespace.Sub+Namespace, a następnie ciąg musi poprzedzać znak plus (+) przy użyciu znaku ucieczki (\\), aby zapobiec interpretacji jako separator zagnieżdżenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2503">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="9cc50-2504">Odbicie emituje tego ciągu w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2504">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="9cc50-2505">A "++" staje się "\\+\\+", a "\\"staje się"\\\\".</span><span class="sxs-lookup"><span data-stu-id="9cc50-2505">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="9cc50-2506">Ta nazwa kwalifikowana może utrwalona i później używana do ładowania <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2506">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="9cc50-2507">Aby wyszukać i załadować <xref:System.Type>, użyj <xref:System.Type.GetType%2A> albo z typem nazwy tylko lub nazwą kwalifikowaną typu zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2507">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="9cc50-2508"><xref:System.Type.GetType%2A> z typem nazwy tylko będzie szukać <xref:System.Type> w zestawie wywołującego, a następnie w zestawie systemowym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2508"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="9cc50-2509"><xref:System.Type.GetType%2A> z zestawem kwalifikowanej nazwy typu będzie szukać <xref:System.Type> w każdym zestawie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2509"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="9cc50-2510">Nazwy typów mogą obejmować końcowe znaki, które wyznaczają dodatkowe informacje dotyczące typu, na przykład to, czy typ jest typem odwołania, typem wskaźnika lub typem tablicowym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2510">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="9cc50-2511">Aby pobrać, wpisz nazwę bez tych znaków końcowych, należy użyć `t.GetElementType().ToString()`, gdzie `t` jest typem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2511">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="9cc50-2512">Spacje są istotne we wszystkich składnikach nazwy z wyjątkiem nazwy zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2512">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="9cc50-2513">Spacje przed separatorem w nazwie zestawu ',' są istotne, ale spacje po separatorze ',' są ignorowane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2513">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="9cc50-2514">Nazwa typu ogólnego kończy się ciągiem początkowych (\`) następują cyfry reprezentujący liczbę wszystkich argumentów typu rodzajowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2514">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="9cc50-2515">Celem tego przekręcaniu nazwy jest umożliwienie kompilatory do obsługi typów ogólnych o takiej samej nazwie, ale z różną liczbę parametrów typu, w tym samym zakresie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2515">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="9cc50-2516">Na przykład odbicia zwraca zniekształcone nazwy `Tuple`1` and `krotki`2` z metod ogólnych `Tuple(Of T)` i `Tuple(Of T0, T1)` w języku Visual Basic lub `Tuple<T>` i krotki`\<T0, T1>` w języku Visual C#.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2516">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="9cc50-2517">Dla typów ogólnych lista argumentów typu jest ujęty w nawiasy i argumenty typu są oddzielone przecinkami.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2517">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="9cc50-2518">Na przykład ogólny <xref:System.Collections.Generic.Dictionary%602> ma dwa parametry typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2518">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="9cc50-2519">A <xref:System.Collections.Generic.Dictionary%602> z `MyType` przy użyciu kluczy typu <xref:System.String> może być reprezentowany w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2519">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="9cc50-2520">Aby określić typu kwalifikowanego zestawu w obrębie listy argumentów typu, należy ująć typu kwalifikowanego zestawu w nawiasy kwadratowe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2520">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="9cc50-2521">W przeciwnym razie przecinki oddzielające części nazwy kwalifikowanej zestawu są interpretowane jako rozdzielający argumentów typu dodatkowe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2521">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="9cc50-2522">Na przykład <xref:System.Collections.Generic.Dictionary%602> z `MyType` z MyAssembly.dll przy użyciu kluczy typu <xref:System.String>, może być następujący:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2522">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-2523">Typu kwalifikowanego zestawu mogą być ujęte w nawiasy kwadratowe, tylko wtedy, gdy pojawia się on w obrębie lista parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2523">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="9cc50-2524">Reguły dotyczące wyszukiwania zestawów dla typów kwalifikowana i niekwalifikowanej w liście parametrów typu są takie same jak reguły dla typów nierodzajowymi kwalifikowana i niekwalifikowane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2524">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="9cc50-2525">Typy dopuszczające wartości zerowe są w wyjątkowym przypadku okna typów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2525">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="9cc50-2526">Na przykład dopuszczający wartości null <xref:System.Int32> jest reprezentowany przez ciąg "System.Nullable'1[System.Int32]".</span><span class="sxs-lookup"><span data-stu-id="9cc50-2526">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-2527">W języku C#, C++ i Visual Basic można również uzyskać przy użyciu operatorów typu typy dopuszczające wartości null.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2527">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="9cc50-2528">Na przykład nullable <xref:System.Boolean> typ zwracany przez `typeof(Nullable<bool>)` w języku C#, `Nullable<Boolean>::typeid` w języku C++ i przez `GetType(Nullable(Of Boolean))` w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2528">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="9cc50-2529">W poniższej tabeli przedstawiono składnię, możesz za pomocą `GetType` dla różnych typów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2529">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="9cc50-2530">Aby uzyskać</span><span class="sxs-lookup"><span data-stu-id="9cc50-2530">To Get</span></span>|<span data-ttu-id="9cc50-2531">Zastosowanie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2531">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="9cc50-2532">Dopuszczający wartości null <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="9cc50-2532">A nullable <xref:System.Int32></span></span>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|<span data-ttu-id="9cc50-2533">Niezarządzany wskaźnik do `MyType`</span><span class="sxs-lookup"><span data-stu-id="9cc50-2533">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="9cc50-2534">Niezarządzany wskaźnik do wskaźnika do `MyType`</span><span class="sxs-lookup"><span data-stu-id="9cc50-2534">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="9cc50-2535">Zarządzane wskaźnik lub odwołanie do `MyType`</span><span class="sxs-lookup"><span data-stu-id="9cc50-2535">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="9cc50-2536">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2536">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="9cc50-2537">Należy pamiętać, że w przeciwieństwie do wskaźników, odwołań są ograniczone do jednego poziomu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2537">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="9cc50-2538">Klasy nadrzędnej i zagnieżdżone klasy</span><span class="sxs-lookup"><span data-stu-id="9cc50-2538">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="9cc50-2539">Jednowymiarowa tablica dolną granicę równą 0</span><span class="sxs-lookup"><span data-stu-id="9cc50-2539">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="9cc50-2540">Jednowymiarowa tablica o nieznanych dolna granica</span><span class="sxs-lookup"><span data-stu-id="9cc50-2540">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="9cc50-2541">N wymiarową tablicą</span><span class="sxs-lookup"><span data-stu-id="9cc50-2541">An n-dimensional array</span></span>|<span data-ttu-id="9cc50-2542">Przecinek (,) znajduje się wewnątrz nawiasów w sumie n-1 razy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2542">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="9cc50-2543">Na przykład `System.Object[,,]` reprezentuje trójwymiarowym `Object` tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2543">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="9cc50-2544">Tablicy dwuwymiarowej tablicy</span><span class="sxs-lookup"><span data-stu-id="9cc50-2544">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="9cc50-2545">Prostokątnej dwuwymiarowej tablicy przy użyciu nieznanego dolne granice</span><span class="sxs-lookup"><span data-stu-id="9cc50-2545">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="9cc50-2546">Typ ogólny z jednego typu argumentu</span><span class="sxs-lookup"><span data-stu-id="9cc50-2546">A generic type with one type argument</span></span>|``Type.GetType("MyGenericType`1[MyType]")``|  
|<span data-ttu-id="9cc50-2547">Typ ogólny z dwoma argumentami typu</span><span class="sxs-lookup"><span data-stu-id="9cc50-2547">A generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|<span data-ttu-id="9cc50-2548">Typ ogólny z dwóch argumentów typu kwalifikowanego zestawu</span><span class="sxs-lookup"><span data-stu-id="9cc50-2548">A generic type with two assembly-qualified type arguments</span></span>|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|<span data-ttu-id="9cc50-2549">Kwalifikowanych dla zestawu typu ogólnego z nieprawidłowym argumentem typu kwalifikowanego zestawu</span><span class="sxs-lookup"><span data-stu-id="9cc50-2549">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|<span data-ttu-id="9cc50-2550">Typ ogólny, którego argument typu jest typ ogólny z dwoma argumentami typu</span><span class="sxs-lookup"><span data-stu-id="9cc50-2550">A generic type whose type argument is a generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-2551">Poniższy przykład pobiera typ `System.Int32` i używa tego typu obiektu do wyświetlenia <xref:System.Type.FullName%2A> właściwość `System.Int32`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2551">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span> <span data-ttu-id="9cc50-2552">Jeśli obiekt typu odwołuje się do zestawu, który nie istnieje, w tym przykładzie zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2552">If a type object refers to an assembly that does not exist, this example throws an exception.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-2553"><paramref name="typeName" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2553"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="9cc50-2554">Inicjator klasy jest wywoływany i zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2554">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="9cc50-2555"><paramref name="throwOnError" /> jest <see langword="true" /> i nie można odnaleźć typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2555"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="9cc50-2556">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2556">-or-</span></span> 
 <span data-ttu-id="9cc50-2557"><paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> zawiera nieprawidłowe znaki, takie jak osadzona karta.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2557"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="9cc50-2558">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2558">-or-</span></span> 
 <span data-ttu-id="9cc50-2559"><paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> jest ciągiem pustym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2559"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="9cc50-2560">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2560">-or-</span></span> 
 <span data-ttu-id="9cc50-2561"><paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> reprezentuje typ tablicy z nieprawidłowym rozmiarem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2561"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="9cc50-2562">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2562">-or-</span></span> 
 <span data-ttu-id="9cc50-2563"><paramref name="typeName" /> reprezentuje tablicę <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2563"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-2564"><paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> ma nieprawidłową składnię.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2564"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span></span> <span data-ttu-id="9cc50-2565">Na przykład "MyType [, \*,]".</span><span class="sxs-lookup"><span data-stu-id="9cc50-2565">For example, "MyType[,\*,]".</span></span>  
  
<span data-ttu-id="9cc50-2566">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2566">-or-</span></span> 
 <span data-ttu-id="9cc50-2567"><paramref name="typeName" /> reprezentuje typ ogólny, który jest typem wskaźnika <see langword="ByRef" /> typu, lub <see cref="T:System.Void" /> jako jeden z argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2567"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="9cc50-2568">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2568">-or-</span></span> 
 <span data-ttu-id="9cc50-2569"><paramref name="typeName" /> reprezentuje typ ogólny, który ma niepoprawną liczbę argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2569"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="9cc50-2570">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2570">-or-</span></span> 
 <span data-ttu-id="9cc50-2571"><paramref name="typeName" /> reprezentuje typ ogólny i jeden z argumentów typu nie spełniają ograniczeń dla odpowiedniego parametru typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2571"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="9cc50-2572"><paramref name="throwOnError" /> jest <see langword="true" /> i nie znaleziono zestawu lub jednej z jego zależności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2572"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="9cc50-2573">W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.IO.IOException" />, a zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2573">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="9cc50-2574">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2574">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="9cc50-2575">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2575">The assembly or one of its dependencies is not valid.</span></span>  
  
<span data-ttu-id="9cc50-2576">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2576">-or-</span></span> 
<span data-ttu-id="9cc50-2577">W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana, a zestaw został skompilowany przy użyciu nowszej wersji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2577">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="9cc50-2578">Określanie w pełni kwalifikowanych nazw typów</span><span class="sxs-lookup"><span data-stu-id="9cc50-2578">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="9cc50-2579">Nazwa kwalifikowanego dla zestawu typu można pobrać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2579">The assembly-qualified name of the type to get.</span></span> <span data-ttu-id="9cc50-2580">Zobacz <see cref="P:System.Type.AssemblyQualifiedName" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2580">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span></span> <span data-ttu-id="9cc50-2581">Jeśli typ jest zawierający obecnie wykonywany zestaw lub biblioteki Mscorlib.dll, wystarczy podać nazwę typu kwalifikowana przez jego przestrzeń nazw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2581">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="9cc50-2582"><see langword="true" /> Aby zgłosić wyjątek, jeśli nie można odnaleźć typu; <see langword="false" /> do zwrócenia <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2582"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="9cc50-2583">Określanie <see langword="false" /> powoduje również pominięcie niektórych warunków wyjątków, ale nie wszystkie z nich.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2583">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="9cc50-2584">Zobacz sekcję Wyjątki.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2584">See the Exceptions section.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="9cc50-2585"><see langword="true" /> Aby wykonać wyszukiwanie bez uwzględniania wielkości liter dla <paramref name="typeName" />, <see langword="false" /> przeprowadzić wyszukiwanie dla <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2585"><see langword="true" /> to perform a case-insensitive search for <paramref name="typeName" />, <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="9cc50-2586">Pobiera <see cref="T:System.Type" /> o określonej nazwie, określając czy zgłosić wyjątek, jeśli typ nie zostanie znaleziony i przeprowadzić wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2586">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="9cc50-2587">Typ o określonej nazwie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2587">The type with the specified name.</span></span> <span data-ttu-id="9cc50-2588">Jeśli typ nie zostanie znaleziony, <paramref name="throwOnError" /> parametr określa, czy <see langword="null" /> zwracany jest lub zostanie zgłoszony wyjątek.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2588">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="9cc50-2589">W niektórych przypadkach występuje wyjątek niezależnie od wartości <paramref name="throwOnError" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2589">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="9cc50-2590">Zobacz sekcję Wyjątki.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2590">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-2591">Możesz użyć <xref:System.Type.GetType%2A> metodę, aby uzyskać <xref:System.Type> obiektu dla typu w innym zestawie, jeśli znasz jego nazwę kwalifikowaną dla zestawu, który można uzyskać z <xref:System.Type.AssemblyQualifiedName>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2591">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly if you know its assembly-qualified name, which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="9cc50-2592"><xref:System.Type.GetType%2A> powoduje, że ładowanie zestawu określonego w `typeName`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2592"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="9cc50-2593">Można również załadować zestawu przy użyciu <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metody, a następnie użyj <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> metodę, aby uzyskać <xref:System.Type> obiektów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2593">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method, and then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method to get <xref:System.Type> objects.</span></span> <span data-ttu-id="9cc50-2594">Jeśli typ znajduje się w zestawie znane w czasie kompilacji program, jest bardziej wydajne, aby użyć `typeof` w C# lub `GetType` operatora w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2594">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C# or the `GetType` operator in Visual Basic.</span></span>
  
 <span data-ttu-id="9cc50-2595">`GetType` działa tylko na zestawy, ładowane z dysku.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2595">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="9cc50-2596">Jeśli wywołasz `GetType` do wyszukania w typ zdefiniowany w zestawie dynamicznym zdefiniowane przy użyciu <xref:System.Reflection.Emit> usług, możesz otrzymać niespójne zachowanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2596">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="9cc50-2597">Zachowanie zależy od tego, czy zestaw dynamiczny jest trwała, oznacza to, utworzony za pomocą `RunAndSave` lub `Save` dostępu tryby <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2597">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="9cc50-2598">Jeśli zestaw dynamiczny jest trwały i został zapisany na dysku przed `GetType` jest wywoływana, moduł ładujący wyszukuje zestaw zapisane na dysku, ładuje tego zestawu i pobiera typ z tego zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2598">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="9cc50-2599">Jeśli zestaw nie został zapisany na dysku po `GetType` jest wywoływana metoda zwraca `null`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2599">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="9cc50-2600">`GetType` nie rozpoznaje przejściowy dynamicznych zestawów; Dlatego wywołanie `GetType` można pobrać typu na przejściowy zwraca zestaw dynamiczny `null`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2600">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="9cc50-2601">Aby użyć `GetType` na modułu dynamicznego subskrybować <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> zdarzenia i wywołania `GetType` przed zapisaniem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2601">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="9cc50-2602">W przeciwnym razie otrzymasz dwie kopie zestawu w pamięci.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2602">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="9cc50-2603">`throwOnError` Parametr określa, co się stanie, gdy typ nie zostanie znaleziony i powoduje również pominięcie niektórych warunków wyjątków, zgodnie z opisem w sekcji wyjątki.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2603">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="9cc50-2604">Niektóre wyjątki są zgłaszane niezależnie od wartości `throwOnError`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2604">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="9cc50-2605">Na przykład, jeśli typ zostanie znaleziony, ale nie może zostać załadowany <xref:System.TypeLoadException> jest zgłaszany nawet wtedy, gdy `throwOnError` jest `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2605">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="9cc50-2606">W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy podstawowej są zwracane przez `Get` metody uwzględnianiem typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2606">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="9cc50-2607">Typ elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="9cc50-2607">Member Type</span></span>|<span data-ttu-id="9cc50-2608">Static</span><span class="sxs-lookup"><span data-stu-id="9cc50-2608">Static</span></span>|<span data-ttu-id="9cc50-2609">Niestatyczna</span><span class="sxs-lookup"><span data-stu-id="9cc50-2609">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="9cc50-2610">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="9cc50-2610">Constructor</span></span>|<span data-ttu-id="9cc50-2611">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2611">No</span></span>|<span data-ttu-id="9cc50-2612">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2612">No</span></span>|  
|<span data-ttu-id="9cc50-2613">Pole</span><span class="sxs-lookup"><span data-stu-id="9cc50-2613">Field</span></span>|<span data-ttu-id="9cc50-2614">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2614">No</span></span>|<span data-ttu-id="9cc50-2615">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2615">Yes.</span></span> <span data-ttu-id="9cc50-2616">Pole jest zawsze ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2616">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-2617">Zdarzenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2617">Event</span></span>|<span data-ttu-id="9cc50-2618">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-2618">Not applicable</span></span>|<span data-ttu-id="9cc50-2619">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2619">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-2620">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2620">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-2621">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2621">See note 2 below.</span></span>|  
|<span data-ttu-id="9cc50-2622">Metoda</span><span class="sxs-lookup"><span data-stu-id="9cc50-2622">Method</span></span>|<span data-ttu-id="9cc50-2623">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2623">No</span></span>|<span data-ttu-id="9cc50-2624">Tak.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2624">Yes.</span></span> <span data-ttu-id="9cc50-2625">Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2625">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="9cc50-2626">Typu zagnieżdżony</span><span class="sxs-lookup"><span data-stu-id="9cc50-2626">Nested Type</span></span>|<span data-ttu-id="9cc50-2627">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2627">No</span></span>|<span data-ttu-id="9cc50-2628">Nie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2628">No</span></span>|  
|<span data-ttu-id="9cc50-2629">Właściwość</span><span class="sxs-lookup"><span data-stu-id="9cc50-2629">Property</span></span>|<span data-ttu-id="9cc50-2630">Nie dotyczy</span><span class="sxs-lookup"><span data-stu-id="9cc50-2630">Not applicable</span></span>|<span data-ttu-id="9cc50-2631">Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2631">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="9cc50-2632">Odbicie traktuje właściwości jako ukryte przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2632">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-2633">Patrz Uwaga 2 poniżej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2633">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="9cc50-2634">Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2634">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="9cc50-2635">To jest porównanie binarne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2635">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="9cc50-2636">W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2636">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="9cc50-2637">Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2637">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="9cc50-2638">Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2638">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="9cc50-2639">Tablic lub typów modelu COM nie są wyszukiwane chyba, że już zostały załadowane do tabeli dostępnych klas.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2639">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="9cc50-2640">`typeName` może być nazwa typu kwalifikowana przez jego przestrzeń nazw lub kwalifikowaną dla zestawu, która zawiera nazwę specyfikacja nazwy zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2640">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="9cc50-2641">Zobacz <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2641">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="9cc50-2642">Jeśli `typeName` obejmuje przestrzeń nazw, ale nie nazwę zestawu, Metoda ta wyszukuje tylko do obiektu wywołującego zestawu i Mscorlib.dll, w tej kolejności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2642">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="9cc50-2643">Jeśli typeName jest w pełni kwalifikowaną nazwą zestawu częściowego lub pełny, Metoda ta wyszukuje w określonym zestawie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2643">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="9cc50-2644">Jeśli zestaw ma silną nazwą, wymagana jest nazwa kompletny zestaw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2644">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="9cc50-2645"><xref:System.Type.AssemblyQualifiedName%2A> Właściwość zwraca w pełni kwalifikowaną nazwę typu w tym typów zagnieżdżonych, nazwa zestawu i argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2645">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and type arguments.</span></span> <span data-ttu-id="9cc50-2646">Wszystkie kompilatory, które obsługują aparat plików wykonywalnych języka wspólnego, w trakcie wykonania wyemitują prostą nazwę klasy zagnieżdżonej, a odbicie podczas kwerendy stworzy zniekształcone nazwy zgodnie z następującymi konwencjami.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2646">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-2647">W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2647">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="9cc50-2648">Na przykład "ProcessorArchitecture = msil".</span><span class="sxs-lookup"><span data-stu-id="9cc50-2648">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="9cc50-2649">Jednak nie są uwzględnione w ciągu zwracanego przez <xref:System.Type.AssemblyQualifiedName%2A> właściwość ze względu na zgodność.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2649">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="9cc50-2650">Można również załadować typów, tworząc <xref:System.Reflection.AssemblyName> obiektu i przekazywania go do odpowiedniego przeciążenia <xref:System.Reflection.Assembly.Load%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2650">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="9cc50-2651">Następnie można użyć <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> metodę, aby załadować typów z zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2651">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="9cc50-2652">Zobacz też <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2652">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="9cc50-2653">Ogranicznik</span><span class="sxs-lookup"><span data-stu-id="9cc50-2653">Delimiter</span></span>|<span data-ttu-id="9cc50-2654">Znaczenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2654">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="9cc50-2655">Ukośnik odwrotny (\\)</span><span class="sxs-lookup"><span data-stu-id="9cc50-2655">Backslash (\\)</span></span>|<span data-ttu-id="9cc50-2656">Znak ucieczki.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2656">Escape character.</span></span>|  
|<span data-ttu-id="9cc50-2657">Początkowych (') | Poprzedza co najmniej jedną cyfrę reprezentującą liczbę parametrów typu, znajduje się na końcu nazwy typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2657">Backtick (\`)|Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="9cc50-2658">Nawiasy kwadratowe ([])</span><span class="sxs-lookup"><span data-stu-id="9cc50-2658">Brackets ([])</span></span>|<span data-ttu-id="9cc50-2659">Ujmij listy argumentów typu rodzajowego, aby uzyskać skonstruowany typ rodzajowy; na liście argumentów typu należy ująć typu kwalifikowanego zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2659">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="9cc50-2660">Przecinek (,)</span><span class="sxs-lookup"><span data-stu-id="9cc50-2660">Comma (,)</span></span>|<span data-ttu-id="9cc50-2661">Poprzedza nazwę zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2661">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="9cc50-2662">Kropka (.)</span><span class="sxs-lookup"><span data-stu-id="9cc50-2662">Period (.)</span></span>|<span data-ttu-id="9cc50-2663">Wskazuje przestrzeń nazw identyfikatorów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2663">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="9cc50-2664">Znak plus (+)</span><span class="sxs-lookup"><span data-stu-id="9cc50-2664">Plus sign (+)</span></span>|<span data-ttu-id="9cc50-2665">Poprzedza klasę zagnieżdżoną.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2665">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="9cc50-2666">Na przykład w pełni kwalifikowana nazwa klasy może wyglądać następująco:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2666">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="9cc50-2667">Jeśli przestrzeń nazw zostały TopNamespace.Sub+Namespace, a następnie ciąg musi poprzedzać znak plus (+) przy użyciu znaku ucieczki (\\), aby zapobiec interpretacji jako separator zagnieżdżenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2667">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="9cc50-2668">Odbicie emituje tego ciągu w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2668">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="9cc50-2669">A "++" staje się "\\+\\+", a "\\"staje się"\\\\".</span><span class="sxs-lookup"><span data-stu-id="9cc50-2669">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="9cc50-2670">Ta nazwa kwalifikowana może utrwalona i później używana do ładowania <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2670">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="9cc50-2671">Aby wyszukać i załadować <xref:System.Type>, użyj <xref:System.Type.GetType%2A> albo z typem nazwy tylko lub nazwą kwalifikowaną typu zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2671">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="9cc50-2672"><xref:System.Type.GetType%2A> z typem nazwy tylko będzie szukać <xref:System.Type> w zestawie wywołującego, a następnie w zestawie systemowym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2672"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="9cc50-2673"><xref:System.Type.GetType%2A> z zestawem kwalifikowanej nazwy typu będzie szukać <xref:System.Type> w każdym zestawie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2673"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="9cc50-2674">Nazwy typów mogą obejmować końcowe znaki, które wyznaczają dodatkowe informacje dotyczące typu, na przykład to, czy typ jest typem odwołania, typem wskaźnika lub typem tablicowym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2674">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="9cc50-2675">Aby pobrać, wpisz nazwę bez tych znaków końcowych, należy użyć `t.GetElementType().ToString()`, gdzie `t` jest typem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2675">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="9cc50-2676">Spacje są istotne we wszystkich składnikach nazwy z wyjątkiem nazwy zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2676">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="9cc50-2677">Spacje przed separatorem w nazwie zestawu ',' są istotne, ale spacje po separatorze ',' są ignorowane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2677">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="9cc50-2678">Nazwa typu ogólnego kończy się ciągiem początkowych (\`) następują cyfry reprezentujący liczbę wszystkich argumentów typu rodzajowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2678">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="9cc50-2679">Celem tego przekręcaniu nazwy jest umożliwienie kompilatory do obsługi typów ogólnych o takiej samej nazwie, ale z różną liczbę parametrów typu, w tym samym zakresie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2679">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="9cc50-2680">Na przykład odbicia zwraca zniekształcone nazwy `Tuple`1` and `krotki`2` z metod ogólnych `Tuple(Of T)` i `Tuple(Of T0, T1)` w języku Visual Basic lub `Tuple<T>` i krotki`\<T0, T1>` w języku Visual C#.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2680">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="9cc50-2681">Dla typów ogólnych lista argumentów typu jest ujęty w nawiasy i argumenty typu są oddzielone przecinkami.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2681">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="9cc50-2682">Na przykład ogólny <xref:System.Collections.Generic.Dictionary%602> ma dwa parametry typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2682">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="9cc50-2683">A <xref:System.Collections.Generic.Dictionary%602> z `MyType` przy użyciu kluczy typu <xref:System.String> może być reprezentowany w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2683">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="9cc50-2684">Aby określić typu kwalifikowanego zestawu w obrębie listy argumentów typu, należy ująć typu kwalifikowanego zestawu w nawiasy kwadratowe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2684">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="9cc50-2685">W przeciwnym razie przecinki oddzielające części nazwy kwalifikowanej zestawu są interpretowane jako rozdzielający argumentów typu dodatkowe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2685">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="9cc50-2686">Na przykład <xref:System.Collections.Generic.Dictionary%602> z `MyType` z MyAssembly.dll przy użyciu kluczy typu <xref:System.String>, może być następujący:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2686">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-2687">Typu kwalifikowanego zestawu mogą być ujęte w nawiasy kwadratowe, tylko wtedy, gdy pojawia się on w obrębie lista parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2687">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="9cc50-2688">Reguły dotyczące wyszukiwania zestawów dla typów kwalifikowana i niekwalifikowanej w liście parametrów typu są takie same jak reguły dla typów nierodzajowymi kwalifikowana i niekwalifikowane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2688">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="9cc50-2689">Typy dopuszczające wartości zerowe są w wyjątkowym przypadku okna typów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2689">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="9cc50-2690">Na przykład dopuszczający wartości null <xref:System.Int32> jest reprezentowany przez ciąg "System.Nullable'1[System.Int32]".</span><span class="sxs-lookup"><span data-stu-id="9cc50-2690">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-2691">W języku C#, C++ i Visual Basic można również uzyskać przy użyciu operatorów typu typy dopuszczające wartości null.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2691">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="9cc50-2692">Na przykład nullable <xref:System.Boolean> typ zwracany przez `typeof(Nullable<bool>)` w języku C#, `Nullable<Boolean>::typeid` w języku C++ i przez `GetType(Nullable(Of Boolean))` w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2692">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="9cc50-2693">W poniższej tabeli przedstawiono składnię, możesz za pomocą `GetType` dla różnych typów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2693">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="9cc50-2694">Aby uzyskać</span><span class="sxs-lookup"><span data-stu-id="9cc50-2694">To Get</span></span>|<span data-ttu-id="9cc50-2695">Zastosowanie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2695">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="9cc50-2696">Dopuszczający wartości null <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="9cc50-2696">A nullable <xref:System.Int32></span></span>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|<span data-ttu-id="9cc50-2697">Niezarządzany wskaźnik do `MyType`</span><span class="sxs-lookup"><span data-stu-id="9cc50-2697">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="9cc50-2698">Niezarządzany wskaźnik do wskaźnika do `MyType`</span><span class="sxs-lookup"><span data-stu-id="9cc50-2698">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="9cc50-2699">Zarządzane wskaźnik lub odwołanie do `MyType`</span><span class="sxs-lookup"><span data-stu-id="9cc50-2699">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="9cc50-2700">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2700">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="9cc50-2701">Należy pamiętać, że w przeciwieństwie do wskaźników, odwołań są ograniczone do jednego poziomu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2701">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="9cc50-2702">Klasy nadrzędnej i zagnieżdżone klasy</span><span class="sxs-lookup"><span data-stu-id="9cc50-2702">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="9cc50-2703">Jednowymiarowa tablica dolną granicę równą 0</span><span class="sxs-lookup"><span data-stu-id="9cc50-2703">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="9cc50-2704">Jednowymiarowa tablica o nieznanych dolna granica</span><span class="sxs-lookup"><span data-stu-id="9cc50-2704">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="9cc50-2705">N wymiarową tablicą</span><span class="sxs-lookup"><span data-stu-id="9cc50-2705">An n-dimensional array</span></span>|<span data-ttu-id="9cc50-2706">Przecinek (,) znajduje się wewnątrz nawiasów w sumie n-1 razy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2706">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="9cc50-2707">Na przykład `System.Object[,,]` reprezentuje trójwymiarowym `Object` tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2707">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="9cc50-2708">Tablicy dwuwymiarowej tablicy</span><span class="sxs-lookup"><span data-stu-id="9cc50-2708">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="9cc50-2709">Prostokątnej dwuwymiarowej tablicy przy użyciu nieznanego dolne granice</span><span class="sxs-lookup"><span data-stu-id="9cc50-2709">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="9cc50-2710">Typ ogólny z jednego typu argumentu</span><span class="sxs-lookup"><span data-stu-id="9cc50-2710">A generic type with one type argument</span></span>|``Type.GetType("MyGenericType`1[MyType]")``|  
|<span data-ttu-id="9cc50-2711">Typ ogólny z dwoma argumentami typu</span><span class="sxs-lookup"><span data-stu-id="9cc50-2711">A generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|<span data-ttu-id="9cc50-2712">Typ ogólny z dwóch argumentów typu kwalifikowanego zestawu</span><span class="sxs-lookup"><span data-stu-id="9cc50-2712">A generic type with two assembly-qualified type arguments</span></span>|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|<span data-ttu-id="9cc50-2713">Kwalifikowanych dla zestawu typu ogólnego z nieprawidłowym argumentem typu kwalifikowanego zestawu</span><span class="sxs-lookup"><span data-stu-id="9cc50-2713">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|<span data-ttu-id="9cc50-2714">Typ ogólny, którego argument typu jest typ ogólny z dwoma argumentami typu</span><span class="sxs-lookup"><span data-stu-id="9cc50-2714">A generic type whose type argument is a generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-2715"><paramref name="typeName" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2715"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="9cc50-2716">Inicjator klasy jest wywoływany i zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2716">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="9cc50-2717"><paramref name="throwOnError" /> jest <see langword="true" /> i nie można odnaleźć typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2717"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="9cc50-2718">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2718">-or-</span></span> 
 <span data-ttu-id="9cc50-2719"><paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> zawiera nieprawidłowe znaki, takie jak osadzona karta.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2719"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="9cc50-2720">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2720">-or-</span></span> 
 <span data-ttu-id="9cc50-2721"><paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> jest ciągiem pustym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2721"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="9cc50-2722">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2722">-or-</span></span> 
 <span data-ttu-id="9cc50-2723"><paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> reprezentuje typ tablicy z nieprawidłowym rozmiarem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2723"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="9cc50-2724">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2724">-or-</span></span> 
 <span data-ttu-id="9cc50-2725"><paramref name="typeName" /> reprezentuje tablicę <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2725"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-2726"><paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> ma nieprawidłową składnię.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2726"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span></span> <span data-ttu-id="9cc50-2727">Na przykład "MyType [, \*,]".</span><span class="sxs-lookup"><span data-stu-id="9cc50-2727">For example, "MyType[,\*,]".</span></span>  
  
<span data-ttu-id="9cc50-2728">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2728">-or-</span></span> 
 <span data-ttu-id="9cc50-2729"><paramref name="typeName" /> reprezentuje typ ogólny, który jest typem wskaźnika <see langword="ByRef" /> typu, lub <see cref="T:System.Void" /> jako jeden z argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2729"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="9cc50-2730">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2730">-or-</span></span> 
 <span data-ttu-id="9cc50-2731"><paramref name="typeName" /> reprezentuje typ ogólny, który ma niepoprawną liczbę argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2731"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="9cc50-2732">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2732">-or-</span></span> 
 <span data-ttu-id="9cc50-2733"><paramref name="typeName" /> reprezentuje typ ogólny i jeden z argumentów typu nie spełniają ograniczeń dla odpowiedniego parametru typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2733"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="9cc50-2734"><paramref name="throwOnError" /> jest <see langword="true" /> i nie znaleziono zestawu lub jednej z jego zależności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2734"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="9cc50-2735">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2735">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="9cc50-2736">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2736">The assembly or one of its dependencies is not valid.</span></span>  
  
<span data-ttu-id="9cc50-2737">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2737">-or-</span></span> 
<span data-ttu-id="9cc50-2738">W wersji 2.0 lub nowsza aparatu plików wykonywalnych języka jest aktualnie załadowana, a zestaw został skompilowany przy użyciu nowszej wersji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2738">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="9cc50-2739">Określanie w pełni kwalifikowanych nazw typów</span><span class="sxs-lookup"><span data-stu-id="9cc50-2739">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="9cc50-2740">Nazwa typu, który można pobrać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2740">The name of the type to get.</span></span> <span data-ttu-id="9cc50-2741">Jeśli <paramref name="typeResolver" /> parametr zostanie podany, nazwa typu może być dowolny ciąg, który <paramref name="typeResolver" /> jest w stanie rozwiązywania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2741">If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving.</span></span> <span data-ttu-id="9cc50-2742">Jeśli <paramref name="assemblyResolver" /> parametr ma pod warunkiem, lub jeśli rozpoznawania typu Standardowy jest używany, <paramref name="typeName" /> musi być kwalifikowana nazwa zestawu (zobacz <see cref="P:System.Type.AssemblyQualifiedName" />), chyba że typ jest zawierający obecnie wykonywany zestaw lub biblioteki Mscorlib.dll, w którym to przypadku wystarczy Podaj nazwę typu kwalifikowana przez jego przestrzeń nazw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2742">If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="assemblyResolver"><span data-ttu-id="9cc50-2743">Metoda, która lokalizuje i zwraca zestaw, który jest określony w <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2743">A method that locates and returns the assembly that is specified in <paramref name="typeName" />.</span></span> <span data-ttu-id="9cc50-2744">Nazwa zestawu jest przekazywany do <paramref name="assemblyResolver" /> jako <see cref="T:System.Reflection.AssemblyName" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2744">The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span> <span data-ttu-id="9cc50-2745">Jeśli <paramref name="typeName" /> nie zawiera nazwy zestawu, <paramref name="assemblyResolver" /> nie zostanie wywołana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2745">If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called.</span></span> <span data-ttu-id="9cc50-2746">Jeśli <paramref name="assemblyResolver" /> nie jest podany, standardowego zestawu rozpoznawanie odbywa się.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2746">If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed.</span></span>  
  
<span data-ttu-id="9cc50-2747">Uwaga nie przechodzą z nieznanych lub niezaufanych wywołujących.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2747">Caution   Do not pass methods from unknown or untrusted callers.</span></span> <span data-ttu-id="9cc50-2748">Ten sposób może spowodować podniesienie uprawnień dla złośliwego kodu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2748">Doing so could result in elevation of privilege for malicious code.</span></span> <span data-ttu-id="9cc50-2749">Użyj tylko określonych przez siebie metod lub tych, które znasz.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2749">Use only methods that you provide or that you are familiar with.</span></span></param>
        <param name="typeResolver"><span data-ttu-id="9cc50-2750">Metody, która lokalizuje i zwraca typ, który jest określony przez <paramref name="typeName" /> z zestawu, który jest zwracany przez <paramref name="assemblyResolver" /> lub rozpoznawania zestawu standardowych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2750">A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution.</span></span> <span data-ttu-id="9cc50-2751">Jeśli nie podano żadnego zestawu, <paramref name="typeResolver" /> metoda może dostarczyć jeden.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2751">If no assembly is provided, the <paramref name="typeResolver" /> method can provide one.</span></span> <span data-ttu-id="9cc50-2752">Ta metoda również przyjmuje parametr, który określa, czy należy wykonać wyszukiwanie bez uwzględniania wielkości liter; <see langword="false" /> jest przekazywany do tego parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2752">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span></span>  
  
<span data-ttu-id="9cc50-2753">Uwaga nie przechodzą z nieznanych lub niezaufanych wywołujących.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2753">Caution   Do not pass methods from unknown or untrusted callers.</span></span></param>
        <summary><span data-ttu-id="9cc50-2754">Pobiera typ o określonej nazwie, opcjonalnie podania niestandardowych metod można rozpoznać zestawu i typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2754">Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</span></span></summary>
        <returns><span data-ttu-id="9cc50-2755">Typ o określonej nazwie lub <see langword="null" /> Jeśli typ nie zostanie znaleziony.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2755">The type with the specified name, or <see langword="null" /> if the type is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-2756">Scenariusze użycia dotyczące tę metodę i szczegółowe informacje o `assemblyResolver` i `typeResolver` parametrów można znaleźć w <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2756">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-2757">Jeśli `typeName` nie można znaleźć, wywołanie <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> metoda zwraca `null`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2757">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> method returns `null`.</span></span> <span data-ttu-id="9cc50-2758">Nie zostanie zgłoszony wyjątek.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2758">It does not throw an exception.</span></span> <span data-ttu-id="9cc50-2759">Do kontrolowania tego, czy wyjątek jest generowany, wywołania przeciążenia <xref:System.Type.GetType%2A> metody, która ma `throwOnError` parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2759">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="9cc50-2760">Wywołanie tego przeciążenia metody jest taka sama jak wywołanie <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenie metody i określając `false` dla `throwOnError` i `ignoreCase` parametrów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2760">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `throwOnError` and `ignoreCase` parameters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-2761"><paramref name="typeName" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2761"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="9cc50-2762">Inicjator klasy jest wywoływany i zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2762">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-2763">Błąd występuje, gdy <paramref name="typeName" /> jest przekształcany do nazwy typu i nazwy zestawu (na przykład, gdy nazwa typu prostego zawiera specjalne znaku o niezmienionym znaczeniu).</span><span class="sxs-lookup"><span data-stu-id="9cc50-2763">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span></span>  
  
<span data-ttu-id="9cc50-2764">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2764">-or-</span></span> 
 <span data-ttu-id="9cc50-2765"><paramref name="typeName" /> reprezentuje typ ogólny, który jest typem wskaźnika <see langword="ByRef" /> typu, lub <see cref="T:System.Void" /> jako jeden z argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2765"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="9cc50-2766">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2766">-or-</span></span> 
 <span data-ttu-id="9cc50-2767"><paramref name="typeName" /> reprezentuje typ ogólny, który ma niepoprawną liczbę argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2767"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="9cc50-2768">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2768">-or-</span></span> 
 <span data-ttu-id="9cc50-2769"><paramref name="typeName" /> reprezentuje typ ogólny i jeden z argumentów typu nie spełniają ograniczeń dla odpowiedniego parametru typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2769"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="9cc50-2770"><paramref name="typeName" /> reprezentuje tablicę <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2770"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="9cc50-2771">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2771">The assembly or one of its dependencies was found, but could not be loaded.</span></span>  
  
<span data-ttu-id="9cc50-2772">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2772">-or-</span></span> 
 <span data-ttu-id="9cc50-2773"><paramref name="typeName" /> zawiera nieprawidłową nazwę zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2773"><paramref name="typeName" /> contains an invalid assembly name.</span></span>  
  
<span data-ttu-id="9cc50-2774">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2774">-or-</span></span> 
 <span data-ttu-id="9cc50-2775"><paramref name="typeName" /> jest nazwą prawidłowego zestawu bez nazwy typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2775"><paramref name="typeName" /> is a valid assembly name without a type name.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="9cc50-2776">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2776">The assembly or one of its dependencies is not valid.</span></span>  
  
<span data-ttu-id="9cc50-2777">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2777">-or-</span></span> 
<span data-ttu-id="9cc50-2778">Zestaw został skompilowany przy użyciu nowszej wersji aparatu plików wykonywalnych języka wspólnego niż wersja, która jest aktualnie załadowana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2778">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="9cc50-2779">Nazwa typu, który można pobrać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2779">The name of the type to get.</span></span> <span data-ttu-id="9cc50-2780">Jeśli <paramref name="typeResolver" /> parametr zostanie podany, nazwa typu może być dowolny ciąg, który <paramref name="typeResolver" /> jest w stanie rozwiązywania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2780">If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving.</span></span> <span data-ttu-id="9cc50-2781">Jeśli <paramref name="assemblyResolver" /> parametr ma pod warunkiem, lub jeśli rozpoznawania typu Standardowy jest używany, <paramref name="typeName" /> musi być kwalifikowana nazwa zestawu (zobacz <see cref="P:System.Type.AssemblyQualifiedName" />), chyba że typ jest zawierający obecnie wykonywany zestaw lub biblioteki Mscorlib.dll, w którym to przypadku wystarczy Podaj nazwę typu kwalifikowana przez jego przestrzeń nazw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2781">If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="assemblyResolver"><span data-ttu-id="9cc50-2782">Metoda, która lokalizuje i zwraca zestaw, który jest określony w <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2782">A method that locates and returns the assembly that is specified in <paramref name="typeName" />.</span></span> <span data-ttu-id="9cc50-2783">Nazwa zestawu jest przekazywany do <paramref name="assemblyResolver" /> jako <see cref="T:System.Reflection.AssemblyName" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2783">The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span> <span data-ttu-id="9cc50-2784">Jeśli <paramref name="typeName" /> nie zawiera nazwy zestawu, <paramref name="assemblyResolver" /> nie zostanie wywołana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2784">If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called.</span></span> <span data-ttu-id="9cc50-2785">Jeśli <paramref name="assemblyResolver" /> nie jest podany, standardowego zestawu rozpoznawanie odbywa się.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2785">If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed.</span></span>  
  
<span data-ttu-id="9cc50-2786">Uwaga nie przechodzą z nieznanych lub niezaufanych wywołujących.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2786">Caution   Do not pass methods from unknown or untrusted callers.</span></span> <span data-ttu-id="9cc50-2787">Ten sposób może spowodować podniesienie uprawnień dla złośliwego kodu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2787">Doing so could result in elevation of privilege for malicious code.</span></span> <span data-ttu-id="9cc50-2788">Użyj tylko określonych przez siebie metod lub tych, które znasz.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2788">Use only methods that you provide or that you are familiar with.</span></span></param>
        <param name="typeResolver"><span data-ttu-id="9cc50-2789">Metody, która lokalizuje i zwraca typ, który jest określony przez <paramref name="typeName" /> z zestawu, który jest zwracany przez <paramref name="assemblyResolver" /> lub rozpoznawania zestawu standardowych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2789">A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution.</span></span> <span data-ttu-id="9cc50-2790">Jeśli nie podano żadnego zestawu, metoda może dostarczyć jeden.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2790">If no assembly is provided, the method can provide one.</span></span> <span data-ttu-id="9cc50-2791">Ta metoda również przyjmuje parametr, który określa, czy należy wykonać wyszukiwanie bez uwzględniania wielkości liter; <see langword="false" /> jest przekazywany do tego parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2791">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span></span>  
  
<span data-ttu-id="9cc50-2792">Uwaga nie przechodzą z nieznanych lub niezaufanych wywołujących.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2792">Caution   Do not pass methods from unknown or untrusted callers.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="9cc50-2793"><see langword="true" /> Aby zgłosić wyjątek, jeśli nie można odnaleźć typu; <see langword="false" /> do zwrócenia <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2793"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="9cc50-2794">Określanie <see langword="false" /> powoduje również pominięcie niektórych warunków wyjątków, ale nie wszystkie z nich.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2794">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="9cc50-2795">Zobacz sekcję Wyjątki.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2795">See the Exceptions section.</span></span></param>
        <summary><span data-ttu-id="9cc50-2796">Pobiera typ o określonej nazwie, określająca, czy zgłosić wyjątek, jeśli typ nie zostanie znaleziony i opcjonalnie podania niestandardowych metod można rozpoznać zestawu i typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2796">Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span></span></summary>
        <returns><span data-ttu-id="9cc50-2797">Typ o określonej nazwie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2797">The type with the specified name.</span></span> <span data-ttu-id="9cc50-2798">Jeśli typ nie zostanie znaleziony, <paramref name="throwOnError" /> parametr określa, czy <see langword="null" /> zwracany jest lub zostanie zgłoszony wyjątek.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2798">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="9cc50-2799">W niektórych przypadkach występuje wyjątek niezależnie od wartości <paramref name="throwOnError" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2799">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="9cc50-2800">Zobacz sekcję Wyjątki.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2800">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-2801">Scenariusze użycia dotyczące tę metodę i szczegółowe informacje o `assemblyResolver` i `typeResolver` parametrów można znaleźć w <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2801">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="9cc50-2802">Wywołanie tego przeciążenia metody jest taka sama jak wywołanie <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenie metody i określając `false` dla `ignoreCase` parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2802">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `ignoreCase` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-2803"><paramref name="typeName" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2803"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="9cc50-2804">Inicjator klasy jest wywoływany i zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2804">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="9cc50-2805"><paramref name="throwOnError" /> jest <see langword="true" /> i nie można odnaleźć typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2805"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="9cc50-2806">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2806">-or-</span></span> 
 <span data-ttu-id="9cc50-2807"><paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> zawiera nieprawidłowe znaki, takie jak osadzona karta.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2807"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="9cc50-2808">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2808">-or-</span></span> 
 <span data-ttu-id="9cc50-2809"><paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> jest ciągiem pustym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2809"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="9cc50-2810">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2810">-or-</span></span> 
 <span data-ttu-id="9cc50-2811"><paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> reprezentuje typ tablicy z nieprawidłowym rozmiarem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2811"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="9cc50-2812">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2812">-or-</span></span> 
 <span data-ttu-id="9cc50-2813"><paramref name="typeName" /> reprezentuje tablicę <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2813"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-2814">Błąd występuje, gdy <paramref name="typeName" /> jest przekształcany do nazwy typu i nazwy zestawu (na przykład, gdy nazwa typu prostego zawiera specjalne znaku o niezmienionym znaczeniu).</span><span class="sxs-lookup"><span data-stu-id="9cc50-2814">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span></span>  
  
<span data-ttu-id="9cc50-2815">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2815">-or-</span></span> 
 <span data-ttu-id="9cc50-2816"><paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> ma nieprawidłową składnię "(na przykład MyType[,\*,]").</span><span class="sxs-lookup"><span data-stu-id="9cc50-2816"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span></span>  
  
<span data-ttu-id="9cc50-2817">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2817">-or-</span></span> 
 <span data-ttu-id="9cc50-2818"><paramref name="typeName" /> reprezentuje typ ogólny, który jest typem wskaźnika <see langword="ByRef" /> typu, lub <see cref="T:System.Void" /> jako jeden z argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2818"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="9cc50-2819">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2819">-or-</span></span> 
 <span data-ttu-id="9cc50-2820"><paramref name="typeName" /> reprezentuje typ ogólny, który ma niepoprawną liczbę argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2820"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="9cc50-2821">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2821">-or-</span></span> 
 <span data-ttu-id="9cc50-2822"><paramref name="typeName" /> reprezentuje typ ogólny i jeden z argumentów typu nie spełniają ograniczeń dla odpowiedniego parametru typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2822"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="9cc50-2823"><paramref name="throwOnError" /> jest <see langword="true" /> i nie znaleziono zestawu lub jednej z jego zależności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2823"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span>  
  
<span data-ttu-id="9cc50-2824">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2824">-or-</span></span> 
 <span data-ttu-id="9cc50-2825"><paramref name="typeName" /> zawiera nieprawidłową nazwę zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2825"><paramref name="typeName" /> contains an invalid assembly name.</span></span>  
  
<span data-ttu-id="9cc50-2826">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2826">-or-</span></span> 
 <span data-ttu-id="9cc50-2827"><paramref name="typeName" /> jest nazwą prawidłowego zestawu bez nazwy typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2827"><paramref name="typeName" /> is a valid assembly name without a type name.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="9cc50-2828">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2828">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="9cc50-2829">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2829">The assembly or one of its dependencies is not valid.</span></span>  
  
<span data-ttu-id="9cc50-2830">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2830">-or-</span></span> 
<span data-ttu-id="9cc50-2831">Zestaw został skompilowany przy użyciu nowszej wersji aparatu plików wykonywalnych języka wspólnego niż wersja, która jest aktualnie załadowana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2831">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="9cc50-2832">Nazwa typu, który można pobrać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2832">The name of the type to get.</span></span> <span data-ttu-id="9cc50-2833">Jeśli <paramref name="typeResolver" /> parametr zostanie podany, nazwa typu może być dowolny ciąg, który <paramref name="typeResolver" /> jest w stanie rozwiązywania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2833">If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving.</span></span> <span data-ttu-id="9cc50-2834">Jeśli <paramref name="assemblyResolver" /> parametr ma pod warunkiem, lub jeśli rozpoznawania typu Standardowy jest używany, <paramref name="typeName" /> musi być kwalifikowana nazwa zestawu (zobacz <see cref="P:System.Type.AssemblyQualifiedName" />), chyba że typ jest zawierający obecnie wykonywany zestaw lub biblioteki Mscorlib.dll, w którym to przypadku wystarczy Podaj nazwę typu kwalifikowana przez jego przestrzeń nazw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2834">If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="assemblyResolver"><span data-ttu-id="9cc50-2835">Metoda, która lokalizuje i zwraca zestaw, który jest określony w <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2835">A method that locates and returns the assembly that is specified in <paramref name="typeName" />.</span></span> <span data-ttu-id="9cc50-2836">Nazwa zestawu jest przekazywany do <paramref name="assemblyResolver" /> jako <see cref="T:System.Reflection.AssemblyName" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2836">The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span> <span data-ttu-id="9cc50-2837">Jeśli <paramref name="typeName" /> nie zawiera nazwy zestawu, <paramref name="assemblyResolver" /> nie zostanie wywołana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2837">If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called.</span></span> <span data-ttu-id="9cc50-2838">Jeśli <paramref name="assemblyResolver" /> nie jest podany, standardowego zestawu rozpoznawanie odbywa się.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2838">If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed.</span></span>  
  
<span data-ttu-id="9cc50-2839">Uwaga nie przechodzą z nieznanych lub niezaufanych wywołujących.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2839">Caution   Do not pass methods from unknown or untrusted callers.</span></span> <span data-ttu-id="9cc50-2840">Ten sposób może spowodować podniesienie uprawnień dla złośliwego kodu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2840">Doing so could result in elevation of privilege for malicious code.</span></span> <span data-ttu-id="9cc50-2841">Użyj tylko określonych przez siebie metod lub tych, które znasz.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2841">Use only methods that you provide or that you are familiar with.</span></span></param>
        <param name="typeResolver"><span data-ttu-id="9cc50-2842">Metody, która lokalizuje i zwraca typ, który jest określony przez <paramref name="typeName" /> z zestawu, który jest zwracany przez <paramref name="assemblyResolver" /> lub rozpoznawania zestawu standardowych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2842">A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution.</span></span> <span data-ttu-id="9cc50-2843">Jeśli nie podano żadnego zestawu, metoda może dostarczyć jeden.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2843">If no assembly is provided, the method can provide one.</span></span> <span data-ttu-id="9cc50-2844">Ta metoda również przyjmuje parametr, który określa, czy należy wykonać wyszukiwanie bez uwzględniania wielkości liter; wartość <paramref name="ignoreCase" /> jest przekazywany do tego parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2844">The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <paramref name="ignoreCase" /> is passed to that parameter.</span></span>  
  
<span data-ttu-id="9cc50-2845">Uwaga nie przechodzą z nieznanych lub niezaufanych wywołujących.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2845">Caution   Do not pass methods from unknown or untrusted callers.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="9cc50-2846"><see langword="true" /> Aby zgłosić wyjątek, jeśli nie można odnaleźć typu; <see langword="false" /> do zwrócenia <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2846"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="9cc50-2847">Określanie <see langword="false" /> powoduje również pominięcie niektórych warunków wyjątków, ale nie wszystkie z nich.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2847">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="9cc50-2848">Zobacz sekcję Wyjątki.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2848">See the Exceptions section.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="9cc50-2849"><see langword="true" /> Aby wykonać wyszukiwanie bez uwzględniania wielkości liter dla <paramref name="typeName" />, <see langword="false" /> przeprowadzić wyszukiwanie dla <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2849"><see langword="true" /> to perform a case-insensitive search for <paramref name="typeName" />, <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="9cc50-2850">Pobiera typ o określonej nazwie, określania, czy przeprowadzić wyszukiwanie i czy chcesz zgłosić wyjątek, jeśli typ nie zostanie znaleziony i opcjonalnie podania niestandardowych metod można rozpoznać zestawu i typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2850">Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span></span></summary>
        <returns><span data-ttu-id="9cc50-2851">Typ o określonej nazwie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2851">The type with the specified name.</span></span> <span data-ttu-id="9cc50-2852">Jeśli typ nie zostanie znaleziony, <paramref name="throwOnError" /> parametr określa, czy <see langword="null" /> zwracany jest lub zostanie zgłoszony wyjątek.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2852">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="9cc50-2853">W niektórych przypadkach występuje wyjątek niezależnie od wartości <paramref name="throwOnError" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2853">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="9cc50-2854">Zobacz sekcję Wyjątki.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2854">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-2855">Użyj tego przeciążenia metody i jego skojarzone przeciążenia (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> i <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) zastąpić domyślną implementację elementu <xref:System.Type.GetType%2A> metody z implementacjami bardziej elastyczne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2855">Use this method overload and its associated overloads (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> and <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) to replace the default implementation of the <xref:System.Type.GetType%2A> method with more flexible implementations.</span></span> <span data-ttu-id="9cc50-2856">Podając własne metody, które rozpoznać nazwy typu i nazwy zestawów, zawierające je, możesz wykonać następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2856">By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:</span></span>  
  
-   <span data-ttu-id="9cc50-2857">Kontroli wersji typu jest ładowany z zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2857">Control which version of an assembly a type is loaded from.</span></span>  
  
-   <span data-ttu-id="9cc50-2858">Podaj inne miejsce do wyszukania nazwy typu, który nie zawiera nazwy zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2858">Provide another place to look for a type name that does not include an assembly name.</span></span>  
  
-   <span data-ttu-id="9cc50-2859">Ładowanie zestawów przy użyciu nazwy zestawów częściowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2859">Load assemblies using partial assembly names.</span></span>  
  
-   <span data-ttu-id="9cc50-2860">Zwróć podklasy <xref:System.Type?displayProperty=nameWithType> nie są tworzone przez środowisko uruchomieniowe języka wspólnego (CLR).</span><span class="sxs-lookup"><span data-stu-id="9cc50-2860">Return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the common language runtime (CLR).</span></span>  
  
 <span data-ttu-id="9cc50-2861">Na przykład serializacji z tolerancją dla wersji ta metoda umożliwia wyszukiwanie dla zestawu "o najlepszej zgodności" przy użyciu nazwy częściowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2861">For example, in version-tolerant serialization this method enables you to search for a "best fit" assembly by using a partial name.</span></span> <span data-ttu-id="9cc50-2862">Inne przeciążenia <xref:System.Type.GetType%2A> metody wymagają nazwę typu kwalifikowanego zestawu, który zawiera numer wersji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2862">Other overloads of the <xref:System.Type.GetType%2A> method require an assembly-qualified type name, which includes the version number.</span></span>  
  
 <span data-ttu-id="9cc50-2863">Alternatywnych implementacji system typów może być konieczne do zwrócenia podklasy <xref:System.Type?displayProperty=nameWithType> nie są tworzone przez środowisko CLR; wszystkie typy, które są zwracane przez inne przeciążenia <xref:System.Type.GetType%2A> metody są typami środowiska wykonawczego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2863">Alternate implementations of the type system may need to return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the CLR; all types that are returned by other overloads of the <xref:System.Type.GetType%2A> method are runtime types.</span></span>  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a><span data-ttu-id="9cc50-2864">Uwagi dotyczące użytkowania</span><span class="sxs-lookup"><span data-stu-id="9cc50-2864">Usage Notes</span></span>  
 <span data-ttu-id="9cc50-2865">Tego przeciążenia metody i jego skojarzone przeciążenia przeanalizować `typeName` w nazwie typu i nazwy zestawu, a następnie rozpoznawania nazw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2865">This method overload and its associated overloads parse `typeName` into the name of a type and the name of an assembly, and then resolve the names.</span></span> <span data-ttu-id="9cc50-2866">Rozpoznawanie nazwy zestawu wcześniejsza rozpoznawanie nazwy typu, ponieważ nazwa typu muszą być rozwiązane w kontekście zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2866">Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-2867">Jeśli nie jesteś zaznajomiony z pojęciem nazw kwalifikowanych dla zestawu typu, zobacz <xref:System.Type.AssemblyQualifiedName%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2867">If you are unfamiliar with the concept of assembly-qualified type names, see the <xref:System.Type.AssemblyQualifiedName%2A> property.</span></span>  
  
 <span data-ttu-id="9cc50-2868">Jeśli `typeName` nie jest kwalifikowana nazwa zestawu, rozpoznawania zestawu jest pomijany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2868">If `typeName` is not an assembly-qualified name, assembly resolution is skipped.</span></span> <span data-ttu-id="9cc50-2869">Można rozwiązać nazwy niekwalifikowanej typów w kontekście Mscorlib.dll lub zawierający obecnie wykonywany zestaw lub opcjonalnie możesz podać zestawu w `typeResolver` parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2869">Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the `typeResolver` parameter.</span></span> <span data-ttu-id="9cc50-2870">W tym lub pominięcie Nazwa zestawu dla różnych rodzajów rozpoznawania nazw są wyświetlane jako tabelę w [rozpoznawanie nazw mieszanych](#mixed_name_resolution) sekcji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2870">The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section.</span></span>  
  
 <span data-ttu-id="9cc50-2871">Uwagi dotyczące użycia ogólne:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2871">General usage notes:</span></span>  
  
-   <span data-ttu-id="9cc50-2872">Nie przekazuj metody `assemblyResolver` lub `typeResolver` jeśli pochodzą z nieznanych lub niezaufanych wywołujących.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2872">Do not pass methods to `assemblyResolver` or `typeResolver` if they come from unknown or untrusted callers.</span></span> <span data-ttu-id="9cc50-2873">Użyj tylko określonych przez siebie metod lub tych, które znasz.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2873">Use only methods that you provide or that you are familiar with.</span></span>  
  
    > [!CAUTION]
    >  <span data-ttu-id="9cc50-2874">Za pomocą metod z nieznanych lub niezaufanych wywołujących może spowodować podniesienie uprawnień dla złośliwego kodu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2874">Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.</span></span>  
  
-   <span data-ttu-id="9cc50-2875">Jeżeli pominięto `assemblyResolver` i/lub `typeResolver` parametrów, wartość `throwOnError` parametr został przekazany do metody, które wykonują domyślnego rozwiązania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2875">If you omit the `assemblyResolver` and/or `typeResolver` parameters, the value of the `throwOnError` parameter is passed to the methods that perform the default resolution.</span></span>  
  
-   <span data-ttu-id="9cc50-2876">Jeśli `throwOnError` jest `true`, ta metoda wyrzuca <xref:System.TypeLoadException> podczas `typeResolver` zwraca `null`, a <xref:System.IO.FileNotFoundException> podczas `assemblyResolver` zwraca `null`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2876">If `throwOnError` is `true`, this method throws a <xref:System.TypeLoadException> when `typeResolver` returns `null`, and a <xref:System.IO.FileNotFoundException> when `assemblyResolver` returns `null`.</span></span>  
  
-   <span data-ttu-id="9cc50-2877">Ta metoda nie przechwytuje wyjątków zgłaszanych przez `assemblyResolver` i `typeResolver`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2877">This method does not catch exceptions thrown by `assemblyResolver` and `typeResolver`.</span></span> <span data-ttu-id="9cc50-2878">Odpowiedzialność za wszelkie wyjątki wyrzucane przez metody rozpoznawania nazw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2878">You are responsible for any exceptions that are thrown by the resolver methods.</span></span>  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a><span data-ttu-id="9cc50-2879">Rozpoznawanie zespołów</span><span class="sxs-lookup"><span data-stu-id="9cc50-2879">Resolving Assemblies</span></span>  
 <span data-ttu-id="9cc50-2880">`assemblyResolver` Metoda otrzymuje <xref:System.Reflection.AssemblyName> obiektu, który jest generowany przez analizowanie ciągu nazwy zestawu, który znajduje się w `typeName`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2880">The `assemblyResolver` method receives an <xref:System.Reflection.AssemblyName> object, which is produced by parsing the string assembly name that is included in `typeName`.</span></span> <span data-ttu-id="9cc50-2881">Jeśli `typeName` nie zawiera nazwy zestawu `assemblyResolver` nie jest wywoływany i `null` jest przekazywany do `typeResolver`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2881">If `typeName` does not contain an assembly name, `assemblyResolver` is not called and `null` is passed to `typeResolver`.</span></span>  
  
 <span data-ttu-id="9cc50-2882">Jeśli `assemblyResolver` nie jest podany, standardowego zestawu badania jest używana do lokalizowania zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2882">If `assemblyResolver` is not supplied, standard assembly probing is used to locate the assembly.</span></span> <span data-ttu-id="9cc50-2883">Jeśli `assemblyResolver` zostanie podany, <xref:System.Type.GetType%2A> metody nie powoduje standardowa badania; w takim przypadku należy zagwarantować, że Twoje `assemblyResolver` może obsłużyć wszystkie zestawy przekazywania do niej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2883">If `assemblyResolver` is provided, the <xref:System.Type.GetType%2A> method does not do standard probing; in that case you must ensure that your `assemblyResolver` can handle all the assemblies you pass to it.</span></span>  
  
 <span data-ttu-id="9cc50-2884">`assemblyResolver` Metoda powinna zwrócić `null` Jeśli zestaw nie jest możliwe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2884">The `assemblyResolver` method should return `null` if the assembly cannot be resolved.</span></span> <span data-ttu-id="9cc50-2885">Jeśli `assemblyResolver` zwraca `null`, `typeResolver` nie jest wywoływana, a żadne dalsze przetwarzanie odbywa się; ponadto, jeśli `throwOnError` jest `true`, <xref:System.IO.FileNotFoundException> zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2885">If `assemblyResolver` returns `null`, `typeResolver` is not called and no further processing occurs; additionally, if `throwOnError` is `true`, a <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="9cc50-2886">Jeśli <xref:System.Reflection.AssemblyName> przekazana do `assemblyResolver` częściowym jest nazwa co najmniej jeden z jego części `null`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2886">If the <xref:System.Reflection.AssemblyName> that is passed to `assemblyResolver` is a partial name, one or more of its parts are `null`.</span></span> <span data-ttu-id="9cc50-2887">Na przykład, jeśli go nie ma wersji <xref:System.Reflection.AssemblyName.Version%2A> właściwość `null`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2887">For example, if it has no version, the <xref:System.Reflection.AssemblyName.Version%2A> property is `null`.</span></span> <span data-ttu-id="9cc50-2888">Jeśli <xref:System.Reflection.AssemblyName.Version%2A> właściwości <xref:System.Reflection.AssemblyName.CultureInfo%2A> właściwości i <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> wszystkie zwrotu metody `null`, a następnie podano prostą nazwę zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2888">If the <xref:System.Reflection.AssemblyName.Version%2A> property, the <xref:System.Reflection.AssemblyName.CultureInfo%2A> property, and the <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> method all return `null`, then only the simple name of the assembly was supplied.</span></span> <span data-ttu-id="9cc50-2889">`assemblyResolver` Metody można użyć lub zignorować wszystkie części nazwy zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2889">The `assemblyResolver` method can use or ignore all parts of the assembly name.</span></span>  
  
 <span data-ttu-id="9cc50-2890">Efekty opcje rozdzielczości w innym zestawie są wyświetlane jako tabeli [rozpoznawanie nazw mieszanych](#mixed_name_resolution) dotyczącej nazwy typów prostych i kwalifikowanych dla zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2890">The effects of different assembly resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a><span data-ttu-id="9cc50-2891">Rozpoznawanie typów</span><span class="sxs-lookup"><span data-stu-id="9cc50-2891">Resolving Types</span></span>  
 <span data-ttu-id="9cc50-2892">Jeśli `typeName` nie określa nazwy zestawu `typeResolver` zawsze jest wywoływany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2892">If `typeName` does not specify an assembly name, `typeResolver` is always called.</span></span> <span data-ttu-id="9cc50-2893">Jeśli `typeName` Określa nazwę zestawu `typeResolver` jest wywoływana tylko wtedy, gdy jest to nazwa zestawu jest pomyślnie rozpoznana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2893">If `typeName` specifies an assembly name, `typeResolver` is called only when the assembly name is successfully resolved.</span></span> <span data-ttu-id="9cc50-2894">Jeśli `assemblyResolver` lub standardowego zestawu sondowanie zwraca `null`, `typeResolver` nie zostanie wywołana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2894">If `assemblyResolver` or standard assembly probing returns `null`, `typeResolver` is not called.</span></span>  
  
 <span data-ttu-id="9cc50-2895">`typeResolver` Metoda otrzymuje trzy argumenty:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2895">The `typeResolver` method receives three arguments:</span></span>  
  
-   <span data-ttu-id="9cc50-2896">Zestaw do wyszukiwania lub `null` Jeśli `typeName` nie zawiera nazwy zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2896">The assembly to search or `null` if `typeName` does not contain an assembly name.</span></span>  
  
-   <span data-ttu-id="9cc50-2897">Prosta nazwa typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2897">The simple name of the type.</span></span> <span data-ttu-id="9cc50-2898">W przypadku typu zagnieżdżonego to najbardziej zewnętrznego typu zawierającego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2898">In the case of a nested type, this is the outermost containing type.</span></span> <span data-ttu-id="9cc50-2899">W przypadku typu ogólnego to prostą nazwę typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2899">In the case of a generic type, this is the simple name of the generic type.</span></span>  
  
-   <span data-ttu-id="9cc50-2900">Wartość logiczna, która jest `true` Jeśli wielkość liter nazwy typu ma być ignorowane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2900">A Boolean value that is `true` if the case of type names is to be ignored.</span></span>  
  
 <span data-ttu-id="9cc50-2901">Implementacja określa sposób, są używane następujące argumenty.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2901">The implementation determines the way these arguments are used.</span></span> <span data-ttu-id="9cc50-2902">`typeResolver` Metoda powinna zwrócić `null` Jeśli nie można rozpoznać typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2902">The `typeResolver` method should return `null` if it cannot resolve the type.</span></span> <span data-ttu-id="9cc50-2903">Jeśli `typeResolver` zwraca `null` i `throwOnError` jest `true`, to przeciążenie <xref:System.Type.GetType%2A> zgłasza <xref:System.TypeLoadException>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2903">If `typeResolver` returns `null` and `throwOnError` is `true`, this overload of <xref:System.Type.GetType%2A> throws a <xref:System.TypeLoadException>.</span></span>  
  
 <span data-ttu-id="9cc50-2904">Efekty opcje rozpoznawania innego typu są wyświetlane jako tabeli [rozpoznawanie nazw mieszanych](#mixed_name_resolution) dotyczącej nazwy typów prostych i kwalifikowanych dla zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2904">The effects of different type resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
#### <a name="resolving-nested-types"></a><span data-ttu-id="9cc50-2905">Rozpoznawanie zagnieżdżonych typów</span><span class="sxs-lookup"><span data-stu-id="9cc50-2905">Resolving Nested Types</span></span>  
 <span data-ttu-id="9cc50-2906">Jeśli `typeName` jest typem zagnieżdżonym tylko nazwę prowadzące z typem jest przekazywany do `typeResolver`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2906">If `typeName` is a nested type, only the name of the outermost containing type is passed to `typeResolver`.</span></span> <span data-ttu-id="9cc50-2907">Gdy `typeResolver` zwraca tego typu <xref:System.Type.GetNestedType%2A> metoda jest wywoływana cyklicznie, dopóki najbardziej typu zagnieżdżonego zostanie rozwiązany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2907">When `typeResolver` returns this type, the <xref:System.Type.GetNestedType%2A> method is called recursively until the innermost nested type has been resolved.</span></span>  
  
#### <a name="resolving-generic-types"></a><span data-ttu-id="9cc50-2908">Rozpoznawanie typów rodzajowych</span><span class="sxs-lookup"><span data-stu-id="9cc50-2908">Resolving Generic Types</span></span>  
 <span data-ttu-id="9cc50-2909"><xref:System.Type.GetType%2A> Nosi nazwę cyklicznie, aby rozwiązać typów ogólnych: Aby rozpoznać typu rodzajowego, a następnie Rozwiąż argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2909">The <xref:System.Type.GetType%2A> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments.</span></span> <span data-ttu-id="9cc50-2910">Jeśli argument typu ogólnego, <xref:System.Type.GetType%2A> nosi nazwę cyklicznie, aby rozwiązać argumentów typu i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2910">If a type argument is generic, <xref:System.Type.GetType%2A> is called recursively to resolve its type arguments, and so on.</span></span>  
  
 <span data-ttu-id="9cc50-2911">Kombinacja `assemblyResolver` i `typeResolver` podane muszą być w stanie rozwiązywania wszystkich poziomów to rekursji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2911">The combination of `assemblyResolver` and `typeResolver` that you provide must be capable of resolving all levels of this recursion.</span></span> <span data-ttu-id="9cc50-2912">Załóżmy, że podajesz `assemblyResolver` sterującą ładowanie `MyAssembly`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2912">For example, suppose you supply an `assemblyResolver` that controls the loading of `MyAssembly`.</span></span> <span data-ttu-id="9cc50-2913">Załóżmy, że chcesz usunąć typ ogólny `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-2913">Suppose you want to resolve the generic type `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic).</span></span> <span data-ttu-id="9cc50-2914">Następująca nazwa typu ogólnego może zostać przekazany:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2914">You might pass the following generic type name:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="9cc50-2915">Należy zauważyć, że `MyType` jest argumentem typu tylko kwalifikowanego zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2915">Notice that `MyType` is the only assembly-qualified type argument.</span></span> <span data-ttu-id="9cc50-2916">Nazwy <xref:System.Collections.Generic.Dictionary%602> i <xref:System.String> klasy nie są kwalifikowaną dla zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2916">The names of the <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String> classes are not assembly-qualified.</span></span> <span data-ttu-id="9cc50-2917">Twoje `typeResolver` stanie dojścia musi być jednym z zestawów lub `null`, ponieważ będzie ona otrzymywać `null` dla <xref:System.Collections.Generic.Dictionary%602> i <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2917">Your `typeResolver` must be able handle either an assembly or `null`, because it will receive `null` for <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String>.</span></span> <span data-ttu-id="9cc50-2918">Może obsługiwać tego przypadku poprzez wywołanie przeciążenia <xref:System.Type.GetType%2A> metody, która przyjmuje ciąg, ponieważ obie nazwy niekwalifikowanej typów Mscorlib.dll:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2918">It can handle that case by calling an overload of the <xref:System.Type.GetType%2A> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 <span data-ttu-id="9cc50-2919">`assemblyResolver` Metoda nie jest wywoływana dla typu słownika i typu string, ponieważ te nazwy typów nie są kwalifikowaną dla zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2919">The `assemblyResolver` method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.</span></span>  
  
 <span data-ttu-id="9cc50-2920">Teraz załóżmy, że zamiast `System.String`, pierwszy typ ogólny, argument jest `YourType`, z `YourAssembly`:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2920">Now suppose that instead of `System.String`, the first generic argument type is `YourType`, from `YourAssembly`:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="9cc50-2921">Ponieważ ten zestaw jest, aby biblioteka Mscorlib.dll ani zawierający obecnie wykonywany zestaw, nie można rozpoznać `YourType` bez nazwy kwalifikowanej zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2921">Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve `YourType` without an assembly-qualified name.</span></span> <span data-ttu-id="9cc50-2922">Ponieważ Twoje `assemblyResolve` będzie wywoływany rekursywnie, musi być w stanie obsłużyć tego przypadku.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2922">Because your `assemblyResolve` will be called recursively, it must be able to handle this case.</span></span> <span data-ttu-id="9cc50-2923">Zamiast zwracać `null` dla zestawów innych niż `MyAssembly`, wykonuje obecnie ładowanie zestawu z użyciem podane <xref:System.Reflection.AssemblyName> obiektu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2923">Instead of returning `null` for assemblies other than `MyAssembly`, it now performs an assembly load using the supplied <xref:System.Reflection.AssemblyName> object.</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 <span data-ttu-id="9cc50-2924">Powrót do [uwagi dotyczące użycia](#usage_notes).</span><span class="sxs-lookup"><span data-stu-id="9cc50-2924">Back to [Usage Notes](#usage_notes).</span></span>  
  
#### <a name="resolving-type-names-with-special-characters"></a><span data-ttu-id="9cc50-2925">Rozpoznawanie nazw typów ze znakami specjalnymi</span><span class="sxs-lookup"><span data-stu-id="9cc50-2925">Resolving Type Names with Special Characters</span></span>  
 <span data-ttu-id="9cc50-2926">Niektóre znaki mają specjalne znaczenie w nazw kwalifikowanych dla zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2926">Certain characters have special meanings in assembly-qualified names.</span></span> <span data-ttu-id="9cc50-2927">Nazwa typu prostego, który zawiera te znaki, znaki powodować błędy podczas analizowania gdy prosta nazwa jest częścią kwalifikowana nazwa zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2927">If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name.</span></span> <span data-ttu-id="9cc50-2928">Aby uniknąć błędów podczas analizowania, znaki specjalne znakiem kreski ułamkowej odwróconej ucieczki musi przed można przekazać nazwę kwalifikowaną dla zestawu, aby <xref:System.Type.GetType%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2928">To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="9cc50-2929">Na przykład, jeśli typ ma nazwę `Strange]Type`, znaku ucieczki musi zostać dodany wcześniej nawias kwadratowy w następujący sposób: `Strange\]Type`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2929">For example, if a type is named `Strange]Type`, the escape character must be added ahead of the square bracket as follows: `Strange\]Type`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-2930">Nazwy tych znaków specjalnych nie można utworzyć w języku Visual Basic lub C#, ale można utworzyć za pomocą języka Microsoft intermediate language (MSIL) lub emitowanie dynamicznych zestawów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2930">Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.</span></span>  
  
 <span data-ttu-id="9cc50-2931">W poniższej tabeli przedstawiono znaki specjalne dla nazwy typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2931">The following table shows the special characters for type names.</span></span>  
  
|<span data-ttu-id="9cc50-2932">Znak</span><span class="sxs-lookup"><span data-stu-id="9cc50-2932">Character</span></span>|<span data-ttu-id="9cc50-2933">Znaczenie</span><span class="sxs-lookup"><span data-stu-id="9cc50-2933">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="9cc50-2934">`,` (przecinek)</span><span class="sxs-lookup"><span data-stu-id="9cc50-2934">`,` (comma)</span></span>|<span data-ttu-id="9cc50-2935">/ / / Ogranicznik nazw kwalifikowanych dla zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2935">Delimiter for assembly-qualified names.</span></span>|  
|<span data-ttu-id="9cc50-2936">`[]` (nawiasy kwadratowe)</span><span class="sxs-lookup"><span data-stu-id="9cc50-2936">`[]` (square brackets)</span></span>|<span data-ttu-id="9cc50-2937">Jako parę sufiks wskazuje typ tablicy; jako parę ogranicznik otacza listy argumentów ogólnych i nazw kwalifikowanych dla zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2937">As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.</span></span>|  
|<span data-ttu-id="9cc50-2938">`&` (handlowe "i")</span><span class="sxs-lookup"><span data-stu-id="9cc50-2938">`&` (ampersand)</span></span>|<span data-ttu-id="9cc50-2939">Jako sufiks wskazuje, że typ jest typem referencyjnym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2939">As a suffix, indicates that a type is a reference type.</span></span>|  
|<span data-ttu-id="9cc50-2940">`*` (gwiazdka)</span><span class="sxs-lookup"><span data-stu-id="9cc50-2940">`*` (asterisk)</span></span>|<span data-ttu-id="9cc50-2941">Jako sufiks wskazuje, że typ jest typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2941">As a suffix, indicates that a type is a pointer type.</span></span>|  
|<span data-ttu-id="9cc50-2942">`+` (znak plus)</span><span class="sxs-lookup"><span data-stu-id="9cc50-2942">`+` (plus)</span></span>|<span data-ttu-id="9cc50-2943">/ / / Ogranicznik zagnieżdżone typy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2943">Delimiter for nested types.</span></span>|  
|<span data-ttu-id="9cc50-2944">`\` (ukośnik odwrotny)</span><span class="sxs-lookup"><span data-stu-id="9cc50-2944">`\` (backslash)</span></span>|<span data-ttu-id="9cc50-2945">Znak ucieczki.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2945">Escape character.</span></span>|  
  
 <span data-ttu-id="9cc50-2946">Właściwości, takie jak <xref:System.Type.AssemblyQualifiedName%2A> return prawidłowo poprzedzone znakiem zmiany znaczenia ciągów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2946">Properties such as <xref:System.Type.AssemblyQualifiedName%2A> return correctly escaped strings.</span></span> <span data-ttu-id="9cc50-2947">Należy przekazać poprawnie o zmienionym znaczeniu ciągów w celu <xref:System.Type.GetType%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2947">You must pass correctly escaped strings to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="9cc50-2948">Z kolei <xref:System.Type.GetType%2A> metoda przekazuje poprawnie o zmienionym znaczeniu nazwy `typeResolver` oraz metody rozpoznawania typu domyślnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2948">In turn, the <xref:System.Type.GetType%2A> method passes correctly escaped names to `typeResolver` and to the default type resolution methods.</span></span> <span data-ttu-id="9cc50-2949">Jeśli chcesz porównać nazwy do nazwy o niezmienionym znaczeniu w `typeResolver`, należy usunąć znaki ucieczki.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2949">If you need to compare a name to an unescaped name in `typeResolver`, you must remove the escape characters.</span></span>  
  
 <span data-ttu-id="9cc50-2950">Powrót do [uwagi dotyczące użycia](#usage_notes).</span><span class="sxs-lookup"><span data-stu-id="9cc50-2950">Back to [Usage Notes](#usage_notes).</span></span>  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a><span data-ttu-id="9cc50-2951">Rozpoznawanie nazw mieszanych</span><span class="sxs-lookup"><span data-stu-id="9cc50-2951">Mixed Name Resolution</span></span>  
 <span data-ttu-id="9cc50-2952">W poniższej tabeli przedstawiono interakcje między `assemblyResolver`, `typeResolver`i rozpoznawania nazw domyślnego dla wszystkich kombinacji nazwy typu i nazwy zestawu w `typeName`:</span><span class="sxs-lookup"><span data-stu-id="9cc50-2952">The following table summarizes the interactions between `assemblyResolver`, `typeResolver`, and default name resolution, for all combinations of type name and assembly name in `typeName`:</span></span>  
  
|<span data-ttu-id="9cc50-2953">Nazwa typu zawartości</span><span class="sxs-lookup"><span data-stu-id="9cc50-2953">Contents of type name</span></span>|<span data-ttu-id="9cc50-2954">Metoda rozpoznawania zestawu</span><span class="sxs-lookup"><span data-stu-id="9cc50-2954">Assembly resolver method</span></span>|<span data-ttu-id="9cc50-2955">Metody rozpoznawania typu</span><span class="sxs-lookup"><span data-stu-id="9cc50-2955">Type resolver method</span></span>|<span data-ttu-id="9cc50-2956">Wynik</span><span class="sxs-lookup"><span data-stu-id="9cc50-2956">Result</span></span>|  
|---------------------------|------------------------------|--------------------------|------------|  
|<span data-ttu-id="9cc50-2957">typ, zestaw</span><span class="sxs-lookup"><span data-stu-id="9cc50-2957">type, assembly</span></span>|<span data-ttu-id="9cc50-2958">wartość null</span><span class="sxs-lookup"><span data-stu-id="9cc50-2958">null</span></span>|<span data-ttu-id="9cc50-2959">wartość null</span><span class="sxs-lookup"><span data-stu-id="9cc50-2959">null</span></span>|<span data-ttu-id="9cc50-2960">Równoważne z wywoływaniem <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2960">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span>|  
|<span data-ttu-id="9cc50-2961">typ, zestaw</span><span class="sxs-lookup"><span data-stu-id="9cc50-2961">type, assembly</span></span>|<span data-ttu-id="9cc50-2962">podano</span><span class="sxs-lookup"><span data-stu-id="9cc50-2962">provided</span></span>|<span data-ttu-id="9cc50-2963">wartość null</span><span class="sxs-lookup"><span data-stu-id="9cc50-2963">null</span></span>|<span data-ttu-id="9cc50-2964">`assemblyResolver` Zwraca zestaw lub zwraca `null` Jeśli nie można rozpoznać zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2964">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="9cc50-2965">Jeśli zestaw nie zostanie rozwiązany, <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> przeciążenie metody jest używana do ładowania typów z zestawu; w przeciwnym razie wystąpi próba rozpoznać typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2965">If the assembly is resolved, the <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.</span></span>|  
|<span data-ttu-id="9cc50-2966">typ, zestaw</span><span class="sxs-lookup"><span data-stu-id="9cc50-2966">type, assembly</span></span>|<span data-ttu-id="9cc50-2967">wartość null</span><span class="sxs-lookup"><span data-stu-id="9cc50-2967">null</span></span>|<span data-ttu-id="9cc50-2968">podano</span><span class="sxs-lookup"><span data-stu-id="9cc50-2968">provided</span></span>|<span data-ttu-id="9cc50-2969">Równoważne do konwertowania nazwy zestawu, aby <xref:System.Reflection.AssemblyName> obiektu i wywoływania <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> przeciążenia metody, aby uzyskać zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2969">Equivalent to converting the assembly name to an <xref:System.Reflection.AssemblyName> object and calling the <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> method overload to get the assembly.</span></span> <span data-ttu-id="9cc50-2970">Jeśli zestaw nie zostanie rozwiązany, zostanie on przekazany do `typeResolver`; w przeciwnym razie `typeResolver` nie jest wywoływany i nie dalsze próby rozwiązania typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2970">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="9cc50-2971">typ, zestaw</span><span class="sxs-lookup"><span data-stu-id="9cc50-2971">type, assembly</span></span>|<span data-ttu-id="9cc50-2972">podano</span><span class="sxs-lookup"><span data-stu-id="9cc50-2972">provided</span></span>|<span data-ttu-id="9cc50-2973">podano</span><span class="sxs-lookup"><span data-stu-id="9cc50-2973">provided</span></span>|<span data-ttu-id="9cc50-2974">`assemblyResolver` Zwraca zestaw lub zwraca `null` Jeśli nie można rozpoznać zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2974">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="9cc50-2975">Jeśli zestaw nie zostanie rozwiązany, zostanie on przekazany do `typeResolver`; w przeciwnym razie `typeResolver` nie jest wywoływany i nie dalsze próby rozwiązania typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2975">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="9cc50-2976">— typ</span><span class="sxs-lookup"><span data-stu-id="9cc50-2976">type</span></span>|<span data-ttu-id="9cc50-2977">wartość NULL, podana</span><span class="sxs-lookup"><span data-stu-id="9cc50-2977">null, provided</span></span>|<span data-ttu-id="9cc50-2978">wartość null</span><span class="sxs-lookup"><span data-stu-id="9cc50-2978">null</span></span>|<span data-ttu-id="9cc50-2979">Równoważne z wywoływaniem <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2979">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="9cc50-2980">Ponieważ nie podano nazwy zestawu, przeszukiwane są tylko Biblioteka Mscorlib.dll i zawierający obecnie wykonywany zestaw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2980">Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched.</span></span> <span data-ttu-id="9cc50-2981">Jeśli `assemblyResolver` zostanie podana, zostanie zignorowany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2981">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="9cc50-2982">— typ</span><span class="sxs-lookup"><span data-stu-id="9cc50-2982">type</span></span>|<span data-ttu-id="9cc50-2983">wartość NULL, podana</span><span class="sxs-lookup"><span data-stu-id="9cc50-2983">null, provided</span></span>|<span data-ttu-id="9cc50-2984">podano</span><span class="sxs-lookup"><span data-stu-id="9cc50-2984">provided</span></span>|<span data-ttu-id="9cc50-2985">`typeResolver` jest wywoływana, i `null` jest przekazywana do zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2985">`typeResolver` is called, and `null` is passed for the assembly.</span></span> <span data-ttu-id="9cc50-2986">`typeResolver` można podać typ z dowolnego zestawu, w tym zestawów, które ładuje do tego celu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2986">`typeResolver` can provide a type from any assembly, including assemblies it loads for the purpose.</span></span> <span data-ttu-id="9cc50-2987">Jeśli `assemblyResolver` zostanie podana, zostanie zignorowany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2987">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="9cc50-2988">zestaw</span><span class="sxs-lookup"><span data-stu-id="9cc50-2988">assembly</span></span>|<span data-ttu-id="9cc50-2989">wartość NULL, podana</span><span class="sxs-lookup"><span data-stu-id="9cc50-2989">null, provided</span></span>|<span data-ttu-id="9cc50-2990">wartość NULL, podana</span><span class="sxs-lookup"><span data-stu-id="9cc50-2990">null, provided</span></span>|<span data-ttu-id="9cc50-2991">Element <xref:System.IO.FileLoadException> jest generowany, ponieważ nazwa zestawu jest analizowany, tak jakby był on nazwę typu kwalifikowanego zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2991">A <xref:System.IO.FileLoadException> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name.</span></span> <span data-ttu-id="9cc50-2992">Skutkuje to nieprawidłowa nazwa zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2992">This results in an invalid assembly name.</span></span>|  
  
 <span data-ttu-id="9cc50-2993">Powrót do: [Uwagi dotyczące użycia](#usage_notes), [rozpoznawania zestawów](#resolving_assemblies), [rozpoznawanie typów](#resolving_types).</span><span class="sxs-lookup"><span data-stu-id="9cc50-2993">Back to: [Usage Notes](#usage_notes), [Resolving Assemblies](#resolving_assemblies), [Resolving Types](#resolving_types).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-2994"><paramref name="typeName" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2994"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="9cc50-2995">Inicjator klasy jest wywoływany i zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2995">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="9cc50-2996"><paramref name="throwOnError" /> jest <see langword="true" /> i nie można odnaleźć typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2996"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="9cc50-2997">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2997">-or-</span></span> 
 <span data-ttu-id="9cc50-2998"><paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> zawiera nieprawidłowe znaki, takie jak osadzona karta.</span><span class="sxs-lookup"><span data-stu-id="9cc50-2998"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="9cc50-2999">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-2999">-or-</span></span> 
 <span data-ttu-id="9cc50-3000"><paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> jest ciągiem pustym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3000"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="9cc50-3001">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3001">-or-</span></span> 
 <span data-ttu-id="9cc50-3002"><paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> reprezentuje typ tablicy z nieprawidłowym rozmiarem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3002"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="9cc50-3003">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3003">-or-</span></span> 
 <span data-ttu-id="9cc50-3004"><paramref name="typeName" /> reprezentuje tablicę <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3004"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-3005">Błąd występuje, gdy <paramref name="typeName" /> jest przekształcany do nazwy typu i nazwy zestawu (na przykład, gdy nazwa typu prostego zawiera specjalne znaku o niezmienionym znaczeniu).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3005">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span></span>  
  
<span data-ttu-id="9cc50-3006">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3006">-or-</span></span> 
 <span data-ttu-id="9cc50-3007"><paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> ma nieprawidłową składnię "(na przykład MyType[,\*,]").</span><span class="sxs-lookup"><span data-stu-id="9cc50-3007"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span></span>  
  
<span data-ttu-id="9cc50-3008">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3008">-or-</span></span> 
 <span data-ttu-id="9cc50-3009"><paramref name="typeName" /> reprezentuje typ ogólny, który jest typem wskaźnika <see langword="ByRef" /> typu, lub <see cref="T:System.Void" /> jako jeden z argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3009"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="9cc50-3010">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3010">-or-</span></span> 
 <span data-ttu-id="9cc50-3011"><paramref name="typeName" /> reprezentuje typ ogólny, który ma niepoprawną liczbę argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3011"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="9cc50-3012">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3012">-or-</span></span> 
 <span data-ttu-id="9cc50-3013"><paramref name="typeName" /> reprezentuje typ ogólny i jeden z argumentów typu nie spełniają ograniczeń dla odpowiedniego parametru typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3013"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="9cc50-3014"><paramref name="throwOnError" /> jest <see langword="true" /> i nie znaleziono zestawu lub jednej z jego zależności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3014"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="9cc50-3015">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3015">The assembly or one of its dependencies was found, but could not be loaded.</span></span>  
  
<span data-ttu-id="9cc50-3016">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3016">-or-</span></span> 
 <span data-ttu-id="9cc50-3017"><paramref name="typeName" /> zawiera nieprawidłową nazwę zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3017"><paramref name="typeName" /> contains an invalid assembly name.</span></span>  
  
<span data-ttu-id="9cc50-3018">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3018">-or-</span></span> 
 <span data-ttu-id="9cc50-3019"><paramref name="typeName" /> jest nazwą prawidłowego zestawu bez nazwy typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3019"><paramref name="typeName" /> is a valid assembly name without a type name.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="9cc50-3020">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3020">The assembly or one of its dependencies is not valid.</span></span>  
  
<span data-ttu-id="9cc50-3021">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3021">-or-</span></span> 
<span data-ttu-id="9cc50-3022">Zestaw został skompilowany przy użyciu nowszej wersji aparatu plików wykonywalnych języka wspólnego niż wersja, która jest aktualnie załadowana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3022">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="args"><span data-ttu-id="9cc50-3023">Tablica obiektów o typach, aby określić.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3023">An array of objects whose types to determine.</span></span></param>
        <summary><span data-ttu-id="9cc50-3024">Pobiera typy obiektów w określonej tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3024">Gets the types of the objects in the specified array.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3025">Tablica <see cref="T:System.Type" /> obiektów reprezentujących rodzaje odpowiednie elementy w <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3025">An array of <see cref="T:System.Type" /> objects representing the types of the corresponding elements in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="9cc50-3026">Poniższy przykład kodu demonstruje sposób używania <xref:System.Type.GetTypeArray%2A> metody, aby wyświetlić listę typów elementów tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3026">The following code example demonstrates how to use the <xref:System.Type.GetTypeArray%2A> method to list the types of the elements of an array.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-3027"><paramref name="args" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3027"><paramref name="args" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cc50-3028">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3028">-or-</span></span> 
<span data-ttu-id="9cc50-3029">Co najmniej jeden z elementów w <paramref name="args" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3029">One or more of the elements in <paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="9cc50-3030">Inicjatory klasy są wywoływane, i zgłasza wyjątek, co najmniej jeden.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3030">The class initializers are invoked and at least one throws an exception.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="9cc50-3031">Typ, którego bazowego typu kodu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3031">The type whose underlying type code to get.</span></span></param>
        <summary><span data-ttu-id="9cc50-3032">Pobiera podstawowy kod typu określonego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3032">Gets the underlying type code of the specified <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3033">Kod typu podstawowego lub <see cref="F:System.TypeCode.Empty" /> Jeśli <paramref name="type" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3033">The code of the underlying type, or <see cref="F:System.TypeCode.Empty" /> if <paramref name="type" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3034">Przy dziedziczeniu z <xref:System.Type>, zachowania tej metody można zmienić poprzez zastąpienie <xref:System.Type.GetTypeCodeImpl%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3034">When you inherit from <xref:System.Type>, you can change the behavior of this method by overriding the <xref:System.Type.GetTypeCodeImpl%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3035">Poniższy przykład kodu demonstruje sposób, w jaki <xref:System.TypeCode> używać wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3035">The following code example demonstrates how the <xref:System.TypeCode> enumeration can be used.</span></span> <span data-ttu-id="9cc50-3036">W bloku decyzji wewnątrz `WriteObjectInfo` metody <xref:System.TypeCode> z <xref:System.Object> parametru jest badany i odpowiedni komunikat jest wyświetlony w konsoli.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3036">In a decision block inside the `WriteObjectInfo` method, the <xref:System.TypeCode> of an <xref:System.Object> parameter is examined, and an appropriate message is written to the console.</span></span>  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-3037">Zwraca podstawowy kod typu tego <see cref="T:System.Type" /> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3037">Returns the underlying type code of this <see cref="T:System.Type" /> instance.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3038">Kod typu podstawowego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3038">The type code of the underlying type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3039">Ta metoda zapewnia to implementacja `static` (w języku C#) lub `Shared` (w języku Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3039">This method provides the implementation for the `static` (in C#) or `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> method.</span></span> <span data-ttu-id="9cc50-3040">Przy dziedziczeniu z <xref:System.Type>, możesz zastąpić tę metodę, aby podać własną implementację <xref:System.Type.GetTypeCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3040">When you inherit from <xref:System.Type>, you can override this method to provide your own implementation of <xref:System.Type.GetTypeCode%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cc50-3041">Pobiera typ ze skojarzonym identyfikatorem określonej klasy (CLSID).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3041">Gets the type associated with the specified class identifier (CLSID).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="9cc50-3042">Identyfikator CLSID typu, który można pobrać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3042">The CLSID of the type to get.</span></span></param>
        <summary><span data-ttu-id="9cc50-3043">Pobiera typ ze skojarzonym identyfikatorem określonej klasy (CLSID).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3043">Gets the type associated with the specified class identifier (CLSID).</span></span></summary>
        <returns><span data-ttu-id="9cc50-3044"><see langword="System.__ComObject" /> niezależnie od tego, czy identyfikator CLSID jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3044"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3045"><xref:System.Type.GetTypeFromCLSID%2A> Metoda obsługuje dostęp z późnym wiązaniem do niezarządzanych obiektów COM z aplikacji .NET Framework, gdy wiesz identyfikator klasy obiektu COM (CLSID).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3045">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="9cc50-3046">Identyfikator klasy dla klasy COM jest zdefiniowany w kluczu HKEY_CLASSES_ROOT\CLSID rejestru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3046">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="9cc50-3047">Można pobrać wartość <xref:System.Type.IsCOMObject%2A> właściwości w celu określenia, czy typ zwracany przez tę metodę jest obiektem COM.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3047">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="9cc50-3048">Możesz wywołać <xref:System.Type.GetTypeFromProgID%2A> metody z późnym wiązaniem dostępu do modelu COM obiekty, których identyfikator programowy (ProgID) wiadomo.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3048">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="9cc50-3049">Utworzenie wystąpienia niezarządzanych obiektu modelu COM z jego identyfikator CLSID jest procesem dwuetapowym:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3049">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="9cc50-3050">Pobierz <xref:System.Type> obiekt, który reprezentuje`__ComObject` , który odpowiada identyfikator CLSID, wywołując <xref:System.Type.GetTypeFromCLSID%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3050">Get a <xref:System.Type> object that represents the`__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="9cc50-3051">Wywołaj <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metodę, aby utworzyć wystąpienie obiektu COM.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3051">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="9cc50-3052">Zobacz przykład ilustracja.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3052">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="9cc50-3053"><xref:System.Type.GetTypeFromCLSID%28System.Guid%29> Przeciążenia ignoruje wszelkie wyjątki, które mogą wystąpić podczas tworzenia wystąpienia <xref:System.Type> na podstawie obiektu `clsid` argumentu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3053">The <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> overload ignores any exception that may occur when instantiating a <xref:System.Type> object based on the `clsid` argument.</span></span> <span data-ttu-id="9cc50-3054">Należy zauważyć, że jest zgłaszany żaden wyjątek, jeśli `clsid` nie zostanie znaleziony w rejestrze.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3054">Note that no exception is thrown if `clsid` is not found in the registry.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3055">W poniższym przykładzie użyto identyfikator CLSID programu Microsoft Word [obiekt aplikacji](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) można pobrać typu modelu COM, który reprezentuje aplikację Microsoft Word.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3055">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="9cc50-3056">Następnie tworzy wystąpienie typu przez wywołanie metody <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metody i zamyka te błędy, wywołując [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3056">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="9cc50-3057">Ta metoda jest przeznaczona do użycia podczas pracy z obiektami COM, a nie z obiektami .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3057">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="9cc50-3058">Wszystkie zarządzane obiekty, w tym te, które są widoczne dla modelu COM (oznacza to, że ich <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atrybut jest <see langword="true" />) ma identyfikator GUID, który jest zwracany przez <see cref="P:System.Type.GUID" /> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3058">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="9cc50-3059">Mimo że metoda zwraca <see cref="T:System.Type" /> obiektów obiekt, który odnosi się do identyfikatora GUID dla programu .NET Framework, nie można użyć, które <see cref="T:System.Type" /> obiektu do utworzenia wystąpienia typu przez wywołanie metody <see cref="M:System.Activator.CreateInstance(System.Type)" /> metody, jak w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3059">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="9cc50-3060">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="9cc50-3060">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="9cc50-3061">Zamiast tego <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> powinna służyć wyłącznie do pobrania identyfikatora GUID niezarządzanych obiektów COM i wynikowy <see cref="T:System.Type" /> obiekt, który jest przekazywany do <see cref="M:System.Activator.CreateInstance(System.Type)" /> metody musi reprezentować obiekt COM niezarządzanych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3061">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="9cc50-3062">Identyfikator CLSID typu, który można pobrać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3062">The CLSID of the type to get.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="9cc50-3063"><see langword="true" /> Umożliwia zgłoszenie każdego wyjątku, który występuje.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3063"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="9cc50-3064">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3064">-or-</span></span> 
 <span data-ttu-id="9cc50-3065"><see langword="false" /> umożliwia zignorowanie każdego wyjątku, który występuje.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3065"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="9cc50-3066">Pobiera typ ze skojarzonym identyfikatorem określonej klasy (CLSID) określająca, czy zgłosić wyjątek, jeśli wystąpi błąd podczas ładowania typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3066">Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3067"><see langword="System.__ComObject" /> niezależnie od tego, czy identyfikator CLSID jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3067"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3068"><xref:System.Type.GetTypeFromCLSID%2A> Metoda obsługuje dostęp z późnym wiązaniem do niezarządzanych obiektów COM z aplikacji .NET Framework, gdy wiesz identyfikator klasy obiektu COM (CLSID).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3068">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="9cc50-3069">Identyfikator klasy dla klasy COM jest zdefiniowany w kluczu HKEY_CLASSES_ROOT\CLSID rejestru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3069">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="9cc50-3070">Można pobrać wartość <xref:System.Type.IsCOMObject%2A> właściwości w celu określenia, czy typ zwracany przez tę metodę jest obiektem COM.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3070">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="9cc50-3071">Możesz wywołać <xref:System.Type.GetTypeFromProgID%2A> metody z późnym wiązaniem dostępu do modelu COM obiekty, których identyfikator programowy (ProgID) wiadomo.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3071">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="9cc50-3072">Utworzenie wystąpienia niezarządzanych obiektu modelu COM z jego identyfikator CLSID jest procesem dwuetapowym:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3072">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="9cc50-3073">Pobierz <xref:System.Type> obiekt, który reprezentuje `__ComObject` , który odpowiada identyfikator CLSID, wywołując <xref:System.Type.GetTypeFromCLSID%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3073">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="9cc50-3074">Wywołaj <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metodę, aby utworzyć wystąpienie obiektu COM.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3074">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="9cc50-3075">Zobacz przykład ilustracja.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3075">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="9cc50-3076">Wyjątki, takie jak <xref:System.OutOfMemoryException> zostanie zgłoszony podczas określania `true` dla `throwOnError`, ale zakończy się niepowodzeniem dla niezarejestrowanych CLSID.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3076">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3077">W poniższym przykładzie użyto identyfikator CLSID programu Microsoft Word [obiekt aplikacji](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) można pobrać typu modelu COM, który reprezentuje aplikację Microsoft Word.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3077">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="9cc50-3078">Następnie tworzy wystąpienie typu przez wywołanie metody <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metody i zamyka te błędy, wywołując [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3078">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span> <span data-ttu-id="9cc50-3079">Wyjątek jest generowany, jeśli wystąpi błąd podczas ładowania typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3079">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="9cc50-3080">Ta metoda jest przeznaczona do użycia podczas pracy z obiektami COM, a nie z obiektami .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3080">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="9cc50-3081">Wszystkie zarządzane obiekty, w tym te, które są widoczne dla modelu COM (oznacza to, że ich <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atrybut jest <see langword="true" />) ma identyfikator GUID, który jest zwracany przez <see cref="P:System.Type.GUID" /> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3081">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="9cc50-3082">Mimo że metoda zwraca <see cref="T:System.Type" /> obiektów obiekt, który odnosi się do identyfikatora GUID dla programu .NET Framework, nie można użyć, które <see cref="T:System.Type" /> obiektu do utworzenia wystąpienia typu przez wywołanie metody <see cref="M:System.Activator.CreateInstance(System.Type)" /> metody, jak w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3082">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="9cc50-3083">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="9cc50-3083">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="9cc50-3084">Zamiast tego <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> powinna służyć wyłącznie do pobrania identyfikatora GUID niezarządzanych obiektów COM i wynikowy <see cref="T:System.Type" /> obiekt, który jest przekazywany do <see cref="M:System.Activator.CreateInstance(System.Type)" /> metody musi reprezentować obiekt COM niezarządzanych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3084">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="9cc50-3085">Identyfikator CLSID typu, który można pobrać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3085">The CLSID of the type to get.</span></span></param>
        <param name="server"><span data-ttu-id="9cc50-3086">Serwer, z którego można załadować typ.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3086">The server from which to load the type.</span></span> <span data-ttu-id="9cc50-3087">Jeśli nazwa serwera jest <see langword="null" />, ta metoda zostanie automatycznie przywrócona do komputera lokalnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3087">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <summary><span data-ttu-id="9cc50-3088">Pobiera typ ze skojarzonym identyfikatorem określonej klasy (CLSID) z określonego serwera.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3088">Gets the type associated with the specified class identifier (CLSID) from the specified server.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3089"><see langword="System.__ComObject" /> niezależnie od tego, czy identyfikator CLSID jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3089"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3090"><xref:System.Type.GetTypeFromCLSID%2A> Metoda obsługuje dostęp z późnym wiązaniem do niezarządzanych obiektów COM z aplikacji .NET Framework, gdy wiesz identyfikator klasy obiektu COM (CLSID).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3090">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="9cc50-3091">Identyfikator klasy dla klasy COM jest zdefiniowany w kluczu HKEY_CLASSES_ROOT\CLSID rejestru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3091">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="9cc50-3092">Można pobrać wartość <xref:System.Type.IsCOMObject%2A> właściwości w celu określenia, czy typ zwracany przez tę metodę jest obiektem COM.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3092">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="9cc50-3093">Możesz wywołać <xref:System.Type.GetTypeFromProgID%2A> metody z późnym wiązaniem dostępu do modelu COM obiekty, których identyfikator programowy (ProgID) wiadomo.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3093">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="9cc50-3094">Utworzenie wystąpienia niezarządzanych obiektu modelu COM z jego identyfikator CLSID jest procesem dwuetapowym:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3094">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="9cc50-3095">Pobierz <xref:System.Type> obiekt, który reprezentuje `__ComObject` , który odpowiada identyfikator CLSID, wywołując <xref:System.Type.GetTypeFromCLSID%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3095">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="9cc50-3096">Wywołaj <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metodę, aby utworzyć wystąpienie obiektu COM.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3096">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3097">W poniższym przykładzie użyto identyfikator CLSID programu Microsoft Word [obiekt aplikacji](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) można pobrać typu modelu COM, który reprezentuje aplikację Microsoft Word z serwerem o nazwie computer17.central.contoso.com.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3097">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com.</span></span> <span data-ttu-id="9cc50-3098">Następnie tworzy wystąpienie typu przez wywołanie metody <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metody i zamyka te błędy, wywołując [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3098">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="9cc50-3099">Ta metoda jest przeznaczona do użycia podczas pracy z obiektami COM, a nie z obiektami .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3099">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="9cc50-3100">Wszystkie zarządzane obiekty, w tym te, które są widoczne dla modelu COM (oznacza to, że ich <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atrybut jest <see langword="true" />) ma identyfikator GUID, który jest zwracany przez <see cref="P:System.Type.GUID" /> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3100">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="9cc50-3101">Mimo że metoda zwraca <see cref="T:System.Type" /> obiektów obiekt, który odnosi się do identyfikatora GUID dla programu .NET Framework, nie można użyć, które <see cref="T:System.Type" /> obiektu do utworzenia wystąpienia typu przez wywołanie metody <see cref="M:System.Activator.CreateInstance(System.Type)" /> metody, jak w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3101">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="9cc50-3102">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="9cc50-3102">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="9cc50-3103">Zamiast tego <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> powinna służyć wyłącznie do pobrania identyfikatora GUID niezarządzanych obiektów COM i wynikowy <see cref="T:System.Type" /> obiekt, który jest przekazywany do <see cref="M:System.Activator.CreateInstance(System.Type)" /> metody musi reprezentować obiekt COM niezarządzanych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3103">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="9cc50-3104">Identyfikator CLSID typu, który można pobrać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3104">The CLSID of the type to get.</span></span></param>
        <param name="server"><span data-ttu-id="9cc50-3105">Serwer, z którego można załadować typ.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3105">The server from which to load the type.</span></span> <span data-ttu-id="9cc50-3106">Jeśli nazwa serwera jest <see langword="null" />, ta metoda zostanie automatycznie przywrócona do komputera lokalnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3106">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="9cc50-3107"><see langword="true" /> Umożliwia zgłoszenie każdego wyjątku, który występuje.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3107"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="9cc50-3108">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3108">-or-</span></span> 
 <span data-ttu-id="9cc50-3109"><see langword="false" /> umożliwia zignorowanie każdego wyjątku, który występuje.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3109"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="9cc50-3110">Pobiera typ ze skojarzonym identyfikatorem określonej klasy (CLSID) z określonego serwera w określeniu, czy zgłosić wyjątek, jeśli wystąpi błąd podczas ładowania typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3110">Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3111"><see langword="System.__ComObject" /> niezależnie od tego, czy identyfikator CLSID jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3111"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3112"><xref:System.Type.GetTypeFromCLSID%2A> Metoda obsługuje dostęp z późnym wiązaniem do niezarządzanych obiektów COM z aplikacji .NET Framework, gdy wiesz identyfikator klasy obiektu COM (CLSID).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3112">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="9cc50-3113">Identyfikator klasy dla klasy COM jest zdefiniowany w kluczu HKEY_CLASSES_ROOT\CLSID rejestru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3113">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="9cc50-3114">Można pobrać wartość <xref:System.Type.IsCOMObject%2A> właściwości w celu określenia, czy typ zwracany przez tę metodę jest obiektem COM.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3114">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="9cc50-3115">Możesz wywołać <xref:System.Type.GetTypeFromProgID%2A> metody z późnym wiązaniem dostępu do modelu COM obiekty, których identyfikator programowy (ProgID) wiadomo.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3115">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="9cc50-3116">Utworzenie wystąpienia niezarządzanych obiektu modelu COM z jego identyfikator CLSID jest procesem dwuetapowym:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3116">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="9cc50-3117">Pobierz <xref:System.Type> obiekt, który reprezentuje `__ComObject` , który odpowiada identyfikator CLSID, wywołując <xref:System.Type.GetTypeFromCLSID%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3117">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="9cc50-3118">Wywołaj <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metodę, aby utworzyć wystąpienie obiektu COM.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3118">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="9cc50-3119">Wyjątki, takie jak <xref:System.OutOfMemoryException> zostanie zgłoszony podczas określania `true` dla `throwOnError`, ale zakończy się niepowodzeniem dla niezarejestrowanych CLSID.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3119">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3120">W poniższym przykładzie użyto identyfikator CLSID programu Microsoft Word [obiekt aplikacji](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) można pobrać typu modelu COM, który reprezentuje aplikację Microsoft Word z serwerem o nazwie computer17.central.contoso.com.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3120">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com.</span></span> <span data-ttu-id="9cc50-3121">Następnie tworzy wystąpienie typu przez wywołanie metody <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metody i zamyka te błędy, wywołując [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3121">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span> <span data-ttu-id="9cc50-3122">Wyjątek jest generowany, jeśli wystąpi błąd podczas ładowania typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3122">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="9cc50-3123">Ta metoda jest przeznaczona do użycia podczas pracy z obiektami COM, a nie z obiektami .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3123">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="9cc50-3124">Wszystkie zarządzane obiekty, w tym te, które są widoczne dla modelu COM (oznacza to, że ich <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atrybut jest <see langword="true" />) ma identyfikator GUID, który jest zwracany przez <see cref="P:System.Type.GUID" /> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3124">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="9cc50-3125">Mimo że <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> metoda zwraca <see cref="T:System.Type" /> obiekt, który odnosi się do identyfikatora GUID dla konkretnego obiektu zarządzanego nie można użyć, które <see cref="T:System.Type" /> obiektu do utworzenia wystąpienia typu przez wywołanie metody <see cref="M:System.Activator.CreateInstance(System.Type)" /> metody, jak w poniższym przykładzie pojawi się.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3125">Although the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for a particular managed object, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="9cc50-3126">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="9cc50-3126">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="9cc50-3127">Zamiast tego <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> powinna służyć wyłącznie do pobrania identyfikatora GUID niezarządzanych obiektów COM i wynikowy <see cref="T:System.Type" /> obiekt, który jest przekazywany do <see cref="M:System.Activator.CreateInstance(System.Type)" /> metody musi reprezentować obiekt COM niezarządzanych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3127">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="9cc50-3128">Obiekt, który odwołuje się do typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3128">The object that refers to the type.</span></span></param>
        <summary><span data-ttu-id="9cc50-3129">Pobiera typ przywoływany przez dojście do określonego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3129">Gets the type referenced by the specified type handle.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3130">Typ odwołuje się określony <see cref="T:System.RuntimeTypeHandle" />, lub <see langword="null" /> Jeśli <see cref="P:System.RuntimeTypeHandle.Value" /> właściwość <paramref name="handle" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3130">The type referenced by the specified <see cref="T:System.RuntimeTypeHandle" />, or <see langword="null" /> if the <see cref="P:System.RuntimeTypeHandle.Value" /> property of <paramref name="handle" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3131">Uchwyty są prawidłowe tylko w domenie aplikacji, w którym zostały uzyskane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3131">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3132">W poniższym przykładzie użyto <xref:System.Type.GetTypeFromHandle%2A> metodę, aby uzyskać <xref:System.Type> obiektu z <xref:System.RuntimeTypeHandle> dostarczone przez <xref:System.Type.GetTypeHandle%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3132">The following example uses the <xref:System.Type.GetTypeFromHandle%2A> method to get a <xref:System.Type> object from a <xref:System.RuntimeTypeHandle> provided by the <xref:System.Type.GetTypeHandle%2A> method.</span></span>  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="9cc50-3133">Inicjator klasy jest wywoływany i zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3133">A class initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cc50-3134">Pobiera typ skojarzony z identyfikatorem określony program (ProgID).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3134">Gets the type associated with the specified program identifier (ProgID).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="9cc50-3135">Identyfikator ProgID typ do pobrania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3135">The ProgID of the type to get.</span></span></param>
        <summary><span data-ttu-id="9cc50-3136">Pobiera typ ze skojarzonym identyfikatorem określony program (ProgID), zwracając wartość null, jeśli napotka błąd podczas ładowania <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3136">Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3137">Typ skojarzoną z określonym identyfikatorem ProgID, jeśli <paramref name="progID" /> jest prawidłowego wpisu w rejestrze, a typem jest z nią skojarzona; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3137">The type associated with the specified ProgID, if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3138">Ta metoda umożliwia obsługę COM.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3138">This method is provided for COM support.</span></span> <span data-ttu-id="9cc50-3139">ProgID nie są używane w Microsoft .NET Framework, ponieważ zostały zastąpione przez koncepcji przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3139">ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-3140"><paramref name="progID" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3140"><paramref name="progID" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="9cc50-3141">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3141">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="9cc50-3142">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3142">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="9cc50-3143">Identyfikator ProgID typ do pobrania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3143">The ProgID of the type to get.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="9cc50-3144"><see langword="true" /> Umożliwia zgłoszenie każdego wyjątku, który występuje.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3144"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="9cc50-3145">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3145">-or-</span></span> 
 <span data-ttu-id="9cc50-3146"><see langword="false" /> umożliwia zignorowanie każdego wyjątku, który występuje.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3146"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="9cc50-3147">Pobiera typ ze skojarzonym identyfikatorem określony program (ProgID) określająca, czy zgłosić wyjątek, jeśli wystąpi błąd podczas ładowania typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3147">Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3148">Typ skojarzony z identyfikatorem określony program (ProgID), jeśli <paramref name="progID" /> jest prawidłowego wpisu w rejestrze, a typem jest z nią skojarzona; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3148">The type associated with the specified program identifier (ProgID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3149">Ta metoda umożliwia obsługę COM.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3149">This method is provided for COM support.</span></span> <span data-ttu-id="9cc50-3150">Identyfikatorów programu nie są używane w programie Microsoft .NET Framework, ponieważ zostały zastąpione przez koncepcji przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3150">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3151">Poniższy przykład pobiera typ, przekazując ProgID, określająca, czy zgłosić wyjątek, jeśli identyfikator ProgID jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3151">The following example retrieves a type by passing a ProgID, specifying whether to throw an exception if the ProgID is invalid.</span></span> <span data-ttu-id="9cc50-3152">Przykład następnie wyświetla identyfikator klasy związane z ProgID, wraz z dowolnego komunikat o wyjątku dotyczy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3152">The example then displays the ClassID related to the ProgID, along with any applicable exception message.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-3153"><paramref name="progID" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3153"><paramref name="progID" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="9cc50-3154">Określony identyfikator ProgID nie jest zarejestrowany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3154">The specified ProgID is not registered.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="9cc50-3155">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3155">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="9cc50-3156">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3156">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="9cc50-3157">ProgID typ do pobrania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3157">The progID of the type to get.</span></span></param>
        <param name="server"><span data-ttu-id="9cc50-3158">Serwer, z którego można załadować typ.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3158">The server from which to load the type.</span></span> <span data-ttu-id="9cc50-3159">Jeśli nazwa serwera jest <see langword="null" />, ta metoda zostanie automatycznie przywrócona do komputera lokalnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3159">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <summary><span data-ttu-id="9cc50-3160">Pobiera typ ze skojarzonym identyfikatorem określony program (progID) z określonego serwera, zwracając wartość null, jeśli wystąpił błąd podczas ładowania typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3160">Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3161">Typ skojarzony z identyfikatorem określony program (progID), jeśli <paramref name="progID" /> jest prawidłowego wpisu w rejestrze, a typem jest z nią skojarzona; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3161">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3162">Ta metoda umożliwia obsługę COM.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3162">This method is provided for COM support.</span></span> <span data-ttu-id="9cc50-3163">Identyfikatorów programu nie są używane w programie Microsoft .NET Framework, ponieważ zostały zastąpione przez koncepcji przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3163">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3164">Poniższy przykład pobiera typ, przekazując ProgID i nazwę serwera.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3164">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="9cc50-3165">Przykład następnie wyświetla identyfikator klasy związane z identyfikator ProgID lub zgłasza wyjątek, jeśli identyfikator ProgID lub nazwa serwera jest nieprawidłowa.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3165">The example then displays the ClassID related to the ProgID, or throws an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-3166"><paramref name="prodID" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3166"><paramref name="prodID" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="9cc50-3167">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3167">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="9cc50-3168">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3168">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="9cc50-3169">ProgID <see cref="T:System.Type" /> można pobrać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3169">The progID of the <see cref="T:System.Type" /> to get.</span></span></param>
        <param name="server"><span data-ttu-id="9cc50-3170">Serwer, z którego można załadować typ.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3170">The server from which to load the type.</span></span> <span data-ttu-id="9cc50-3171">Jeśli nazwa serwera jest <see langword="null" />, ta metoda zostanie automatycznie przywrócona do komputera lokalnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3171">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="9cc50-3172"><see langword="true" /> Umożliwia zgłoszenie każdego wyjątku, który występuje.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3172"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="9cc50-3173">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3173">-or-</span></span> 
 <span data-ttu-id="9cc50-3174"><see langword="false" /> umożliwia zignorowanie każdego wyjątku, który występuje.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3174"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="9cc50-3175">Pobiera typ ze skojarzonym identyfikatorem określony program (progID) z określonego serwera w określeniu, czy zgłosić wyjątek, jeśli wystąpi błąd podczas ładowania typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3175">Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3176">Typ skojarzony z identyfikatorem określony program (progID), jeśli <paramref name="progID" /> jest prawidłowego wpisu w rejestrze, a typem jest z nią skojarzona; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3176">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3177">Ta metoda umożliwia obsługę COM.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3177">This method is provided for COM support.</span></span> <span data-ttu-id="9cc50-3178">Identyfikatorów programu nie są używane w programie Microsoft .NET Framework, ponieważ zostały zastąpione przez koncepcji przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3178">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3179">Poniższy przykład pobiera typ, przekazując ProgID i nazwę serwera.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3179">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="9cc50-3180">Przykład następnie wyświetla identyfikator klasy związane z ProgID, określająca, czy zgłosić wyjątek, jeśli identyfikator ProgID lub nazwa serwera jest nieprawidłowa.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3180">The example then displays the ClassID related to the ProgID, specifying whether to throw an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-3181"><paramref name="progID" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3181"><paramref name="progID" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="9cc50-3182">Określony identyfikator progID nie jest zarejestrowany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3182">The specified progID is not registered.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="9cc50-3183">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3183">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="9cc50-3184">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3184">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="9cc50-3185">Obiekt, dla którego można pobrać typu obsługi.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3185">The object for which to get the type handle.</span></span></param>
        <summary><span data-ttu-id="9cc50-3186">Pobiera uchwytu <see cref="T:System.Type" /> określonego obiektu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3186">Gets the handle for the <see cref="T:System.Type" /> of a specified object.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3187">Dojście do <see cref="T:System.Type" /> określonego <see cref="T:System.Object" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3187">The handle for the <see cref="T:System.Type" /> of the specified <see cref="T:System.Object" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3188">Uchwyty są prawidłowe tylko w domenie aplikacji, w którym zostały uzyskane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3188">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3189">W poniższym przykładzie zdefiniowano klasę `MyClass1`, pobiera jego wystąpienie i pobiera uchwyt środowiska uruchomieniowego obiektu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3189">The following example defines the class `MyClass1`, gets an instance of it, and retrieves the runtime handle of the object.</span></span>  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-3190"><paramref name="o" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3190"><paramref name="o" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3191">Pobiera identyfikator GUID skojarzony z <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3191">Gets the GUID associated with the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="9cc50-3192">Identyfikator GUID skojarzony z <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3192">The GUID associated with the <see cref="T:System.Type" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3193">Identyfikator GUID jest skojarzony z typu przy użyciu <xref:System.Runtime.InteropServices.GuidAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3193">A GUID is associated with a type using the <xref:System.Runtime.InteropServices.GuidAttribute> attribute.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3194">Poniższy przykład tworzy klasę `MyClass1` w metodę publiczną, tworzy `Type` obiekt odpowiadający `MyClass1`i pobiera <xref:System.Guid> struktury za pomocą `GUID` właściwość `Type` klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3194">The following example creates the class `MyClass1` with a public method, creates a `Type` object corresponding to `MyClass1`, and gets the <xref:System.Guid> structure using the `GUID` property of the `Type` class.</span></span>  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3195">Pobiera wartość wskazującą czy bieżący <see cref="T:System.Type" /> obejmuje lub odwołuje się do innego typu; który jest, czy bieżący <see cref="T:System.Type" /> jest tablicą, wskaźnik, lub jest przekazywany przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3195">Gets a value indicating whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span></span></summary>
        <value><span data-ttu-id="9cc50-3196"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest tablicą, wskaźnik, lub jest przekazywany przez odwołanie; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3196"><see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3197">Na przykład Type.GetType("Int32[]"). Zwraca HasElementType `true`, ale Type.GetType("Int32"). Zwraca HasElementType `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3197">For example, Type.GetType("Int32[]").HasElementType returns `true`, but Type.GetType("Int32").HasElementType returns `false`.</span></span> <span data-ttu-id="9cc50-3198">Zwraca także HasElementType `true` dla "Int32 \*" i "Int32 &".</span><span class="sxs-lookup"><span data-stu-id="9cc50-3198">HasElementType also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
 <span data-ttu-id="9cc50-3199">Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny lub parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3199">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3200">Poniższy przykład zwraca `true` lub `false` w zależności od tego, czy obiekt jest tablicą, typu odwołania lub wskaźnik.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3200">The following example returns `true` or `false` depending on whether or not the object is an array, a reference type, or a pointer.</span></span>  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-3201">W przypadku przesłonięcia w klasie pochodnej, implementuje <see cref="P:System.Type.HasElementType" /> właściwości i określa, czy bieżący <see cref="T:System.Type" /> obejmuje lub odwołuje się do innego typu; który jest, czy bieżący <see cref="T:System.Type" /> jest tablicą, wskaźnik, lub jest przekazywany przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3201">When overridden in a derived class, implements the <see cref="P:System.Type.HasElementType" /> property and determines whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3202"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest tablicą, wskaźnik, lub jest przekazywany przez odwołanie; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3202"><see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3203">Na przykład Type.GetType("Int32[]"). Zwraca HasElementTypeImpl `true`, ale Type.GetType("Int32"). Zwraca HasElementTypeImpl `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3203">For example, Type.GetType("Int32[]").HasElementTypeImpl returns `true`, but Type.GetType("Int32").HasElementTypeImpl returns `false`.</span></span> <span data-ttu-id="9cc50-3204">Zwraca także HasElementTypeImpl `true` dla "Int32 \*" i "Int32 &".</span><span class="sxs-lookup"><span data-stu-id="9cc50-3204">HasElementTypeImpl also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3205">W poniższym przykładzie zdefiniowano klasę `MyTypeDelegator`, co zastępuje `HasElementTypeImpl` metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3205">The following example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="9cc50-3206">Sprawdza, czy główna klasa `HasElementType` właściwości i wyświetla typ elementu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3206">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cc50-3207">Wywołuje określonego członka bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3207">Invokes a specific member of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-3208">Ciąg zawierający nazwę konstruktora, metody, właściwości lub pól członka do wywołania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3208">The string containing the name of the constructor, method, property, or field member to invoke.</span></span>  
  
<span data-ttu-id="9cc50-3209">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3209">-or-</span></span> 
<span data-ttu-id="9cc50-3210">Ciąg pusty ("") do wywołania domyślny element członkowski.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3210">An empty string ("") to invoke the default member.</span></span>  
  
<span data-ttu-id="9cc50-3211">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3211">-or-</span></span> 
<span data-ttu-id="9cc50-3212">Aby uzyskać <see langword="IDispatch" /> członków, ciąg reprezentujący identyfikator DispID, na przykład "[identyfikator DispID = 3]".</span><span class="sxs-lookup"><span data-stu-id="9cc50-3212">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="9cc50-3213">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3213">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span> <span data-ttu-id="9cc50-3214">Dostęp może być jednym z <see langword="BindingFlags" /> takich jak <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3214">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span></span> <span data-ttu-id="9cc50-3215">Typ wyszukiwania nie muszą być określane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3215">The type of lookup need not be specified.</span></span> <span data-ttu-id="9cc50-3216">W przypadku pominięcia typ wyszukiwania <see langword="BindingFlags.Public" />  |  <see langword="BindingFlags.Instance" />  |  <see langword="BindingFlags.Static" /> są używane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3216">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span></span></param>
        <param name="binder"><span data-ttu-id="9cc50-3217">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3217">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="9cc50-3218">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3218">-or-</span></span> 
<span data-ttu-id="9cc50-3219">Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3219">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span> <span data-ttu-id="9cc50-3220">Należy pamiętać, że jawne określenie <see cref="T:System.Reflection.Binder" /> obiekt może być wymagane dla pomyślnie wywołanie przeciążenia metody ze zmiennymi argumentami.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3220">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span></span></param>
        <param name="target"><span data-ttu-id="9cc50-3221">Obiekt do wywołania określonego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3221">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="9cc50-3222">Tablica zawierająca argumenty do przekazania do składowej na potrzeby wywołania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3222">An array containing the arguments to pass to the member to invoke.</span></span></param>
        <summary><span data-ttu-id="9cc50-3223">Wywołuje określony element członkowski, dopasowanie określoną listę argumentów i za pomocą ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3223">Invokes the specified member, using the specified binding constraints and matching the specified argument list.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3224">Obiekt reprezentujący wartość zwracaną wywołanego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3224">An object representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-3225">Nie można użyć <xref:System.Type.InvokeMember%2A> do wywoływania metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3225">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="9cc50-3226">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania elementów członkowskich, które można uwzględnić w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3226">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-3227">Określ `BindingFlags.Public` obejmujący publiczne elementy członkowskie w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3227">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-3228">Określ `BindingFlags.NonPublic` obejmujący elementów członkowskich niepublicznych (czyli prywatnych i chronionych elementów członkowskich) w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3228">Specify `BindingFlags.NonPublic` to include non-public members (that is, private and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-3229">Określ `BindingFlags.FlattenHierarchy` obejmujący statyczne elementy członkowskie w hierarchii.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3229">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="9cc50-3230">Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3230">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="9cc50-3231">`BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3231">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="9cc50-3232">`BindingFlags.DeclaredOnly` Aby wyszukać tylko do elementów członkowskich zadeklarowanych w <xref:System.Type>, nie elementów członkowskich, które zostały po prostu odziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3232">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="9cc50-3233">Następujące <xref:System.Reflection.BindingFlags> flagi wywołania może służyć do określenia, jaką akcję należy podjąć przy użyciu elementu członkowskiego:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3233">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="9cc50-3234">`CreateInstance` Aby wywołać konstruktora.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3234">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="9cc50-3235">`name` jest ignorowany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3235">`name` is ignored.</span></span> <span data-ttu-id="9cc50-3236">Nieprawidłowy inne flagi wywołania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3236">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="9cc50-3237">`InvokeMethod` do wywołania metody, ale nie konstruktorze lub inicjatorze typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3237">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="9cc50-3238">Nie jest prawidłowy z `SetField` lub `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3238">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="9cc50-3239">Jeśli `InvokeMethod` jest określony przez siebie, `BindingFlags.Public`, `BindingFlags.Instance`, i `BindingFlags.Static` są automatycznie dołączane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3239">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="9cc50-3240">`GetField` można pobrać wartości pola.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3240">`GetField` to get the value of a field.</span></span> <span data-ttu-id="9cc50-3241">Nie jest prawidłowy z `SetField`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3241">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="9cc50-3242">`SetField` można ustawić wartości pola.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3242">`SetField` to set the value of a field.</span></span> <span data-ttu-id="9cc50-3243">Nie jest prawidłowy z `GetField`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3243">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="9cc50-3244">`GetProperty` można pobrać właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3244">`GetProperty` to get a property.</span></span> <span data-ttu-id="9cc50-3245">Nie jest prawidłowy z `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3245">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="9cc50-3246">`SetProperty` można ustawić właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3246">`SetProperty` to set a property.</span></span> <span data-ttu-id="9cc50-3247">Nie jest prawidłowy z `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3247">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="9cc50-3248">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3248">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="9cc50-3249">Metoda zostanie wywołana, jeśli są spełnione oba poniższe warunki:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3249">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="9cc50-3250">Liczba parametrów w deklaracji metody jest równa liczbie argumentów `args` tablicy (chyba że argumenty domyślne są zdefiniowane w składowej i `BindingFlags.OptionalParamBinding` jest określony).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3250">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="9cc50-3251">Typ każdego argumentu mogą być konwertowane przez binder typowi parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3251">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="9cc50-3252">Obiekt wiążący znajdzie wszystkie metody dopasowania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3252">The binder will find all of the matching methods.</span></span> <span data-ttu-id="9cc50-3253">Te metody zostaną znalezione, oparte na typie powiązania żądane (<xref:System.Reflection.BindingFlags> wartości `InvokeMethod`, `GetProperty`i tak dalej).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3253">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="9cc50-3254">Zestaw metod są filtrowane według nazwy, liczba argumentów i zestaw modyfikatorów wyszukiwania zdefiniowane w obiekt wiążący.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3254">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="9cc50-3255">Po wybraniu metody jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3255">After the method is selected, it is invoked.</span></span> <span data-ttu-id="9cc50-3256">Dostępność jest sprawdzana w tym momencie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3256">Accessibility is checked at that point.</span></span> <span data-ttu-id="9cc50-3257">Wyszukiwanie może kontrolować, które zestaw metod, przeszukiwane są na podstawie atrybutu ułatwień dostępu powiązany z metodą.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3257">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="9cc50-3258"><xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Metody <xref:System.Reflection.Binder> klasy jest odpowiedzialny za wybranie wywoływanej metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3258">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="9cc50-3259">Domyślny integrator wybiera najbardziej określonego dopasowania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3259">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="9cc50-3260">Ograniczenia dostępu są ignorowane w przypadku w pełni zaufany kod; oznacza to, konstruktory prywatne, metody, pola i właściwości mogą być dostępne i wywoływane za pośrednictwem <xref:System.Reflection> zawsze, gdy kod jest w pełni zaufany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3260">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="9cc50-3261">Możesz użyć `Type.InvokeMember` można ustawić pola na określoną wartość, określając <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3261">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cc50-3262">Na przykład, jeśli chcesz ustawić pole publiczne wystąpienia o nazwie F klasy C i F jest `String`, można użyć kodu takiego jak:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3262">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 <span data-ttu-id="9cc50-3263">Jeśli jest F `String[]`, można użyć kodu takiego jak:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3263">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 <span data-ttu-id="9cc50-3264">która zainicjuje pole F do tej nowej tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3264">which will initialize the field F to this new array.</span></span> <span data-ttu-id="9cc50-3265">Można również użyć `Type.InvokeMember` próba ustawienia pozycji w tablicy, podając indeks wartości, a następnie wartość następnego przy użyciu następującego kodu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3265">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 <span data-ttu-id="9cc50-3266">Spowoduje to zmianę w tablicy, która F zawiera ciąg "b", ciąg "z".</span><span class="sxs-lookup"><span data-stu-id="9cc50-3266">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="9cc50-3267">Gdy wywołujesz `IDispatch` elementu członkowskiego, możesz określić identyfikator DispID zamiast nazwy elementu członkowskiego, używając formatu ciągu "[identyfikator DispID = ##]".</span><span class="sxs-lookup"><span data-stu-id="9cc50-3267">When you invoke an `IDispatch` member, you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="9cc50-3268">Na przykład, jeśli identyfikator DispID MyComMethod wynosi 3, możesz określić ciąg "[identyfikator DispID = 3]" zamiast "MyComMethod".</span><span class="sxs-lookup"><span data-stu-id="9cc50-3268">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="9cc50-3269">Wywoływanie składowej przez identyfikator DispID jest szybsze niż Wyszukiwanie elementu członkowskiego według nazwy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3269">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="9cc50-3270">W scenariuszach złożoną agregację DispID czasami jest jedynym sposobem, aby wywołać żądanego elementu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3270">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-3271">Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do dostępu do elementów członkowskich niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga, a jeśli zestaw uprawnień elementów członkowskich niepublicznych jest ograniczony do obiektu wywołującego przyznania zestawu lub być podzbiorem jej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3271">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="9cc50-3272">(Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="9cc50-3272">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="9cc50-3273">Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3273">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3274">W poniższym przykładzie użyto `InvokeMember` do dostępu do elementów członkowskich typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3274">The following example uses `InvokeMember` to access members of a type.</span></span>  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-3275"><paramref name="invokeAttr" /> nie zawiera <see langword="CreateInstance" /> i <paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3275"><paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-3276"><paramref name="invokeAttr" /> nie jest prawidłowym <see cref="T:System.Reflection.BindingFlags" /> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3276"><paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span></span>  
  
<span data-ttu-id="9cc50-3277">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3277">-or-</span></span> 
 <span data-ttu-id="9cc50-3278"><paramref name="invokeAttr" /> nie zawiera jedną z następujących flag powiązania: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, lub <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3278"><paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="9cc50-3279">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3279">-or-</span></span> 
 <span data-ttu-id="9cc50-3280"><paramref name="invokeAttr" /> zawiera <see langword="CreateInstance" /> w połączeniu z <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, lub <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3280"><paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="9cc50-3281">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3281">-or-</span></span> 
 <span data-ttu-id="9cc50-3282"><paramref name="invokeAttr" /> zawiera zarówno <see langword="GetField" /> i <see langword="SetField" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3282"><paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span></span>  
  
<span data-ttu-id="9cc50-3283">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3283">-or-</span></span> 
 <span data-ttu-id="9cc50-3284"><paramref name="invokeAttr" /> zawiera zarówno <see langword="GetProperty" /> i <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3284"><paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="9cc50-3285">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3285">-or-</span></span> 
 <span data-ttu-id="9cc50-3286"><paramref name="invokeAttr" /> zawiera <see langword="InvokeMethod" /> w połączeniu z <see langword="SetField" /> lub <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3286"><paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="9cc50-3287">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3287">-or-</span></span> 
 <span data-ttu-id="9cc50-3288"><paramref name="invokeAttr" /> zawiera <see langword="SetField" /> i <paramref name="args" /> ma więcej niż jeden element.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3288"><paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span></span>  
  
<span data-ttu-id="9cc50-3289">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3289">-or-</span></span> 
<span data-ttu-id="9cc50-3290">Ta metoda jest wywoływana dla obiektu COM i jedną z następujących flag powiązania nie przekazano: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, lub <see langword="BindingFlags.PutRefDispProperty" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3290">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span></span>  
  
<span data-ttu-id="9cc50-3291">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3291">-or-</span></span> 
<span data-ttu-id="9cc50-3292">Jedna z nich tablic nazwany parametr zawiera ciąg, który jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3292">One of the named parameter arrays contains a string that is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="9cc50-3293">Określony element członkowski jest inicjator klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3293">The specified member is a class initializer.</span></span></exception>
        <exception cref="T:System.MissingFieldException"><span data-ttu-id="9cc50-3294">Nie można odnaleźć pola lub właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3294">The field or property cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="9cc50-3295">Brak metody można znaleźć odpowiadającej argumentów <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3295">No method can be found that matches the arguments in <paramref name="args" />.</span></span>  
  
<span data-ttu-id="9cc50-3296">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3296">-or-</span></span> 
<span data-ttu-id="9cc50-3297">Bieżący <see cref="T:System.Type" /> obiekt reprezentuje typ, który zawiera parametry typu otwartego, czyli <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3297">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="9cc50-3298">Nie można wywołać określonego elementu członkowskiego <paramref name="target" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3298">The specified member cannot be invoked on <paramref name="target" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="9cc50-3299">Więcej niż jednej metody odpowiadającego kryteriom powiązania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3299">More than one method matches the binding criteria.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cc50-3300">.NET Compact Framework nie obsługuje obecnie tej metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3300">The .NET Compact Framework does not currently support this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cc50-3301">Metody reprezentowanej przez <paramref name="name" /> ma jeden lub więcej określonych parametrów typu rodzajowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3301">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span></span> <span data-ttu-id="9cc50-3302">Oznacza to, że metody <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> właściwość zwraca <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3302">That is, the method's <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="9cc50-3303">W celu uzyskiwania dostępu do elementów członkowskich niepublicznych, niezależnie od ich zestawu uprawnień.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3303">for accessing non-public members regardless of their grant set.</span></span> <span data-ttu-id="9cc50-3304">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="9cc50-3304">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="9cc50-3305">Aby wywoływać kod niezarządzany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3305">to call unmanaged code.</span></span> <span data-ttu-id="9cc50-3306">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="9cc50-3306">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-3307">Ciąg zawierający nazwę konstruktora, metody, właściwości lub pól członka do wywołania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3307">The string containing the name of the constructor, method, property, or field member to invoke.</span></span>  
  
<span data-ttu-id="9cc50-3308">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3308">-or-</span></span> 
<span data-ttu-id="9cc50-3309">Ciąg pusty ("") do wywołania domyślny element członkowski.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3309">An empty string ("") to invoke the default member.</span></span>  
  
<span data-ttu-id="9cc50-3310">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3310">-or-</span></span> 
<span data-ttu-id="9cc50-3311">Aby uzyskać <see langword="IDispatch" /> członków, ciąg reprezentujący identyfikator DispID, na przykład "[identyfikator DispID = 3]".</span><span class="sxs-lookup"><span data-stu-id="9cc50-3311">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="9cc50-3312">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3312">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span> <span data-ttu-id="9cc50-3313">Dostęp może być jednym z <see langword="BindingFlags" /> takich jak <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3313">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span></span> <span data-ttu-id="9cc50-3314">Typ wyszukiwania nie muszą być określane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3314">The type of lookup need not be specified.</span></span> <span data-ttu-id="9cc50-3315">W przypadku pominięcia typ wyszukiwania <see langword="BindingFlags.Public" />  |  <see langword="BindingFlags.Instance" />  |  <see langword="BindingFlags.Static" /> są używane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3315">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span></span></param>
        <param name="binder"><span data-ttu-id="9cc50-3316">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3316">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="9cc50-3317">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3317">-or-</span></span> 
<span data-ttu-id="9cc50-3318">Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3318">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span> <span data-ttu-id="9cc50-3319">Należy pamiętać, że jawne określenie <see cref="T:System.Reflection.Binder" /> obiekt może być wymagane dla pomyślnie wywołanie przeciążenia metody ze zmiennymi argumentami.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3319">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span></span></param>
        <param name="target"><span data-ttu-id="9cc50-3320">Obiekt do wywołania określonego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3320">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="9cc50-3321">Tablica zawierająca argumenty do przekazania do składowej na potrzeby wywołania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3321">An array containing the arguments to pass to the member to invoke.</span></span></param>
        <param name="culture"><span data-ttu-id="9cc50-3322">Obiekt reprezentujący globalizacji ustawienia regionalne, które będą niezbędne do konwersji specyficzne dla ustawień regionalnych, takich jak konwertowanie liczbowych <see cref="T:System.String" /> do <see cref="T:System.Double" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3322">The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <see cref="T:System.String" /> to a <see cref="T:System.Double" />.</span></span>  
  
<span data-ttu-id="9cc50-3323">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3323">-or-</span></span> 
<span data-ttu-id="9cc50-3324">Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic) do użycia bieżący wątek <see cref="T:System.Globalization.CultureInfo" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3324">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span></span></param>
        <summary><span data-ttu-id="9cc50-3325">Wywołuje określony element członkowski, dopasowanie określoną listę argumentów i kultury i za pomocą ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3325">Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3326">Obiekt reprezentujący wartość zwracaną wywołanego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3326">An object representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3327">Mimo że domyślny integrator nie przetwarza <xref:System.Globalization.CultureInfo> ( `culture` parametru), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `culture`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3327">Although the default binder does not process <xref:System.Globalization.CultureInfo> (the `culture` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `culture`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-3328">Nie można użyć <xref:System.Type.InvokeMember%2A> do wywoływania metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3328">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="9cc50-3329">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania elementów członkowskich, które można uwzględnić w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3329">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-3330">Określ `BindingFlags.Public` obejmujący publiczne elementy członkowskie w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3330">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-3331">Określ `BindingFlags.NonPublic` obejmujący elementów członkowskich niepublicznych (czyli prywatne, wewnętrzne i chronione elementy członkowskie) w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3331">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-3332">Określ `BindingFlags.FlattenHierarchy` obejmujący statyczne elementy członkowskie w hierarchii.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3332">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="9cc50-3333">Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3333">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="9cc50-3334">`BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3334">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="9cc50-3335">`BindingFlags.DeclaredOnly` Aby wyszukać tylko do elementów członkowskich zadeklarowanych w <xref:System.Type>, nie elementów członkowskich, które zostały po prostu odziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3335">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="9cc50-3336">Następujące <xref:System.Reflection.BindingFlags> flagi wywołania może służyć do określenia, jaką akcję należy podjąć przy użyciu elementu członkowskiego:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3336">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="9cc50-3337">`CreateInstance` Aby wywołać konstruktora.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3337">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="9cc50-3338">`name` jest ignorowany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3338">`name` is ignored.</span></span> <span data-ttu-id="9cc50-3339">Nieprawidłowy inne flagi wywołania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3339">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="9cc50-3340">`InvokeMethod` do wywołania metody, ale nie konstruktorze lub inicjatorze typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3340">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="9cc50-3341">Nie jest prawidłowy z `SetField` lub `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3341">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="9cc50-3342">Jeśli `InvokeMethod` jest określony przez siebie, `BindingFlags.Public`, `BindingFlags.Instance`, i `BindingFlags.Static` są automatycznie dołączane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3342">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="9cc50-3343">`GetField` można pobrać wartości pola.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3343">`GetField` to get the value of a field.</span></span> <span data-ttu-id="9cc50-3344">Nie jest prawidłowy z `SetField`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3344">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="9cc50-3345">`SetField` można ustawić wartości pola.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3345">`SetField` to set the value of a field.</span></span> <span data-ttu-id="9cc50-3346">Nie jest prawidłowy z `GetField`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3346">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="9cc50-3347">`GetProperty` można pobrać właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3347">`GetProperty` to get a property.</span></span> <span data-ttu-id="9cc50-3348">Nie jest prawidłowy z `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3348">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="9cc50-3349">`SetProperty` można ustawić właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3349">`SetProperty` to set a property.</span></span> <span data-ttu-id="9cc50-3350">Nie jest prawidłowy z `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3350">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="9cc50-3351">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3351">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="9cc50-3352">Metoda zostanie wywołana, jeśli są spełnione oba poniższe warunki:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3352">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="9cc50-3353">Liczba parametrów w deklaracji metody jest równa liczbie argumentów `args` tablicy (chyba że argumenty domyślne są zdefiniowane w składowej i `BindingFlags.OptionalParamBinding` jest określony).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3353">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="9cc50-3354">Typ każdego argumentu mogą być konwertowane przez binder typowi parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3354">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="9cc50-3355">Obiekt wiążący znajdzie wszystkie metody dopasowania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3355">The binder will find all of the matching methods.</span></span> <span data-ttu-id="9cc50-3356">Te metody zostaną znalezione, oparte na typie powiązania żądane (<xref:System.Reflection.BindingFlags> wartości `InvokeMethod`, `GetProperty`i tak dalej).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3356">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="9cc50-3357">Zestaw metod są filtrowane według nazwy, liczba argumentów i zestaw modyfikatorów wyszukiwania zdefiniowane w obiekt wiążący.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3357">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="9cc50-3358">Po wybraniu metody jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3358">After the method is selected, it is invoked.</span></span> <span data-ttu-id="9cc50-3359">Dostępność jest sprawdzana w tym momencie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3359">Accessibility is checked at that point.</span></span> <span data-ttu-id="9cc50-3360">Wyszukiwanie może kontrolować, które zestaw metod, przeszukiwane są na podstawie atrybutu ułatwień dostępu powiązany z metodą.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3360">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="9cc50-3361"><xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Metody <xref:System.Reflection.Binder> klasy jest odpowiedzialny za wybranie wywoływanej metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3361">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="9cc50-3362">Domyślny integrator wybiera najbardziej określonego dopasowania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3362">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="9cc50-3363">Ograniczenia dostępu są ignorowane w przypadku w pełni zaufany kod; oznacza to, że konstruktory prywatne, metody, pola i właściwości umożliwia dostęp i wywoływany przez odbicie, zawsze wtedy, gdy kod jest w pełni zaufany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3363">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="9cc50-3364">Możesz użyć `Type.InvokeMember` można ustawić pola na określoną wartość, określając <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3364">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cc50-3365">Na przykład, jeśli chcesz ustawić pole publiczne wystąpienia o nazwie F klasy C i F jest `String` można użyć kodu takiego jak:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3365">For example, if you want to set a public instance field named F on class C, and F is a `String` you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 <span data-ttu-id="9cc50-3366">Jeśli jest F `String[]`, można użyć kodu takiego jak:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3366">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 <span data-ttu-id="9cc50-3367">która zainicjuje pole F do tej nowej tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3367">which will initialize the field F to this new array.</span></span> <span data-ttu-id="9cc50-3368">Można również użyć `Type.InvokeMember` próba ustawienia pozycji w tablicy, podając indeks wartości, a następnie wartość następnego przy użyciu następującego kodu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3368">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 <span data-ttu-id="9cc50-3369">Spowoduje to zmianę w tablicy, która F zawiera ciąg "b", ciąg "z".</span><span class="sxs-lookup"><span data-stu-id="9cc50-3369">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="9cc50-3370">Gdy wywołujesz `IDispatch` elementu członkowskiego, możesz określić identyfikator DispID zamiast nazwy elementu członkowskiego, używając formatu ciągu "[identyfikator DispID = ##]".</span><span class="sxs-lookup"><span data-stu-id="9cc50-3370">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="9cc50-3371">Na przykład, jeśli identyfikator DispID MyComMethod wynosi 3, możesz określić ciąg "[identyfikator DispID = 3]" zamiast "MyComMethod".</span><span class="sxs-lookup"><span data-stu-id="9cc50-3371">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="9cc50-3372">Wywoływanie składowej przez identyfikator DispID jest szybsze niż Wyszukiwanie elementu członkowskiego według nazwy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3372">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="9cc50-3373">W scenariuszach złożoną agregację DispID czasami jest jedynym sposobem, aby wywołać żądanego elementu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3373">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-3374">Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do dostępu do elementów członkowskich niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga, a jeśli zestaw uprawnień elementów członkowskich niepublicznych jest ograniczony do obiektu wywołującego przyznania zestawu lub być podzbiorem jej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3374">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="9cc50-3375">(Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="9cc50-3375">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="9cc50-3376">Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3376">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-3377"><paramref name="invokeAttr" /> nie zawiera <see langword="CreateInstance" /> i <paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3377"><paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-3378"><paramref name="invokeAttr" /> nie jest prawidłowym <see cref="T:System.Reflection.BindingFlags" /> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3378"><paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span></span>  
  
<span data-ttu-id="9cc50-3379">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3379">-or-</span></span> 
 <span data-ttu-id="9cc50-3380"><paramref name="invokeAttr" /> nie zawiera jedną z następujących flag powiązania: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, lub <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3380"><paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="9cc50-3381">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3381">-or-</span></span> 
 <span data-ttu-id="9cc50-3382"><paramref name="invokeAttr" /> zawiera <see langword="CreateInstance" /> w połączeniu z <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, lub <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3382"><paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="9cc50-3383">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3383">-or-</span></span> 
 <span data-ttu-id="9cc50-3384"><paramref name="invokeAttr" /> zawiera zarówno <see langword="GetField" /> i <see langword="SetField" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3384"><paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span></span>  
  
<span data-ttu-id="9cc50-3385">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3385">-or-</span></span> 
 <span data-ttu-id="9cc50-3386"><paramref name="invokeAttr" /> zawiera zarówno <see langword="GetProperty" /> i <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3386"><paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="9cc50-3387">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3387">-or-</span></span> 
 <span data-ttu-id="9cc50-3388"><paramref name="invokeAttr" /> zawiera <see langword="InvokeMethod" /> w połączeniu z <see langword="SetField" /> lub <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3388"><paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="9cc50-3389">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3389">-or-</span></span> 
 <span data-ttu-id="9cc50-3390"><paramref name="invokeAttr" /> zawiera <see langword="SetField" /> i <paramref name="args" /> ma więcej niż jeden element.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3390"><paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span></span>  
  
<span data-ttu-id="9cc50-3391">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3391">-or-</span></span> 
<span data-ttu-id="9cc50-3392">Ta metoda jest wywoływana dla obiektu COM i jedną z następujących flag powiązania nie przekazano: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, lub <see langword="BindingFlags.PutRefDispProperty" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3392">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span></span>  
  
<span data-ttu-id="9cc50-3393">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3393">-or-</span></span> 
<span data-ttu-id="9cc50-3394">Jedna z nich tablic nazwany parametr zawiera ciąg, który jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3394">One of the named parameter arrays contains a string that is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="9cc50-3395">Określony element członkowski jest inicjator klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3395">The specified member is a class initializer.</span></span></exception>
        <exception cref="T:System.MissingFieldException"><span data-ttu-id="9cc50-3396">Nie można odnaleźć pola lub właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3396">The field or property cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="9cc50-3397">Brak metody można znaleźć odpowiadającej argumentów <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3397">No method can be found that matches the arguments in <paramref name="args" />.</span></span>  
  
<span data-ttu-id="9cc50-3398">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3398">-or-</span></span> 
<span data-ttu-id="9cc50-3399">Bieżący <see cref="T:System.Type" /> obiekt reprezentuje typ, który zawiera parametry typu otwartego, czyli <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3399">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="9cc50-3400">Nie można wywołać określonego elementu członkowskiego <paramref name="target" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3400">The specified member cannot be invoked on <paramref name="target" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="9cc50-3401">Więcej niż jednej metody odpowiadającego kryteriom powiązania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3401">More than one method matches the binding criteria.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cc50-3402">Metody reprezentowanej przez <paramref name="name" /> ma jeden lub więcej określonych parametrów typu rodzajowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3402">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span></span> <span data-ttu-id="9cc50-3403">Oznacza to, że metody <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> właściwość zwraca <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3403">That is, the method's <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="9cc50-3404">W celu uzyskiwania dostępu do elementów członkowskich niepublicznych, niezależnie od ich zestawu uprawnień.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3404">for accessing non-public members regardless of their grant set.</span></span> <span data-ttu-id="9cc50-3405">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="9cc50-3405">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="9cc50-3406">Aby wywoływać kod niezarządzany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3406">to call unmanaged code.</span></span> <span data-ttu-id="9cc50-3407">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="9cc50-3407">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="namedParameters" Type="System.String[]" Index="7" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9cc50-3408">Ciąg zawierający nazwę konstruktora, metody, właściwości lub pól członka do wywołania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3408">The string containing the name of the constructor, method, property, or field member to invoke.</span></span>  
  
<span data-ttu-id="9cc50-3409">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3409">-or-</span></span> 
<span data-ttu-id="9cc50-3410">Ciąg pusty ("") do wywołania domyślny element członkowski.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3410">An empty string ("") to invoke the default member.</span></span>  
  
<span data-ttu-id="9cc50-3411">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3411">-or-</span></span> 
<span data-ttu-id="9cc50-3412">Aby uzyskać <see langword="IDispatch" /> członków, ciąg reprezentujący identyfikator DispID, na przykład "[identyfikator DispID = 3]".</span><span class="sxs-lookup"><span data-stu-id="9cc50-3412">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="9cc50-3413">Maska bitów składająca się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3413">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span> <span data-ttu-id="9cc50-3414">Dostęp może być jednym z <see langword="BindingFlags" /> takich jak <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3414">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span></span> <span data-ttu-id="9cc50-3415">Typ wyszukiwania nie muszą być określane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3415">The type of lookup need not be specified.</span></span> <span data-ttu-id="9cc50-3416">W przypadku pominięcia typ wyszukiwania <see langword="BindingFlags.Public" />  |  <see langword="BindingFlags.Instance" />  |  <see langword="BindingFlags.Static" /> są używane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3416">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span></span></param>
        <param name="binder"><span data-ttu-id="9cc50-3417">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3417">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="9cc50-3418">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3418">-or-</span></span> 
<span data-ttu-id="9cc50-3419">Odwołanie o wartości null (Nothing w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3419">A null reference (Nothing in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span> <span data-ttu-id="9cc50-3420">Należy pamiętać, że jawne określenie <see cref="T:System.Reflection.Binder" /> obiekt może być wymagane dla pomyślnie wywołanie przeciążenia metody ze zmiennymi argumentami.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3420">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span></span></param>
        <param name="target"><span data-ttu-id="9cc50-3421">Obiekt do wywołania określonego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3421">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="9cc50-3422">Tablica zawierająca argumenty do przekazania do składowej na potrzeby wywołania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3422">An array containing the arguments to pass to the member to invoke.</span></span></param>
        <param name="modifiers"><span data-ttu-id="9cc50-3423">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiednim elementem w <paramref name="args" /> tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3423">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="args" /> array.</span></span> <span data-ttu-id="9cc50-3424">Parametr skojarzonych z nimi atrybutów są przechowywane w podpisie elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3424">A parameter's associated attributes are stored in the member's signature.</span></span>  
  
<span data-ttu-id="9cc50-3425">Tylko wtedy, gdy wywołanie składnika modelu COM, domyślny integrator przetwarza tego parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3425">The default binder processes this parameter only when calling a COM component.</span></span></param>
        <param name="culture"><span data-ttu-id="9cc50-3426"><see cref="T:System.Globalization.CultureInfo" /> Obiekt reprezentujący globalizacji ustawienia regionalne, które mogą być konieczne w przypadku konwersji specyficzne dla ustawień regionalnych, takich jak konwertowanie ciągów liczbowych na wartość o podwójnej precyzji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3426">The <see cref="T:System.Globalization.CultureInfo" /> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</span></span>  
  
<span data-ttu-id="9cc50-3427">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3427">-or-</span></span> 
<span data-ttu-id="9cc50-3428">Odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic) do użycia bieżący wątek <see cref="T:System.Globalization.CultureInfo" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3428">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span></span></param>
        <param name="namedParameters"><span data-ttu-id="9cc50-3429">Tablica zawierająca nazwy parametrów, do której wartości w <paramref name="args" /> tablicy są przekazywane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3429">An array containing the names of the parameters to which the values in the <paramref name="args" /> array are passed.</span></span></param>
        <summary><span data-ttu-id="9cc50-3430">W przypadku przesłonięcia w klasie pochodnej, wywołuje określonego elementu członkowskiego, dopasowanie określoną listę argumentów, Modyfikatory i kultury i za pomocą ograniczeń w określonym powiązaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3430">When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3431">Obiekt reprezentujący wartość zwracaną wywołanego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3431">An object representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3432">`InvokeMember` wywołuje członek konstruktora lub metody, pobiera lub ustawia element właściwości, pobiera lub ustawia element członkowski pola danych lub pobiera lub ustawia element członkowski tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3432">`InvokeMember` calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-3433">Nie można użyć <xref:System.Type.InvokeMember%2A> do wywoływania metody rodzajowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3433">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="9cc50-3434">Gdy wywołujesz `IDispatch` elementu członkowskiego, możesz określić identyfikator DispID zamiast nazwy elementu członkowskiego, używając formatu ciągu "[identyfikator DispID = ##]".</span><span class="sxs-lookup"><span data-stu-id="9cc50-3434">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="9cc50-3435">Na przykład, jeśli identyfikator DispID MyComMethod wynosi 3, możesz określić ciąg "[identyfikator DispID = 3]" zamiast "MyComMethod".</span><span class="sxs-lookup"><span data-stu-id="9cc50-3435">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="9cc50-3436">Wywoływanie składowej przez identyfikator DispID jest szybsze niż Wyszukiwanie elementu członkowskiego według nazwy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3436">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="9cc50-3437">W scenariuszach złożoną agregację DispID czasami jest jedynym sposobem, aby wywołać żądanego elementu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3437">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
 <span data-ttu-id="9cc50-3438">Mimo że domyślny integrator nie przetwarza <xref:System.Reflection.ParameterModifier> lub <xref:System.Globalization.CultureInfo> ( `modifiers` i `culture` parametrów), można użyć streszczenia <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy do napisania niestandardowego integratora, który przetwarza `modifiers` i `culture`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3438">Although the default binder does not process <xref:System.Reflection.ParameterModifier> or <xref:System.Globalization.CultureInfo> (the `modifiers` and `culture` parameters), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers` and `culture`.</span></span> <span data-ttu-id="9cc50-3439">`ParameterModifier` jest używana tylko podczas wywoływania przez współdziałania z modelem COM i są obsługiwane tylko w przypadku parametrów, które są przekazywane przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3439">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="9cc50-3440">Każdy parametr w `namedParameters` tablicy pobiera wartość w odpowiednim elementem w `args` tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3440">Each parameter in the `namedParameters` array gets the value in the corresponding element in the `args` array.</span></span> <span data-ttu-id="9cc50-3441">Jeśli długość `args` jest większa niż długość `namedParameters`, pozostałe wartości argumentów są przekazywane w kolejności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3441">If the length of `args` is greater than the length of `namedParameters`, the remaining argument values are passed in order.</span></span>  
  
 <span data-ttu-id="9cc50-3442">`namedParameters` Tablicy można zmienić kolejność argumentów w tablicy wejściowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3442">The `namedParameters` array can be used to change the order of arguments in an input array.</span></span> <span data-ttu-id="9cc50-3443">Na przykład, biorąc pod uwagę metody `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` w języku Visual Basic) i Tablica wejściowa `{ 42, "x" }`, Tablica wejściowa mogą być przekazywane bez zmian do `args` Jeśli tablica `{ "b", "a" }` podano dla `namedParameters`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3443">For example, given the method `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) and the input array `{ 42, "x" }`, the input array can be passed unchanged to `args` if the array `{ "b", "a" }` is supplied for `namedParameters`.</span></span>  
  
 <span data-ttu-id="9cc50-3444">Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania elementów członkowskich, które można uwzględnić w wyszukiwaniu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3444">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="9cc50-3445">Określ `BindingFlags.Public` obejmujący publiczne elementy członkowskie w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3445">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-3446">Określ `BindingFlags.NonPublic` obejmujący elementów członkowskich niepublicznych (czyli prywatne, wewnętrzne i chronione elementy członkowskie) w wyszukiwaniu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3446">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="9cc50-3447">Określ `BindingFlags.FlattenHierarchy` obejmujący statyczne elementy członkowskie w hierarchii.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3447">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="9cc50-3448">Następujące <xref:System.Reflection.BindingFlags> flagi modyfikatora może służyć do zmiany sposobu działania wyszukiwania:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3448">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="9cc50-3449">`BindingFlags.IgnoreCase` Aby zignorować wielkość liter `name`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3449">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="9cc50-3450">`BindingFlags.DeclaredOnly` Aby wyszukać tylko do elementów członkowskich zadeklarowanych w <xref:System.Type>, nie elementów członkowskich, które zostały po prostu odziedziczone.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3450">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="9cc50-3451">Następujące <xref:System.Reflection.BindingFlags> flagi wywołania może służyć do określenia, jaką akcję należy podjąć przy użyciu elementu członkowskiego:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3451">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="9cc50-3452">`CreateInstance` Aby wywołać konstruktora.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3452">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="9cc50-3453">`name` jest ignorowany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3453">`name` is ignored.</span></span> <span data-ttu-id="9cc50-3454">Nieprawidłowy inne flagi wywołania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3454">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="9cc50-3455">`InvokeMethod` do wywołania metody, ale nie konstruktorze lub inicjatorze typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3455">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="9cc50-3456">Nie jest prawidłowy z `SetField` lub `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3456">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="9cc50-3457">Jeśli `InvokeMethod` jest określony przez siebie, `BindingFlags.Public`, `BindingFlags.Instance`, i `BindingFlags.Static` są automatycznie dołączane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3457">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="9cc50-3458">`GetField` można pobrać wartości pola.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3458">`GetField` to get the value of a field.</span></span> <span data-ttu-id="9cc50-3459">Nie jest prawidłowy z `SetField`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3459">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="9cc50-3460">`SetField` można ustawić wartości pola.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3460">`SetField` to set the value of a field.</span></span> <span data-ttu-id="9cc50-3461">Nie jest prawidłowy z `GetField`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3461">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="9cc50-3462">`GetProperty` można pobrać właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3462">`GetProperty` to get a property.</span></span> <span data-ttu-id="9cc50-3463">Nie jest prawidłowy z `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3463">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="9cc50-3464">`SetProperty` można ustawić właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3464">`SetProperty` to set a property.</span></span> <span data-ttu-id="9cc50-3465">Nie jest prawidłowy z `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3465">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="9cc50-3466">Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3466">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="9cc50-3467">Metoda zostanie wywołana, jeśli są spełnione oba poniższe warunki:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3467">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="9cc50-3468">Liczba parametrów w deklaracji metody jest równa liczbie argumentów `args` tablicy (chyba że argumenty domyślne są zdefiniowane w składowej i `BindingFlags.OptionalParamBinding` jest określony).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3468">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="9cc50-3469">Typ każdego argumentu mogą być konwertowane przez binder typowi parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3469">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="9cc50-3470">Obiekt wiążący znajdzie wszystkie metody dopasowania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3470">The binder will find all of the matching methods.</span></span> <span data-ttu-id="9cc50-3471">Te metody zostaną znalezione, oparte na typie powiązania żądane (<xref:System.Reflection.BindingFlags> wartości `InvokeMethod`, `GetProperty`i tak dalej).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3471">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="9cc50-3472">Zestaw metod są filtrowane według nazwy, liczba argumentów i zestaw modyfikatorów wyszukiwania zdefiniowane w obiekt wiążący.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3472">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="9cc50-3473">Po wybraniu metody jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3473">After the method is selected, it is invoked.</span></span> <span data-ttu-id="9cc50-3474">Dostępność jest sprawdzana w tym momencie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3474">Accessibility is checked at that point.</span></span> <span data-ttu-id="9cc50-3475">Wyszukiwanie może kontrolować, które zestaw metod, przeszukiwane są na podstawie atrybutu ułatwień dostępu powiązany z metodą.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3475">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="9cc50-3476"><xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Metody <xref:System.Reflection.Binder> klasy jest odpowiedzialny za wybranie wywoływanej metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3476">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="9cc50-3477">Domyślny integrator wybiera najbardziej określonego dopasowania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3477">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="9cc50-3478">`InvokeMember` może służyć do wywołania metody z parametrami, które mają przypisane wartości domyślne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3478">`InvokeMember` can be used to invoke methods with parameters that have default values.</span></span> <span data-ttu-id="9cc50-3479">Aby powiązać z tych metod, wymaga odbicia <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> należy określić.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3479">To bind to these methods, Reflection requires <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> to be specified.</span></span> <span data-ttu-id="9cc50-3480">Dla parametru, który ma wartość domyślną, możesz podać inną wartość, lub podaj <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> Aby użyć wartości domyślnej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3480">For a parameter that has a default value, you can either supply a different value, or supply <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> to use the default value.</span></span>  
  
 <span data-ttu-id="9cc50-3481">Rozważmy na przykład metody takie jak MyMethod (int x, float y = w wersji 2.0).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3481">For example, consider a method such as MyMethod(int x, float y = 2.0).</span></span> <span data-ttu-id="9cc50-3482">Aby wywołać tej metody za pomocą tylko pierwszy argument jako MyMethod(4), jedną z powyższych flag powiązania i przekazać dwa argumenty, a mianowicie 4 dla pierwszego argumentu i `Missing.Value` dla drugiego argumentu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3482">To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and `Missing.Value` for the second argument.</span></span> <span data-ttu-id="9cc50-3483">Chyba że używasz `Missing.Value`, nie może pominąć parametrów opcjonalnych za pomocą `Invoke` metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3483">Unless you use `Missing.Value`, you may not omit optional parameters with the `Invoke` method.</span></span> <span data-ttu-id="9cc50-3484">Jeśli należy to zrobić, użyj `InvokeMember` zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3484">If you must do so, use `InvokeMember` instead.</span></span>  
  
 <span data-ttu-id="9cc50-3485">Ograniczenia dostępu są ignorowane w przypadku w pełni zaufany kod; oznacza to, konstruktory prywatne, metody, pola i właściwości mogą być dostępne i wywoływane za pośrednictwem <xref:System.Reflection> zawsze, gdy kod jest w pełni zaufany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3485">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="9cc50-3486">Możesz użyć `Type.InvokeMember` można ustawić pola na określoną wartość, określając <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3486">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cc50-3487">Na przykład, jeśli chcesz ustawić pole publiczne wystąpienia o nazwie F klasy C i F jest `String`, można użyć kodu takiego jak:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3487">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 <span data-ttu-id="9cc50-3488">Jeśli jest F `String[]`, można użyć kodu takiego jak:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3488">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 <span data-ttu-id="9cc50-3489">która zainicjuje pole F do tej nowej tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3489">which will initialize the field F to this new array.</span></span> <span data-ttu-id="9cc50-3490">Można również użyć `Type.InvokeMember` próba ustawienia pozycji w tablicy, podając indeks wartości, a następnie wartość następnego przy użyciu następującego kodu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3490">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 <span data-ttu-id="9cc50-3491">Spowoduje to zmianę w tablicy, która F zawiera ciąg "b", ciąg "z".</span><span class="sxs-lookup"><span data-stu-id="9cc50-3491">This will change string "z" in the array that F holds to string "b".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-3492">Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do dostępu do elementów członkowskich niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga, a jeśli zestaw uprawnień elementów członkowskich niepublicznych jest ograniczony do obiektu wywołującego przyznania zestawu lub być podzbiorem jej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3492">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="9cc50-3493">(Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="9cc50-3493">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="9cc50-3494">Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3494">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-3495"><paramref name="invokeAttr" /> nie zawiera <see langword="CreateInstance" /> i <paramref name="name" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3495"><paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-3496"><paramref name="args" /> i <paramref name="modifiers" /> nie mają tę samą długość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3496"><paramref name="args" /> and <paramref name="modifiers" /> do not have the same length.</span></span>  
  
<span data-ttu-id="9cc50-3497">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3497">-or-</span></span> 
 <span data-ttu-id="9cc50-3498"><paramref name="invokeAttr" /> nie jest prawidłowym <see cref="T:System.Reflection.BindingFlags" /> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3498"><paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span></span>  
  
<span data-ttu-id="9cc50-3499">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3499">-or-</span></span> 
 <span data-ttu-id="9cc50-3500"><paramref name="invokeAttr" /> nie zawiera jedną z następujących flag powiązania: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, lub <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3500"><paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="9cc50-3501">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3501">-or-</span></span> 
 <span data-ttu-id="9cc50-3502"><paramref name="invokeAttr" /> zawiera <see langword="CreateInstance" /> w połączeniu z <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, lub <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3502"><paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="9cc50-3503">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3503">-or-</span></span> 
 <span data-ttu-id="9cc50-3504"><paramref name="invokeAttr" /> zawiera zarówno <see langword="GetField" /> i <see langword="SetField" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3504"><paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span></span>  
  
<span data-ttu-id="9cc50-3505">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3505">-or-</span></span> 
 <span data-ttu-id="9cc50-3506"><paramref name="invokeAttr" /> zawiera zarówno <see langword="GetProperty" /> i <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3506"><paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="9cc50-3507">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3507">-or-</span></span> 
 <span data-ttu-id="9cc50-3508"><paramref name="invokeAttr" /> zawiera <see langword="InvokeMethod" /> w połączeniu z <see langword="SetField" /> lub <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3508"><paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="9cc50-3509">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3509">-or-</span></span> 
 <span data-ttu-id="9cc50-3510"><paramref name="invokeAttr" /> zawiera <see langword="SetField" /> i <paramref name="args" /> ma więcej niż jeden element.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3510"><paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span></span>  
  
<span data-ttu-id="9cc50-3511">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3511">-or-</span></span> 
<span data-ttu-id="9cc50-3512">Tablica parametrów nazwanych jest większa niż tablica argumentów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3512">The named parameter array is larger than the argument array.</span></span>  
  
<span data-ttu-id="9cc50-3513">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3513">-or-</span></span> 
<span data-ttu-id="9cc50-3514">Ta metoda jest wywoływana dla obiektu COM i jedną z następujących flag powiązania nie przekazano: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, lub <see langword="BindingFlags.PutRefDispProperty" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3514">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span></span>  
  
<span data-ttu-id="9cc50-3515">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3515">-or-</span></span> 
<span data-ttu-id="9cc50-3516">Jedna z nich tablic nazwany parametr zawiera ciąg, który jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3516">One of the named parameter arrays contains a string that is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="9cc50-3517">Określony element członkowski jest inicjator klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3517">The specified member is a class initializer.</span></span></exception>
        <exception cref="T:System.MissingFieldException"><span data-ttu-id="9cc50-3518">Nie można odnaleźć pola lub właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3518">The field or property cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="9cc50-3519">Brak metody można znaleźć odpowiadającej argumentów <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3519">No method can be found that matches the arguments in <paramref name="args" />.</span></span>  
  
<span data-ttu-id="9cc50-3520">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3520">-or-</span></span> 
<span data-ttu-id="9cc50-3521">Brak elementów członkowskich, można znaleźć zawierającej nazwy argumentów dostarczone w <paramref name="namedParameters" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3521">No member can be found that has the argument names supplied in <paramref name="namedParameters" />.</span></span>  
  
<span data-ttu-id="9cc50-3522">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-3522">-or-</span></span> 
<span data-ttu-id="9cc50-3523">Bieżący <see cref="T:System.Type" /> obiekt reprezentuje typ, który zawiera parametry typu otwartego, czyli <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3523">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="9cc50-3524">Nie można wywołać określonego elementu członkowskiego <paramref name="target" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3524">The specified member cannot be invoked on <paramref name="target" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="9cc50-3525">Więcej niż jednej metody odpowiadającego kryteriom powiązania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3525">More than one method matches the binding criteria.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cc50-3526">Metody reprezentowanej przez <paramref name="name" /> ma jeden lub więcej określonych parametrów typu rodzajowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3526">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span></span> <span data-ttu-id="9cc50-3527">Oznacza to, że metody <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> właściwość zwraca <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3527">That is, the method's <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="9cc50-3528">W celu uzyskiwania dostępu do elementów członkowskich niepublicznych, niezależnie od ich zestawu uprawnień.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3528">for accessing non-public members regardless of their grant set.</span></span> <span data-ttu-id="9cc50-3529">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="9cc50-3529">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="9cc50-3530">Aby wywoływać kod niezarządzany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3530">to call unmanaged code.</span></span> <span data-ttu-id="9cc50-3531">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="9cc50-3531">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3532">Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest abstrakcyjny i musi zostać zastąpiona.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3532">Gets a value indicating whether the <see cref="T:System.Type" /> is abstract and must be overridden.</span></span></summary>
        <value><span data-ttu-id="9cc50-3533"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest abstrakcyjna; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3533"><see langword="true" /> if the <see cref="T:System.Type" /> is abstract; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3534"><xref:System.Type.IsAbstract%2A> Właściwość zwraca `true` w następujących przypadkach:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3534">The <xref:System.Type.IsAbstract%2A> property returns `true` in the following cases:</span></span>  
  
-   <span data-ttu-id="9cc50-3535">Bieżącym typem jest abstrakcyjna; oznacza to, że ten nie można utworzyć wystąpienia, ale tylko może służyć jako klasa bazowa dla klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3535">The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes.</span></span> <span data-ttu-id="9cc50-3536">W języku C#, klasy abstrakcyjne są oznaczone [abstrakcyjne](~/docs/csharp/language-reference/keywords/abstract.md) słowo kluczowe w języku Visual Basic są oznaczone [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) — słowo kluczowe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3536">In C#, abstract classes are marked with the [abstract](~/docs/csharp/language-reference/keywords/abstract.md) keyword; in Visual Basic, they are marked with the [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) keyword.</span></span>  
  
-   <span data-ttu-id="9cc50-3537">Bieżący typ jest interfejsem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3537">The current type is an interface.</span></span>  
  
 <span data-ttu-id="9cc50-3538">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3538">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3539">Poniższy przykład tworzy tablicę <xref:System.Type> obiekty reprezentujące następujących typów: zawiera zwraca typ `true` Jeśli określony obiekt jest `abstract`; w przeciwnym razie zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3539">The following example creates an array of <xref:System.Type> objects that represent the following types:contains type returns `true` if the specified object is `abstract`; otherwise, it returns `false`.</span></span>  
  
-   <span data-ttu-id="9cc50-3540">`AbstractClass`, klasa abstrakcyjna (klasa jest oznaczona jako `abstract` w języku C# i `MustInherit` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3540">`AbstractClass`, an abstract class (a class marked as `abstract` in C# and `MustInherit` in Visual Basic).</span></span>  
  
-   <span data-ttu-id="9cc50-3541">`DerivedClass`, klasa, która dziedziczy `AbstractClass`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3541">`DerivedClass`, a class that inherits from `AbstractClass`.</span></span>  
  
-   <span data-ttu-id="9cc50-3542">`SingleClass`,-dziedziczone klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3542">`SingleClass`, a non-inheritable class.</span></span> <span data-ttu-id="9cc50-3543">Jest on zdefiniowany jako `sealed` w języku C# i `NotInheritable` w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3543">It is defined as `sealed` in C# and `NotInheritable` in Visual Basic.</span></span>  
  
-   <span data-ttu-id="9cc50-3544">`ITypeInfo`, interfejs.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3544">`ITypeInfo`, an interface.</span></span>  
  
-   <span data-ttu-id="9cc50-3545">`ImplementingClass`, klasa, która implementuje `ITypeInfo` interfejsu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3545">`ImplementingClass`, a class that implements the `ITypeInfo` interface.</span></span>  
  
 <span data-ttu-id="9cc50-3546">Metoda ta zwraca `true` tylko w przypadku `AbstractClass`, klasa abstrakcyjna, i `ITypeInfo`, interfejs.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3546">The method returns `true` only for `AbstractClass`, the abstract class, and `ITypeInfo`, the interface.</span></span>  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3547">Pobiera wartość wskazującą czy ciąg formatu atrybut <see langword="AnsiClass" /> wybrano <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3547">Gets a value indicating whether the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="9cc50-3548"><see langword="true" /> Jeśli ciąg formatu atrybut <see langword="AnsiClass" /> wybrano <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3548"><see langword="true" /> if the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3549"><xref:System.Reflection.TypeAttributes.StringFormatMask> Wybiera atrybuty format ciągu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3549">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="9cc50-3550">Atrybuty formatu ciągu ulepszenia współdziałania, definiując, jak interpretować ciągów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3550">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="9cc50-3551">Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny, właściwość ta odnoszą się do definicji typu ogólnego, z którego skonstruowano.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3551">If the current <xref:System.Type> represents a generic type, this property pertains to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="9cc50-3552">Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3552">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="9cc50-3553">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3553">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3554">Poniższy przykład pobiera informacje o polu i sprawdza, czy `AnsiClass` atrybutu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3554">The following example gets the field information and checks for the `AnsiClass` attribute.</span></span>  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3555">Pobiera wartość wskazującą, czy typ jest tablicą.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3555">Gets a value that indicates whether the type is an array.</span></span></summary>
        <value><span data-ttu-id="9cc50-3556"><see langword="true" /> Jeśli bieżący typ jest tablicą; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3556"><see langword="true" /> if the current type is an array; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3557"><xref:System.Type.IsArray%2A> Właściwość zwraca `false` dla <xref:System.Array> klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3557">The <xref:System.Type.IsArray%2A> property returns `false` for the <xref:System.Array> class.</span></span> <span data-ttu-id="9cc50-3558">Również zwraca `false` Jeśli bieżące wystąpienie jest <xref:System.Type> obiekt, który reprezentuje typ kolekcji lub interfejs, zaprojektowane do pracy z kolekcjami, takich jak <xref:System.Collections.IEnumerable> lub <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3558">It also returns `false` if the current instance is a <xref:System.Type> object that represents a collection type or an interface designed to work with collections, such as <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
 <span data-ttu-id="9cc50-3559">Aby sprawdzić, czy tablica, należy użyć kodu takiego jak:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3559">To check for an array, use code such as:</span></span>  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 <span data-ttu-id="9cc50-3560">Jeśli bieżący typ reprezentuje typ ogólny lub parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3560">If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="9cc50-3561">Ta właściwość jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3561">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3562">Poniższy przykład demonstruje użycie <xref:System.Type.IsArray%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3562">The following example demonstrates using the <xref:System.Type.IsArray%2A> property.</span></span>  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-3563">W przypadku przesłonięcia w klasie pochodnej, implementuje <see cref="P:System.Type.IsArray" /> właściwości i określa, czy <see cref="T:System.Type" /> jest tablicą.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3563">When overridden in a derived class, implements the <see cref="P:System.Type.IsArray" /> property and determines whether the <see cref="T:System.Type" /> is an array.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3564"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest tablicą, a w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3564"><see langword="true" /> if the <see cref="T:System.Type" /> is an array; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3565">Wystąpienie <xref:System.Array> klasy musi zwracać `false` , ponieważ jest to obiekt, nie tablica.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3565">An instance of the <xref:System.Array> class must return `false` because it is an object, not an array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3566">Poniższy przykład zastępuje `IsArrayImpl` method in Class metoda `MyTypeDelegator` klasy sprawdza, czy zmienna jest tablicą, a następnie wyświetla wynik.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3566">The following example overrides the `IsArrayImpl` method in the `MyTypeDelegator` class, checks if a variable is an array, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="9cc50-3567">Typ do porównania z bieżącym typem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3567">The type to compare with the current type.</span></span></param>
        <summary><span data-ttu-id="9cc50-3568">Określa, czy wystąpienia określonego typu można przypisać do wystąpienia typu bieżącego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3568">Determines whether an instance of a specified type can be assigned to an instance of the current type.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3569"><see langword="true" /> Jeśli dowolny z następujących warunków jest spełniony:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3569"><see langword="true" /> if any of the following conditions is true:</span></span> <span data-ttu-id="9cc50-3570">
-   <paramref name="c" /> i bieżące wystąpienie reprezentują tego samego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3570">
-   <paramref name="c" /> and the current instance represent the same type.</span></span>  
  <span data-ttu-id="9cc50-3571">
-   <paramref name="c" /> pochodzi bezpośrednio lub pośrednio od bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3571">
-   <paramref name="c" /> is derived either directly or indirectly from the current instance.</span></span> <span data-ttu-id="9cc50-3572"><paramref name="c" /> pochodzi bezpośrednio z bieżącym wystąpieniem dziedziczy bieżące wystąpienie; <paramref name="c" /> pochodzi pośrednio od bieżącego wystąpienia, jeśli jest dziedziczona z serii co najmniej jedną klasę, które dziedziczą z bieżącym wystąpieniem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3572"><paramref name="c" /> is derived directly from the current instance if it inherits from the current instance; <paramref name="c" /> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.</span></span>  
  
<span data-ttu-id="9cc50-3573">-Bieżące wystąpienie jest interfejsem, który <paramref name="c" /> implementuje.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3573">-   The current instance is an interface that <paramref name="c" /> implements.</span></span>  
  <span data-ttu-id="9cc50-3574">
-   <paramref name="c" /> jest parametr typu ogólnego, a bieżące wystąpienie reprezentuje jedną z ograniczeń <paramref name="c" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3574">
-   <paramref name="c" /> is a generic type parameter, and the current instance represents one of the constraints of <paramref name="c" />.</span></span>  
  
<span data-ttu-id="9cc50-3575">W poniższym przykładzie bieżące wystąpienie jest <see cref="T:System.Type" /> obiekt, który reprezentuje <see cref="T:System.IO.Stream" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3575">In the following example, the current instance is a <see cref="T:System.Type" /> object that represents the <see cref="T:System.IO.Stream" /> class.</span></span> <span data-ttu-id="9cc50-3576"><c>GenericWithConstraint</c> jest typem ogólnym, na której parametr typu ogólnego, musi być typu <see cref="T:System.IO.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3576"><c>GenericWithConstraint</c> is a generic type whose generic type parameter must be of type    <see cref="T:System.IO.Stream" />.</span></span> <span data-ttu-id="9cc50-3577">Przekazywanie jako parametr typu ogólnego <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> wskazuje, czy wystąpienie parametru typu generycznego można przypisać do <see cref="T:System.IO.Stream" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3577">Passing its generic type parameter to the <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> indicates that  an instance of the generic type parameter can be assigned to an <see cref="T:System.IO.Stream" /> object.</span></span>  
  
<span data-ttu-id="9cc50-3578">[! code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [! kodu vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]</span><span class="sxs-lookup"><span data-stu-id="9cc50-3578">[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]</span></span> <span data-ttu-id="9cc50-3579">
-   <paramref name="c" /> Typ reprezentujący wartość, a bieżące wystąpienie reprezentuje <c>Nullable&lt;c&gt; </c> (<c>Nullable (Of c)</c> w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3579">
-   <paramref name="c" /> represents a value type, and the current instance represents <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> in Visual Basic).</span></span>  
  
 <span data-ttu-id="9cc50-3580"><see langword="false" /> Jeśli żaden z tych warunków jest spełniony, lub jeśli <paramref name="c" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3580"><see langword="false" /> if none of these conditions are true, or if <paramref name="c" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3581"><xref:System.Type.IsAssignableFrom%2A> Metoda może służyć do określenia, czy wystąpienie `c` można przypisać z wystąpieniem bieżącego typu, metoda jest najbardziej przydatna podczas obsługi obiektów, których typy nie są znane w czasie projektowania i umożliwia warunkowe przypisanie w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3581">The <xref:System.Type.IsAssignableFrom%2A> method can be used to determine whether an instance of `c` can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 <span data-ttu-id="9cc50-3582">Ta metoda ten sposób zapewnia, że wiersz kodu, takie jak następujące będą wykonywane w czasie wykonywania bez niepotrzebnego <xref:System.InvalidCastException> lub wyjątku podobnych wyjątek:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3582">This method thus ensures that a line of code like the following will execute at runtime without throwing an <xref:System.InvalidCastException> exception or a similar exception:</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 <span data-ttu-id="9cc50-3583">Metoda ta może być zastąpiona przez klasę pochodną.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3583">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-3584">Definicja typu ogólnego nie jest możliwy do przypisania z zamkniętej skonstruowanego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3584">A generic type definition is not assignable from a closed constructed type.</span></span> <span data-ttu-id="9cc50-3585">Oznacza to, że nie można przypisać zamknięte skonstruowanego typu `MyGenericList<int>` (`MyGenericList(Of Integer)` w języku Visual Basic) do zmiennej typu `MyGenericList<T>`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3585">That is, you cannot assign the closed constructed type `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) to a variable of type `MyGenericList<T>`.</span></span>  
  
 <span data-ttu-id="9cc50-3586">Jeśli `c` parametr jest typu <xref:System.Reflection.Emit.TypeBuilder>, wynik jest oparty na typie, który ma zostać utworzony.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3586">If the `c` parameter is of type <xref:System.Reflection.Emit.TypeBuilder>, the result is based on the type that is to be built.</span></span> <span data-ttu-id="9cc50-3587">Poniższy przykład kodu demonstruje, to przy użyciu wbudowanego typu o nazwie `B`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3587">The following code example demonstrates this using a built type named `B`.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3588">W poniższym przykładzie pokazano `IsAssignableFrom` przy użyciu metody zdefiniowanych klas, tablic liczby całkowitej i typy ogólne.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3588">The following example demonstrates the `IsAssignableFrom` method using defined classes, integer arrays, and generics.</span></span>  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3589">Pobiera wartość wskazującą czy ciąg formatu atrybut <see langword="AutoClass" /> wybrano <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3589">Gets a value indicating whether the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="9cc50-3590"><see langword="true" /> Jeśli ciąg formatu atrybut <see langword="AutoClass" /> wybrano <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3590"><see langword="true" /> if the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3591"><xref:System.Reflection.TypeAttributes.StringFormatMask> Wybiera atrybuty format ciągu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3591">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="9cc50-3592">Atrybuty formatu ciągu ulepszenia współdziałania, definiując, jak interpretować ciągów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3592">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="9cc50-3593">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3593">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="9cc50-3594">Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3594">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="9cc50-3595">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3595">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3596">Pobiera wartość wskazującą, czy pola bieżącego typu są ułożone automatycznie przez środowisko uruchomieniowe języka wspólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3596">Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</span></span></summary>
        <value><span data-ttu-id="9cc50-3597"><see langword="true" /> Jeśli <see cref="P:System.Type.Attributes" /> zawiera właściwości bieżącego typu <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3597"><see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3598">Ta właściwość jest udostępniana dla wygody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3598">This property is provided as a convenience.</span></span> <span data-ttu-id="9cc50-3599">Alternatywnie, można użyć <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> wartości wyliczenia, aby wybrać atrybuty układu typu, a następnie w celu przetestowania, czy <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> jest ustawiona.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3599">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="9cc50-3600"><xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, I <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> wartości wyliczenia wskazuje sposób pola tego typu są ułożone w pamięci.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3600">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="9cc50-3601">W przypadku typów dynamicznych, możesz określić <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> podczas tworzenia tego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3601">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="9cc50-3602">W kodzie, należy zastosować <xref:System.Runtime.InteropServices.StructLayoutAttribute> atrybutem <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> wartość wyliczenia do typu, aby określić odpowiedni sposób, aby zmienić układ klasy środowiska uruchomieniowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3602">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-3603">Nie można użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metodę pozwala ustalić czy <xref:System.Runtime.InteropServices.StructLayoutAttribute> zastosowano do typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3603">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="9cc50-3604">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3604">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="9cc50-3605">Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="9cc50-3605">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="9cc50-3606">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3606">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3607">Poniższy przykład tworzy wystąpienie tego typu i wyświetla <xref:System.Type.IsAutoLayout%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3607">The following example creates an instance of the type and displays the <xref:System.Type.IsAutoLayout%2A> property.</span></span>  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md"><span data-ttu-id="9cc50-3608">Składniki samoopisujące się i metadane</span><span class="sxs-lookup"><span data-stu-id="9cc50-3608">Metadata and Self-Describing Components</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3609">Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest przekazywany przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3609">Gets a value indicating whether the <see cref="T:System.Type" /> is passed by reference.</span></span></summary>
        <value><span data-ttu-id="9cc50-3610"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest przekazywany przez odwołanie; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3610"><see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3611">Aby przejść do rzeczywistego typu, wyłuskania typ, który został przekazany przez odwołanie, a następnie wywołaj <xref:System.Type.GetElementType%2A> tego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3611">To get to the actual type, dereference the type that was passed by reference, and then call <xref:System.Type.GetElementType%2A> on that type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3612">W poniższym przykładzie pokazano użycie `IsByRef` właściwość do sprawdzenia, czy określony typ jest przekazywany przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3612">The following example demonstrates a use of the `IsByRef` property to check whether a specified type is passed by reference.</span></span> <span data-ttu-id="9cc50-3613">W przykładzie zdefiniowano klasę `MyTypeDelegator`, co zastępuje `HasElementTypeImpl` metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3613">The example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="9cc50-3614">Sprawdza, czy główna klasa `HasElementType` właściwości i wyświetla typ elementu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3614">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-3615">W przypadku przesłonięcia w klasie pochodnej, implementuje <see cref="P:System.Type.IsByRef" /> właściwości i określa, czy <see cref="T:System.Type" /> jest przekazywany przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3615">When overridden in a derived class, implements the <see cref="P:System.Type.IsByRef" /> property and determines whether the <see cref="T:System.Type" /> is passed by reference.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3616"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest przekazywany przez odwołanie; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3616"><see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3617">Pobiera wartość wskazującą czy <see cref="T:System.Type" /> klasy lub delegata; oznacza to, nie jest typem wartości lub interfejs.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3617">Gets a value indicating whether the <see cref="T:System.Type" /> is a class or a delegate; that is, not a value type or interface.</span></span></summary>
        <value><span data-ttu-id="9cc50-3618"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest klasą; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3618"><see langword="true" /> if the <see cref="T:System.Type" /> is a class; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3619">Ta właściwość zwraca `true` dla klasy, a także delegatów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3619">This property returns `true` for classes as well as delegates.</span></span> <span data-ttu-id="9cc50-3620">Zwraca `false` dla typów wartości (w przypadku struktur i wyliczenia) nawet wtedy, gdy są one ramce.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3620">It returns `false` for value types (for structures and enumerations) even if they are boxed.</span></span>  
  
 <span data-ttu-id="9cc50-3621">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `true`. Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta zwraca `true` Jeśli definicja typu ogólnego jest definicją klasy; oznacza to też nie definiuje interfejs lub typu wartościowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3621">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `true`.If the current <xref:System.Type> represents a constructed generic type, this property returns `true` if the generic type definition is a class definition; that is, it does not define an interface or a value type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-3622">Ta właściwość zwraca `true` dla `Type` wystąpienia reprezentujące <xref:System.Enum> i <xref:System.ValueType> klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3622">This property returns `true` for `Type` instances that represent the <xref:System.Enum> and <xref:System.ValueType> classes.</span></span> <span data-ttu-id="9cc50-3623">Te dwie klasy są typami podstawowymi dla wyliczeń i typy wartości, odpowiednio, ale nie są one wyliczenia ani typów wartości, samodzielnie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3623">These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves.</span></span> <span data-ttu-id="9cc50-3624">Aby uzyskać więcej informacji, zobacz <xref:System.Type.IsValueType%2A> i <xref:System.Type.IsEnum%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3624">For more information, see the <xref:System.Type.IsValueType%2A> and <xref:System.Type.IsEnum%2A> properties.</span></span>  
  
 <span data-ttu-id="9cc50-3625"><xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> Wartość wyliczenia wyróżnia deklaracji typu klasy lub interfejsu. Jednak zarówno klasy i typy wartości są oznaczone <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3625">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> attribute.</span></span> <span data-ttu-id="9cc50-3626">Jeśli pobieranie wartości właściwości atrybutów i użyj typu <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> wartość, aby określić, czy typ jest klasą zamiast typu wartości, musisz również wywołać <xref:System.Type.IsValueType%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3626">If you retrieve the value of a type's Attributes property and use the <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> value to determine whether a type is a class instead of a value type, you must also call the <xref:System.Type.IsValueType%2A> property.</span></span> <span data-ttu-id="9cc50-3627">Przykład <xref:System.Reflection.TypeAttributes> wyliczenia zawiera dodatkowe informacje, a także anexample.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3627">The example for the <xref:System.Reflection.TypeAttributes> enumeration contains additional information as well as anexample.</span></span>  
  
 <span data-ttu-id="9cc50-3628">Ta właściwość jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3628">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3629">Poniższy przykład tworzy wystąpienie typu i wskazuje, czy typ jest klasą.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3629">The following example creates an instance of a type and indicates whether the type is a class.</span></span>  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3630">Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest obiektem COM.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3630">Gets a value indicating whether the <see cref="T:System.Type" /> is a COM object.</span></span></summary>
        <value><span data-ttu-id="9cc50-3631"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest obiektem COM; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3631"><see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3632">Ta metoda zwraca `false` dla interfejsów COM, ponieważ nie są obiektami.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3632">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="9cc50-3633">Interfejsy modelu COM może być implementowany przez obiekty programu Microsoft .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3633">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 <span data-ttu-id="9cc50-3634">Można również załadować klasy COM i uzyskać `Type` obiektu dla tej klasy COM za pomocą [Tlbimp.exe (Importer biblioteki typów)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) narzędzia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3634">You can also load a COM class and get a `Type` object for that COM class by using the [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool.</span></span>  
  
 <span data-ttu-id="9cc50-3635">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3635">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="9cc50-3636">Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int`> (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3636">For example, if the current <xref:System.Type> represents `MyGenericType<int`> (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="9cc50-3637">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3637">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-3638">W przypadku przesłonięcia w klasie pochodnej, implementuje <see cref="P:System.Type.IsCOMObject" /> właściwości i określa, czy <see cref="T:System.Type" /> jest obiektem COM.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3638">When overridden in a derived class, implements the <see cref="P:System.Type.IsCOMObject" /> property and determines whether the <see cref="T:System.Type" /> is a COM object.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3639"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest obiektem COM; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3639"><see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3640">Ta metoda zwraca `false` dla interfejsów COM, ponieważ nie są obiektami.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3640">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="9cc50-3641">Interfejsy modelu COM może być implementowany przez obiekty programu Microsoft .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3641">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3642">Pobiera wartość wskazującą, czy ten obiekt reprezentuje zbudowany typ ogólny.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3642">Gets a value that indicates whether this object represents a constructed generic type.</span></span> <span data-ttu-id="9cc50-3643">Można utworzyć wystąpienia elementu zbudowany typ ogólny.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3643">You can create instances of a constructed generic type.</span></span></summary>
        <value><span data-ttu-id="9cc50-3644"><see langword="true" /> Jeśli ten obiekt reprezentuje zbudowany typ ogólny; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3644"><see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3645">Skonstruowany typ rodzajowy miał jawnie typów dostarczonych dla wszystkich jego parametrów typu rodzajowego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3645">A constructed generic type has had explicit types supplied for all of its generic type parameters.</span></span> <span data-ttu-id="9cc50-3646">Ona również jest określana jako zamknięty typ ogólny.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3646">It is also referred to as a closed generic type.</span></span>  
  
 <span data-ttu-id="9cc50-3647">Gdy ta właściwość jest `true`, można utworzyć wystąpienia typu bieżącego; znajduje się w `false`, to nie jest możliwe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3647">When this property is `true`, you can create instances of the current type; when it is `false`, you can't.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3648">Pobiera wartość wskazującą czy <see cref="T:System.Type" /> może znajdować się w kontekście.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3648">Gets a value indicating whether the <see cref="T:System.Type" /> can be hosted in a context.</span></span></summary>
        <value><span data-ttu-id="9cc50-3649"><see langword="true" /> Jeśli <see cref="T:System.Type" /> może być hostowana w kontekście, w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3649"><see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3650">Kontekst przechwytuje wywołania do składowych klasy i wymusza zasady, które są stosowane do klasy, takie jak synchronizacja.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3650">A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization.</span></span> <span data-ttu-id="9cc50-3651">Aby uzyskać szczegółowe informacje o kontekstach komunikacji zdalnej, zobacz <xref:System.Runtime.Remoting.Contexts.Context>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3651">For more detailed information on remoting contexts, see <xref:System.Runtime.Remoting.Contexts.Context>.</span></span>  
  
 <span data-ttu-id="9cc50-3652">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3652">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3653">W poniższym przykładzie pokazano `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, i <xref:System.Type.IsPrimitive%2A> właściwości <xref:System.Type> klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3653">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="9cc50-3654">Sprawdza, czy dany typ może być hostowana w kontekście, czy mogą być przekazywane przez odwołanie i zezwolić na określony typ jest typem danych pierwotnych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3654">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-3655">Implementuje <see cref="P:System.Type.IsContextful" /> właściwości i określa, czy <see cref="T:System.Type" /> może znajdować się w kontekście.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3655">Implements the <see cref="P:System.Type.IsContextful" /> property and determines whether the <see cref="T:System.Type" /> can be hosted in a context.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3656"><see langword="true" /> Jeśli <see cref="T:System.Type" /> może być hostowana w kontekście, w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3656"><see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3657">Metoda ta może być zastąpiona przez klasę pochodną.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3657">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="9cc50-3658">Kontekst przechwytuje wywołania do składowych klasy i wymuszać zasady, które są stosowane do klasy, takie jak synchronizacja.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3658">A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3659">W poniższym przykładzie pokazano użycie `IsContextfulImpl` metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3659">The following example demonstrates a use of the `IsContextfulImpl` method.</span></span>  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3660">Pobiera wartość wskazującą czy bieżący <see cref="T:System.Type" /> reprezentuje wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3660">Gets a value indicating whether the current <see cref="T:System.Type" /> represents an enumeration.</span></span></summary>
        <value><span data-ttu-id="9cc50-3661"><see langword="true" /> Jeśli bieżący <see cref="T:System.Type" /> reprezentuje wyliczenia; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3661"><see langword="true" /> if the current <see cref="T:System.Type" /> represents an enumeration; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3662">Ta właściwość zwraca `true` wyliczania, ale nie dla <xref:System.Enum> samego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3662">This property returns `true` for an enumeration, but not for the <xref:System.Enum> type itself.</span></span>  
  
 <span data-ttu-id="9cc50-3663">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3663">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="9cc50-3664">Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3664">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="9cc50-3665">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3665">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="9cc50-3666">Ta właściwość jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3666">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3667">Poniższy przykład pokazuje sposób użycia `IsEnum` właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3667">The following example demonstrates how to use the `IsEnum` property.</span></span>  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="9cc50-3668">Wartość, która ma zostać przetestowana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3668">The value to be tested.</span></span></param>
        <summary><span data-ttu-id="9cc50-3669">Zwraca wartość wskazującą, czy określona wartość istnieje w bieżącym typem wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3669">Returns a value that indicates whether the specified value exists in the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3670"><see langword="true" /> Jeśli określona wartość jest elementem członkowskim bieżącego typu wyliczenia; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3670"><see langword="true" /> if the specified value is a member of the current enumeration type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-3671">Bieżący typ nie jest wyliczeniem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3671">The current type is not an enumeration.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-3672"><paramref name="value" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3672"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cc50-3673"><paramref name="value" /> jest typem, który nie może być podstawowym typem wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3673"><paramref name="value" /> is of a type that cannot be the underlying type of an enumeration.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="9cc50-3674">Typ modelu COM, który jest testowany pod kątem równoważności z bieżącym typem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3674">The COM type that is tested for equivalence with the current type.</span></span></param>
        <summary><span data-ttu-id="9cc50-3675">Określa, czy dwa typy COM ma taką samą tożsamość i kwalifikują się do równoważeniu typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3675">Determines whether two COM types have the same identity and are eligible for type equivalence.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3676"><see langword="true" /> Jeśli typy modelu COM są równoważne; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3676"><see langword="true" /> if the COM types are equivalent; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9cc50-3677">Ta metoda zwraca też wartość <see langword="false" /> czy jeden typ w zestawie, który jest ładowany do wykonania, a drugi to w zestawie, który jest ładowany do kontekstu reflection-only.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3677">This method also returns <see langword="false" /> if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3678">Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], środowisko uruchomieniowe języka wspólnego obsługuje osadzanie informacji o typie dla typów modelu COM bezpośrednio do zestawów zarządzanych, zamiast zestawów zarządzanych uzyskać informacje o typie dla typów modelu COM z międzyoperacyjności zestawy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3678">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies.</span></span> <span data-ttu-id="9cc50-3679">Informacje o typie osadzony zawiera tylko typy i elementy członkowskie, które są rzeczywiście używane przez zestaw zarządzany, dwóch zestawów zarządzanych, może być bardzo różne widoki tego samego typu COM.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3679">Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type.</span></span> <span data-ttu-id="9cc50-3680">Każdy zestaw zarządzany ma inną <xref:System.Type> obiektu do reprezentowania jej widok typów modelu COM.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3680">Each managed assembly has a different <xref:System.Type> object to represent its view of the COM type.</span></span> <span data-ttu-id="9cc50-3681">Środowisko uruchomieniowe języka wspólnego obsługuje równoważności typu między te różne widoki dla interfejsy, struktury, wyliczenia i delegaty.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3681">The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.</span></span>  
  
 <span data-ttu-id="9cc50-3682">Równoważności typu oznacza o tym, że obiekt COM, który jest przekazywany z jednego zestawu zarządzanego do innego, mogą być rzutowane do odpowiedniego zarządzane typu w zestawie odbierania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3682">Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly.</span></span> <span data-ttu-id="9cc50-3683"><xref:System.Type.IsEquivalentTo%2A> Metoda umożliwia zestawu, aby ustalić, czy obiekt COM, uzyskany z innego zestawu ma taką samą tożsamość COM jako jeden z typów międzyoperacyjnych pierwszego zestawu własnych osadzone i dlatego mogą być rzutowane na tego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3683">The <xref:System.Type.IsEquivalentTo%2A> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.</span></span>  
  
 <span data-ttu-id="9cc50-3684">Aby uzyskać więcej informacji, zobacz [równoważności typów i osadzone typy międzyoperacyjne](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3684">For more information, see [Type Equivalence and Embedded Interop Types](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3685">Pobiera wartość wskazującą, czy pola bieżącego typu są ułożone w jawnie określonych przesunięć.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3685">Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</span></span></summary>
        <value><span data-ttu-id="9cc50-3686"><see langword="true" /> Jeśli <see cref="P:System.Type.Attributes" /> zawiera właściwości bieżącego typu <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3686"><see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3687">Ta właściwość jest udostępniana dla wygody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3687">This property is provided as a convenience.</span></span> <span data-ttu-id="9cc50-3688">Alternatywnie, można użyć <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> wartości wyliczenia, aby wybrać atrybuty układu typu, a następnie w celu przetestowania, czy <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> jest ustawiona.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3688">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="9cc50-3689"><xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, I <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> wartości wyliczenia wskazuje sposób pola tego typu są ułożone w pamięci.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3689">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="9cc50-3690">W przypadku typów dynamicznych, możesz określić <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> podczas tworzenia tego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3690">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="9cc50-3691">W kodzie, należy zastosować <xref:System.Runtime.InteropServices.StructLayoutAttribute> atrybutem <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> wartość wyliczenia do typu, aby określić przesunięcie, w których start pola zostaną wyraźnie wskazane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3691">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-3692">Nie można użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metodę pozwala ustalić czy <xref:System.Runtime.InteropServices.StructLayoutAttribute> zastosowano do typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3692">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="9cc50-3693">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3693">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="9cc50-3694">Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3694">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="9cc50-3695">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3695">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3696">Poniższy przykład tworzy wystąpienie typu i wyświetla wartość jego <xref:System.Type.IsExplicitLayout%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3696">The following example creates an instance of a type and displays the value of its <xref:System.Type.IsExplicitLayout%2A> property.</span></span> <span data-ttu-id="9cc50-3697">Używa ona `MySystemTime` klasy, która jest również w przykładzie kodu dla <xref:System.Runtime.InteropServices.StructLayoutAttribute>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3697">It uses the `MySystemTime` class, which is also in the code example for <xref:System.Runtime.InteropServices.StructLayoutAttribute>.</span></span>  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md"><span data-ttu-id="9cc50-3698">Składniki samoopisujące się i metadane</span><span class="sxs-lookup"><span data-stu-id="9cc50-3698">Metadata and Self-Describing Components</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3699">Pobiera wartość wskazującą czy bieżący <see cref="T:System.Type" /> reprezentuje parametr typu w definicji typu ogólnego lub metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3699">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or method.</span></span></summary>
        <value><span data-ttu-id="9cc50-3700"><see langword="true" /> Jeśli <see cref="T:System.Type" /> obiekt reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej definicję; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3700"><see langword="true" /> if the <see cref="T:System.Type" /> object represents a type parameter of a generic type definition or generic method definition; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3701"><xref:System.Type> obiekty, które reprezentują parametry typu ogólnego, można uzyskać przez wywołanie metody <xref:System.Type.GetGenericArguments%2A> metody <xref:System.Type> obiekt, który reprezentuje definicję typu ogólnego lub <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> metody <xref:System.Reflection.MethodInfo> obiekt, który reprezentuje metody ogólnej Definicja.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3701"><xref:System.Type> objects that represent generic type parameters can be obtained by calling the <xref:System.Type.GetGenericArguments%2A> method of a <xref:System.Type> object that represents a generic type definition, or the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> method of a <xref:System.Reflection.MethodInfo> object that represents a generic method definition.</span></span>  
  
-   <span data-ttu-id="9cc50-3702">Dla typu ogólnego lub definicję metody <xref:System.Type.IsGenericParameter%2A> właściwość zwraca `true` dla każdego elementu tablicy wynikowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3702">For a generic type or method definition, the <xref:System.Type.IsGenericParameter%2A> property returns `true` for every element of the resulting array.</span></span>  
  
-   <span data-ttu-id="9cc50-3703">Zamknięte skonstruowanego typu lub metody <xref:System.Type.IsGenericParameter%2A> właściwość zwraca `false` dla każdego elementu w tablicy zwracanej przez <xref:System.Type.GetGenericArguments%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3703">For a closed constructed type or method, the <xref:System.Type.IsGenericParameter%2A> property returns `false` for every element of the array returned by the <xref:System.Type.GetGenericArguments%2A> method.</span></span>  
  
-   <span data-ttu-id="9cc50-3704">Otwórz skonstruowanego typu lub metody niektóre elementy tablicy mogą być określone typy, a inne mogą mieć parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3704">For an open constructed type or method, some elements of the array might be specific types and others might be type parameters.</span></span> <span data-ttu-id="9cc50-3705"><xref:System.Type.IsGenericParameter%2A> Zwraca `false` dla typów i `true` dla parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3705"><xref:System.Type.IsGenericParameter%2A> returns `false` for the types and `true` for the type parameters.</span></span> <span data-ttu-id="9cc50-3706">Przykład kodu dla <xref:System.Type.ContainsGenericParameters%2A> właściwość pokazuje klasę ogólną za pomocą kombinacji typów parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3706">The code example for the <xref:System.Type.ContainsGenericParameters%2A> property demonstrates a generic class with a mixture of types and type parameters.</span></span>  
  
 <span data-ttu-id="9cc50-3707">Aby uzyskać listę niezmiennych warunków dla terminów używanych w odbiciu rodzajowym, zobacz <xref:System.Type.IsGenericType%2A> uwagi dotyczące właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3707">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3708">W poniższym przykładzie użyto <xref:System.Type.IsGenericParameter%2A> właściwość do badania parametrów typu rodzajowego w typie ogólnym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3708">The following example uses the <xref:System.Type.IsGenericParameter%2A> property to test for generic type parameters in a generic type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="9cc50-3709">Odbicie i typy ogólne</span><span class="sxs-lookup"><span data-stu-id="9cc50-3709">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="9cc50-3710">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</span><span class="sxs-lookup"><span data-stu-id="9cc50-3710">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3711">Pobiera wartość wskazującą, czy bieżący typ jest typem ogólnym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3711">Gets a value indicating whether the current type is a generic type.</span></span></summary>
        <value><span data-ttu-id="9cc50-3712"><see langword="true" /> Jeśli bieżący typ jest typem podstawowym; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3712"><see langword="true" /> if the current type is a generic type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3713">Użyj <xref:System.Type.IsGenericType%2A> właściwości, aby określić, czy <xref:System.Type> obiekt reprezentuje typ ogólny.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3713">Use the <xref:System.Type.IsGenericType%2A> property to determine whether a <xref:System.Type> object represents a generic type.</span></span> <span data-ttu-id="9cc50-3714">Użyj <xref:System.Type.ContainsGenericParameters%2A> właściwości, aby określić, czy <xref:System.Type> obiekt reprezentuje skonstruowanego typu otwartego lub zamkniętych skonstruowanego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3714">Use the <xref:System.Type.ContainsGenericParameters%2A> property to determine whether a <xref:System.Type> object represents an open constructed type or a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-3715"><xref:System.Type.IsGenericType%2A> Właściwość zwraca `false` jeśli natychmiastowe nie jest to typ ogólny.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3715">The <xref:System.Type.IsGenericType%2A> property returns `false` if the immediate type is not generic.</span></span> <span data-ttu-id="9cc50-3716">Na przykład tablica, której elementy są typu `A<int>` (`A(Of Integer)` w języku Visual Basic) sam nie jest typem ogólnym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3716">For example, an array whose elements are of type `A<int>` (`A(Of Integer)` in Visual Basic) is not itself a generic type.</span></span>  
  
 <span data-ttu-id="9cc50-3717">Poniższa tabela zawiera podsumowanie niezmiennych warunków dla typowych terminów używanych w odbiciu rodzajowym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3717">The following table summarizes the invariant conditions for common terms used in generic reflection.</span></span>  
  
|<span data-ttu-id="9cc50-3718">Termin</span><span class="sxs-lookup"><span data-stu-id="9cc50-3718">Term</span></span>|<span data-ttu-id="9cc50-3719">Niezmiennej</span><span class="sxs-lookup"><span data-stu-id="9cc50-3719">Invariant</span></span>|  
|----------|---------------|  
|<span data-ttu-id="9cc50-3720">Definicja typu ogólnego</span><span class="sxs-lookup"><span data-stu-id="9cc50-3720">generic type definition</span></span>|<span data-ttu-id="9cc50-3721"><xref:System.Type.IsGenericTypeDefinition%2A> Właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3721">The <xref:System.Type.IsGenericTypeDefinition%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="9cc50-3722">Definiuje typ ogólny.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3722">Defines a generic type.</span></span> <span data-ttu-id="9cc50-3723">Skonstruowany typ jest tworzony przez wywołanie <xref:System.Type.MakeGenericType%2A> metody <xref:System.Type> obiekt, który reprezentuje definicji typu ogólnego i określając tablicę argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3723">A constructed type is created by calling the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object that represents a generic type definition and specifying an array of type arguments.</span></span><br /><br /> <span data-ttu-id="9cc50-3724"><xref:System.Type.MakeGenericType%2A> można wywołać tylko w definicji typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3724"><xref:System.Type.MakeGenericType%2A> can be called only on generic type definitions.</span></span><br /><br /> <span data-ttu-id="9cc50-3725">Dowolna definicja typu ogólnego jest typem ogólnym ( <xref:System.Type.IsGenericType%2A> właściwość `true`), ale nie jest to prawdą.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3725">Any generic type definition is a generic type (the <xref:System.Type.IsGenericType%2A> property is `true`), but the converse is not true.</span></span>|  
|<span data-ttu-id="9cc50-3726">Typ ogólny</span><span class="sxs-lookup"><span data-stu-id="9cc50-3726">generic type</span></span>|<span data-ttu-id="9cc50-3727"><xref:System.Type.IsGenericType%2A> Właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3727">The <xref:System.Type.IsGenericType%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="9cc50-3728">Może być definicji typu ogólnego, skonstruowanego typu otwartego lub zamkniętych skonstruowanego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3728">Can be a generic type definition, an open constructed type, or a closed constructed type.</span></span><br /><br /> <span data-ttu-id="9cc50-3729">Należy pamiętać, że tablica typu którego typ elementu jest ogólny sam nie jest typem ogólnym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3729">Note that an array type whose element type is generic is not itself a generic type.</span></span> <span data-ttu-id="9cc50-3730">To samo dotyczy programu <xref:System.Type> obiekt reprezentujący wskaźnik do typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3730">The same is true of a <xref:System.Type> object representing a pointer to a generic type.</span></span>|  
|<span data-ttu-id="9cc50-3731">Otwórz skonstruowanego typu</span><span class="sxs-lookup"><span data-stu-id="9cc50-3731">open constructed type</span></span>|<span data-ttu-id="9cc50-3732"><xref:System.Type.ContainsGenericParameters%2A> Właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3732">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="9cc50-3733">Przykłady to typ ogólny, który ma nieprzypisanych parametry typu, typ, który jest zagnieżdżony w definicji typu ogólnego lub skonstruowanego typu otwartego lub typ ogólny, który ma argument typu, dla którego <xref:System.Type.ContainsGenericParameters%2A> właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3733">Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="9cc50-3734">Nie jest możliwe do utworzenia wystąpienia typu otwartego skonstruowany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3734">It is not possible to create an instance of an open constructed type.</span></span><br /><br /> <span data-ttu-id="9cc50-3735">Należy pamiętać, że nie wszystkie otwarte typy utworzone są rodzajowe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3735">Note that not all open constructed types are generic.</span></span> <span data-ttu-id="9cc50-3736">Na przykład nie jest ogólna tablica, którego typ elementu jest definicja typu ogólnego i nie jest ogólna wskaźnik do skonstruowanego typu otwartego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3736">For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.</span></span>|  
|<span data-ttu-id="9cc50-3737">skonstruowany typ zamknięty</span><span class="sxs-lookup"><span data-stu-id="9cc50-3737">closed constructed type</span></span>|<span data-ttu-id="9cc50-3738"><xref:System.Type.ContainsGenericParameters%2A> Właściwość `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3738">The <xref:System.Type.ContainsGenericParameters%2A> property is `false`.</span></span><br /><br /> <span data-ttu-id="9cc50-3739">Gdy zbadane cyklicznie, typ nie ma nieprzypisane ogólnych parametrów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3739">When examined recursively, the type has no unassigned generic parameters.</span></span>|  
|<span data-ttu-id="9cc50-3740">Parametr typu ogólnego</span><span class="sxs-lookup"><span data-stu-id="9cc50-3740">generic type parameter</span></span>|<span data-ttu-id="9cc50-3741"><xref:System.Type.IsGenericParameter%2A> Właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3741">The <xref:System.Type.IsGenericParameter%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="9cc50-3742"><xref:System.Type.ContainsGenericParameters%2A> Właściwość `true`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3742">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="9cc50-3743">W definicji typu ogólnego jest symbolem zastępczym dla typu, który zostanie przypisany później.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3743">In a generic type definition, a placeholder for a type that will be assigned later.</span></span>|  
|<span data-ttu-id="9cc50-3744">argument typu ogólnego</span><span class="sxs-lookup"><span data-stu-id="9cc50-3744">generic type argument</span></span>|<span data-ttu-id="9cc50-3745">Może być dowolnego typu, w tym parametr typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3745">Can be any type, including a generic type parameter.</span></span><br /><br /> <span data-ttu-id="9cc50-3746">Argumenty typu są określane jako tablicę <xref:System.Type> przekazywanym do <xref:System.Type.MakeGenericType%2A> metody podczas tworzenia zbudowany typ ogólny.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3746">Type arguments are specified as an array of <xref:System.Type> objects passed to the <xref:System.Type.MakeGenericType%2A> method when creating a constructed generic type.</span></span> <span data-ttu-id="9cc50-3747">W przypadku wystąpienia wynikowy typ ma zostać utworzony <xref:System.Type.ContainsGenericParameters%2A> właściwość musi być `false` dla wszystkich argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3747">If instances of the resulting type are to be created, the <xref:System.Type.ContainsGenericParameters%2A> property must be `false` for all the type arguments.</span></span>|  
  
 <span data-ttu-id="9cc50-3748">Następujący przykładowy kod i tabeli przedstawiono niektóre z tych warunków i invariants.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3748">The following code example and table illustrate some of these terms and invariants.</span></span> <span data-ttu-id="9cc50-3749">`Derived` Klasy ma szczególne znaczenie, ponieważ jego typ podstawowy jest typem stworzonego elementu, który zawiera kombinację typów parametrów typu w jego lista argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3749">The `Derived` class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 <span data-ttu-id="9cc50-3750">W poniższej tabeli przedstawiono przykłady, które oraz tworzyć dotyczące klas `Base`, `Derived`, i `G`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3750">The following table shows examples that use and build on the classes `Base`, `Derived`, and `G`.</span></span> <span data-ttu-id="9cc50-3751">W przypadku kodu C++ i C# jest taka sama, jest wyświetlana tylko jedna pozycja.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3751">When the C++ and C# code is the same, only one entry is shown.</span></span>  
  
|<span data-ttu-id="9cc50-3752">Przykład</span><span class="sxs-lookup"><span data-stu-id="9cc50-3752">Example</span></span>|<span data-ttu-id="9cc50-3753">Invariants</span><span class="sxs-lookup"><span data-stu-id="9cc50-3753">Invariants</span></span>|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|<span data-ttu-id="9cc50-3754">Dla tego typu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3754">For this type:</span></span><br /><br /> <span data-ttu-id="9cc50-3755"><xref:System.Type.IsGenericType%2A> jest `true`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3755"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="9cc50-3756"><xref:System.Type.IsGenericTypeDefinition%2A> jest `true`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3756"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="9cc50-3757"><xref:System.Type.ContainsGenericParameters%2A> jest `true`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3757"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|<span data-ttu-id="9cc50-3758">Dla tego typu:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3758">For this type:</span></span><br /><br /> <span data-ttu-id="9cc50-3759"><xref:System.Type.IsGenericType%2A> jest `true`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3759"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="9cc50-3760"><xref:System.Type.IsGenericTypeDefinition%2A> jest `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3760"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="9cc50-3761"><xref:System.Type.ContainsGenericParameters%2A> jest `true`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3761"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|<span data-ttu-id="9cc50-3762">Dla typu zmiennej `d`:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3762">For the type of variable `d`:</span></span><br /><br /> <span data-ttu-id="9cc50-3763"><xref:System.Type.IsGenericType%2A> jest `false` ponieważ `d` jest tablicą.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3763"><xref:System.Type.IsGenericType%2A> is `false` because `d` is an array.</span></span><br /><br /> <span data-ttu-id="9cc50-3764"><xref:System.Type.IsGenericTypeDefinition%2A> jest `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3764"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="9cc50-3765"><xref:System.Type.ContainsGenericParameters%2A> jest `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3765"><xref:System.Type.ContainsGenericParameters%2A> is `false`.</span></span>|  
|<span data-ttu-id="9cc50-3766">`T`, `U`, i `V` (wszędzie, gdzie są wyświetlane)</span><span class="sxs-lookup"><span data-stu-id="9cc50-3766">`T`, `U`, and `V` (everywhere they appear)</span></span>|<span data-ttu-id="9cc50-3767"><xref:System.Type.IsGenericParameter%2A> jest `true`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3767"><xref:System.Type.IsGenericParameter%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="9cc50-3768"><xref:System.Type.IsGenericType%2A> jest `false` ponieważ nie istnieje żaden sposób ograniczyć parametr typu do typów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3768"><xref:System.Type.IsGenericType%2A> is `false` because there is no way to constrain a type parameter to generic types.</span></span><br /><br /> <span data-ttu-id="9cc50-3769"><xref:System.Type.IsGenericTypeDefinition%2A> jest `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3769"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="9cc50-3770"><xref:System.Type.ContainsGenericParameters%2A> jest `true` ponieważ `T`, `U`, i `V` są same parametry typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3770"><xref:System.Type.ContainsGenericParameters%2A> is `true` because `T`, `U`, and `V` are themselves generic type parameters.</span></span> <span data-ttu-id="9cc50-3771">To nie oznacza niczego o argumentach typu, które są przypisane do ich później.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3771">This does not imply anything about type arguments that are assigned to them later.</span></span>|  
|<span data-ttu-id="9cc50-3772">Typ pola `F`</span><span class="sxs-lookup"><span data-stu-id="9cc50-3772">The type of field `F`</span></span>|<span data-ttu-id="9cc50-3773"><xref:System.Type.IsGenericType%2A> jest `true`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3773"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="9cc50-3774"><xref:System.Type.IsGenericTypeDefinition%2A> jest `false` , ponieważ typ przypisany do typu parametru `G`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3774"><xref:System.Type.IsGenericTypeDefinition%2A> is `false` because a type has been assigned to the type parameter of `G`.</span></span> <span data-ttu-id="9cc50-3775">Należy pamiętać, że jest to równoważne wywołaniem <xref:System.Type.MakeGenericType%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3775">Note that this is equivalent to having called the <xref:System.Type.MakeGenericType%2A> method.</span></span><br /><br /> <span data-ttu-id="9cc50-3776"><xref:System.Type.ContainsGenericParameters%2A> jest `true` ponieważ typ pola `F` ma argument typu, który jest typem otwartym skonstruowany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3776"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the type of field `F` has a type argument that is an open constructed type.</span></span> <span data-ttu-id="9cc50-3777">Skonstruowany typ jest otwarty ponieważ jej argument typu (czyli `Base`) jest definicja typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3777">The constructed type is open because its type argument (that is, `Base`) is a generic type definition.</span></span> <span data-ttu-id="9cc50-3778">Obrazuje to cykliczne rodzaj <xref:System.Type.IsGenericType%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3778">This illustrates the recursive nature of the <xref:System.Type.IsGenericType%2A> property.</span></span>|  
|<span data-ttu-id="9cc50-3779">Klasa zagnieżdżona `Nested`</span><span class="sxs-lookup"><span data-stu-id="9cc50-3779">The nested class `Nested`</span></span>|<span data-ttu-id="9cc50-3780"><xref:System.Type.IsGenericType%2A> jest `true`, nawet jeśli `Nested` klasa ma żadnych parametrów typu rodzajowego, własnych, ponieważ jest zagnieżdżony w typie ogólnym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3780"><xref:System.Type.IsGenericType%2A> is `true`, even though the `Nested` class has no generic type parameters of its own, because it is nested in a generic type.</span></span><br /><br /> <span data-ttu-id="9cc50-3781"><xref:System.Type.IsGenericTypeDefinition%2A> jest `true`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3781"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span> <span data-ttu-id="9cc50-3782">Oznacza to, można wywołać <xref:System.Type.MakeGenericType%2A> metody i dostarczyć parametr typu otaczającego `Derived`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3782">That is, you can call the <xref:System.Type.MakeGenericType%2A> method and supply the type parameter of the enclosing type, `Derived`.</span></span><br /><br /> <span data-ttu-id="9cc50-3783"><xref:System.Type.ContainsGenericParameters%2A> jest `true` ponieważ otaczający typ `Derived`, ma parametry typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3783"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the enclosing type, `Derived`, has generic type parameters.</span></span> <span data-ttu-id="9cc50-3784">Obrazuje to cykliczne rodzaj <xref:System.Type.ContainsGenericParameters%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3784">This illustrates the recursive nature of the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3785">Poniższy przykład kodu wyświetla wartość <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, i <xref:System.Type.ContainsGenericParameters%2A> właściwości typów, opisanych w sekcji uwag.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3785">The following code example displays the value of the <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, and <xref:System.Type.ContainsGenericParameters%2A> properties for the types described in the Remarks section.</span></span> <span data-ttu-id="9cc50-3786">Objaśnienia dotyczące wartości właściwości Zobacz towarzyszący tabelę w uwagi.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3786">For explanations of the property values, see the accompanying table in Remarks.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="9cc50-3787">Odbicie i typy ogólne</span><span class="sxs-lookup"><span data-stu-id="9cc50-3787">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="9cc50-3788">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</span><span class="sxs-lookup"><span data-stu-id="9cc50-3788">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3789">Pobiera wartość wskazującą czy bieżący <see cref="T:System.Type" /> reprezentuje definicji typu ogólnego, z którego można skonstruować innych typów ogólnych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3789">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a generic type definition, from which other generic types can be constructed.</span></span></summary>
        <value><span data-ttu-id="9cc50-3790"><see langword="true" /> Jeśli <see cref="T:System.Type" /> obiekt reprezentuje definicji typu ogólnego; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3790"><see langword="true" /> if the <see cref="T:System.Type" /> object represents a generic type definition; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3791">Definicja typu ogólnego jest szablonem, z którego można skonstruować innych typów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3791">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="9cc50-3792">Na przykład z definicji typu ogólnego `G<T>` (wyrażony w języku C# składni; `G(Of T)` w języku Visual Basic lub `generic <typename T> ref class G` w języku C++) można utworzyć i utworzyć wystąpienie typu `G<int>` (`G(Of Integer)` w języku Visual Basic), przez wywołanie metody <xref:System.Type.MakeGenericType%2A> metody z argumentem ogólnym lista zawierająca <xref:System.Int32> typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3792">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic), by calling the <xref:System.Type.MakeGenericType%2A> method with a generic argument list containing the <xref:System.Int32> type.</span></span> <span data-ttu-id="9cc50-3793">Biorąc pod uwagę <xref:System.Type> obiekt reprezentujący to skonstruowany typ <xref:System.Type.GetGenericTypeDefinition%2A> metoda otrzymuje w definicji typu ogólnego ponownie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3793">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method gets the generic type definition back again.</span></span>  
  
 <span data-ttu-id="9cc50-3794">Użyj <xref:System.Type.IsGenericTypeDefinition%2A> właściwości w celu określenia, czy można utworzyć nowych typów z bieżącego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3794">Use the <xref:System.Type.IsGenericTypeDefinition%2A> property to determine whether you can create new types from the current type.</span></span> <span data-ttu-id="9cc50-3795">Jeśli <xref:System.Type.IsGenericTypeDefinition%2A> właściwość zwraca `true`, można wywołać <xref:System.Type.MakeGenericType%2A> metodę w celu utworzenia nowych typów rodzajowych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3795">If the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `true`, you can call the <xref:System.Type.MakeGenericType%2A> method to create new generic types.</span></span>  
  
 <span data-ttu-id="9cc50-3796">Aby uzyskać listę niezmiennych warunków dla terminów używanych w odbiciu rodzajowym, zobacz <xref:System.Type.IsGenericType%2A> uwagi dotyczące właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3796">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3797">Poniższy przykład wyświetla informacje o typie, w tym, czy jest definicja typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3797">The following example displays information about a type, including whether or not it is a generic type definition.</span></span> <span data-ttu-id="9cc50-3798">Skonstruowany typ, jego definicję typu ogólnego i typu zwykłego, zostaną wyświetlone informacje.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3798">Information is displayed for a constructed type, for its generic type definition, and for an ordinary type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="9cc50-3799">Odbicie i typy ogólne</span><span class="sxs-lookup"><span data-stu-id="9cc50-3799">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="9cc50-3800">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</span><span class="sxs-lookup"><span data-stu-id="9cc50-3800">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3801">Pobiera wartość wskazującą czy <see cref="T:System.Type" /> ma <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> zastosowany, wskazujący, że został zaimportowany z biblioteki typów COM.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3801">Gets a value indicating whether the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> attribute applied, indicating that it was imported from a COM type library.</span></span></summary>
        <value><span data-ttu-id="9cc50-3802"><see langword="true" /> Jeśli <see cref="T:System.Type" /> ma <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3802"><see langword="true" /> if the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3803">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3803">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="9cc50-3804">Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="9cc50-3804">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="9cc50-3805">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3805">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="9cc50-3806">Obiekt do porównania z bieżącym typem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3806">The object to compare with the current type.</span></span></param>
        <summary><span data-ttu-id="9cc50-3807">Określa, czy określony obiekt jest wystąpieniem bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3807">Determines whether the specified object is an instance of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3808"><see langword="true" /> Jeśli bieżący <see langword="Type" /> znajduje się w hierarchii dziedziczenia obiektu reprezentowanego przez <paramref name="o" />, lub, jeśli bieżący <see langword="Type" /> jest interfejsem, <paramref name="o" /> implementuje.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3808"><see langword="true" /> if the current <see langword="Type" /> is in the inheritance hierarchy of the object represented by <paramref name="o" />, or if the current <see langword="Type" /> is an interface that <paramref name="o" /> implements.</span></span> <span data-ttu-id="9cc50-3809"><see langword="false" /> Jeśli żadna z tych warunków jest przypadek, gdy <paramref name="o" /> jest <see langword="null" />, lub, jeśli bieżący <see langword="Type" /> jest to otwarty typ ogólny (oznacza to, że <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" />).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3809"><see langword="false" /> if neither of these conditions is the case, if <paramref name="o" /> is <see langword="null" />, or if the current <see langword="Type" /> is an open generic type (that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3810">Metoda ta może być zastąpiona przez klasę pochodną.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3810">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-3811">Skonstruowany typ nie jest wystąpieniem jego definicji typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3811">A constructed type is not an instance of its generic type definition.</span></span> <span data-ttu-id="9cc50-3812">Oznacza to, że `MyGenericList<int>` (`MyGenericList(Of Integer)` w języku Visual Basic) nie jest wystąpieniem `MyGenericList<T>` (`MyGenericList(Of T)` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3812">That is, `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) is not an instance of `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3813">W poniższym przykładzie pokazano użycie `IsInstanceOfType` metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3813">The following example demonstrates the use of the `IsInstanceOfType` method.</span></span>  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3814">Pobiera wartość wskazującą czy <see cref="T:System.Type" /> interfejsu; nie jest klasą lub typu wartości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3814">Gets a value indicating whether the <see cref="T:System.Type" /> is an interface; that is, not a class or a value type.</span></span></summary>
        <value><span data-ttu-id="9cc50-3815"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest interfejsem; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3815"><see langword="true" /> if the <see cref="T:System.Type" /> is an interface; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3816"><xref:System.Reflection.TypeAttributes.ClassSemanticsMask> Wyróżnia deklaracji typu jako typ klasy, interfejsu lub wartość.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3816">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distinguishes a type declaration as class, interface or value type.</span></span>  
  
 <span data-ttu-id="9cc50-3817">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3817">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="9cc50-3818">Ta właściwość jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3818">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3819">Poniższy przykład tworzy interfejs, sprawdza, czy typ interfejsu i wskazuje, czy klasa ma `IsInterface` zestawu właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3819">The following example creates an interface, checks for the interface type, and indicates whether a class has the `IsInterface` property set.</span></span>  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3820">Pobiera wartość wskazującą, czy pola bieżącego typu są ułożone sekwencyjnie w kolejności, że zostały zdefiniowane lub emitowany do metadanych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3820">Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</span></span></summary>
        <value><span data-ttu-id="9cc50-3821"><see langword="true" /> Jeśli <see cref="P:System.Type.Attributes" /> zawiera właściwości bieżącego typu <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3821"><see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3822">Ta właściwość jest udostępniana dla wygody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3822">This property is provided as a convenience.</span></span> <span data-ttu-id="9cc50-3823">Alternatywnie, można użyć <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> wartości wyliczenia, aby wybrać atrybuty układu typu, a następnie w celu przetestowania, czy <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> jest ustawiona.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3823">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="9cc50-3824"><xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, I <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> wartości wyliczenia wskazuje sposób pola tego typu są ułożone w pamięci.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3824">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="9cc50-3825">W przypadku typów dynamicznych, możesz określić <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> podczas tworzenia tego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3825">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="9cc50-3826">W kodzie, należy zastosować <xref:System.Runtime.InteropServices.StructLayoutAttribute> atrybutem <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> wartość wyliczenia do typu, aby określić, że układ jest sekwencyjny.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3826">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value to the type, to specify that layout is sequential.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-3827">Nie można użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metodę pozwala ustalić czy <xref:System.Runtime.InteropServices.StructLayoutAttribute> zastosowano do typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3827">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="9cc50-3828">Aby uzyskać więcej informacji, zobacz część 9.1.2 specyfikacja Common Language Infrastructure (CLI) dokumentacji dotyczącej, "partycja II: Definicja metadanych i semantyka".</span><span class="sxs-lookup"><span data-stu-id="9cc50-3828">For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="9cc50-3829">Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) w witrynie Ecma International w sieci Web.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3829">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="9cc50-3830">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3830">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="9cc50-3831">Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3831">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="9cc50-3832">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3832">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3833">Poniższy przykład tworzy wystąpienie klasy, dla którego <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> wartości wyliczenia w <xref:System.Runtime.InteropServices.StructLayoutAttribute> klasa została ustawiona, sprawdza, czy <xref:System.Type.IsLayoutSequential%2A> właściwości i wyświetla wynik.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3833">The following example creates an instance of a class for which the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value in the <xref:System.Runtime.InteropServices.StructLayoutAttribute> class has been set, checks for the <xref:System.Type.IsLayoutSequential%2A> property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md"><span data-ttu-id="9cc50-3834">Składniki samoopisujące się i metadane</span><span class="sxs-lookup"><span data-stu-id="9cc50-3834">Metadata and Self-Describing Components</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3835">Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest przekazywany przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3835">Gets a value indicating whether the <see cref="T:System.Type" /> is marshaled by reference.</span></span></summary>
        <value><span data-ttu-id="9cc50-3836"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest organizowane przez odwołanie; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3836"><see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="9cc50-3837">W poniższym przykładzie pokazano `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, i <xref:System.Type.IsPrimitive%2A> właściwości <xref:System.Type> klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3837">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="9cc50-3838">Sprawdza, czy dany typ może być hostowana w kontekście, czy mogą być przekazywane przez odwołanie i zezwolić na określony typ jest typem danych pierwotnych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3838">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-3839">Implementuje <see cref="P:System.Type.IsMarshalByRef" /> właściwości i określa, czy <see cref="T:System.Type" /> jest przekazywany przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3839">Implements the <see cref="P:System.Type.IsMarshalByRef" /> property and determines whether the <see cref="T:System.Type" /> is marshaled by reference.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3840"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest organizowane przez odwołanie; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3840"><see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3841">Metoda ta może być zastąpiona przez klasę pochodną.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3841">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3842">Poniższy przykład określa, czy dany typ jest przekazywany przez odwołanie, a następnie wyświetla wynik.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3842">The following example determines whether the given type is marshaled by reference and displays the result.</span></span>  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3843">Pobiera wartość wskazującą czy bieżący <see cref="T:System.Type" /> obiekt reprezentuje typ, którego definicja jest zagnieżdżona w definicji typu innego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3843">Gets a value indicating whether the current <see cref="T:System.Type" /> object represents a type whose definition is nested inside the definition of another type.</span></span></summary>
        <value><span data-ttu-id="9cc50-3844"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zagnieżdżone wewnątrz innego typu; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3844"><see langword="true" /> if the <see cref="T:System.Type" /> is nested inside another type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3845"><xref:System.Type.IsNested%2A> Właściwość zwraca `true` dla wszystkich zagnieżdżonych typów, niezależnie od tego, widoczność.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3845">The <xref:System.Type.IsNested%2A> property returns `true` for all nested types, regardless of visibility.</span></span> <span data-ttu-id="9cc50-3846">Aby sprawdzić zagnieżdżanie i widoczność w tym samym czasie, należy użyć powiązane właściwości <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, lub <xref:System.Type.IsNestedPublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3846">To test for nesting and visibility at the same time, use the related properties <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, or <xref:System.Type.IsNestedPublic%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-3847"><xref:System.Reflection.TypeAttributes.VisibilityMask> Element członkowski wyliczenia wybiera atrybuty widoczności dla typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3847">The <xref:System.Reflection.TypeAttributes.VisibilityMask> enumeration member selects the visibility attributes for a type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3848">Poniższy przykład tworzy zewnętrznej klasy, wprowadzając szereg klas zagnieżdżonych, które mają różne rodzaje widoczności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3848">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="9cc50-3849">Następnie pobiera wartość liczby związanych z widocznością <xref:System.Type> właściwości dla typu nadrzędnego, a każdy z jego typów zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3849">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3850">Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest zagnieżdżony i są widoczne tylko w ramach ich własnych zestawach.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3850">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own assembly.</span></span></summary>
        <value><span data-ttu-id="9cc50-3851"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zagnieżdżony i widoczne tylko w ramach ich własnych zestawach; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3851"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own assembly; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3852">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3852">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="9cc50-3853"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wybiera atrybuty widoczności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3853"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3854">Poniższy przykład tworzy zewnętrznej klasy, wprowadzając szereg klas zagnieżdżonych, które mają różne rodzaje widoczności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3854">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="9cc50-3855">Następnie pobiera wartość liczby związanych z widocznością <xref:System.Type> właściwości dla typu nadrzędnego, a każdy z jego typów zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3855">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3856">Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest zagnieżdżony i są widoczne tylko dla klas, które należą do jego własnej rodzinę i swój własny zestaw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3856">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly.</span></span></summary>
        <value><span data-ttu-id="9cc50-3857"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zagnieżdżony i widoczne tylko dla klas, które należą do jego własnej rodzinę i swój własny zestaw; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3857"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3858">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3858">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="9cc50-3859"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wybiera atrybuty widoczności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3859"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-3860">W językach C# i Visual Basic nie dołączaj semantykę, która zezwala na określanie typu zagnieżdżonego, która jest widoczna tylko dla typów chronionych w ich własnych zestawach.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3860">The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly.</span></span> <span data-ttu-id="9cc50-3861">`protected internal` wgląd w języku C# i `Protected Friend` widoczność w języku Visual Basic określić typu zagnieżdżonego, który jest widoczny, chronione typy i typy w tym samym zestawie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3861">`protected internal` visibility in C# and `Protected Friend` visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.</span></span>  
  
 <span data-ttu-id="9cc50-3862">A <xref:System.Type> rodziny obiektu jest zdefiniowana jako wszystkich obiektów tego samego <xref:System.Type> i jego podtypów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3862">A <xref:System.Type> object's family is defined as all objects of the same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3863">Poniższy przykład tworzy zewnętrznej klasy, wprowadzając szereg klas zagnieżdżonych, które mają różne rodzaje widoczności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3863">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="9cc50-3864">Następnie pobiera wartość liczby związanych z widocznością <xref:System.Type> właściwości dla typu nadrzędnego, a każdy z jego typów zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3864">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3865">Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest zagnieżdżony i są widoczne tylko w obrębie własnej rodziny.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3865">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own family.</span></span></summary>
        <value><span data-ttu-id="9cc50-3866"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zagnieżdżony i widoczne tylko w obrębie własnej rodziny; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3866"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own family; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3867">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3867">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="9cc50-3868"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wybiera atrybuty widoczności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3868"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="9cc50-3869">A <xref:System.Type> rodziny obiektu jest zdefiniowana jako wszystkich obiektów dokładnie tych samych <xref:System.Type> i jego podtypów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3869">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3870">Poniższy przykład tworzy zewnętrznej klasy, wprowadzając szereg klas zagnieżdżonych, które mają różne rodzaje widoczności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3870">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="9cc50-3871">Następnie pobiera wartość liczby związanych z widocznością <xref:System.Type> właściwości dla typu nadrzędnego, a każdy z jego typów zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3871">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3872">Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest zagnieżdżony i są widoczne tylko dla klas, które należą do jednej swój własny rodziny i swój własny zestaw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3872">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to either its own family or to its own assembly.</span></span></summary>
        <value><span data-ttu-id="9cc50-3873"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zagnieżdżony i widoczne tylko dla klas, które należą do jego własnej rodziny lub ich własnych zestawach; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3873"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3874">W przypadku widoczności typu `protected internal` w języku C# lub `Protected Friend` w języku Visual Basic <xref:System.Type.IsNestedFamORAssem%2A> właściwość zwraca `true`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3874">If the visibility of a type is `protected internal` in C# or `Protected Friend` in Visual Basic, the <xref:System.Type.IsNestedFamORAssem%2A> property returns `true`.</span></span>  
  
 <span data-ttu-id="9cc50-3875">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3875">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="9cc50-3876"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wybiera atrybuty widoczności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3876"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="9cc50-3877">A <xref:System.Type> rodziny obiektu jest zdefiniowana jako wszystkich obiektów dokładnie tych samych <xref:System.Type> i jego podtypów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3877">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3878">Poniższy przykład tworzy zewnętrznej klasy, wprowadzając szereg klas zagnieżdżonych, które mają różne rodzaje widoczności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3878">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="9cc50-3879">Następnie pobiera wartość liczby związanych z widocznością <xref:System.Type> właściwości dla typu nadrzędnego, a każdy z jego typów zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3879">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3880">Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest zagnieżdżony, a następnie deklarować prywatnych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3880">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and declared private.</span></span></summary>
        <value><span data-ttu-id="9cc50-3881"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zagnieżdżony i zadeklarować prywatny; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3881"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and declared private; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3882">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3882">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="9cc50-3883"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wybiera atrybuty widoczności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3883"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3884">Poniższy przykład tworzy zewnętrznej klasy, wprowadzając szereg klas zagnieżdżonych, które mają różne rodzaje widoczności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3884">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="9cc50-3885">Następnie pobiera wartość liczby związanych z widocznością <xref:System.Type> właściwości dla typu nadrzędnego, a każdy z jego typów zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3885">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3886">Pobiera wartość wskazującą, czy klasa jest zagnieżdżone i zadeklarowana publicznych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3886">Gets a value indicating whether a class is nested and declared public.</span></span></summary>
        <value><span data-ttu-id="9cc50-3887"><see langword="true" /> Jeśli klasa jest publiczny zagnieżdżony i zadeklarowane; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3887"><see langword="true" /> if the class is nested and declared public; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3888">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3888">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="9cc50-3889"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wybiera atrybuty widoczności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3889"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3890">Poniższy przykład tworzy zewnętrznej klasy, wprowadzając szereg klas zagnieżdżonych, które mają różne rodzaje widoczności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3890">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="9cc50-3891">Następnie pobiera wartość liczby związanych z widocznością <xref:System.Type> właściwości dla typu nadrzędnego, a każdy z jego typów zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3891">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3892">Pobiera wartość wskazującą czy <see cref="T:System.Type" /> nie jest zadeklarowany jako publiczny.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3892">Gets a value indicating whether the <see cref="T:System.Type" /> is not declared public.</span></span></summary>
        <value><span data-ttu-id="9cc50-3893"><see langword="true" /> Jeśli <see cref="T:System.Type" /> nie jest zadeklarowany jako publiczny i nie jest typem zagnieżdżonym; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3893"><see langword="true" /> if the <see cref="T:System.Type" /> is not declared public and is not a nested type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3894">Nie należy używać tej właściwości z typów zagnieżdżonych. Użyj <xref:System.Type.IsNestedPublic%2A> właściwości zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3894">Do not use this property with nested types; use the <xref:System.Type.IsNestedPublic%2A> property instead.</span></span>  
  
 <span data-ttu-id="9cc50-3895">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3895">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3896">W tym przykładzie użyto `IsNotPublic` właściwości, aby uzyskać wgląd w tego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3896">This example uses the `IsNotPublic` property to get the visibility of the type.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 <span data-ttu-id="9cc50-3897">Poniższy przykład kodu pokazuje, dlaczego nie można użyć `IsPublic` i `IsNotPublic` dla klas zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3897">The following code example demonstrates why you cannot use `IsPublic` and `IsNotPublic` for nested classes.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 <span data-ttu-id="9cc50-3898">Klasy zagnieżdżone, można zignorować w wynikach `IsPublic` i `IsNotPublic` i które należy zwrócić uwagę tylko wyniki `IsNestedPublic` i `IsNestedPrivate`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3898">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of `IsNestedPublic` and `IsNestedPrivate`.</span></span> <span data-ttu-id="9cc50-3899">Dane wyjściowe odbicia dla fragmentu kodu będzie następujący:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3899">The reflection output for this code fragment would be as follows:</span></span>  
  
|<span data-ttu-id="9cc50-3900">Class</span><span class="sxs-lookup"><span data-stu-id="9cc50-3900">Class</span></span>|<span data-ttu-id="9cc50-3901">IsNotPublic</span><span class="sxs-lookup"><span data-stu-id="9cc50-3901">IsNotPublic</span></span>|<span data-ttu-id="9cc50-3902">IsPublic</span><span class="sxs-lookup"><span data-stu-id="9cc50-3902">IsPublic</span></span>|<span data-ttu-id="9cc50-3903">IsNestedPublic</span><span class="sxs-lookup"><span data-stu-id="9cc50-3903">IsNestedPublic</span></span>|<span data-ttu-id="9cc50-3904">IsNestedPrivate</span><span class="sxs-lookup"><span data-stu-id="9cc50-3904">IsNestedPrivate</span></span>|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|<span data-ttu-id="9cc50-3905">ELEMENT</span><span class="sxs-lookup"><span data-stu-id="9cc50-3905">A</span></span>|<span data-ttu-id="9cc50-3906">FAŁSZ</span><span class="sxs-lookup"><span data-stu-id="9cc50-3906">FALSE</span></span>|<span data-ttu-id="9cc50-3907">WARTOŚĆ TRUE</span><span class="sxs-lookup"><span data-stu-id="9cc50-3907">TRUE</span></span>|<span data-ttu-id="9cc50-3908">FAŁSZ</span><span class="sxs-lookup"><span data-stu-id="9cc50-3908">FALSE</span></span>|<span data-ttu-id="9cc50-3909">FAŁSZ</span><span class="sxs-lookup"><span data-stu-id="9cc50-3909">FALSE</span></span>|  
|<span data-ttu-id="9cc50-3910">B</span><span class="sxs-lookup"><span data-stu-id="9cc50-3910">B</span></span>|<span data-ttu-id="9cc50-3911">FAŁSZ</span><span class="sxs-lookup"><span data-stu-id="9cc50-3911">FALSE</span></span>|<span data-ttu-id="9cc50-3912">FAŁSZ</span><span class="sxs-lookup"><span data-stu-id="9cc50-3912">FALSE</span></span>|<span data-ttu-id="9cc50-3913">WARTOŚĆ TRUE</span><span class="sxs-lookup"><span data-stu-id="9cc50-3913">TRUE</span></span>|<span data-ttu-id="9cc50-3914">FAŁSZ</span><span class="sxs-lookup"><span data-stu-id="9cc50-3914">FALSE</span></span>|  
|<span data-ttu-id="9cc50-3915">C</span><span class="sxs-lookup"><span data-stu-id="9cc50-3915">C</span></span>|<span data-ttu-id="9cc50-3916">FAŁSZ</span><span class="sxs-lookup"><span data-stu-id="9cc50-3916">FALSE</span></span>|<span data-ttu-id="9cc50-3917">FAŁSZ</span><span class="sxs-lookup"><span data-stu-id="9cc50-3917">FALSE</span></span>|<span data-ttu-id="9cc50-3918">FAŁSZ</span><span class="sxs-lookup"><span data-stu-id="9cc50-3918">FALSE</span></span>|<span data-ttu-id="9cc50-3919">WARTOŚĆ TRUE</span><span class="sxs-lookup"><span data-stu-id="9cc50-3919">TRUE</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3920">Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest wskaźnikiem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3920">Gets a value indicating whether the <see cref="T:System.Type" /> is a pointer.</span></span></summary>
        <value><span data-ttu-id="9cc50-3921"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest wskaźnikiem typu; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3921"><see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3922">Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny lub parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3922">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="9cc50-3923">Ta właściwość jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3923">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3924">Poniższy przykład pokazuje wykorzystanie `IsPointer` właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3924">The following example shows a use of the `IsPointer` property.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-3925">W przypadku przesłonięcia w klasie pochodnej, implementuje <see cref="P:System.Type.IsPointer" /> właściwości i określa, czy <see cref="T:System.Type" /> jest wskaźnikiem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3925">When overridden in a derived class, implements the <see cref="P:System.Type.IsPointer" /> property and determines whether the <see cref="T:System.Type" /> is a pointer.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3926"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest wskaźnikiem typu; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3926"><see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3927">Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest jednym z typów pierwotnych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3927">Gets a value indicating whether the <see cref="T:System.Type" /> is one of the primitive types.</span></span></summary>
        <value><span data-ttu-id="9cc50-3928"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest jednym z typów pierwotnych; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3928"><see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3929">Typy pierwotne są <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, i <xref:System.Single>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3929">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
 <span data-ttu-id="9cc50-3930">Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny lub parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3930">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3931">W poniższym przykładzie pokazano `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, i <xref:System.Type.IsPrimitive%2A> właściwości <xref:System.Type> klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3931">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="9cc50-3932">Sprawdza, czy dany typ może być hostowana w kontekście, czy mogą być przekazywane przez odwołanie i zezwolić na określony typ jest typem danych pierwotnych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3932">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-3933">W przypadku przesłonięcia w klasie pochodnej, implementuje <see cref="P:System.Type.IsPrimitive" /> właściwości i określa, czy <see cref="T:System.Type" /> jest jednym z typów pierwotnych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3933">When overridden in a derived class, implements the <see cref="P:System.Type.IsPrimitive" /> property and determines whether the <see cref="T:System.Type" /> is one of the primitive types.</span></span></summary>
        <returns><span data-ttu-id="9cc50-3934"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest jednym z typów pierwotnych; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3934"><see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3935">Typy pierwotne są <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, i <xref:System.Single>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3935">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3936">Poniższy przykład określa, czy dany typ jest typem pierwotnym i wyświetla wynik.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3936">The following example determines whether the given type is a primitive type and displays the result.</span></span>  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3937">Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest zadeklarowany jako publiczny.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3937">Gets a value indicating whether the <see cref="T:System.Type" /> is declared public.</span></span></summary>
        <value><span data-ttu-id="9cc50-3938"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zadeklarowany jako publiczny i nie jest typem zagnieżdżonym; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3938"><see langword="true" /> if the <see cref="T:System.Type" /> is declared public and is not a nested type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3939">Nie należy używać z typów zagnieżdżonych. Użyj <xref:System.Type.IsNestedPublic%2A> zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3939">Do not use with nested types; use <xref:System.Type.IsNestedPublic%2A> instead.</span></span>  
  
 <span data-ttu-id="9cc50-3940">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca `true`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3940">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `true`.</span></span>  
  
 <span data-ttu-id="9cc50-3941"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wybiera atrybuty widoczności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3941"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3942">Poniższy przykład tworzy wystąpienie `MyTestClass`, sprawdza, czy `IsPublic` właściwości i wyświetla wynik.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3942">The following example creates an instance of `MyTestClass`, checks for the `IsPublic` property, and displays the result.</span></span>  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 <span data-ttu-id="9cc50-3943">Klasy zagnieżdżone, można zignorować w wynikach `IsPublic` i `IsNotPublic` i które należy zwrócić uwagę tylko wyniki <xref:System.Type.IsNestedPublic%2A> i <xref:System.Type.IsNestedPrivate%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3943">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of <xref:System.Type.IsNestedPublic%2A> and <xref:System.Type.IsNestedPrivate%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3944">Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest zadeklarowany jako zapieczętowany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3944">Gets a value indicating whether the <see cref="T:System.Type" /> is declared sealed.</span></span></summary>
        <value><span data-ttu-id="9cc50-3945"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zadeklarowany jako sealed; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3945"><see langword="true" /> if the <see cref="T:System.Type" /> is declared sealed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3946">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, właściwość ta zwraca zawsze `true`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3946">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-3947">Poniższy przykład tworzy wystąpienie `sealed` klasy sprawdza, czy `IsSealed` właściwości i wyświetla wynik.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3947">The following example creates an instance of a `sealed` class, checks for the `IsSealed` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3948">Pobiera wartość wskazującą, czy bieżący typ jest krytyczne dla bezpieczeństwa lub zabezpieczenia bezpieczny krytyczny na bieżącym poziomie zaufania i dlatego mogą wykonywać krytyczne operacje.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3948">Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</span></span></summary>
        <value><span data-ttu-id="9cc50-3949"><see langword="true" /> w przypadku bieżącego typu zabezpieczenia krytyczny lub zabezpieczenia bezpieczny krytyczny bieżącym poziomie zaufania. <see langword="false" /> , gdy jest za przezroczysty.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3949"><see langword="true" /> if the current type is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3950"><xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, I <xref:System.Type.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości typu na jego bieżący poziom zaufania, zgodnie z ustaleniami środowisko uruchomieniowe języka wspólnego (CLR).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3950">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="9cc50-3951">W poniższej tabeli przedstawiono kombinacje tych właściwości:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3951">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="9cc50-3952">Poziom zabezpieczeń</span><span class="sxs-lookup"><span data-stu-id="9cc50-3952">Security level</span></span>|<span data-ttu-id="9cc50-3953">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="9cc50-3953">IsSecurityCritical</span></span>|<span data-ttu-id="9cc50-3954">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="9cc50-3954">IsSecuritySafeCritical</span></span>|<span data-ttu-id="9cc50-3955">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="9cc50-3955">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="9cc50-3956">Krytyczny</span><span class="sxs-lookup"><span data-stu-id="9cc50-3956">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="9cc50-3957">Bezpieczne krytyczne</span><span class="sxs-lookup"><span data-stu-id="9cc50-3957">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="9cc50-3958">Przezroczyste</span><span class="sxs-lookup"><span data-stu-id="9cc50-3958">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="9cc50-3959">Korzystanie z tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu i jego typów, sprawdzania bieżącego poziomu zaufania i próby zduplikowania reguł w środowisku uruchomieniowym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3959">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="9cc50-3960">Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3960">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="9cc50-3961">Jeżeli zestaw jest ładowany do domeny aplikacji częściowo zaufanej (na przykład w domenie aplikacji w trybie piaskownicy), środowisko wykonawcze ignoruje adnotacje zabezpieczeń zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3961">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="9cc50-3962">Zestaw i wszystkie jego typy są traktowane jako przezroczyste.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3962">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="9cc50-3963">Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3963">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="9cc50-3964">Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3964">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="9cc50-3965">Aktualne poziomy zaufania zestawów i domen aplikacji można określić za pomocą <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> i <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3965">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="9cc50-3966">Aby uzyskać więcej informacji dotyczących odbicia i przejrzystości, zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3966">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="9cc50-3967">Aby uzyskać informacje o przezroczystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3967">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="9cc50-3968">Zagadnienia dotyczące zabezpieczeń dla odbicia</span><span class="sxs-lookup"><span data-stu-id="9cc50-3968">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="9cc50-3969">Zmiany zabezpieczeń w programie .NET Framework</span><span class="sxs-lookup"><span data-stu-id="9cc50-3969">Security Changes in the .NET Framework</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3970">Pobiera wartość, która wskazuje, czy bieżący typ zabezpieczenia bezpieczny krytyczny bieżącym poziomie zaufania. oznacza to, czy go może wykonywać krytyczne operacje i może zostać oceniony przez kod przezroczysty.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3970">Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span></span></summary>
        <value><span data-ttu-id="9cc50-3971"><see langword="true" /> w przypadku bieżącego typu zabezpieczenia bezpieczny krytyczny bieżącym poziomie zaufania. <see langword="false" /> przypadku krytyczne dla bezpieczeństwa lub przezroczyste.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3971"><see langword="true" /> if the current type is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3972"><xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, I <xref:System.Type.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości typu na jego bieżący poziom zaufania, zgodnie z ustaleniami środowisko uruchomieniowe języka wspólnego (CLR).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3972">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="9cc50-3973">W poniższej tabeli przedstawiono kombinacje tych właściwości:</span><span class="sxs-lookup"><span data-stu-id="9cc50-3973">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="9cc50-3974">Poziom zabezpieczeń</span><span class="sxs-lookup"><span data-stu-id="9cc50-3974">Security level</span></span>|<span data-ttu-id="9cc50-3975">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="9cc50-3975">IsSecurityCritical</span></span>|<span data-ttu-id="9cc50-3976">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="9cc50-3976">IsSecuritySafeCritical</span></span>|<span data-ttu-id="9cc50-3977">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="9cc50-3977">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="9cc50-3978">Krytyczny</span><span class="sxs-lookup"><span data-stu-id="9cc50-3978">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="9cc50-3979">Bezpieczne krytyczne</span><span class="sxs-lookup"><span data-stu-id="9cc50-3979">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="9cc50-3980">Przezroczyste</span><span class="sxs-lookup"><span data-stu-id="9cc50-3980">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="9cc50-3981">Korzystanie z tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu i jego typów, sprawdzania bieżącego poziomu zaufania i próby zduplikowania reguł w środowisku uruchomieniowym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3981">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="9cc50-3982">Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3982">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="9cc50-3983">Jeżeli zestaw jest ładowany do domeny aplikacji częściowo zaufanej (na przykład w domenie aplikacji w trybie piaskownicy), środowisko wykonawcze ignoruje adnotacje zabezpieczeń zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3983">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="9cc50-3984">Zestaw i wszystkie jego typy są traktowane jako przezroczyste.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3984">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="9cc50-3985">Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3985">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="9cc50-3986">Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3986">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="9cc50-3987">Aktualne poziomy zaufania zestawów i domen aplikacji można określić za pomocą <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> i <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3987">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="9cc50-3988">Aby uzyskać więcej informacji dotyczących odbicia i przejrzystości, zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3988">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="9cc50-3989">Aby uzyskać informacje o przezroczystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3989">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="9cc50-3990">Zagadnienia dotyczące zabezpieczeń dla odbicia</span><span class="sxs-lookup"><span data-stu-id="9cc50-3990">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="9cc50-3991">Zmiany zabezpieczeń w programie .NET Framework</span><span class="sxs-lookup"><span data-stu-id="9cc50-3991">Security Changes in the .NET Framework</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-3992">Pobiera wartość wskazującą, czy bieżący typ jest niewidoczne na bieżącym poziomie zaufania i dlatego nie można wykonać operacji krytycznych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3992">Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</span></span></summary>
        <value><span data-ttu-id="9cc50-3993"><see langword="true" /> Jeśli typ jest przezroczyste dla zabezpieczeń na bieżącym poziomie zaufania; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3993"><see langword="true" /> if the type is security-transparent at the current trust level; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-3994">Jeśli ta właściwość zwraca `true`, <xref:System.Type.IsSecurityCritical%2A> i <xref:System.Type.IsSecuritySafeCritical%2A> return właściwości `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3994">If this property returns `true`, the <xref:System.Type.IsSecurityCritical%2A> and <xref:System.Type.IsSecuritySafeCritical%2A> properties return `false`.</span></span>  
  
 <span data-ttu-id="9cc50-3995"><xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, I <xref:System.Type.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości typu na jego bieżący poziom zaufania, zgodnie z ustaleniami środowisko uruchomieniowe języka wspólnego (CLR).</span><span class="sxs-lookup"><span data-stu-id="9cc50-3995">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="9cc50-3996">Korzystanie z tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu i jego typów, sprawdzania bieżącego poziomu zaufania i próby zduplikowania reguł w środowisku uruchomieniowym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3996">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="9cc50-3997">Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3997">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="9cc50-3998">Jeżeli zestaw jest ładowany do domeny aplikacji częściowo zaufanej (na przykład w domenie aplikacji w trybie piaskownicy), środowisko wykonawcze ignoruje adnotacje zabezpieczeń zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3998">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="9cc50-3999">Zestaw i wszystkie jego typy są traktowane jako przezroczyste.</span><span class="sxs-lookup"><span data-stu-id="9cc50-3999">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="9cc50-4000">Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu).</span><span class="sxs-lookup"><span data-stu-id="9cc50-4000">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="9cc50-4001">Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4001">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="9cc50-4002">Aktualne poziomy zaufania zestawów i domen aplikacji można określić za pomocą <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> i <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4002">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="9cc50-4003">Aby uzyskać więcej informacji dotyczących odbicia i przejrzystości, zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="9cc50-4003">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="9cc50-4004">Aby uzyskać informacje o przezroczystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="9cc50-4004">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="9cc50-4005">Zagadnienia dotyczące zabezpieczeń dla odbicia</span><span class="sxs-lookup"><span data-stu-id="9cc50-4005">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="9cc50-4006">Zmiany zabezpieczeń w programie .NET Framework</span><span class="sxs-lookup"><span data-stu-id="9cc50-4006">Security Changes in the .NET Framework</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-4007">Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest możliwy do serializacji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4007">Gets a value indicating whether the <see cref="T:System.Type" /> is serializable.</span></span></summary>
        <value><span data-ttu-id="9cc50-4008"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest możliwy do serializacji; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4008"><see langword="true" /> if the <see cref="T:System.Type" /> is serializable; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="9cc50-4009">Typy, które są zdefiniowane w programie .NET Standard nie są oznaczone <xref:System.SerializableAttribute>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4009">Types that are defined in the .NET Standard are not marked with <xref:System.SerializableAttribute>.</span></span> <span data-ttu-id="9cc50-4010">Zamiast tego każda implementacja .NET określa, czy typ jest możliwy do serializacji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4010">Instead, each .NET implementation determines whether a type is serializable.</span></span> <span data-ttu-id="9cc50-4011">W czasie wykonywania, można użyć <xref:System.Type.IsSerializable%2A> właściwości w celu określenia, czy tę implementację obsługuje serializacji wystąpienia tego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4011">At run time, you can use the <xref:System.Type.IsSerializable%2A> property to determine whether that implementation supports serialization of an instance of the type.</span></span> <span data-ttu-id="9cc50-4012">Aby uzyskać więcej informacji i obejrzeć przykład, zobacz [sposobu ustalenia, czy obiekt standardowy .NET jest możliwy do serializacji](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).</span><span class="sxs-lookup"><span data-stu-id="9cc50-4012">For more information and an example, see [How to determine if a .NET Standard object is serializable](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).</span></span>
  
 <span data-ttu-id="9cc50-4013">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4013">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="9cc50-4014">Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4014">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="9cc50-4015">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4015">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-4016">Poniższy przykład tworzy wystąpienie `MyTestClass` klasy, ustawia atrybut [Serializable] i sprawdza `IsSerializable` właściwość `true` lub `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4016">The following example creates an instance of `MyTestClass` class, sets the [Serializable] attribute, and checks the `IsSerializable` property for `true` or `false`.</span></span>  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-4017">Pobiera wartość wskazującą, czy typ ma nazwę, która wymaga specjalnej obsługi.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4017">Gets a value indicating whether the type has a name that requires special handling.</span></span></summary>
        <value><span data-ttu-id="9cc50-4018"><see langword="true" /> Jeśli typ ma nazwę, która wymaga specjalnej obsługi; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4018"><see langword="true" /> if the type has a name that requires special handling; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4019">Nazwy, które zaczynają się od lub zawierać znaku podkreślenia (_), metod dostępu do właściwości i metod przeciążenia operatora to przykłady typów, które mogą wymagać specjalnego traktowania przez niektóre kompilatory.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4019">Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</span></span>  
  
 <span data-ttu-id="9cc50-4020">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4020">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="9cc50-4021">Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4021">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="9cc50-4022">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4022">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="9cc50-4023">Typ do porównania z bieżącym typem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4023">The type to compare with the current type.</span></span></param>
        <summary><span data-ttu-id="9cc50-4024">Określa, czy bieżący <see cref="T:System.Type" /> pochodzi z określonego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4024">Determines whether the current <see cref="T:System.Type" /> derives from the specified <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="9cc50-4025"><see langword="true" /> Jeśli bieżący <see langword="Type" /> pochodzi od klasy <paramref name="c" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4025"><see langword="true" /> if the current <see langword="Type" /> derives from <paramref name="c" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9cc50-4026">Ta metoda zwraca też wartość <see langword="false" /> Jeśli <paramref name="c" /> i bieżący <see langword="Type" /> są takie same.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4026">This method also returns <see langword="false" /> if <paramref name="c" /> and the current <see langword="Type" /> are equal.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4027">Możesz wywołać <xref:System.Type.IsSubclassOf%2A> metodę, aby określić jedną z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="9cc50-4027">You can call the <xref:System.Type.IsSubclassOf%2A> method to determine any of the following:</span></span>  
  
-   <span data-ttu-id="9cc50-4028">Czy jedna klasa pochodzi z innego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4028">Whether one class derives from another.</span></span>  
  
-   <span data-ttu-id="9cc50-4029">Czy typ pochodzi od klasy <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4029">Whether a type derives from <xref:System.ValueType>.</span></span> <span data-ttu-id="9cc50-4030">Jednak <xref:System.Type.IsValueType%2A> jest bardziej efektywne sposobem ustalenia, czy typ jest typem wartości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4030">However, the <xref:System.Type.IsValueType%2A> is a more efficient way to determine whether a type is a value type.</span></span>  
  
-   <span data-ttu-id="9cc50-4031">Czy typ pochodzi od klasy <xref:System.Enum>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4031">Whether a type derives from <xref:System.Enum>.</span></span> <span data-ttu-id="9cc50-4032">Jednak <xref:System.Type.IsEnum%2A> metoda jest bardziej efektywne sposobem ustalenia, czy typ jest wyliczeniem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4032">However, the <xref:System.Type.IsEnum%2A> method is a more efficient way to determine whether a type is an enumeration.</span></span>  
  
-   <span data-ttu-id="9cc50-4033">Czy typ jest delegatem, oznacza to, czy wywodzi się z poziomu <xref:System.Delegate> lub <xref:System.MulticastDelegate>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4033">Whether a type is a delegate, that is, whether it derives from either <xref:System.Delegate> or <xref:System.MulticastDelegate>.</span></span>  
  
 <span data-ttu-id="9cc50-4034"><xref:System.Type.IsSubclassOf%2A> Metoda nie może służyć do określenia, czy interfejs pochodzi z innego interfejsu lub tego, czy klasa implementuje interfejs.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4034">The <xref:System.Type.IsSubclassOf%2A> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface.</span></span> <span data-ttu-id="9cc50-4035">Użyj <xref:System.Type.IsAssignableFrom%2A> metody, w tym celu, co ilustruje poniższy przykład.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4035">Use the <xref:System.Type.IsAssignableFrom%2A> method for that purpose, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 <span data-ttu-id="9cc50-4036">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, pochodzi z jej ograniczenia klasy lub <xref:System.Object?displayProperty=nameWithType> Jeśli go nie ma ograniczenia klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4036">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <xref:System.Object?displayProperty=nameWithType> if it has no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-4037">Z wyjątkiem w przypadku korzystania z interfejsów, <xref:System.Type.IsSubclassOf%2A> jest przeciwny z <xref:System.Type.IsAssignableFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4037">Except when used with interfaces, <xref:System.Type.IsSubclassOf%2A> is the converse of <xref:System.Type.IsAssignableFrom%2A>.</span></span> <span data-ttu-id="9cc50-4038">Oznacza to jeśli `t1.IsSubclassOf(t2)` jest `true`, następnie `t2.IsAssignableFrom(t1)` jest również `true`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4038">That is, if `t1.IsSubclassOf(t2)` is `true`, then `t2.IsAssignableFrom(t1)` is also `true`.</span></span>  
  
 <span data-ttu-id="9cc50-4039">Metoda ta może być zastąpiona przez klasę pochodną.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4039">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-4040">Poniższy przykład tworzy klasę o nazwie `Class1` i Klasa pochodna o nazwie `DerivedC1`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4040">The following example creates a class named `Class1` and a derived class named `DerivedC1`.</span></span> <span data-ttu-id="9cc50-4041">Wywołuje <xref:System.Type.IsSubclassOf%2A> metodę, aby pokazać, że `DerivedC1` jest podklasą `Class1`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4041">It calls the <xref:System.Type.IsSubclassOf%2A> method to show that `DerivedC1` is a subclass of `Class1`.</span></span>  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-4042"><paramref name="c" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4042"><paramref name="c" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-4043">Pobiera wartość wskazującą czy ciąg formatu atrybut <see langword="UnicodeClass" /> wybrano <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4043">Gets a value indicating whether the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="9cc50-4044"><see langword="true" /> Jeśli ciąg formatu atrybut <see langword="UnicodeClass" /> wybrano <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4044"><see langword="true" /> if the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4045"><xref:System.Reflection.TypeAttributes.StringFormatMask> Służy do wybierania atrybuty format ciągu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4045">The <xref:System.Reflection.TypeAttributes.StringFormatMask> is used to select the string format attributes.</span></span> <span data-ttu-id="9cc50-4046">Atrybuty formatu ciągu ulepszenia współdziałania, definiując, jak interpretować ciągów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4046">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="9cc50-4047">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4047">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="9cc50-4048">Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4048">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="9cc50-4049">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4049">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-4050">Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest typem wartości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4050">Gets a value indicating whether the <see cref="T:System.Type" /> is a value type.</span></span></summary>
        <value><span data-ttu-id="9cc50-4051"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest typem wartości; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4051"><see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4052">Typy wartości są typy, które są reprezentowane jako sekwencje bitów; typy wartości nie są klas lub interfejsów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4052">Value types are types that are represented as sequences of bits; value types are not classes or interfaces.</span></span> <span data-ttu-id="9cc50-4053">Typy wartości są określane jako "struktur" w niektórych językach programowania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4053">Value types are referred to as "structs" in some programming languages.</span></span> <span data-ttu-id="9cc50-4054">Typy wyliczeniowe są w wyjątkowym przypadku okna typów wartości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4054">Enums are a special case of value types.</span></span>  
  
 <span data-ttu-id="9cc50-4055">Ta właściwość zwraca `false` dla <xref:System.ValueType> klasy, ponieważ <xref:System.ValueType> nie jest typem wartości, sam.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4055">This property returns `false` for the <xref:System.ValueType> class, because <xref:System.ValueType> is not a value type itself.</span></span> <span data-ttu-id="9cc50-4056">Jest klasą bazową dla wszystkich typów wartości, a w związku z tym dowolny typ wartości można przypisać do niej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4056">It is the base class for all value types, and therefore any value type can be assigned to it.</span></span> <span data-ttu-id="9cc50-4057">To nie jest możliwe Jeśli <xref:System.ValueType> sam był typem wartości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4057">This would not be possible if <xref:System.ValueType> itself was a value type.</span></span> <span data-ttu-id="9cc50-4058">Typy wartości jest ramce, gdy są one przypisane do pola typu <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4058">Value types are boxed when they are assigned to a field of type <xref:System.ValueType>.</span></span>  
  
 <span data-ttu-id="9cc50-4059">Ta właściwość zwraca `true` wyliczenia, ale nie <xref:System.Enum> samego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4059">This property returns `true` for enumerations, but not for the <xref:System.Enum> type itself.</span></span> <span data-ttu-id="9cc50-4060">Aby uzyskać przykład demonstrujący ten problem, zobacz <xref:System.Type.IsEnum%2A>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4060">For an example that demonstrates this behavior, see <xref:System.Type.IsEnum%2A>.</span></span>  
  
 <span data-ttu-id="9cc50-4061">Ta właściwość jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4061">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-4062">Poniższy przykład tworzy zmienną typu `MyEnum`, sprawdza, czy `IsValueType` właściwości i wyświetla wynik.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4062">The following example creates a variable of type `MyEnum`, checks for the `IsValueType` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-4063">Implementuje <see cref="P:System.Type.IsValueType" /> właściwości i określa, czy <see cref="T:System.Type" /> typu wartości; oznacza to, że nie jest klasą lub interfejs.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4063">Implements the <see cref="P:System.Type.IsValueType" /> property and determines whether the <see cref="T:System.Type" /> is a value type; that is, not a class or an interface.</span></span></summary>
        <returns><span data-ttu-id="9cc50-4064"><see langword="true" /> Jeśli <see cref="T:System.Type" /> jest typem wartości; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4064"><see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4065">Ta metoda jest dostarczana, aby umożliwić implementowania systemów alternatywnego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4065">This method is provided to enable the implementation of alternate type systems.</span></span> <span data-ttu-id="9cc50-4066">Ogólnie nieużywanych w kodzie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4066">It is not generally used in application code.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-4067">Pobiera wartość wskazującą czy <see cref="T:System.Type" /> może zostać oceniony przez kod poza zestawem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4067">Gets a value indicating whether the <see cref="T:System.Type" /> can be accessed by code outside the assembly.</span></span></summary>
        <value><span data-ttu-id="9cc50-4068"><see langword="true" /> Jeśli bieżący <see cref="T:System.Type" /> jest typ publiczny lub publiczny zagnieżdżony typ taki sposób, że wszystkie typy otaczającej są publiczne; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4068"><see langword="true" /> if the current <see cref="T:System.Type" /> is a public type or a public nested type such that all the enclosing types are public; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4069">Aby ustalić, czy typ jest częścią interfejsu publicznego zestaw składników, należy użyć tej właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4069">Use this property to determine whether a type is part of the public interface of a component assembly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-4070">Poniższy przykład kodu sprawdza dwie klasy, tylko jeden z nich jest widoczna spoza zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4070">The following code example tests two classes, only one of which is visible outside the assembly.</span></span>  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cc50-4071">Zwraca <see cref="T:System.Type" /> obiekt, który reprezentuje tablicę bieżącego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4071">Returns a <see cref="T:System.Type" /> object that represents an array of the current type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-4072">Zwraca <see cref="T:System.Type" /> obiektów reprezentująca tablicę jednowymiarową bieżącego typu z dolną granicę równą zero.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4072">Returns a <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span></span></summary>
        <returns><span data-ttu-id="9cc50-4073">A <see cref="T:System.Type" /> obiektów reprezentująca tablicę jednowymiarową bieżącego typu z dolną granicę równą zero.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4073">A <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4074"><xref:System.Type.MakeArrayType%2A> Metoda zapewnia sposób wygenerować typy tablic z typów elementów, których są obliczane w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4074">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
 <span data-ttu-id="9cc50-4075">**Uwaga** środowiska uruchomieniowego języka wspólnego rozróżnia wektorów (oznacza to, że tablice jednowymiarowe, które są zawsze liczony od zera) i tablic wielowymiarowych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4075">**Note** The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="9cc50-4076">Wektor, który zawsze ma tylko jeden wymiar, nie jest taka sama jak tablicy wielowymiarowej, który ma miejsce tylko jeden wymiar.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4076">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="9cc50-4077">Tego przeciążenia metody należy używać tylko do utworzenia typy wektorów i jest jedynym sposobem, aby utworzyć typ wektora.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4077">This method overload can only be used to create vector types, and it is the only way to create a vector type.</span></span> <span data-ttu-id="9cc50-4078">Użyj <xref:System.Type.MakeArrayType%28System.Int32%29> przeciążenia metody, aby utworzyć typy tablic wielowymiarowych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4078">Use the <xref:System.Type.MakeArrayType%28System.Int32%29> method overload to create multidimensional array types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-4079">Poniższy przykład kodu tworzy tablicę, `ref` (`ByRef` w języku Visual Basic) oraz typy wskaźników dla `Test` klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4079">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cc50-4080">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4080">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="9cc50-4081">Klasy pochodne muszą zapewniać implementację.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4081">Derived classes must provide an implementation.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="9cc50-4082">Bieżącym typem jest <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4082">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="9cc50-4083">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-4083">-or-</span></span> 
<span data-ttu-id="9cc50-4084">Bieżącym typem jest <see langword="ByRef" /> typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4084">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="9cc50-4085">Oznacza to, że <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4085">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rank"><span data-ttu-id="9cc50-4086">Liczba wymiarów tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4086">The number of dimensions for the array.</span></span> <span data-ttu-id="9cc50-4087">Ta liczba musi być mniejsza lub równa 32.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4087">This number must be less than or equal to 32.</span></span></param>
        <summary><span data-ttu-id="9cc50-4088">Zwraca <see cref="T:System.Type" /> obiekt reprezentujący bieżącego typu, o określoną liczbę wymiarów tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4088">Returns a <see cref="T:System.Type" /> object representing an array of the current type, with the specified number of dimensions.</span></span></summary>
        <returns><span data-ttu-id="9cc50-4089">Obiekt reprezentujący bieżącego typu, o określoną liczbę wymiarów tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4089">An object representing an array of the current type, with the specified number of dimensions.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4090"><xref:System.Type.MakeArrayType%2A> Metoda zapewnia sposób wygenerować typy tablic z typów elementów, których są obliczane w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4090">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-4091">Środowisko uruchomieniowe języka wspólnego rozróżnia wektorów (oznacza to, że tablice jednowymiarowe, które są zawsze liczony od zera) i tablic wielowymiarowych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4091">The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="9cc50-4092">Wektor, który zawsze ma tylko jeden wymiar, nie jest taka sama jak tablicy wielowymiarowej, który ma miejsce tylko jeden wymiar.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4092">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="9cc50-4093">Nie można użyć tego przeciążenia metody, aby utworzyć typ wektora; Jeśli `rank` wynosi 1, tego przeciążenia metody zwraca typ tablicy wielowymiarowej, która ma jeden wymiar.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4093">You cannot use this method overload to create a vector type; if `rank` is 1, this method overload returns a multidimensional array type that happens to have one dimension.</span></span> <span data-ttu-id="9cc50-4094">Użyj <xref:System.Type.MakeArrayType> przeciążenia metody, aby utworzyć typy wektorów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4094">Use the <xref:System.Type.MakeArrayType> method overload to create vector types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-4095">Poniższy przykład kodu tworzy tablicę, `ref` (`ByRef` w języku Visual Basic) oraz typy wskaźników dla `Test` klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4095">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="9cc50-4096"><paramref name="rank" /> jest nieprawidłowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4096"><paramref name="rank" /> is invalid.</span></span> <span data-ttu-id="9cc50-4097">Na przykład 0 ani ujemna.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4097">For example, 0 or negative.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cc50-4098">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4098">The invoked method is not supported in the base class.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="9cc50-4099">Bieżącym typem jest <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4099">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="9cc50-4100">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-4100">-or-</span></span> 
<span data-ttu-id="9cc50-4101">Bieżącym typem jest <see langword="ByRef" /> typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4101">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="9cc50-4102">Oznacza to, że <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4102">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span>  
  
<span data-ttu-id="9cc50-4103">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-4103">-or-</span></span> 
 <span data-ttu-id="9cc50-4104"><paramref name="rank" /> jest większe niż 32.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4104"><paramref name="rank" /> is greater than 32.</span></span></exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-4105">Zwraca <see cref="T:System.Type" /> obiekt, który reprezentuje bieżący typ, gdy dane są przekazywane jako <see langword="ref" /> parametru (<see langword="ByRef" /> parametru w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-4105">Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span></span></summary>
        <returns><span data-ttu-id="9cc50-4106">A <see cref="T:System.Type" /> obiekt, który reprezentuje bieżący typ, gdy dane są przekazywane jako <see langword="ref" /> parametru (<see langword="ByRef" /> parametru w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-4106">A <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4107"><xref:System.Type.MakeByRefType%2A> Metoda zapewnia sposób generowania `ref` typów (`ByRef` w języku Visual Basic) dla parametru listy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4107">The <xref:System.Type.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.</span></span>  
  
 <span data-ttu-id="9cc50-4108">Przy użyciu składni języka Microsoft intermediate language (MSIL), jeśli bieżący <xref:System.Type> obiekt reprezentuje <xref:System.Int32>, Metoda ta zwraca <xref:System.Type> obiekt reprezentujący `Int32&`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4108">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32&`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-4109">Poniższy przykład kodu tworzy tablicę, `ref` (`ByRef` w języku Visual Basic) oraz typy wskaźników dla `Test` klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4109">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cc50-4110">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4110">The invoked method is not supported in the base class.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="9cc50-4111">Bieżącym typem jest <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4111">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="9cc50-4112">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-4112">-or-</span></span> 
<span data-ttu-id="9cc50-4113">Bieżącym typem jest <see langword="ByRef" /> typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4113">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="9cc50-4114">Oznacza to, że <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4114">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericSignatureType">
      <MemberSignature Language="C#" Value="public static Type MakeGenericSignatureType (Type genericTypeDefinition, params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericSignatureType(class System.Type genericTypeDefinition, class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericSignatureType(System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericSignatureType (genericTypeDefinition As Type, ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericSignatureType(Type ^ genericTypeDefinition, ... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="static member MakeGenericSignatureType : Type * Type[] -&gt; Type" Usage="System.Type.MakeGenericSignatureType (genericTypeDefinition, typeArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericTypeDefinition" Type="System.Type" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="typeArguments" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="genericTypeDefinition">To be added.</param>
        <param name="typeArguments">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments"><span data-ttu-id="9cc50-4115">Tablica typów do podstawienia dla parametrów typu bieżącego typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4115">An array of types to be substituted for the type parameters of the current generic type.</span></span></param>
        <summary><span data-ttu-id="9cc50-4116">Zastępuje elementy tablicy, rodzajów bieżącej definicji typu ogólnego dla parametrów typu i zwraca <see cref="T:System.Type" /> obiekt reprezentujący wynikowy tworzony typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4116">Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <see cref="T:System.Type" /> object representing the resulting constructed type.</span></span></summary>
        <returns><span data-ttu-id="9cc50-4117">A <see cref="T:System.Type" /> reprezentuje zbudowany typ sformułowany, zastępując elementy <paramref name="typeArguments" /> dla parametrów typu bieżącego typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4117">A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4118"><xref:System.Type.MakeGenericType%2A> Metoda umożliwia pisanie kodu, który przypisuje określone typy parametrów typu w definicji typu ogólnego, co powoduje utworzenie <xref:System.Type> obiekt, który reprezentuje zbudowany określonego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4118">The <xref:System.Type.MakeGenericType%2A> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <xref:System.Type> object that represents a particular constructed type.</span></span> <span data-ttu-id="9cc50-4119">Możesz użyć tej funkcji <xref:System.Type> obiektu do utworzenia wystąpienia środowiska wykonawczego skonstruowanego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4119">You can use this <xref:System.Type> object to create run-time instances of the constructed type.</span></span>  
  
 <span data-ttu-id="9cc50-4120">Typy są konstruowane przy użyciu <xref:System.Type.MakeGenericType%2A> może być otwarty, oznacza to, że niektóre z ich argumentami typu może być otaczającej metody rodzajowe i typy parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4120">Types constructed with <xref:System.Type.MakeGenericType%2A> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types.</span></span> <span data-ttu-id="9cc50-4121">Można na przykład takie Otwórz typy utworzone podczas emitowanie dynamicznych zestawów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4121">You might use such open constructed types when you emit dynamic assemblies.</span></span> <span data-ttu-id="9cc50-4122">Rozważmy na przykład klasy `Base` i `Derived` w poniższym kodzie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4122">For example, consider the classes `Base` and `Derived` in the following code.</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="9cc50-4123">Aby wygenerować `Derived` w zestawie dynamicznym, należy go utworzyć jego typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4123">To generate `Derived` in a dynamic assembly, it is necessary to construct its base type.</span></span> <span data-ttu-id="9cc50-4124">Aby to zrobić, należy wywołać <xref:System.Type.MakeGenericType%2A> metody <xref:System.Type> obiekt reprezentujący klasę `Base`, za pomocą argumentów typu rodzajowego <xref:System.Int32> i parametr typu `V` z `Derived`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4124">To do this, call the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object representing the class `Base`, using the generic type arguments <xref:System.Int32> and the type parameter `V` from `Derived`.</span></span> <span data-ttu-id="9cc50-4125">Ponieważ typy i parametry typu ogólnego są reprezentowane przez <xref:System.Type> obiektów, oba te elementy tablicy mogą być przekazywane do <xref:System.Type.MakeGenericType%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4125">Because types and generic type parameters are both represented by <xref:System.Type> objects, an array containing both can be passed to the <xref:System.Type.MakeGenericType%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-4126">Skonstruowany typ takich jak `Base<int, V>` jest przydatne w przypadku gdy emitowanie kodu, ale nie można wywołać <xref:System.Type.MakeGenericType%2A> metody dla tego typu, ponieważ nie jest definicja typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4126">A constructed type such as `Base<int, V>` is useful when emitting code, but you cannot call the <xref:System.Type.MakeGenericType%2A> method on this type because it is not a generic type definition.</span></span> <span data-ttu-id="9cc50-4127">Aby utworzyć zamknięte skonstruowanego typu, który może być utworzone, należy najpierw wywołać <xref:System.Type.GetGenericTypeDefinition%2A> metodę, aby uzyskać <xref:System.Type> obiekt reprezentujący definicji typu ogólnego, a następnie wywołać <xref:System.Type.MakeGenericType%2A> z argumentami odpowiedniego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4127">To create a closed constructed type that can be instantiated, first call the <xref:System.Type.GetGenericTypeDefinition%2A> method to get a <xref:System.Type> object representing the generic type definition and then call <xref:System.Type.MakeGenericType%2A> with the desired type arguments.</span></span>  
  
 <span data-ttu-id="9cc50-4128"><xref:System.Type> Obiektu zwróconego przez <xref:System.Type.MakeGenericType%2A> jest taka sama jak <xref:System.Type> można uzyskać przez wywołanie <xref:System.Object.GetType%2A> metody wynikowy tworzony typ, lub <xref:System.Object.GetType%2A> metoda dowolnego skonstruowany typ, który został utworzony z tej samej ogólny Definicja typu przy użyciu tych samych argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4128">The <xref:System.Type> object returned by <xref:System.Type.MakeGenericType%2A> is the same as the <xref:System.Type> obtained by calling the <xref:System.Object.GetType%2A> method of the resulting constructed type, or the <xref:System.Object.GetType%2A> method of any constructed type that was created from the same generic type definition using the same type arguments.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cc50-4129">Tablica typów ogólnych sam nie jest typem ogólnym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4129">An array of generic types is not itself a generic type.</span></span> <span data-ttu-id="9cc50-4130">Nie można wywołać <xref:System.Type.MakeGenericType%2A> na tablicy wpisz na przykład `C<T>[]` (`Dim ac() As C(Of T)` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-4130">You cannot call <xref:System.Type.MakeGenericType%2A> on an array type such as `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic).</span></span> <span data-ttu-id="9cc50-4131">Do konstruowania zamknięty typ ogólny z `C<T>[]`, wywołaj <xref:System.Type.GetElementType%2A> uzyskać definicji typu ogólnego `C<T>`; wywołania <xref:System.Type.MakeGenericType%2A> w definicji typu ogólnego do utworzenia skonstruowanego typu; i na koniec wywołania <xref:System.Type.MakeArrayType%2A> metody skonstruowany typ do utworzenia typu tablicy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4131">To construct a closed generic type from `C<T>[]`, call <xref:System.Type.GetElementType%2A> to obtain the generic type definition `C<T>`; call <xref:System.Type.MakeGenericType%2A> on the generic type definition to create the constructed type; and finally call the <xref:System.Type.MakeArrayType%2A> method on the constructed type to create the array type.</span></span> <span data-ttu-id="9cc50-4132">To samo dotyczy typów wskaźnika i `ref` typów (`ByRef` w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9cc50-4132">The same is true of pointer types and `ref` types (`ByRef` in Visual Basic).</span></span>  
  
 <span data-ttu-id="9cc50-4133">Aby uzyskać listę niezmiennych warunków dla terminów używanych w odbiciu rodzajowym, zobacz <xref:System.Type.IsGenericType%2A> uwagi dotyczące właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4133">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
## <a name="nested-types"></a><span data-ttu-id="9cc50-4134">Zagnieżdżone typy</span><span class="sxs-lookup"><span data-stu-id="9cc50-4134">Nested Types</span></span>  
 <span data-ttu-id="9cc50-4135">Jeśli nie zdefiniowano typu ogólnego przy użyciu języka C#, C++ lub Visual Basic, jego zagnieżdżone typy są rodzajowe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4135">If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic.</span></span> <span data-ttu-id="9cc50-4136">Ta zasada obowiązuje, nawet jeśli typy zagnieżdżone nie może mieć typu parametrów we własnym zakresie, ponieważ wszystkie trzy języki obejmują parametry typu otaczającej typów w liście parametrów typu w przypadku zagnieżdżonych typów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4136">This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types.</span></span> <span data-ttu-id="9cc50-4137">Należy wziąć pod uwagę następujące klasy:</span><span class="sxs-lookup"><span data-stu-id="9cc50-4137">Consider the following classes:</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 <span data-ttu-id="9cc50-4138">Lista parametrów typu klasy zagnieżdżonej `Inner` ma dwa parametry typu `T` i `U`, pierwszy z nich jest parametr typu klasy otaczającej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4138">The type parameter list of the nested class `Inner` has two type parameters, `T` and `U`, the first of which is the type parameter of its enclosing class.</span></span> <span data-ttu-id="9cc50-4139">Podobnie, lista parametrów typu klasy zagnieżdżonej `Innermost1` ma trzy parametry typu, `T`, `U`, i `V`, za pomocą `T` i `U` pochodzące z jej otaczającej klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4139">Similarly, the type parameter list of the nested class `Innermost1` has three type parameters, `T`, `U`, and `V`, with `T` and `U` coming from its enclosing classes.</span></span> <span data-ttu-id="9cc50-4140">Klasa zagnieżdżona `Innermost2` ma dwa parametry typu `T` i `U`, które pochodzą z jej otaczającej klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4140">The nested class `Innermost2` has two type parameters, `T` and `U`, which come from its enclosing classes.</span></span>  
  
 <span data-ttu-id="9cc50-4141">Jeśli lista parametrów typu otaczającego ma więcej niż jeden parametr typu, wszystkie parametry typu w kolejności zostaną uwzględnione na liście parametrów typu typu zagnieżdżonego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4141">If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.</span></span>  
  
 <span data-ttu-id="9cc50-4142">Aby skonstruować typu ogólnego z definicji typu ogólnego dla typu zagnieżdżonego, należy wywołać <xref:System.Type.MakeGenericType%2A> metody za pomocą tablicy utworzone przez złączenie tablicami argument typu wszystkich otaczający typów, począwszy od najbardziej zewnętrznego typu ogólnego, i kończącą Wpisz tablica argumentów typu zagnieżdżonego, ma parametry typu swój własny.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4142">To construct a generic type from the generic type definition for a nested type, call the <xref:System.Type.MakeGenericType%2A> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own.</span></span> <span data-ttu-id="9cc50-4143">Aby utworzyć wystąpienie `Innermost1`, wywołania <xref:System.Type.MakeGenericType%2A> metody z tablicę zawierającą trzy typy ma być przypisane do T, U i V. Aby utworzyć wystąpienie `Innermost2`, wywołanie <xref:System.Type.MakeGenericType%2A> metody z tablicę zawierającą dwa typy ma być przypisane do T i U.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4143">To create an instance of `Innermost1`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing three types, to be assigned to T, U, and V. To create an instance of `Innermost2`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing two types, to be assigned to T and U.</span></span>  
  
 <span data-ttu-id="9cc50-4144">Języki propagować parametrów typu w otaczającej typów w ten sposób, aby można było używać parametrów typu otaczającego typu do zdefiniowania pola zagnieżdżonych typów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4144">The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types.</span></span> <span data-ttu-id="9cc50-4145">W przeciwnym razie parametrów typu nie jest w zakresie, w ramach organów zagnieżdżone typy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4145">Otherwise, the type parameters would not be in scope within the bodies of the nested types.</span></span> <span data-ttu-id="9cc50-4146">Można zdefiniować typy zagnieżdżone bez propagowanie parametrów typu w otaczającej typów, emitowanie kodu w zestawach dynamicznych lub używając [Ilasm.exe (asembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="9cc50-4146">It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span> <span data-ttu-id="9cc50-4147">Należy wziąć pod uwagę następujący kod MSIL assembler:</span><span class="sxs-lookup"><span data-stu-id="9cc50-4147">Consider the following code for the MSIL assembler:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="9cc50-4148">W tym przykładzie nie jest możliwe zdefiniowanie pola typu `T` lub `U` w klasie `Innermost`, ponieważ te parametry typu nie są w zakresie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4148">In this example, it is not possible to define a field of type `T` or `U` in class `Innermost`, because those type parameters are not in scope.</span></span> <span data-ttu-id="9cc50-4149">W poniższym kodzie asemblera zdefiniowano klasy zagnieżdżone, które zachowują się sposób, w jaki gdyby zdefiniowany w języku C++, Visual Basic i C#:</span><span class="sxs-lookup"><span data-stu-id="9cc50-4149">The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="9cc50-4150">Możesz użyć [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do zbadania zagnieżdżonych klas zdefiniowanych w językach wysokiego poziomu i sprawdź, czy ten schemat nazewnictwa.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4150">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine nested classes defined in the high-level languages and observe this naming scheme.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-4151">W poniższym przykładzie użyto <xref:System.Type.MakeGenericType%2A> metodę w celu utworzenia skonstruowanego typu w definicji typu ogólnego dla <xref:System.Collections.Generic.Dictionary%602> typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4151">The following example uses the <xref:System.Type.MakeGenericType%2A> method to create a constructed type from the generic type definition for the <xref:System.Collections.Generic.Dictionary%602> type.</span></span> <span data-ttu-id="9cc50-4152">Reprezentuje zbudowany typ <xref:System.Collections.Generic.Dictionary%602> z `Test` obiektów za pomocą kluczy ciągu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4152">The constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cc50-4153">Bieżący typ nie reprezentuje definicji typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4153">The current type does not represent a generic type definition.</span></span> <span data-ttu-id="9cc50-4154">Oznacza to, że <see cref="P:System.Type.IsGenericTypeDefinition" /> zwraca <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4154">That is, <see cref="P:System.Type.IsGenericTypeDefinition" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-4155"><paramref name="typeArguments" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4155"><paramref name="typeArguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cc50-4156">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-4156">-or-</span></span> 
<span data-ttu-id="9cc50-4157">Każdy z elementów <paramref name="typeArguments" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4157">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-4158">Liczba elementów w <paramref name="typeArguments" /> nie jest taka sama jak liczba parametrów typu w bieżącej definicji typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4158">The number of elements in <paramref name="typeArguments" /> is not the same as the number of type parameters in the current generic type definition.</span></span>  
  
<span data-ttu-id="9cc50-4159">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-4159">-or-</span></span> 
<span data-ttu-id="9cc50-4160">Każdy z elementów <paramref name="typeArguments" /> nie spełnia warunków ograniczenia określone dla odpowiedniego parametru typu bieżącego typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4160">Any element of <paramref name="typeArguments" /> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.</span></span>  
  
<span data-ttu-id="9cc50-4161">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-4161">-or-</span></span> 
 <span data-ttu-id="9cc50-4162"><paramref name="typeArguments" /> zawiera element, który jest typem wskaźnika (<see cref="P:System.Type.IsPointer" /> zwraca <see langword="true" />), typ przez odwołanie (<see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />), lub <see cref="T:System.Void" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4162"><paramref name="typeArguments" /> contains an element that is a pointer type (<see cref="P:System.Type.IsPointer" /> returns <see langword="true" />), a by-ref type (<see cref="P:System.Type.IsByRef" /> returns <see langword="true" />), or <see cref="T:System.Void" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cc50-4163">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4163">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="9cc50-4164">Klasy pochodne muszą zapewniać implementację.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4164">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="9cc50-4165">Odbicie i typy ogólne</span><span class="sxs-lookup"><span data-stu-id="9cc50-4165">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="9cc50-4166">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</span><span class="sxs-lookup"><span data-stu-id="9cc50-4166">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-4167">Zwraca <see cref="T:System.Type" /> obiekt, który reprezentuje wskaźnik do bieżącego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4167">Returns a <see cref="T:System.Type" /> object that represents a pointer to the current type.</span></span></summary>
        <returns><span data-ttu-id="9cc50-4168">A <see cref="T:System.Type" /> obiekt, który reprezentuje wskaźnik do bieżącego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4168">A <see cref="T:System.Type" /> object that represents a pointer to the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4169"><xref:System.Type.MakePointerType%2A> Metoda zapewnia sposób generowania typów wskaźnika do listy parametrów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4169">The <xref:System.Type.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.</span></span>  
  
 <span data-ttu-id="9cc50-4170">Przy użyciu składni języka Microsoft intermediate language (MSIL), jeśli bieżący <xref:System.Type> obiekt reprezentuje <xref:System.Int32>, Metoda ta zwraca <xref:System.Type> obiekt reprezentujący `Int32*`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4170">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32*`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-4171">Poniższy przykład kodu tworzy tablicę, `ref` (`ByRef` w języku Visual Basic) oraz typy wskaźników dla `Test` klasy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4171">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cc50-4172">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4172">The invoked method is not supported in the base class.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="9cc50-4173">Bieżącym typem jest <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4173">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="9cc50-4174">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-4174">-or-</span></span> 
<span data-ttu-id="9cc50-4175">Bieżącym typem jest <see langword="ByRef" /> typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4175">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="9cc50-4176">Oznacza to, że <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4176">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-4177">Pobiera <see cref="T:System.Reflection.MemberTypes" /> wartość wskazującą, czy ten element członkowski jest typem lub typu zagnieżdżonego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4177">Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span></span></summary>
        <value><span data-ttu-id="9cc50-4178">A <see cref="T:System.Reflection.MemberTypes" /> wartość wskazującą, czy ten element członkowski jest typem lub typu zagnieżdżonego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4178">A <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4179">Ta właściwość zastępuje <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4179">This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cc50-4180">Dlatego podczas badania zbiór <xref:System.Reflection.MemberInfo> obiektów — na przykład tablica zwrócona przez <xref:System.Type.GetMembers%2A> — <xref:System.Reflection.MemberInfo.MemberType%2A> właściwość zwraca <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> kiedy dany element jest typu zagnieżdżonego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4180">Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objects - for example, the array returned by <xref:System.Type.GetMembers%2A> - the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> when a given member is a nested type.</span></span>  
  
 <span data-ttu-id="9cc50-4181">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta ma zastosowanie do definicji typu ogólnego, z którego skonstruowano.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4181">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="9cc50-4182">Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4182">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="9cc50-4183">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca zawsze <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4183">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-4184">Poniższy kod przedstawia przykład `MemberType` pola jako parametr do `GetMember` metody:</span><span class="sxs-lookup"><span data-stu-id="9cc50-4184">The following code example shows the `MemberType` field as a parameter to the `GetMember` method:</span></span>  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-4185">Reprezentuje wartość Brak w <see cref="T:System.Type" /> informacji.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4185">Represents a missing value in the <see cref="T:System.Type" /> information.</span></span> <span data-ttu-id="9cc50-4186">To pole jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4186">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4187">Użyj `Missing` pola do wywoływania przez odbicie, aby uzyskać wartość domyślna parametru.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4187">Use the `Missing` field for invocation through reflection to obtain the default value of a parameter.</span></span> <span data-ttu-id="9cc50-4188">Jeśli `Missing` pola są przekazywane do wartości parametru i nie ma wartości domyślnej dla tego parametru <xref:System.ArgumentException> zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4188">If the `Missing` field is passed in for a parameter value and there is no default value for that parameter, an <xref:System.ArgumentException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-4189">Poniższy przykład kodu pokazuje użycie `Missing` pola, które można wywołać metody z jej argumentów domyślnych.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4189">The following code example shows the use of the `Missing` field to invoke a method with its default arguments.</span></span>  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 <span data-ttu-id="9cc50-4190">Ten kod generuje następujące dane wyjściowe:</span><span class="sxs-lookup"><span data-stu-id="9cc50-4190">This code produces the following output:</span></span>  
  
 <span data-ttu-id="9cc50-4191">= 10, b = 55.3 c = 12</span><span class="sxs-lookup"><span data-stu-id="9cc50-4191">a = 10 b = 55.3 c = 12</span></span>  
  
 <span data-ttu-id="9cc50-4192">= 10, b = 1,3 c = 1</span><span class="sxs-lookup"><span data-stu-id="9cc50-4192">a = 10 b = 1.3 c = 1</span></span>  
  
 <span data-ttu-id="9cc50-4193">= 10, b = 1.2 c = 1</span><span class="sxs-lookup"><span data-stu-id="9cc50-4193">a = 10 b = 1.2 c = 1</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-4194">Pobiera moduł (DLL), w którym bieżącego <see cref="T:System.Type" /> jest zdefiniowana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4194">Gets the module (the DLL) in which the current <see cref="T:System.Type" /> is defined.</span></span></summary>
        <value><span data-ttu-id="9cc50-4195">Moduł, w którym bieżącego <see cref="T:System.Type" /> jest zdefiniowana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4195">The module in which the current <see cref="T:System.Type" /> is defined.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4196">Jeśli bieżący <xref:System.Type> reprezentuje zbudowany typ ogólny, właściwość ta zwraca modułu, w którym zdefiniowano definicji typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4196">If the current <xref:System.Type> represents a constructed generic type, this property returns the module in which the generic type definition was defined.</span></span> <span data-ttu-id="9cc50-4197">Na przykład, jeśli utworzysz wystąpienie `MyGenericStack<int>`, <xref:System.Type.Module%2A> właściwość skonstruowanego typu zwraca modułu, w którym `MyGenericStack<T>` jest zdefiniowana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4197">For example, if you create an instance of `MyGenericStack<int>`, the <xref:System.Type.Module%2A> property for the constructed type returns the module in which `MyGenericStack<T>` is defined.</span></span>  
  
 <span data-ttu-id="9cc50-4198">Podobnie jeśli bieżący <xref:System.Type> reprezentuje parametr ogólny `T`, właściwość ta zwraca zestaw, który zawiera typ ogólny, który definiuje `T`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4198">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-4199">Ten poniższy przykład demonstruje użycie <xref:System.Type.Namespace%2A> i `Module` właściwości i <xref:System.Type.ToString%2A> metody <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4199">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and `Module` properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-4200">W przypadku przesłonięcia w klasie pochodnej pobiera nazwę bieżącego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4200">When overridden in a derived class, gets the name of the current type.</span></span></summary>
        <value><span data-ttu-id="9cc50-4201">Nazwa bieżącego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4201">The name of the current type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-4202">Pobiera obszar nazw <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4202">Gets the namespace of the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="9cc50-4203">Przestrzeń nazw <see cref="T:System.Type" />; <see langword="null" /> czy bieżące wystąpienie nie ma obszaru nazw reprezentuje parametr ogólny.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4203">The namespace of the <see cref="T:System.Type" />; <see langword="null" /> if the current instance has no namespace or represents a generic parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4204">Przestrzeń nazw jest logiczną projektowania nazewnictwa wygody używane głównie do zdefiniowania zakresu w aplikacji i organizowanie klasami i innymi typami w strukturze hierarchicznej jednego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4204">A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure.</span></span> <span data-ttu-id="9cc50-4205">Z punktu widzenia środowiska uruchomieniowego nie ma żadnych obszarów nazw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4205">From the viewpoint of the runtime, there are no namespaces.</span></span>  
  
 <span data-ttu-id="9cc50-4206">Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny skonstruowany, właściwość ta zwraca przestrzeni nazw, który zawiera definicję typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4206">If the current <xref:System.Type> represents a constructed generic type, this property returns the namespace that contains the generic type definition.</span></span> <span data-ttu-id="9cc50-4207">Podobnie jeśli bieżący <xref:System.Type> reprezentuje parametr ogólny `T`, właściwość ta zwraca przestrzeni nazw, który zawiera definicję typu ogólnego, który definiuje `T`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4207">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the namespace that contains the generic type definition that defines `T`.</span></span>  
  
 <span data-ttu-id="9cc50-4208">Jeśli bieżący <xref:System.Type> obiekt reprezentuje parametr ogólny, właściwość ta zwraca `null`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4208">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-4209">Ten poniższy przykład demonstruje użycie `Namespace` i <xref:System.Type.Module%2A> właściwości i <xref:System.Type.ToString%2A> metody <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4209">This following example demonstrates a use of the `Namespace` and <xref:System.Type.Module%2A> properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="9cc50-4210">Określanie w pełni kwalifikowanych nazw typów</span><span class="sxs-lookup"><span data-stu-id="9cc50-4210">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="9cc50-4211">Pierwszy obiekt, który ma zostać porównany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4211">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="9cc50-4212">Drugi obiekt, który będzie porównywany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4212">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="9cc50-4213">Wskazuje, czy dwa <see cref="T:System.Type" /> obiekty są sobie równe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4213">Indicates whether two <see cref="T:System.Type" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="9cc50-4214"><see langword="true" /> Jeśli <paramref name="left" /> jest równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4214"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="9cc50-4215">Pierwszy obiekt, który ma zostać porównany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4215">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="9cc50-4216">Drugi obiekt, który będzie porównywany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4216">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="9cc50-4217">Wskazuje, czy dwa <see cref="T:System.Type" /> obiekty nie są równe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4217">Indicates whether two <see cref="T:System.Type" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="9cc50-4218"><see langword="true" /> Jeśli <paramref name="left" /> nie jest równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4218"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-4219">Pobiera obiekt klasy, który został użyty do uzyskania tego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4219">Gets the class object that was used to obtain this member.</span></span></summary>
        <value><span data-ttu-id="9cc50-4220"><see langword="Type" /> Obiektu za pomocą którego należy to <see cref="T:System.Type" /> obiekt został uzyskany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4220">The <see langword="Type" /> object through which this <see cref="T:System.Type" /> object was obtained.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4221">Aby uzyskać <xref:System.Type> obiektów, wartość tej właściwości jest zawsze taka sama jak wartość <xref:System.Type.DeclaringType%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4221">For <xref:System.Type> objects, the value of this property is always the same as the value of the <xref:System.Type.DeclaringType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-4222">W tym przykładzie jest wyświetlany odbitych typ klasy zagnieżdżonej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4222">This example displays the reflected type of a nested class.</span></span>  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="9cc50-4223">Nazwa kwalifikowanego dla zestawu <see cref="T:System.Type" /> można pobrać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4223">The assembly-qualified name of the <see cref="T:System.Type" /> to get.</span></span></param>
        <param name="throwIfNotFound"><span data-ttu-id="9cc50-4224"><see langword="true" /> Aby zgłosić <see cref="T:System.TypeLoadException" /> Jeśli nie można odnaleźć typu; <see langword="false" /> do zwrócenia <see langword="null" /> Jeśli nie można odnaleźć typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4224"><see langword="true" /> to throw a <see cref="T:System.TypeLoadException" /> if the type cannot be found; <see langword="false" /> to return <see langword="null" /> if the type cannot be found.</span></span> <span data-ttu-id="9cc50-4225">Określanie <see langword="false" /> powoduje również pominięcie niektórych warunków wyjątków, ale nie wszystkie z nich.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4225">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="9cc50-4226">Zobacz sekcję Wyjątki.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4226">See the Exceptions section.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="9cc50-4227"><see langword="true" /> Aby wykonać wyszukiwanie bez uwzględniania wielkości liter dla <paramref name="typeName" />; <see langword="false" /> przeprowadzić wyszukiwanie dla <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4227"><see langword="true" /> to perform a case-insensitive search for <paramref name="typeName" />; <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="9cc50-4228">Pobiera <see cref="T:System.Type" /> o określonej nazwie określenie, czy przeprowadzić wyszukiwanie i czy chcesz zgłosić wyjątek, jeśli typ nie zostanie znaleziony.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4228">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found.</span></span> <span data-ttu-id="9cc50-4229">Typ jest ładowany w celu odbicia, nie do wykonania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4229">The type is loaded for reflection only, not for execution.</span></span></summary>
        <returns><span data-ttu-id="9cc50-4230">Typ o określonej nazwie, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4230">The type with the specified name, if found; otherwise, <see langword="null" />.</span></span> <span data-ttu-id="9cc50-4231">Jeśli typ nie zostanie znaleziony, <paramref name="throwIfNotFound" /> parametr określa, czy <see langword="null" /> zwracany jest lub zostanie zgłoszony wyjątek.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4231">If the type is not found, the <paramref name="throwIfNotFound" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="9cc50-4232">W niektórych przypadkach występuje wyjątek niezależnie od wartości <paramref name="throwIfNotFound" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4232">In some cases, an exception is thrown regardless of the value of <paramref name="throwIfNotFound" />.</span></span> <span data-ttu-id="9cc50-4233">Zobacz sekcję Wyjątki.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4233">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4234">Jeśli zestawu zawierającego typ nie jest już załadowane do kontekstu reflection-only, za pomocą <xref:System.Type.ReflectionOnlyGetType%2A> metodą jest odpowiednikiem pierwszego ładowania zestawu w celu odbicia tylko przy użyciu <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> metody, a następnie ładowania typu przez wywołanie metody zestawu <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4234">If the assembly containing the type is not already loaded into the reflection-only context, using the <xref:System.Type.ReflectionOnlyGetType%2A> method is equivalent to first loading the assembly for reflection only, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, and then loading the type by calling the assembly's <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="9cc50-4235">Aby uzyskać informacji na temat nazw kwalifikowanych dla zestawu, zobacz <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4235">For information about assembly-qualified names, see the <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="9cc50-4236">Aby uzyskać więcej informacji na temat określania nazwy typów, zobacz <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenie metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4236">For additional details on specifying type names, see the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="9cc50-4237">Jeśli zestaw jest już załadowany w celu wykonywania, kolejną kopię są ładowane do kontekstu reflection-only.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4237">If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.</span></span>  
  
 <span data-ttu-id="9cc50-4238">`throwIfNotFound` Parametr określa, co się stanie, gdy typ nie zostanie znaleziony i powoduje również pominięcie niektórych warunków wyjątków, zgodnie z opisem w sekcji wyjątki.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4238">The `throwIfNotFound` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="9cc50-4239">Niektóre wyjątki są zgłaszane niezależnie od wartości `throwIfNotFound`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4239">Some exceptions are thrown regardless of the value of `throwIfNotFound`.</span></span> <span data-ttu-id="9cc50-4240">Na przykład, jeśli zestaw nie jest prawidłowy <xref:System.BadImageFormatException> jest zgłaszany nawet wtedy, gdy `throwIfNotFound` jest `false`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4240">For example, if the assembly is not valid, a <xref:System.BadImageFormatException> is thrown even if `throwIfNotFound` is `false`.</span></span>  
  
 <span data-ttu-id="9cc50-4241">Aby uzyskać więcej informacji o korzystaniu z kontekstu reflection-only, zobacz [jak: Ładowanie zestawów do kontekstu Reflection-Only](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span><span class="sxs-lookup"><span data-stu-id="9cc50-4241">For more information about using the reflection-only context, see [How to: Load Assemblies into the Reflection-Only Context](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cc50-4242"><paramref name="typeName" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4242"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="9cc50-4243">Inicjator klasy jest wywoływany i zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4243">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="9cc50-4244"><paramref name="throwIfNotFound" /> jest <see langword="true" /> i nie można odnaleźć typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4244"><paramref name="throwIfNotFound" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="9cc50-4245">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-4245">-or-</span></span> 
 <span data-ttu-id="9cc50-4246"><paramref name="throwIfNotFound" /> jest <see langword="true" /> i <paramref name="typeName" /> zawiera nieprawidłowe znaki, takie jak osadzona karta.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4246"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="9cc50-4247">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-4247">-or-</span></span> 
 <span data-ttu-id="9cc50-4248"><paramref name="throwIfNotFound" /> jest <see langword="true" /> i <paramref name="typeName" /> jest ciągiem pustym.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4248"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="9cc50-4249">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-4249">-or-</span></span> 
 <span data-ttu-id="9cc50-4250"><paramref name="throwIfNotFound" /> jest <see langword="true" /> i <paramref name="typeName" /> reprezentuje typ tablicy z nieprawidłowym rozmiarem.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4250"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="9cc50-4251">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-4251">-or-</span></span> 
 <span data-ttu-id="9cc50-4252"><paramref name="typeName" /> reprezentuje tablicę <see cref="T:System.TypedReference" /> obiektów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4252"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" /> objects.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cc50-4253"><paramref name="typeName" /> nie ma nazwy zestawu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4253"><paramref name="typeName" /> does not include the assembly name.</span></span>  
  
<span data-ttu-id="9cc50-4254">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-4254">-or-</span></span> 
 <span data-ttu-id="9cc50-4255"><paramref name="throwIfNotFound" /> jest <see langword="true" /> i <paramref name="typeName" /> ma nieprawidłową składnię, na przykład "MyType [, \*,]".</span><span class="sxs-lookup"><span data-stu-id="9cc50-4255"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax; for example, "MyType[,\*,]".</span></span>  
  
<span data-ttu-id="9cc50-4256">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-4256">-or-</span></span> 
 <span data-ttu-id="9cc50-4257"><paramref name="typeName" /> reprezentuje typ ogólny, który jest typem wskaźnika <see langword="ByRef" /> typu, lub <see cref="T:System.Void" /> jako jeden z argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4257"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="9cc50-4258">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-4258">-or-</span></span> 
 <span data-ttu-id="9cc50-4259"><paramref name="typeName" /> reprezentuje typ ogólny, który ma niepoprawną liczbę argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4259"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="9cc50-4260">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-4260">-or-</span></span> 
 <span data-ttu-id="9cc50-4261"><paramref name="typeName" /> reprezentuje typ ogólny i jeden z argumentów typu nie spełniają ograniczeń dla odpowiedniego parametru typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4261"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="9cc50-4262"><paramref name="throwIfNotFound" /> jest <see langword="true" /> i nie znaleziono zestawu lub jednej z jego zależności.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4262"><paramref name="throwIfNotFound" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="9cc50-4263">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4263">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="9cc50-4264">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4264">The assembly or one of its dependencies is not valid.</span></span>  
  
<span data-ttu-id="9cc50-4265">—lub—</span><span class="sxs-lookup"><span data-stu-id="9cc50-4265">-or-</span></span> 
<span data-ttu-id="9cc50-4266">Zestaw został skompilowany przy użyciu nowszej wersji aparatu plików wykonywalnych języka wspólnego niż wersja, która jest aktualnie załadowana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4266">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="9cc50-4267">Określanie w pełni kwalifikowanych nazw typów</span><span class="sxs-lookup"><span data-stu-id="9cc50-4267">Specifying Fully Qualified Type Names</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md"><span data-ttu-id="9cc50-4268">Instrukcje: Ładowanie zestawów do kontekstu Reflection-Only</span><span class="sxs-lookup"><span data-stu-id="9cc50-4268">How to: Load Assemblies into the Reflection-Only Context</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-4269">Pobiera <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> układ bieżącego typu, który opisuje.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4269">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the layout of the current type.</span></span></summary>
        <value><span data-ttu-id="9cc50-4270">Pobiera <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> , który opisuje funkcje brutto układ bieżącego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4270">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the gross layout features of the current type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4271"><xref:System.Runtime.InteropServices.StructLayoutAttribute> nie jest zwracana przez <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4271"><xref:System.Runtime.InteropServices.StructLayoutAttribute> is not returned by the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method.</span></span> <span data-ttu-id="9cc50-4272">Zamiast tego należy używać tej właściwości, aby z niej skorzystać.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4272">Instead, use this property to get it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-4273">Poniższy przykładowy kod najpierw definiuje klasy, struktury i struktury z atrybutami specjalnego układu (struktur są zagnieżdżone w obrębie klasy).</span><span class="sxs-lookup"><span data-stu-id="9cc50-4273">The following code example first defines a class, a structure, and a structure with special layout attributes (the structures are nested within the class).</span></span> <span data-ttu-id="9cc50-4274">Następnie w przykładzie <xref:System.Type.StructLayoutAttribute%2A> właściwości w celu uzyskania <xref:System.Runtime.InteropServices.StructLayoutAttribute> dla każdego typu i wyświetla właściwości atrybutów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4274">The example then uses the <xref:System.Type.StructLayoutAttribute%2A> property to obtain a <xref:System.Runtime.InteropServices.StructLayoutAttribute> for each type, and displays the properties of the attributes.</span></span>  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cc50-4275">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4275">The invoked method is not supported in the base class.</span></span></exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="9cc50-4276">Zarezerwowane do użytku w przyszłości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4276">Reserved for future use.</span></span> <span data-ttu-id="9cc50-4277">Musi być wartością IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4277">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="9cc50-4278">Przekazana tablica nazw ma być mapowana.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4278">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="9cc50-4279">Liczba nazw, które mają być mapowane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4279">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="9cc50-4280">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4280">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="9cc50-4281">Tablica przydzielana przez obiekt wywołujący, który otrzymuje numery identyfikacyjne odpowiadających nazw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4281">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="9cc50-4282">Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4282">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4283">Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4283">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="9cc50-4284">Aby uzyskać więcej informacji na temat `IDispatch::GetIDsOfNames`, zobacz: Biblioteka MSDN.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4284">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="9cc50-4285">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4285">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="9cc50-4286">Informacje o typie, który będzie zwracany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4286">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="9cc50-4287">Identyfikator regionalny dla informacji o typie.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4287">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="9cc50-4288">Wskaźnik do obiektu informacji żądanego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4288">A pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="9cc50-4289">Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4289">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4290">Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4290">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="9cc50-4291">Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfo`, zobacz: Biblioteka MSDN.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4291">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="9cc50-4292">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4292">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="9cc50-4293">Wskazuje lokalizację, która odbiera informację o liczbie typów dostarczanych przez obiekt.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4293">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="9cc50-4294">Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</span><span class="sxs-lookup"><span data-stu-id="9cc50-4294">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4295">Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4295">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="9cc50-4296">Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfoCount`, zobacz: Biblioteka MSDN.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4296">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="9cc50-4297">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4297">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="9cc50-4298">Określa element członkowski.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4298">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="9cc50-4299">Zarezerwowane do użytku w przyszłości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4299">Reserved for future use.</span></span> <span data-ttu-id="9cc50-4300">Musi być wartością IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4300">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="9cc50-4301">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4301">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="9cc50-4302">Flagi opisujące kontekst wywołania.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4302">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="9cc50-4303">Wskaźnik do struktury zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4303">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="9cc50-4304">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4304">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="9cc50-4305">Wskaźnik do struktury, która zawiera informacje o wyjątku.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4305">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="9cc50-4306">Indeks pierwszego argumentu, który zawiera błąd.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4306">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="9cc50-4307">Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4307">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4308">Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4308">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="9cc50-4309">Aby uzyskać więcej informacji na temat `IDispatch::Invoke`, zobacz: Biblioteka MSDN.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4309">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="9cc50-4310">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4310">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cc50-4311">Zwraca <see langword="String" /> reprezentujący nazwę bieżącego <see langword="Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4311">Returns a <see langword="String" /> representing the name of the current <see langword="Type" />.</span></span></summary>
        <returns><span data-ttu-id="9cc50-4312">A <see cref="T:System.String" /> reprezentujący nazwę bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4312">A <see cref="T:System.String" /> representing the name of the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4313">Ta metoda zwraca w pełni kwalifikowaną wspólnego języka środowiska uruchomieniowego przestrzeni nazw i nazwę dla wszystkich pierwotnych typów.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4313">This method returns the fully qualified common language runtime namespace and name for all primitive types.</span></span> <span data-ttu-id="9cc50-4314">Na przykład C# instrukcja, `(long)0.Type().ToString()` zwraca "System.Int64", a nie tylko "Int64".</span><span class="sxs-lookup"><span data-stu-id="9cc50-4314">For example, the C# instruction, `(long)0.Type().ToString()` returns "System.Int64" instead of merely "Int64".</span></span>  
  
 <span data-ttu-id="9cc50-4315">Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny, typ i argumentów typu są kwalifikowane według przestrzeni nazw i typ zagnieżdżony, ale nie przez zestaw.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4315">If the current <xref:System.Type> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly.</span></span> <span data-ttu-id="9cc50-4316">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, Metoda ta zwraca niekwalifikowana nazwa parametru typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4316">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-4317">Ten poniższy przykład demonstruje użycie <xref:System.Type.Namespace%2A> i <xref:System.Type.Module%2A> właściwości i `ToString` metody <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4317">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and <xref:System.Type.Module%2A> properties and the `ToString` method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 <span data-ttu-id="9cc50-4318">W poniższym przykładzie porównano ciągów zwracanych przez <xref:System.Type.ToString%2A> metody i `Name`, <xref:System.Type.FullName%2A>, i <xref:System.Type.AssemblyQualifiedName%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4318">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-4319">Pobiera uchwyt dla bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4319">Gets the handle for the current <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="9cc50-4320">Dojście do bieżącego <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4320">The handle for the current <see cref="T:System.Type" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4321">`TypeHandle` hermetyzuje wskaźnik do struktury danych wewnętrznych, który reprezentuje typ.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4321">`TypeHandle` encapsulates a pointer to an internal data structure that represents the type.</span></span> <span data-ttu-id="9cc50-4322">Tego dojścia jest unikatowa w okresie istnienia procesu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4322">This handle is unique during the process lifetime.</span></span> <span data-ttu-id="9cc50-4323">Uchwyt jest prawidłowy tylko w domenie aplikacji, w której zostały pobrane.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4323">The handle is valid only in the application domain in which it was obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cc50-4324">Poniższy przykład zwraca uchwyt danego typu i przechodzi uchwyt do metody, która pobiera typ dojścia i wyświetla go.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4324">The following example returns the handle of the corresponding type and passes the handle to a method that gets the type from the handle and displays it.</span></span>  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cc50-4325">.NET Compact Framework nie obsługuje obecnie tej właściwości.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4325">The .NET Compact Framework does not currently support this property.</span></span></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-4326">Pobiera inicjator dla typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4326">Gets the initializer for the type.</span></span></summary>
        <value><span data-ttu-id="9cc50-4327">Obiekt, który zawiera nazwę Konstruktor klasy <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4327">An object that contains the name of the class constructor for the <see cref="T:System.Type" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cc50-4328">Inicjatory klasy są również dostępne za pośrednictwem <xref:System.Type.FindMembers%2A> metodę, lub za pomocą przeciążenia <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, i <xref:System.Type.GetConstructors%2A> metod, które przyjmują <xref:System.Reflection.BindingFlags> jako parametr.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4328">Class initializers are also available through the <xref:System.Type.FindMembers%2A> method, or through overloads of the <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, and <xref:System.Type.GetConstructors%2A> methods that take <xref:System.Reflection.BindingFlags> as a parameter.</span></span>  
  
 <span data-ttu-id="9cc50-4329">Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody rodzajowej, właściwość ta zwraca `null`.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4329">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cc50-4330">Wskazuje typ dostarczane przez środowisko uruchomieniowe języka wspólnego reprezentujący tego typu.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4330">Indicates the type provided by the common language runtime that represents this type.</span></span></summary>
        <value><span data-ttu-id="9cc50-4331">Podstawowy typ systemu <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="9cc50-4331">The underlying system type for the <see cref="T:System.Type" />.</span></span></value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="Type" FullName="System.Type">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c506fd1b3595bfc48e2b3ee5266d70df1d949954" />
    <Meta Name="ms.sourcegitcommit" Value="d3cf721118797166546daadbf87d91d5c256d489" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/28/2018" />
    <Meta Name="ms.locfileid" Value="37077286" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje typ deklaracji: klas typów, typów interfejsów, typy tablic, typy wartości, Typy wyliczeniowe, parametrów typu, definicji typu ogólnego i open lub closed skonstruowane typów ogólnych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Type` jest elementem głównym <xref:System.Reflection> funkcji i jest podstawową metodą uzyskuje dostęp do metadanych. Użyj elementów członkowskich <xref:System.Type> Aby uzyskać informacje o deklaracji typu o elementach członkowskich typu (na przykład konstruktorów, metod pola, właściwości i zdarzeń klasy), a także modułu i zestawu, w której jest wdrażane klasy.  
  
 Żadne uprawnienia są wymagane do kodu w celu uzyskania informacji na temat typów i ich elementy członkowskie, niezależnie od ich poziomy dostępu za pomocą odbicia. Nie uprawnienia są wymagane dla kodu na potrzeby dostępu do publicznych elementów członkowskich lub innych elementach członkowskich, których poziomy dostępu czy stały się widoczne podczas normalnego kompilacji odbicia. Jednak aby kod, aby używał odbicia do dostępu do elementów członkowskich, które zazwyczaj będzie niedostępny, takich jak prywatny lub wewnętrzny metody lub chronione pól typu, nie dziedziczy z klasy, kod musi mieć <xref:System.Security.Permissions.ReflectionPermission>. Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).  
  
 `Type` jest to abstrakcyjna klasa podstawowa, która zezwala na wiele implementacji. System będzie zawsze dostarczaj klasy pochodnej `RuntimeType`. Odbicie wszystkie klasy, począwszy od programu word środowiska uruchomieniowego tworzonych tylko raz dla każdego obiektu w operacjach porównania systemu i pomocy technicznej.  
  
> [!NOTE]
>  W scenariuszach wielowątkowości, nie należy blokować <xref:System.Type> obiektów, aby można było zsynchronizować dostęp do `static` danych. Inny kod, w którym masz kontrolka nie może być również zablokować danego typu klasy. Może to doprowadzić do zakleszczenia. Zamiast tego należy zsynchronizować dostęp do danych statycznych blokując prywatnej `static` obiektu.  
  
> [!NOTE]
>  Klasy pochodne mogą uzyskiwać dostęp do chronionych elementów członkowskich klasy podstawowej kodu wywołującego. Ponadto jest dozwolony dostęp do elementów członkowskich zestawu kod wywołujący zestawu. Reguły jeśli mają dostęp w kodzie z wczesnym wiązaniem, następnie również możesz dostępu w kodzie późnym wiązaniem.  
  
> [!NOTE]
>  Interfejsy, które rozszerzają inne interfejsy nie dziedziczą metody zdefiniowane w interfejsach rozszerzonej.  
  
 W tej sekcji:  
  
 [Jakie typy reprezentuje obiekt typu?](#WhatTypes)   
 [Trwa pobieranie obiektu typu](#Retrieve)   
 [Porównanie obiektów typu równości](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>Jakie typy reprezentuje obiekt typu?  
 Ta klasa jest wielowątkowość; wiele wątków jednocześnie może odczytać z wystąpienia tego typu. Wystąpienie <xref:System.Type> klasa może reprezentować żadnego z następujących typów:  
  
-   Klasy  
  
-   Typy wartości  
  
-   Tablice  
  
-   Interfejsy  
  
-   Wyliczenia  
  
-   Delegaty  
  
-   Utworzone typy ogólne i definicje typu ogólnego  
  
-   Argumenty typów i wpisz parametry ogólne typy utworzone, definicje typu ogólnego i definicje Metoda ogólna  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>Trwa pobieranie obiektu typu  
 <xref:System.Type> Obiekt skojarzony z określonym typem można uzyskać w następujący sposób:  
  
-   Wystąpienie <xref:System.Object.GetType%2A?displayProperty=nameWithType> metoda zwraca <xref:System.Type> obiekt, który reprezentuje typ wystąpienia. Ponieważ wszystkie typy zarządzane pochodzi od <xref:System.Object>, <xref:System.Object.GetType%2A> metoda może być wywołana na wystąpienia dowolnego typu.  
  
     Następujące przykładowe wywołania <xref:System.Object.GetType%2A?displayProperty=nameWithType> metodę, aby określić typ środowiska uruchomieniowego każdego obiektu w tablicy object.  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   Statycznych <xref:System.Type.GetType%2A?displayProperty=nameWithType> metody zwracają <xref:System.Type> obiekt, który reprezentuje typ określony przez jego w pełni kwalifikowanej nazwy.  
  
-   <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, I <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> metody zwracają `Type` obiektów, które reprezentują typy zdefiniowane w module. Pierwsza metoda pozwala uzyskać tablicę <xref:System.Type> obiektów dla wszystkich typów publicznych i prywatnych zdefiniowany w module. (Można uzyskać wystąpienia `Module` za pośrednictwem <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> lub <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> metody, lub za pomocą <xref:System.Type.Module%2A?displayProperty=nameWithType> właściwości.)  
  
-   <xref:System.Reflection.Assembly?displayProperty=nameWithType> Obiekt zawiera wiele metod można pobrać klas zdefiniowanych w zestawie, w tym <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, i <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.  
  
-   <xref:System.Type.FindInterfaces%2A> Metoda zwraca wyfiltrowanej listy typów interfejsu obsługiwanych przez typ.  
  
-   <xref:System.Type.GetElementType%2A> Metoda zwraca `Type` obiekt, który reprezentuje element.  
  
-   <xref:System.Type.GetInterfaces%2A> i <xref:System.Type.GetInterface%2A> metody zwracają <xref:System.Type> reprezentujący typów interfejsów obsługiwane przez typ obiektów.  
  
-   <xref:System.Type.GetTypeArray%2A> Metoda zwraca tablicę <xref:System.Type> obiekty reprezentujące typów określonych przez dowolny zestaw obiektów. Obiekty są określane za pomocą tablicy typu <xref:System.Object>.  
  
-   <xref:System.Type.GetTypeFromProgID%2A> i <xref:System.Type.GetTypeFromCLSID%2A> udostępniono metody współdziałania COM. Zwracają <xref:System.Type> obiekt, który reprezentuje typ określony przez `ProgID` lub `CLSID`.  
  
-   <xref:System.Type.GetTypeFromHandle%2A> Metody podano współdziałania. Zwraca `Type` obiekt, który reprezentuje typ określony przez dojście klasy.  
  
-   C# `typeof` operatora C++ `typeid` operatora i Visual Basic `GetType` uzyskać operator `Type` obiektu dla typu.  
  
-   <xref:System.Type.MakeGenericType%2A> Metoda zwraca <xref:System.Type> obiekt reprezentujący skonstruowanego typu ogólnego, który jest typem otwartym skonstruowane, jeśli jego <xref:System.Type.ContainsGenericParameters%2A> zwraca `true`, i zamkniętej zbudowane typu w przeciwnym razie wartość. Tylko wtedy, gdy jest ono zamknięte, można utworzyć wystąpienia typu ogólnego.  
  
-   <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, I <xref:System.Type.MakeByRefType%2A> metody zwracają <xref:System.Type> obiektów, które reprezentują odpowiednio tablicę określonego typu, wskaźnik do określonego typu i typ parametru odwołania (`ref` w języku C# `ByRef`w języku Visual Basic).  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>Porównanie obiektów typu równości  
 A <xref:System.Type> obiektu czy reprezentuje typ jest unikatowa; oznacza to, że dwa <xref:System.Type> odwołania do obiektu odnoszą się do tego samego obiektu tylko wtedy, gdy reprezentują tego samego typu. Dzięki temu porównanie <xref:System.Type> obiektów przy użyciu równości odwołań. Poniższy przykład porównuje <xref:System.Type> obiektów, które reprezentują wartości liczby całkowitej w celu ustalenia, czy są tego samego typu.  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano kilka funkcji reprezentatywny <xref:System.Type>. C# `typeof` — operator (`GetType` operatora w języku Visual Basic `typeid` operator w programie Visual C++) jest używany do pobierania <xref:System.Type> reprezentujący obiekt <xref:System.String>. Z tego <xref:System.Type> obiektu <xref:System.Type.GetMethod%2A> metody jest używany do pobierania <xref:System.Reflection.MethodInfo> reprezentujący <xref:System.String.Substring%2A> przeciążenia, które przyjmuje początkową lokalizację i długości.  
  
 Aby zidentyfikować sygnatura przeciążenia, przykładowy kod tworzy tablicy tymczasowej zawierającego dwa <xref:System.Type> obiekty reprezentujące `int` (`Integer` w języku Visual Basic).  
  
> [!NOTE]
>  Aby była precyzyjna, tablica zawiera dwa odwołania do wystąpienia <xref:System.Type> reprezentujący `int` w bieżącej domenie aplikacji. Dla dowolnego typu, jest tylko jedno wystąpienie <xref:System.Type> na domeny aplikacji.  
  
 Przykład kodu wykorzystuje <xref:System.Reflection.MethodInfo> do wywołania <xref:System.String.Substring%2A> metody w ciągu "Hello, World!" i wyświetla wyniki.  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <block subset="none" type="overrides">
      <para>Przy dziedziczeniu z <see langword="Type" />, konieczne jest przesłonięcie następujących członków:- <see cref="P:System.Type.Assembly" />   
  
-    <see cref="P:System.Type.AssemblyQualifiedName" />   
  
-    <see cref="P:System.Type.BaseType" />   
  
-    <see cref="P:System.Type.FullName" />   
  
-    <see cref="M:System.Type.GetAttributeFlagsImpl" />   
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,  -   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para>
    </block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Type" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływany przez klas pochodnych podczas konstruowania typu obiektów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Reflection.Assembly" /> , w którym zadeklarowano typ. Dla typów ogólnych pobiera <see cref="T:System.Reflection.Assembly" /> w jest zdefiniowany typ ogólny.</summary>
        <value>
          <see cref="T:System.Reflection.Assembly" /> Wystąpienie, które opisano zestaw zawierający typ bieżącego. Dla typów ogólnych wystąpienie opisuje zestaw zawierający definicji typu ogólnego, nie zestawu, które tworzy i używa określonego typu skonstruowane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> obiekt reprezentuje skonstruowanego typu ogólnego, ta właściwość zwraca zestaw zawierający definicji typu ogólnego. Załóżmy na przykład, można utworzyć zestawu o nazwie MyGenerics.dll, który zawiera definicję typu ogólnego `MyGenericStack<T>` (`MyGenericStack(Of T)` w języku Visual Basic `generic<T> ref class MyGenericStack` w języku C++). W przypadku utworzenia wystąpienia `MyGenericStack<int>` (`MyGenericStack(Of Integer)` w języku Visual Basic) w innym zestawie <xref:System.Type.Assembly%2A> zwraca właściwości dla typu skonstruowane <xref:System.Reflection.Assembly> obiekt, który reprezentuje MyGenerics.dll.  
  
 Podobnie jeśli bieżący <xref:System.Type> obiekt reprezentuje nieprzypisanego parametru ogólnego `T`, ta właściwość zwraca zestaw zawierający typ ogólny, który definiuje `T`.  
  
 Jeśli <xref:System.Type.Assembly%2A?displayProperty=nameWithType> właściwość nie jest dostępna na konkretnej implementacji .NET, takich jak .NET Core lub platformy uniwersalnej systemu Windows, należy użyć <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> właściwości zamiast tego.      
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono nazwy zestawu skojarzonego z klasą i w pełni kwalifikowana nazwa typu.  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kwalifikowaną dla zestawu nazwę typu, która zawiera nazwę zestawu, z której ta <see cref="T:System.Type" /> obiekt został załadowany.</summary>
        <value>Nazwa kwalifikowana zestawu <see cref="T:System.Type" />, która zawiera nazwę zestawu, w którym <see cref="T:System.Type" /> został załadowany, lub <see langword="null" /> Jeśli bieżące wystąpienie reprezentuje parametr typu ogólnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwa kwalifikowana zestawu typu składa się z nazwy typu, łącznie z jej przestrzenią nazw i przecinek, a następnie według nazwy wyświetlanej zestawu. Nazwa wyświetlana zestawu są uzyskiwane przy użyciu <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> właściwości.  
  
> [!NOTE]
>  W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw. Na przykład "ProcessorArchitecture = msil". Jednak nie jest uwzględnione w ciągu zwróconego przez <xref:System.Type.AssemblyQualifiedName%2A> właściwości ze względu na zgodność. Zobacz <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 Prosta nazwa klasy zagnieżdżonej Emituj wszystkich kompilatorów, które obsługują środowisko uruchomieniowe języka wspólnego, oraz odbicia konstrukcji nazwa zniekształcona po otrzymaniu kwerendy, zgodnie z następujących konwencji.  
  
|Ogranicznik|Znaczenie|  
|---------------|-------------|  
|Ukośnik odwrotny (\\)|Znak ucieczki.|  
|Przecinek (,)|Poprzedza nazwę zestawu.|  
|Znak plus (+)|Poprzedza klasę zagnieżdżoną.|  
|Kropka (.)|Wskazuje przestrzeń nazw identyfikatorów.|  
|Nawiasy kwadratowe ([])|Po nazwie typu oznacza tablicy tego typu.<br /><br /> —lub—<br /><br /> Dla typu ogólnego umieszcza listy argumentów typu ogólnego.<br /><br /> —lub—<br /><br /> Na liście argumentów typu umieszcza typu kwalifikowanego zestawu.|  
  
 Na przykład nazwa kwalifikowana zestawu dla klasy może wyglądać następująco:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 Jeśli przestrzeń nazw zawiera znak plus, na przykład TopNamespace.Sub+Namespace, a następnie znak plus (+) może być poprzedzone znaku ucieczki (\\) aby zapobiec interpretowany jako separator zagnieżdżenia. Ten ciąg będzie emisja odbicia w następujący sposób:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 A "++" staje się "\\+\\+", a "\\"staje się"\\\\".  
  
 Utrwalenia i później użyć do załadowania tego kwalifikowana nazwa <xref:System.Type>. Aby wyszukać i załadować <xref:System.Type>, użyj <xref:System.Type.GetType%2A> albo z typem nazwy lub tylko o nazwie typu kwalifikowanej zestawu. <xref:System.Type.GetType%2A> z typem nazwę tylko będzie szukać <xref:System.Type> w zestawie wywołującego, a następnie w zestawu systemowego. <xref:System.Type.GetType%2A> z zestawu będzie szukać kwalifikowana nazwa typu <xref:System.Type> w dowolnym zestawie.  
  
 Nazwy typów mogą obejmować końcowe znaki, które wyznaczają dodatkowe informacje dotyczące typu, na przykład to, czy typ jest typem odwołania, typem wskaźnika lub typem tablicowym. Aby pobrać nazwę typu bez tych końcowych znaków, należy użyć `t.GetElementType().ToString()`, gdzie `t` jest typem.  
  
 Spacje są istotne we wszystkich składnikach nazwy z wyjątkiem nazwy zestawu. Spacje przed separatorem w nazwie zestawu ',' są istotne, ale spacje po separatorze ',' są ignorowane.  
  
 Argumentów ogólnych typów ogólnych są kwalifikowana przez nazwę zestawu. Na przykład w nazwie typu kwalifikowanego zestawu `MyGenericClass<int>` (`MyGenericClass(Of Integer)` w języku Visual Basic), `int` jest rozszerzona na nazwę typu kwalifikowanego zestawu <xref:System.Int32>.  
  
 Jeśli bieżący <xref:System.Type> obiekt reprezentuje parametr ogólny, ta właściwość zwraca `null`.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono nazwy zestawu skojarzonego z klasą i w pełni kwalifikowana nazwa typu.  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 Poniższy przykład porównuje ciągi zwrócony przez <xref:System.Type.ToString%2A> — metoda i `Name`, <xref:System.Type.FullName%2A>, i <xref:System.Type.AssemblyQualifiedName%2A> właściwości.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera atrybuty skojarzone z <see cref="T:System.Type" />.</summary>
        <value>A <see cref="T:System.Reflection.TypeAttributes" /> obiekt reprezentujący zestaw atrybutów <see cref="T:System.Type" />, chyba że <see cref="T:System.Type" /> reprezentuje parametr typu ogólnego, w których przypadku wartość jest nieokreślony.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektórzy członkowie <xref:System.Reflection.TypeAttributes> wyliczenia są maski, które reprezentują grupy wartości. Każda grupa zawiera jeden element członkowski, którego odpowiednia wartość wynosi zero. Na przykład podstawową wartość <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> element członkowski w <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> grupy wynosi zero, ponieważ jest <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> element członkowski w <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> grupy. W związku z tym należy użyć maski przed przeprowadzeniem jej testów dla tych wartości. Przykład stanowi ilustrację.  
  
> [!TIP]
>  W większości przypadków, takie jak właściwości <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, i <xref:System.Type.IsSpecialName%2A> są łatwiejsze w użyciu niż atrybuty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta właściwość zwraca atrybuty definicji typu ogólnego. Na przykład atrybuty zwracane dla `MyGenericClass<int>` (`MyGenericClass(Of Integer)` w języku Visual Basic) są atrybuty `MyGenericClass<T>` (`MyGenericClass(Of T)` w języku Visual Basic).  
  
 Jeśli bieżącego <xref:System.Type> reprezentuje parametr typu ogólnego — to znaczy, jeśli <xref:System.Type.IsGenericParameter%2A> zwraca właściwości `true` — <xref:System.Reflection.TypeAttributes> określono wartość zwrócona przez tę właściwość.  
  
   
  
## Examples  
 Następujące usesthe przykład <xref:System.Type.Attributes%2A> właściwości.  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ, z którego bieżący <see cref="T:System.Type" /> bezpośrednio dziedziczy.</summary>
        <value>
          <see cref="T:System.Type" /> z którego bieżący <see cref="T:System.Type" /> dziedziczy bezpośrednio, lub <see langword="null" /> Jeśli bieżące <see langword="Type" /> reprezentuje <see cref="T:System.Object" /> klasy lub interfejsu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ podstawowy jest typem, po którym dziedziczy bezpośrednio bieżącego typu. <xref:System.Object> jest to jedyny typ, który nie ma związku z tym typem bazowym `null` jest zwracana jako typ bazowy <xref:System.Object>.  
  
 Interfejsy dziedziczyć zero lub więcej interfejsów podstawowego; Ta właściwość zwraca `null` Jeśli `Type` obiekt reprezentuje interfejs. Można ustalić interfejsach podstawowych z <xref:System.Type.GetInterfaces%2A> lub <xref:System.Type.FindInterfaces%2A>.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowane ogólny typ, typ podstawowy odzwierciedla argumentów rodzajowych. Na przykład wziąć pod uwagę następujące deklaracje:  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 Dla typu skonstruowane `C<int>` (`C(Of Integer)` w języku Visual Basic), <xref:System.Type.BaseType%2A> zwraca właściwość `B<int>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu definicji typu ogólnego, <xref:System.Type.BaseType%2A> zwraca ograniczenie klasy, oznacza to, że parametr typu musi dziedziczyć klasy. Jeśli istnieje bez ograniczenia klasy <xref:System.Type.BaseType%2A> zwraca <xref:System.Object?displayProperty=nameWithType>.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, przy użyciu <xref:System.Type.BaseType%2A> właściwości.  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 W poniższym przykładzie użyto rekursji, aby wyświetlić listę hierarchii dziedziczenia pełną każdej klasy znaleziony w zestawie. W przykładzie zdefiniowano klasę o nazwie `C` która pochodzi z klasy o nazwie `B`, która z kolei jest pochodną klasy o nazwie `A`.  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy bieżące <see cref="T:System.Type" /> obiekt ma parametry typu, które nie zostały zastąpione przez określone typy.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> samego parametru typu ogólnego lub obiektu ma parametrów typu, dla których określonych typów nie zostały podane; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby można było utworzyć wystąpienia typu, musi być nie definicji typu ogólnego lub Otwórz typy utworzone w argumentach typu samego typu, w dowolnej otaczającego typów ogólnych lub elementów tego typu. Innymi słowy to jest że w przypadku badane cyklicznie, typ musi zawierać żadnych parametrów typu ogólnego.  
  
 Ponieważ typy mogą być arbitralnie złożone, co to jest trudne. Dla wygody i zmniejszyć ryzyko błędów <xref:System.Type.ContainsGenericParameters%2A> właściwość udostępnia standardowy sposób, aby odróżnić zamkniętego typy utworzone, które można wdrożyć, i typy, których nie można skonstruować open. Jeśli <xref:System.Type.ContainsGenericParameters%2A> zwraca `true`, nie można utworzyć wystąpienia typu.  
  
 <xref:System.Type.ContainsGenericParameters%2A> Właściwość wyszukuje rekursywnie dla parametrów typu. Na przykład zwraca `true` dla tablicy, której elementy są typu `A<T>` (`A(Of T)` w języku Visual Basic), nawet jeśli tablica nie jest samego ogólnego. Natomiast to z zachowaniem <xref:System.Type.IsGenericType%2A> właściwość, która zwraca `false` dla tablic.  
  
 Zbiór przykład klasy i tabelę przedstawiającą wartości <xref:System.Type.ContainsGenericParameters%2A> właściwości, zobacz <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Definiuje klasę ogólnego z dwoma parametrami typu, następnie definiuje drugi klasy ogólnej, która pochodzi z klasy pierwszy w następującym przykładzie. Klasa podstawowa klasy pochodnej ma dwa argumenty typu: pierwsza to <xref:System.Int32> , a drugim parametrem typu w typie pochodnym. W przykładzie przedstawiono informacje o tych klas rodzajowych, w tym pozycje raportowane przez <xref:System.Type.GenericParameterPosition%2A> właściwości.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Reflection.MethodBase" /> reprezentujący deklarujący metody, jeśli bieżący <see cref="T:System.Type" /> reprezentuje parametr typu metody ogólnej.</summary>
        <value>Jeśli bieżący <see cref="T:System.Type" /> reprezentuje parametr typu metody ogólnej <see cref="T:System.Reflection.MethodBase" /> reprezentująca deklarowanie metody; w przeciwnym razie <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda deklarujący jest ogólną definicją metody. Oznacza to, że jeśli <xref:System.Type.DeclaringMethod%2A> nie zwraca `null`, następnie `DeclaringMethod.IsGenericMethodDefinition` zwraca `true`.  
  
 <xref:System.Type.DeclaringType%2A> i <xref:System.Type.DeclaringMethod%2A> właściwości zidentyfikować definicji typu ogólnego lub metody ogólnej definicji, w którym została pierwotnie zdefiniowana parametr typu ogólnego:  
  
-   Jeśli <xref:System.Type.DeclaringMethod%2A> zwraca <xref:System.Reflection.MethodInfo>, że <xref:System.Reflection.MethodInfo> reprezentuje definicję metody rodzajowej i obecnie <xref:System.Type> obiekt reprezentuje parametr typu tej definicji metody rodzajowej.  
  
-   Jeśli <xref:System.Type.DeclaringMethod%2A> zwraca `null`, a następnie <xref:System.Type.DeclaringType%2A> właściwość zawsze zwraca <xref:System.Type> obiekt reprezentujący definicji typu ogólnego i obecnie <xref:System.Type> obiekt reprezentuje parametr typu ogólnego typu Definicja.  
  
-   Pobieranie <xref:System.Type.DeclaringMethod%2A> właściwości w typie których <xref:System.Type.IsGenericParameter%2A> właściwość jest `false` zgłasza <xref:System.InvalidOperationException>.  
  
 <xref:System.Reflection.MethodBase> Zwróconego przez <xref:System.Type.DeclaringMethod%2A> właściwości <xref:System.Reflection.MethodInfo> w przypadku metody ogólnej lub <xref:System.Reflection.ConstructorInfo> w przypadku ogólnych konstruktora.  
  
> [!NOTE]
>  W programie .NET Framework w wersji 2.0 konstruktorów rodzajowe nie są obsługiwane.  
  
 Lista niezmiennej warunki terminów używanych w ogólnym odbicia, zobacz <xref:System.Type.IsGenericType%2A> właściwości uwagi.  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje klasę, która ma metody ogólnej, przypisuje argument typu metody i wywołuje wynikowy skonstruowane Metoda ogólna. Wyświetla również informacje o definicję metody rodzajowej i skonstruowane — metoda. Podczas wyświetlania informacji o parametrach typu definicję metody rodzajowej w `DisplayGenericMethodInfo` metody przykładowy kod przedstawia wartość <xref:System.Type.DeclaringMethod%2A> właściwości dla parametru typu ogólnego metody.  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ, który deklaruje bieżącego typu zagnieżdżonego lub parametr typu ogólnego.</summary>
        <value>A <see cref="T:System.Type" /> obiekt reprezentujący otaczający typ, jeśli bieżący typ jest typem zagnieżdżonym; lub definicji typu ogólnego, jeśli bieżący typ jest parametr typu ogólnego; lub typu, który deklaruje metody ogólnej, jeśli typ bieżącego parametru typu metody ogólne; w przeciwnym razie <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> obiekt reprezentuje parametr typu ogólnego, ta właściwość zwraca definicji typu ogólnego.  
  
 Jeśli bieżący <xref:System.Type> obiekt reprezentuje parametr typu metody ogólnej, ta właściwość zwraca typ, który zawiera definicję metody rodzajowej. Jeśli typ jest rodzajowy, jest zwracany definicji typu ogólnego. Oznacza to, poniższy kod zwraca definicji typu ogólnego <xref:System.Collections.Generic.List%601> klasy ogólnej, który zawiera <xref:System.Collections.Generic.List%601.ConvertAll%2A> ogólnej metody:  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ parametru w definicji typu ogólnego lub metody ogólnej <xref:System.Type.DeclaringType%2A> i <xref:System.Type.DeclaringMethod%2A> właściwości zidentyfikować definicji typu ogólnego lub ogólną definicją metody, gdzie parametr typu ogólnego została pierwotnie zdefiniowana:  
  
-   Jeśli <xref:System.Type.DeclaringMethod%2A> zwraca <xref:System.Reflection.MethodInfo>, że <xref:System.Reflection.MethodInfo> reprezentuje definicję metody rodzajowej i obecnie <xref:System.Type> obiekt reprezentuje parametr typu tej definicji metody rodzajowej.  
  
-   Jeśli <xref:System.Type.DeclaringMethod%2A> zwraca `null`, a następnie <xref:System.Type.DeclaringType%2A> właściwość zawsze zwraca <xref:System.Type> obiekt reprezentujący definicji typu ogólnego i obecnie <xref:System.Type> obiekt reprezentuje parametr typu ogólnego typu Definicja.  
  
-   Pobieranie <xref:System.Type.DeclaringType%2A> właściwości w typie których <xref:System.Type.IsGenericParameter%2A> właściwość jest `false` zgłasza <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 W tym przykładzie wyświetla typ deklarujący metody w klasie pochodnej.  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do domyślnego integratora, która implementuje wewnętrzne zasady dotyczące wybierania odpowiednich elementów członkowskich do wywołania przez <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</summary>
        <value>Odwołanie do domyślnego integratora używaną przez system.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślny integrator wyposażone w środowisko uruchomieniowe języka wspólnego ma zastosowanie, nawet w najbardziej specjalne okoliczności. Jeśli potrzebujesz integrator następujące reguły, które różnią się od podanej domyślnego integratora, definiują typ pochodny <xref:System.Reflection.Binder> klasy i przekaż wystąpienie tego typu za pomocą `binder` parametru jednego z <xref:System.Type.InvokeMember%2A> przeciążenia.  
  
 Odbicie modele wspólny system typów reguł ułatwień dostępu. Na przykład jeśli element wywołujący jest w tym samym zestawie, obiekt wywołujący nie potrzebuje specjalne uprawnienia dla wewnętrzne elementy członkowskie. W przeciwnym razie wywołujący musi <xref:System.Security.Permissions.ReflectionPermission>. Jest to zgodne z wyszukiwania elementów członkowskich, które są chronione, prywatne i tak dalej.  
  
 Ogólną zasadą jest to, że <xref:System.Reflection.Binder.ChangeType%2A> należy wykonywać tylko rozszerzanie konwersji, które nigdy nie spowodować utratę danych. Konwertuje wartość całkowita 32-bitowa wartość całkowita 64-bitowych jest przykładem konwersję rozszerzającą. Jest to różnią się od użycia konwersji zawężającej, która może spowodować utratę danych. Przykład konwersji zawężającej jest konwersja 64-bitowej podpisanej liczby całkowitej na całkowita 32-bitowych.  
  
 W poniższej tabeli wymieniono konwersje obsługiwane przez domyślny integrator.  
  
|Typ źródła|Typ docelowy|  
|-----------------|-----------------|  
|Dowolnego typu|Jego typ podstawowy.|  
|Dowolnego typu|Interfejs, który implementuje.|  
|Char|Unt16, UInt32, Int32, UInt64, Int64, Single, Double|  
|Byte|Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double|  
|SByte|Int16, Int32, Int64, Single, Double|  
|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  
|Int16|Int32, Int64, Single, Double|  
|UInt32|UInt64, Int64, Single, Double|  
|Int32|Int64, jeden dwukrotnie|  
|UInt64|Single, Double|  
|Int64|Single, Double|  
|Single|Double|  
|Non-reference|Przez odwołanie.|  
  
   
  
## Examples  
 Poniższy przykład pobiera domyślnego integratora z `DefaultBinder` właściwości oraz wywołuje członkiem MyClass przez przekazanie `DefaultBinder` wartość jako parametr <xref:System.Type.InvokeMember%2A>.  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Oddziela nazwy w przestrzeni nazw <see cref="T:System.Type" />. To pole jest tylko do odczytu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje pustą tablicę typu <see cref="T:System.Type" />. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod przedstawia przykład `EmptyTypes` pola używanego w jednym z `GetConstructor` metody w celu uzyskania konstruktora, który nie przyjmuje żadnych parametrów.  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy bieżący typ źródłowy system <see cref="T:System.Type" /> jest taki sam jak podstawowy typ systemu określonego <see cref="T:System.Object" /> lub <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Obiektu, którego typ podstawowy system jest ma zostać porównane z typem bazowym systemu bieżącego <see cref="T:System.Type" />. Dla porównania zakończyła się powodzeniem <c>o</c> musi być w stanie rzutowania lub konwersji do typu obiektu <see cref="T:System.Type" />.</param>
        <summary>Określa, czy bieżący typ źródłowy system <see cref="T:System.Type" /> obiekt jest taki sam jak podstawowy typ systemu określonego <see cref="T:System.Object" />.</summary>
        <returns>
          <see langword="true" /> Jeśli typ źródłowy system <paramref name="o" /> jest taki sam jak podstawowy typ systemu bieżącego <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />. Ta metoda zwraca również wartość <see langword="false" /> jeśli:.  
  
-   <paramref name="o" /> jest <see langword="null" />.  
  
-   <paramref name="o" /> Nie można rzutować lub przekonwertować <see cref="T:System.Type" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Rzutuje go `o` do obiektu typu <xref:System.Type> i wywołuje <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Type.Equals%28System.Object%29> do porównania z różnymi <xref:System.Type> obiekt wystąpień z różnymi <xref:System.Object> wystąpień.  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 Dwie czynności są szczególnie warto zauważyć, informacje w przykładzie:  
  
-   Porównanie <xref:System.Type> obiekt, który reprezentuje liczbą całkowitą o <xref:System.Reflection.TypeInfo> obiekt, który reprezentuje całkowitą zwracany `true` ponieważ <xref:System.Reflection.TypeInfo> jest pochodną <xref:System.Type>.  
  
-   Porównanie <xref:System.Type> obiekt, który reprezentuje <xref:System.Collections.Generic.IList%601> obiektu (otwartym typem ogólnym) z `List(Of String)` zwraca obiekt (zamkniętego typu ogólnego) `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">Obiektu, którego typ podstawowy system jest ma zostać porównane z typem bazowym systemu bieżącego <see cref="T:System.Type" />.</param>
        <summary>Określa, czy bieżący typ źródłowy system <see cref="T:System.Type" /> jest taki sam jak podstawowy typ systemu określonego <see cref="T:System.Type" />.</summary>
        <returns>
          <see langword="true" /> Jeśli typ źródłowy system <paramref name="o" /> jest taki sam jak podstawowy typ systemu bieżącego <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto `Equals` Aby porównać dwa typy.  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje filtr Członek używane w atrybutach. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To pole zawiera odwołanie do obiektu delegowanego używane przez <xref:System.Type.FindMembers%2A> metody. Metoda zamknięte przez ten delegat przyjmuje dwa parametry: pierwszy jest <xref:System.Reflection.MemberInfo> obiektu, a drugi jest `Object`. Metoda określa, czy `MemberInfo` obiektu kryteria określone przez `Object`. `Object` Można przypisać wartość jednego z pola klasy <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, lub <xref:System.Reflection.MethodImplAttributes>.  
  
 Na przykład `Object` można przypisać wartości pola z `FieldAttributes` takich jak publicznego. W takim przypadku, gdy `FilterAttribute` jest wywoływany delegat, będzie zwracać `true` tylko wtedy, gdy metoda reprezentowany przez `MemberInfo` obiektu zostanie nadany atrybut pole publiczne w metadanych.  
  
   
  
## Examples  
 Poniższy przykład pobiera `FilterAttribute` delegować, przekazuje ją jako parametr <xref:System.Type.FindMembers%2A> metody i zawiera określone elementy członkowskie i ich atrybutów.  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje filtr z uwzględnieniem wielkości liter elementu członkowskiego używane w nazwach. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To pole zawiera odwołanie do obiektu delegowanego używane przez <xref:System.Type.FindMembers%2A> metody. Metoda zamknięte przez ten delegat przyjmuje dwa parametry: pierwszy jest <xref:System.Reflection.MemberInfo> obiektu, a drugi jest `Object`. Metoda określa, czy `MemberInfo` obiektu kryteria określone przez `Object`. `Object` Jest przypisywana wartość ciągu, co może obejmować końcowe "*" wieloznacznego. Tylko zakończenia ciąg znaków wieloznacznych jest obsługiwana.  
  
 Na przykład `Object` można przypisać wartości "Bajtów *". W takim przypadku, gdy `FilterName` jest wywoływany delegat, będzie zwracać `true` tylko wtedy, gdy metoda reprezentowany przez `MemberInfo` obiekt ma nazwę, która rozpoczyna się od "Bajtów".  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera metody skojarzone z użytkownika `Application` typu.  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje filtr bez uwzględniania wielkości liter elementu członkowskiego używane na nazwy. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To pole zawiera odwołanie do obiektu delegowanego używane przez <xref:System.Type.FindMembers%2A> metody. Metoda zamknięte przez ten delegat przyjmuje dwa parametry: pierwszy jest <xref:System.Reflection.MemberInfo> obiektu, a drugi jest `Object`. Metoda określa, czy `MemberInfo` obiektu kryteria określone przez `Object`. `Object` Jest przypisywana wartość ciągu, co może obejmować końcowe "*" wieloznacznego. Tylko zakończenia ciąg znaków wieloznacznych jest obsługiwana.  
  
 Na przykład `Object` można przypisać wartości "Bajtów *". W takim przypadku, gdy `FilterName` jest wywoływany delegat, zwróci wartość true, tylko jeśli metoda reprezentowany przez `MemberInfo` obiekt ma nazwę, która rozpoczyna się od "bajtów", bez uwzględnienia wielkości liter.  
  
   
  
## Examples  
 Poniższy przykład pobiera `MemberFilter` delegować, przekazuje ją jako parametr <xref:System.Type.FindMembers%2A> metody i wyświetla metod i ich atrybuty `String` klasy, które rozpoczynają się od litery "c", niezależnie od przypadku.  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">Delegat, który porównuje interfejsy przed <c>filterCriteria</c>.</param>
        <param name="filterCriteria">Kryteria wyszukiwania, które określa, czy interfejs powinien być uwzględniany w zwróconej tablicy.</param>
        <summary>Zwraca tablicę <see cref="T:System.Type" /> obiektów reprezentujący filtrowana lista interfejsy zaimplementowano lub dziedziczone przez bieżące <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiektów reprezentujący filtrowana lista interfejsy zaimplementowano lub dziedziczone przez bieżący <see cref="T:System.Type" />, lub pusta tablica typu <see cref="T:System.Type" /> Jeśli żadne interfejsy zgodne z filtrem są zaimplementowano lub dziedziczone przez bieżący <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
 <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> i <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegatów dostarczonych przez <xref:System.Reflection.Module?displayProperty=nameWithType> klasa może być również używana, w miejsce <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegowanie.  
  
 Wszystkie interfejsy implementowane przez tę klasę są brane pod uwagę podczas wyszukiwania, czy podana przez klasę podstawową lub tej samej klasy.  
  
 Ta metoda wyszukiwania w hierarchii klasy podstawowej, zwracanie wszystkich zgodnych interfejsów, każda klasa implementuje oraz wszystkie dopasowania każdego z tych interfejsów implementuje interfejsy (to znaczy, zwracany jest przechodnie zamknięcia interfejsy zgodne). Żadne zduplikowane interfejsy są zwracane.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ parametru w definicji typu ogólnego lub metody ogólnej <xref:System.Type.FindInterfaces%2A> wyszukiwanie wszystkich interfejsów zadeklarowany w ograniczenia dotyczące parametrów typu, a wszystkie interfejsy dziedziczone za pośrednictwem interfejsów zadeklarowany w ograniczenia. Jeśli bieżący <xref:System.Type> reprezentuje typem argumentu typu ogólnego, <xref:System.Type.FindInterfaces%2A> przeszukuje wszystkie interfejsy implementowane przez ten typ, czy są one zgodne z ograniczeniami.  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A> może zwracać interfejsy ogólne, nawet w przypadku typów, które nie są ogólne. Na przykład może zastosować nierodzajowe typu `IEnumerable<int>` (`IEnumerable(Of Integer)` w języku Visual Basic).  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie określonego interfejsu zaimplementowano lub dziedziczone przez określony typ, a następnie wyświetla nazwy interfejsu.  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator statyczny jest wywoływany i zgłasza wyjątek.</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">Obiekt, który wskazuje typ elementu członkowskiego do wyszukania.</param>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić <see langword="null" />.</param>
        <param name="filter">Delegata, który wykonuje porównań, zwracając <see langword="true" /> Jeśli element członkowski obecnie sprawdzana dopasowań <c>filterCriteria</c> i <see langword="false" /> inaczej. Można użyć <see langword="FilterAttribute" />, <see langword="FilterName" />, i <see langword="FilterNameIgnoreCase" /> delegatów dostarczonych przez tę klasę. Pierwszy używa pola <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, i <see langword="MethodImplAttributes" /> jako kryteria wyszukiwania, a następnie użyć dwóch delegatów <see langword="String" /> obiektów jako kryterium wyszukiwania.</param>
        <param name="filterCriteria">Kryteria wyszukiwania, które określa, czy element członkowski jest zwracany w tablicy <see langword="MemberInfo" /> obiektów.  Pola <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, i <see langword="MethodImplAttributes" /> mogą być używane w połączeniu z <see langword="FilterAttribute" /> delegata dostarczonych przez tę klasę.</param>
        <summary>Zwraca tablicę filtrowane <see cref="T:System.Reflection.MemberInfo" /> obiektów typu określonego elementu członkowskiego.</summary>
        <returns>Filtrowane tablicę <see cref="T:System.Reflection.MemberInfo" /> obiektów typu określonego elementu członkowskiego.  - lub - pustą tablicę typu <see cref="T:System.Reflection.MemberInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma elementów członkowskich typu <paramref name="memberType" /> spełniających kryteria filtrowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
 Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania członków do wyszukiwania:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` aby można było pobrać typ zwracany.  
  
-   Określ `BindingFlags.Instance` aby w wyszukiwaniu uwzględnić elementów członkowskich wystąpień.  
  
-   Określ `BindingFlags.Static` aby w wyszukiwaniu uwzględnić statycznych elementów członkowskich.  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić publiczne elementy członkowskie.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić niepublicznych elementów członkowskich (to znaczy prywatnych, wewnętrznych i chronionych elementów członkowskich).  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikator można zmienić, jak działa wyszukiwanie:  
  
-   `BindingFlags.DeclaredOnly` do wyszukiwania tylko do elementów członkowskich zadeklarowana w <xref:System.Type>, nie elementów członkowskich, które zostały odziedziczone po prostu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Prawidłowymi wartościami dla <xref:System.Type.MemberType%2A> są zdefiniowane w <xref:System.Reflection.MemberInfo>. Jeśli nie zostaną znalezione nie takich członków, zwracana jest pusta tablica.  
  
 Aby uzyskać inicjatora — klasa (.cctor) za pomocą tej metody, należy określić <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic). Można również uzyskać za pomocą inicjatora klasy <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego lub metody ogólnej <xref:System.Type.FindMembers%2A> przetwarza żadnych elementów członkowskich zadeklarowanych przez ograniczenie klasy i ograniczenia interfejsu parametru typu.  
  
   
  
## Examples  
 Poniższy przykład znajduje wszystkie elementy członkowskie w klasie, spełniających określone kryteria wyszukiwania, a następnie wyświetla pasujących elementów członkowskich.  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera w pełni kwalifikowana nazwa typu, łącznie z jego przestrzeni nazw, ale nie jej zestaw.</summary>
        <value>W pełni kwalifikowana nazwa typu, łącznie z jego przestrzeni nazw, ale nie jej zestaw; lub <see langword="null" /> Jeśli bieżące wystąpienie reprezentuje parametr typu ogólnego, typu tablicy, typ wskaźnika lub <see langword="byref" /> typu na podstawie parametru typu lub nie jest definicją typu ogólnego, który zawiera nierozpoznany typ parametry typu ogólnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład w pełni kwalifikowana nazwa <xref:System.String> jest typu `System.String`. Natomiast to nazwą kwalifikowaną dla zestawu zwrócony przez <xref:System.Type.AssemblyQualifiedName%2A> właściwość, która składa się z pełną nazwę i pełną nazwą zestawu.  
  
 Jeśli typ bieżącego reprezentuje zamkniętego typu ogólnego, argumentów typu ciąg zwrócony przez <xref:System.Type.FullName%2A> właściwości jest kwalifikowana ich pełną nazwą zestawu, nawet jeśli reprezentacja ciągu samego typu ogólnego nie jest kwalifikowana przez jego pełny Nazwa zestawu. Poniższy przykład przedstawia różnica we właściwości Pełna nazwa typu, który reprezentuje definicji typu ogólnego i odpowiadającą zamkniętego typu ogólnego.  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 Ta właściwość zwraca `null` jeśli:  
  
-   Bieżący <xref:System.Type> obiekt reprezentuje parametr typu ogólnego.  
  
     Poniższy przykład pobiera parametr typu <xref:System.Nullable%601> typu i prób, aby wyświetlić jego <xref:System.Type.FullName%2A> właściwości.  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   Bieżący <xref:System.Type> obiekt reprezentuje typem tablicy typu wskaźnika lub `byref` typu, który jest oparty na parametr typu ogólnego.  
  
     W poniższym przykładzie zdefiniowano typu ogólnego, `Generictype1<T>`, z trzech metod: `Display(T[])`, która została przekazana Tablica typu T; `HandleT(T)`, który jest przekazywany obiekt T; i `ChangeValue(ref T)`, który jest przekazywany obiekt T przez odwołanie. Ponieważ C# i Visual Basic nie umożliwiają definiowanie T jako wskaźnik w `HandleT` metody mamy do wywołania <xref:System.Type.MakePointerType%2A> metoda <xref:System.Type> obiekt, który reprezentuje typ parametru metody, aby utworzyć wskaźnik do typu ogólnego. Dane wyjściowe w przykładzie pokazano, że we wszystkich trzech przypadkach <xref:System.Type.FullName%2A> jest właściwość `null`.  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   Bieżący typ zawiera parametry typu ogólnego, które nie zostały zastąpione przez określone typy (oznacza to, <xref:System.Type.ContainsGenericParameters%2A> zwraca właściwości `true`), ale ten typ nie jest definicją typu ogólnego (oznacza to, <xref:System.Type.IsGenericTypeDefinition%2A> zwraca właściwości `false`  
  
     W poniższym przykładzie `Derived<T>` dziedziczy `Base<T>`. <xref:System.Type.BaseType%2A> Uzyskuje właściwości <xref:System.Type> obiekt, który reprezentuje typ bazowy `Derived<T>`, a jego <xref:System.Type.FullName%2A> zwraca `null`.  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     Aby uzyskać <xref:System.Type.FullName%2A> nie jest to `null`, można użyć <xref:System.Type.GetGenericTypeDefinition%2A> metody można pobrać definicji typu ogólnego, jak pokazano w przykładzie.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono pełną nazwę określonego typu.  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 Poniższy przykład porównuje ciągi zwrócony przez <xref:System.Type.ToString%2A> — metoda i `Name`, <xref:System.Type.FullName%2A>, i <xref:System.Type.AssemblyQualifiedName%2A> właściwości.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kombinację <see cref="T:System.Reflection.GenericParameterAttributes" /> flagi opisujące Kowariancja i ograniczeń specjalnych bieżącego parametru typu ogólnego.</summary>
        <value>Bitowe połączenie <see cref="T:System.Reflection.GenericParameterAttributes" /> wartości, które opisano Kowariancja i ograniczeń specjalnych bieżącego parametru typu ogólnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości zawiera flagi opisujące czy bieżący parametr ogólny typu jest kowariantny i flag, które opisują żadnych ograniczeń specjalnych. Użyj <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> wartość, aby wybrać flagi Kowariancja i użyj <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> wartość, aby wybrać flagi ograniczenia.  
  
 Lista niezmiennej warunki terminów używanych w ogólnym odbicia, zobacz <xref:System.Type.IsGenericType%2A> właściwości uwagi.  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje typu ogólnego `Test` z dwoma parametrami typu, które mają różne ograniczenia. Gdy program jest wykonywana, ograniczenia są sprawdzane przy użyciu <xref:System.Type.GenericParameterAttributes%2A> właściwości i <xref:System.Type.GetGenericParameterConstraints%2A> metody.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący <see cref="T:System.Type" /> obiektu nie jest parametrem typu ogólnego. Oznacza to <see cref="P:System.Type.IsGenericParameter" /> zwraca właściwość <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pozycję parametru typu z typu listy wartości parametru typu ogólnego lub metody, która zadeklarowana jako parametr, gdy <see cref="T:System.Type" /> obiekt reprezentuje parametr typu ogólnego lub metody rodzajowej.</summary>
        <value>Pozycja parametru typu na liście parametrów typu ogólnego typu lub metody definiującej parametr. Rozpocznij liczby pozycji w lokalizacji 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GenericParameterPosition%2A> Właściwość zwraca pozycja parametru typu na liście parametrów w definicji typu ogólnego lub definicję metody rodzajowej gdzie parametr typu została pierwotnie zdefiniowana. <xref:System.Type.DeclaringType%2A> i <xref:System.Type.DeclaringMethod%2A> właściwości zidentyfikować ogólną definicję typu lub metody:  
  
-   Jeśli <xref:System.Type.DeclaringMethod%2A> zwraca <xref:System.Reflection.MethodInfo>, że <xref:System.Reflection.MethodInfo> reprezentuje definicję metody rodzajowej i obecnie <xref:System.Type> obiekt reprezentuje parametr typu tej definicji metody rodzajowej.  
  
-   Jeśli <xref:System.Type.DeclaringMethod%2A> zwraca `null`, a następnie <xref:System.Type.DeclaringType%2A> właściwość zawsze zwraca <xref:System.Type> obiekt reprezentujący definicji typu ogólnego i obecnie <xref:System.Type> obiekt reprezentuje parametr typu ogólnego typu Definicja.  
  
 Aby zapewnić poprawny kontekst dla wartości <xref:System.Type.GenericParameterPosition%2A> właściwości, konieczne jest określenie typu ogólnego lub metody parametr typu należy. Rozważmy na przykład wartość zwracaną metody ogólnej `GetSomething` w następującym kodzie:  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 Typ zwracany przez `GetSomething` zależy od argumentów typu dostarczonego do klasy `A` i `GetSomething` samej siebie. Możesz uzyskać <xref:System.Reflection.MethodInfo> dla `GetSomething`, i z którego można uzyskać typ zwracany. Po sprawdzeniu parametrów typu zwracanego typu <xref:System.Type.GenericParameterPosition%2A> zwraca wartość 0 dla obu. Pozycja `V` wynosi 0, ponieważ `V` jest pierwszym parametrem typu na liście parametrów typu dla klasy `A`. Pozycja `X` wynosi 0, ponieważ `X` jest pierwszym parametrem typu na liście parametrów typu dla `GetSomething`.  
  
> [!NOTE]
>  Wywoływanie <xref:System.Type.GenericParameterPosition%2A> właściwości powoduje zgłoszenie wyjątku, jeśli bieżący <xref:System.Type> nie reprezentuje parametr typu. Po sprawdzeniu argumentów typu otwartego skonstruowanego typu użyć <xref:System.Type.IsGenericParameter%2A> właściwości stwierdzić, którego parametrów typu i typów. <xref:System.Type.IsGenericParameter%2A> Zwraca `true` dla parametru typu; można użyć <xref:System.Type.GenericParameterPosition%2A> metodę, aby uzyskać jego położenie i użyj <xref:System.Type.DeclaringMethod%2A> i <xref:System.Type.DeclaringType%2A> właściwości, aby określić metoda rodzajowa lub definicji, który definiuje ona typu .  
  
   
  
## Examples  
 W poniższym przykładzie definiuje klasy ogólnej z dwoma parametrami typu i definiuje drugi klasy ogólnej, która pochodzi z klasy pierwszy. Klasa podstawowa klasy pochodnej ma dwa argumenty typu: pierwsza to <xref:System.Int32>, a drugą jest parametrem typu w typie pochodnym. W przykładzie przedstawiono informacje o tych klas rodzajowych, w tym pozycje raportowane przez <xref:System.Type.GenericParameterPosition%2A> właściwości.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący typ nie reprezentuje parametr typu. Oznacza to <see cref="P:System.Type.IsGenericParameter" /> zwraca <see langword="false" />.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera tablicę argumentów typu ogólnego dla tego typu.</summary>
        <value>Tablica argumentów typu ogólnego dla tego typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość pobiera tylko argumenty typu ogólnego; oznacza to, że typy, które zostały określone dla bieżącego typu parametrów typu ogólnego. Jeśli typ bieżącego jest definicją typu ogólnego, ta właściwość zwraca pustą tablicę.  
  
> [!NOTE]
>  Jeśli typem ogólnym jest używana metoda rodzajowa lub innego typu ogólnego, niektóre z jego argumentów typu ogólnego może być parametry typu ogólnego, metody lub typu otaczającego.  
  
 Aby uzyskać parametry typu ogólnego typu, który reprezentuje definicji typu ogólnego, należy użyć <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> właściwości. Aby uzyskać <xref:System.Reflection.TypeInfo> obiektu dla bieżącej <xref:System.Type> obiektów, użyj <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> — metoda rozszerzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera liczbę wymiarów tablicy.</summary>
        <returns>Liczba całkowita, która zawiera liczby wymiarów w bieżącym typie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie przedstawiono liczby wymiarów w tablicy.  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Funkcjonalność tej metody w klasie podstawowej nie jest obsługiwana i musi zostać wdrożona w klasie pochodnej zamiast tego.</exception>
        <exception cref="T:System.ArgumentException">Bieżący typ nie jest tablicą.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, implementuje <see cref="P:System.Type.Attributes" /> właściwości i pobiera maską bitów i wskazujący atrybuty skojarzone z <see cref="T:System.Type" />.</summary>
        <returns>A <see cref="T:System.Reflection.TypeAttributes" /> obiekt reprezentujący zestaw atrybutów <see cref="T:System.Type" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera konstruktora określonego bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">Tablica <see cref="T:System.Type" /> obiekty reprezentujące numer zamówienia i typy parametrów dla żądanego konstruktora.  - lub - pustą tablicę <see cref="T:System.Type" /> obiektów, aby uzyskać konstruktora, który nie przyjmuje żadnych parametrów. Pusta tablica jest zapewniana przez <see langword="static" /> pola <see cref="F:System.Type.EmptyTypes" />.</param>
        <summary>Wyszukuje konstruktora wystąpienia publicznego, którego parametry są zgodne z typami w określonej tablicy.</summary>
        <returns>Obiekt przedstawiający konstruktora wystąpienia publicznego, którego parametry są zgodne typy tablicy typu parametru, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie metody szuka konstruktorów wystąpienia publicznego i nie może zostać użyty do uzyskania inicjatora klasy (.cctor). Aby uzyskać inicjatora klasy, użyj przeciążenia, które przyjmuje <xref:System.Reflection.BindingFlags>i określ <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic). Można również uzyskać za pomocą inicjatora klasy <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 Jeśli żądanego Konstruktor jest niepubliczne, ta metoda zwraca `null`.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.ConstructorInfo> z parametrami typu zastępuje argumenty odpowiedniego typu. Jeśli bieżący <xref:System.Type> reprezentuje typ parametru w definicji typu ogólnego lub metody ogólnej, ta metoda zawsze zwraca `null`.  
  
   
  
## Examples  
 Poniższy przykład uzyskuje typ `MyClass`, pobiera <xref:System.Reflection.ConstructorInfo> obiektu i wyświetla sygnatury konstruktora.  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> jest <see langword="null" />.  - lub - jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> jest wielowymiarowy.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić <see langword="null" />.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  - lub - odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentującą numer, kolejność i typy parametrów dla konstruktora, aby uzyskać.  - lub - pustą tablicę typu <see cref="T:System.Type" /> (to znaczy wpisz typów [] = nowe Type[0]) można pobrać konstruktora, który nie przyjmuje żadnych parametrów.  - lub - <see cref="F:System.Type.EmptyTypes" />.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiadający mu element w tablicy parametrów typu. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Wyszukuje konstruktora, którego parametry są zgodne określone typy argumentów i Modyfikatory korzystanie z określonymi ograniczeniami wiązania.</summary>
        <returns>A <see cref="T:System.Reflection.ConstructorInfo" /> obiekt reprezentujący Konstruktor, który spełnia określonych wymagań, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli istnieje dopasowanie dokładne, `binder` podejmie próbę wymuszone typów parametrów określonych w `types` tablicy, aby wybrać dopasowania. Jeśli `binder` jest w stanie wybierz dopasowania, a następnie `null` jest zwracany.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowanie konstruktora, która do wyszukiwania:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` aby można było pobrać typ zwracany.  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić konstruktorów publicznych.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić konstruktorów niepublicznego (to znaczy konstruktorów prywatnych, wewnętrznych i chronionych).  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Aby uzyskać przy użyciu tego przeciążenia metody inicjatora — klasa (.cctor), należy określić <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic). Można również uzyskać za pomocą inicjatora klasy <xref:System.Type.TypeInitializer%2A> właściwości.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.ConstructorInfo> z parametrami typu zastępuje argumenty odpowiedniego typu. Jeśli bieżący <xref:System.Type> reprezentuje typ parametru w definicji typu ogólnego lub metody ogólnej, ta metoda zawsze zwraca `null`.  
  
   
  
## Examples  
 Następujący program uzyskuje typ `MyClass1` klasy pobiera <xref:System.Reflection.ConstructorInfo> obiekt dopasowania flagi określone powiązanie i wyświetla podpisu konstruktora.  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> jest <see langword="null" />.  - lub - jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> jest wielowymiarowy.  - lub - <paramref name="modifiers" /> jest wielowymiarowy.  - lub - <paramref name="types" /> i <paramref name="modifiers" /> nie mają taką samą długość.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić <see langword="null" />.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  - lub - odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Obiekt, który określa zestaw reguł dotyczących kolejność i układ argumentów, jak wartość zwracana jest przekazywany, jakie rejestrów są używane dla argumentów i stosu jest wyczyszczone.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentującą numer, kolejność i typy parametrów dla konstruktora, aby uzyskać.  - lub - pustą tablicę typu <see cref="T:System.Type" /> (to znaczy wpisz typów [] = nowe Type[0]) można pobrać konstruktora, który nie przyjmuje żadnych parametrów.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiadającego mu elementu w <c>typy</c> tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Wyszukuje konstruktora, którego parametry są zgodne określone typy argumentów i Modyfikatory korzystanie z określonymi ograniczeniami wiązania i określonej konwencji wywoływania.</summary>
        <returns>Obiekt reprezentujący Konstruktor, który spełnia określonych wymagań, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że nie może przetwarzać domyślnego integratora <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> klasa umożliwiająca zapisanie integratora niestandardowej, która przetwarzać `modifiers`. `ParameterModifier` jest używana tylko podczas wywoływania metody za pomocą międzyoperacyjności COM i obsługiwane są tylko parametry, które są przekazywane przez odwołanie.  
  
 Jeśli istnieje dopasowanie dokładne, `binder` podejmie próbę wymuszone typów parametrów określonych w `types` tablicy, aby wybrać dopasowania. Jeśli `binder` jest w stanie wybierz dopasowania, a następnie `null` jest zwracany.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowanie konstruktora, która do wyszukiwania:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` aby można było pobrać typ zwracany.  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić konstruktorów publicznych.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić konstruktorów niepublicznego (to znaczy konstruktorów prywatnych, wewnętrznych i chronionych).  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Aby uzyskać inicjatora — klasa (.cctor) za pomocą tej metody, należy określić <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic). Można również uzyskać za pomocą inicjatora klasy <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 W poniższej tabeli przedstawiono elementy członkowskie klasy podstawowej zwracanych przez `Get` metody, gdy w czasie wykonywania odbicia typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.ConstructorInfo> z parametrami typu zastępuje argumenty odpowiedniego typu. Jeśli bieżący <xref:System.Type> reprezentuje typ parametru w definicji typu ogólnego lub metody ogólnej, ta metoda zawsze zwraca `null`.  
  
   
  
## Examples  
 Poniższy przykład uzyskuje typ `MyClass1`, pobiera <xref:System.Reflection.ConstructorInfo> obiekt, który odpowiada flagi określone powiązanie i wyświetla sygnatury konstruktora.  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> jest <see langword="null" />.  - lub - jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> jest wielowymiarowy.  - lub - <paramref name="modifiers" /> jest wielowymiarowy.  - lub - <paramref name="types" /> i <paramref name="modifiers" /> nie mają taką samą długość.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić <see langword="null" />.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  - lub - odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Obiekt, który określa zestaw reguł dotyczących kolejność i układ argumentów, jak wartość zwracana jest przekazywany, jakie rejestrów są używane dla argumentów i stosu jest wyczyszczone.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentującą numer, kolejność i typy parametrów dla konstruktora, aby uzyskać.  - lub - pustą tablicę typu <see cref="T:System.Type" /> (to znaczy wpisz typów [] = nowe Type[0]) można pobrać konstruktora, który nie przyjmuje żadnych parametrów.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiadającego mu elementu w <c>typy</c> tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej wyszukuje konstruktora, którego parametry są zgodne określone typy argumentów i modyfikatory, korzystanie z określonymi ograniczeniami wiązania i określonej konwencji wywoływania.</summary>
        <returns>A <see cref="T:System.Reflection.ConstructorInfo" /> obiekt reprezentujący Konstruktor, który spełnia określonych wymagań, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że nie może przetwarzać domyślnego integratora <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> klasa umożliwiająca zapisanie integratora niestandardowej, która przetwarzać `modifiers`. `ParameterModifier` jest używana tylko podczas wywoływania metody za pomocą międzyoperacyjności COM i obsługiwane są tylko parametry, które są przekazywane przez odwołanie.  
  
 Jeśli istnieje dopasowanie dokładne, `binder` podejmie próbę wymuszone typów parametrów określonych w `types` tablicy, aby wybrać dopasowania. Jeśli `binder` jest w stanie wybierz dopasowania, a następnie `null` jest zwracany.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowanie konstruktora, która do wyszukiwania:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` aby można było pobrać typ zwracany.  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić konstruktorów publicznych.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić konstruktorów niepublicznego (to znaczy konstruktorów prywatnych, wewnętrznych i chronionych).  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Ta metoda implementuje <xref:System.Type.GetConstructor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> jest <see langword="null" />.  - lub - jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> jest wielowymiarowy.  - lub - <paramref name="modifiers" /> jest wielowymiarowy.  - lub - <paramref name="types" /> i <paramref name="modifiers" /> nie mają taką samą długość.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący typ <see cref="T:System.Reflection.Emit.TypeBuilder" /> lub <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera konstruktorów bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie konstruktory publiczne zdefiniowane dla bieżącego <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Reflection.ConstructorInfo" /> obiekty reprezentujące wszystkich zdefiniowanych dla bieżącej konstruktorów wystąpienia publicznego <see cref="T:System.Type" />, z wyjątkiem inicjatora typu (w konstruktorze statycznym). Jeśli ma konstruktorów wystąpienia publicznego są zdefiniowane dla bieżącego <see cref="T:System.Type" />, lub, jeśli bieżący <see cref="T:System.Type" /> reprezentuje typ parametru w definicji typu ogólnego lub metody ogólnej pustą tablicę typu <see cref="T:System.Reflection.ConstructorInfo" /> jest zwracany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A> Metoda nie zwraca konstruktorów w określonej kolejności, takie jak deklaracja kolejności. Kod nie zależy od kolejności, w której są zwracane konstruktorów, ponieważ różniącą się kolejności.  
  
 W poniższej tabeli przedstawiono elementy członkowskie klasy podstawowej zwracanych przez `Get` metody, gdy w czasie wykonywania odbicia typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Przeciążenie tej metody wymaga <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> przeciążenie metody z <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> w języku Visual Basic). Nie będzie zawierał inicjatory klasy (.cctor). Aby znaleźć inicjatory klasy, użyj przeciążenia, które przyjmuje <xref:System.Reflection.BindingFlags>i określ <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic). Można również uzyskać za pomocą inicjatora klasy <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.ConstructorInfo> obiektów z parametrami typu zastępuje argumenty odpowiedniego typu. Na przykład jeśli klasa `C<T>` ma Konstruktor `C(T t1)` (`Sub New(ByVal t1 As T)` w języku Visual Basic), wywoływania <xref:System.Type.GetConstructors%2A> na `C<int>` zwraca <xref:System.Reflection.ConstructorInfo> reprezentujący `C(int t1)` w języku C# (`Sub New(ByVal t1 As Integer)` w języku Visual Basic).  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, <xref:System.Type.GetConstructors%2A> metoda zwraca pustą tablicę.  
  
   
  
## Examples  
 Ten przykład przedstawia dane wyjściowe <xref:System.Type.GetConstructors%2A> przeciążenia z klasy, która ma dwa konstruktory wystąpień i jeden konstruktor statyczny.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 Wynik tego kodu jest:  
  
 2  
  
 False  
  
 False  
  
 Ponieważ <xref:System.Type.GetConstructors> przeciążenia używa tylko <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> i <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, Konstruktor statyczny nie jest traktowane przez `for` wyrażenie ani oceniane przez `IsStatic`.  
  
 Aby znaleźć konstruktory statyczne, użyj <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> przeciążenia i przekaż kombinacja (logiczne `OR`) z <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, jak pokazano w poniższym przykładzie:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Wynik jest teraz:  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wyszukuje konstruktorów zdefiniowanych dla bieżącej <see cref="T:System.Type" />, przy użyciu określonego <see langword="BindingFlags" />.</summary>
        <returns>Tablica <see cref="T:System.Reflection.ConstructorInfo" /> obiekty reprezentujące wszystkich konstruktorów zdefiniowanych dla bieżącej <see cref="T:System.Type" /> zgodnego z określonymi ograniczeniami wiązania, jeśli jest on zdefiniowany w tym inicjatora typu. Zwraca pustą tablicę typu <see cref="T:System.Reflection.ConstructorInfo" /> jeśli ma konstruktorów zdefiniowanych dla bieżącej <see cref="T:System.Type" />, jeśli żadna z konstruktorów zdefiniowanych nie zgadza się z ograniczeniami wiązania lub bieżący <see cref="T:System.Type" /> reprezentuje parametr w definicji typu typu ogólnego lub metody ogólnej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A> Metoda nie zwraca konstruktorów w określonej kolejności, takie jak deklaracja kolejności. Kod nie zależy od kolejności, w której są zwracane konstruktorów, ponieważ różniącą się kolejności.  
  
 `bindingAttr` może służyć do określenia, czy mają być zwracane tylko konstruktorów publicznych lub konstruktorów publicznych i niepublicznych.  
  
 Jeśli istnieje dopasowanie dokładne, `binder` podejmie próbę wymuszone typów parametrów określonych w `types` tablicy, aby wybrać dopasowania. Jeśli `binder` jest w stanie wybierz dopasowania, a następnie `null` jest zwracany.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowanie konstruktora, która do wyszukiwania:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` aby można było pobrać typ zwracany.  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić konstruktorów publicznych.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić konstruktorów niepublicznego (to znaczy konstruktorów prywatnych, wewnętrznych i chronionych). Konstruktory klas podstawowych nie są zwracane.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Aby uzyskać przy użyciu tego przeciążenia metody inicjatora — klasa (.cctor), należy określić <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic). Można również uzyskać za pomocą inicjatora klasy <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.ConstructorInfo> obiektów z parametrami typu zastępuje argumenty odpowiedniego typu. Na przykład jeśli klasa `C<T>` ma Konstruktor `C(T t1)` (`Sub New(ByVal t1 As T)` w języku Visual Basic), wywoływania <xref:System.Type.GetConstructors%2A> na `C<int>` zwraca <xref:System.Reflection.ConstructorInfo> reprezentujący `C(int t1)` w języku C# (`Sub New(ByVal t1 As Integer)` w języku Visual Basic).  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, <xref:System.Type.GetConstructors%2A> metoda zwraca pustą tablicę.  
  
   
  
## Examples  
 Ten przykład przedstawia dane wyjściowe <xref:System.Type.GetConstructors> przeciążenia z klasy, która ma dwa konstruktory wystąpień i jeden konstruktor statyczny.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 Wynik tego kodu jest:  
  
 2  
  
 False  
  
 False  
  
 Ponieważ <xref:System.Type.GetConstructors%2A> przeciążenia używa tylko <xref:System.Reflection.BindingFlags.Public> i <xref:System.Reflection.BindingFlags.Instance>, Konstruktor statyczny nie jest traktowane przez `for` wyrażenie ani oceniane przez `IsStatic`.  
  
 Aby znaleźć konstruktory statyczne, użyj <xref:System.Type.GetConstructors%2A> przeciążenia i przekaż go kombinacja (lub logicznej) <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, jak pokazano w poniższym przykładzie:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Wynik jest teraz:  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyszukiwanie elementów członkowskich zdefiniowanych dla bieżącej <see cref="T:System.Type" /> którego <see cref="T:System.Reflection.DefaultMemberAttribute" /> jest ustawiona.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące domyślne wszystkich członków bieżącej <see cref="T:System.Type" />.  - lub - pustą tablicę typu <see cref="T:System.Reflection.MemberInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma domyślne elementy członkowskie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetDefaultMembers%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takich jak alfabetycznej lub deklaracji kolejności. Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.  
  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
 Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.  
  
 W poniższej tabeli przedstawiono elementy członkowskie klasy podstawowej zwracanych przez `Get` metody, gdy w czasie wykonywania odbicia typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.MemberInfo> obiektów z parametrami typu zastępuje argumenty odpowiedniego typu. Na przykład jeśli klasa `C<T>` ma właściwość `P` zwracającą `T`, wywoływania <xref:System.Type.GetDefaultMembers%2A> na `C<int>` zwraca `int P` w języku C# (`Property P As Integer` w języku Visual Basic).  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje ograniczenie klasy elementów członkowskich lub elementów członkowskich <xref:System.Object> przypadku bez ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład pobiera informacje domyślny element członkowski z `MyClass` i wyświetla domyślne elementy członkowskie.  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po przesłonięciu w klasie pochodnej zwraca <see cref="T:System.Type" /> obiektu ujęty lub odwołuje się do bieżącego typu tablicy, wskaźnik lub odwołanie.</summary>
        <returns>
          <see cref="T:System.Type" /> Obiektu ujęty lub odwołuje się do bieżącego tablicy, wskaźnika lub typ referencyjny lub <see langword="null" /> Jeśli bieżące <see cref="T:System.Type" /> nie jest tablicą ani wskaźnikiem, lub nie jest przekazywana przez odwołanie lub reprezentuje typu ogólnego lub parametrem typu w Definicja typu ogólnego lub metody ogólnej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca `null` dla <xref:System.Array> klasy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, przy użyciu `GetElementType` metody.  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Wartość, której nazwa ma być pobrana.</param>
        <summary>Zwraca nazwę stała, która została określona wartość dla bieżącego typu wyliczenia.</summary>
        <returns>Nazwa elementu członkowskiego bieżącego typu wyliczenia, która ma określoną wartość, lub <see langword="null" /> przypadku nieznalezienia takie stałej.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Bieżący typ nie jest wyliczeniem.  - lub - <paramref name="value" /> nie jest ani bieżącego typu ani nie ma ten sam typ podstawowy jako bieżącego typu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca nazwy elementów członkowskich bieżącego typu wyliczenia.</summary>
        <returns>Tablica zawierająca nazwy elementów członkowskich wyliczenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy tablicy zwracanej wartości są sortowane według wartości binarne (to znaczy wartości bez znaku) stałych wyliczeniowych. Jeśli tablica zawiera wyliczone stałe z tą samą wartością, kolejność odpowiadających im nazw jest nieokreślony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżący typ nie jest wyliczeniem.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca typ podstawowy bieżącego typu wyliczenia.</summary>
        <returns>Typ bazowy w bieżącym wyliczeniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie jest podstawowy typ wyliczenia w języku C# i Visual Basic <xref:System.Int32>. Można określić innych typów całkowitych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżący typ nie jest wyliczeniem.  - lub - typ wyliczenia jest nieprawidłowy, ponieważ zawiera on więcej niż jedno pole wystąpienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę wartości stałych do bieżącego typu wyliczenia.</summary>
        <returns>Tablica, która zawiera wartości. Elementy tablicy są sortowane według wartości binarne (to znaczy wartości bez znaku) stałe wyliczenia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Bieżący typ nie jest wyliczeniem.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określonego zdarzenia zadeklarowane lub dziedziczone przez bieżący <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę zdarzenia, które jest zadeklarowany lub dziedziczone przez bieżący <see cref="T:System.Type" />.</param>
        <summary>Zwraca <see cref="T:System.Reflection.EventInfo" /> obiekt reprezentujący określonego zdarzenia publicznego.</summary>
        <returns>Obiekt reprezentujący określonego publicznego zdarzenia, które jest zadeklarowany lub dziedziczone przez bieżący <see cref="T:System.Type" />, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenie jest uważane za publiczne odbicie, jeżeli ma co najmniej jedną metodę lub metodę dostępu, która jest publiczna. W przeciwnym razie zdarzenia jest uznawane za prywatne, i musi być <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic połączyć wartości przy użyciu `Or`) go.  
  
 Wyszukiwanie `name` jest rozróżniana wielkość liter. Wyszukiwanie obejmuje zdarzenia wystąpienia publicznego statyczny i publiczny.  
  
 W poniższej tabeli przedstawiono elementy członkowskie klasy podstawowej zwracanych przez `Get` metody, gdy w czasie wykonywania odbicia typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.EventInfo> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda przeszukuje zdarzenia ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Reflection.EventInfo> obiektu i pobiera zdarzenia dla klasy przycisk określonego zdarzenia.  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę zdarzenia, które jest zadeklarowany lub dziedziczone przez bieżący <see cref="T:System.Type" />.</param>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić <see langword="null" />.</param>
        <summary>Po przesłonięciu w klasie pochodnej zwraca <see cref="T:System.Reflection.EventInfo" /> obiekt reprezentujący określonego zdarzenia, korzystanie z określonymi ograniczeniami wiązania.</summary>
        <returns>Obiekt reprezentujący określonego zdarzenia, które jest zadeklarowany lub dziedziczone przez bieżący <see cref="T:System.Type" />, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania zdarzeń do wyszukiwania:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` aby można było pobrać typ zwracany.  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić zdarzenia publiczne.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić niepublicznych zdarzenia (to znaczy prywatnych, wewnętrznych i chronionych zdarzenia).  
  
-   Określ `BindingFlags.FlattenHierarchy` uwzględnienie `public` i `protected` statycznych elementów członkowskich w hierarchii; `private` statycznych elementów członkowskich w klasach dziedziczonych nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikator można zmienić, jak działa wyszukiwanie:  
  
-   `BindingFlags.IgnoreCase` ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko zdarzenia, które są zadeklarowane w <xref:System.Type>, nie zdarzenia, które zostały odziedziczone po prostu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Zdarzenie jest uważane za publiczne odbicie, jeżeli ma co najmniej jedną metodę lub metodę dostępu, która jest publiczna. W przeciwnym razie zdarzenia jest uznawane za prywatne, i musi być <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic połączyć wartości przy użyciu `Or`) go.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.EventInfo> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda przeszukuje zdarzenia ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> metody do wyszukiwania typu publiczne lub niepubliczne zdarzenia o nazwie "Kliknij przycisk" nie będący `static` (`Shared` w języku Visual Basic).  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera zdarzenia, które są zadeklarowane lub dziedziczone przez bieżący <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie publiczne zdarzenia, które są zadeklarowane lub dziedziczone przez bieżący <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Reflection.EventInfo" /> obiekty reprezentujące wszystkie zdarzenia publiczne, które są zadeklarowane lub dziedziczone przez bieżący <see cref="T:System.Type" />.  - lub - pustą tablicę typu <see cref="T:System.Reflection.EventInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma zdarzenia publiczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenie jest uważane za publiczne odbicie, jeżeli ma co najmniej jedną metodę lub metodę dostępu, która jest publiczna. W przeciwnym razie zdarzenia jest uznawane za prywatne, i musi być <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic połączyć wartości przy użyciu `Or`) go.  
  
 <xref:System.Type.GetEvents%2A> — Metoda nie zwraca zdarzeń w określonej kolejności, takich jak alfabetycznej lub deklaracji kolejności. Kod nie zależy od kolejności, w której zdarzenia są zwracane, ponieważ różniącą się kolejności.  
  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
 W poniższej tabeli przedstawiono elementy członkowskie klasy podstawowej zwracanych przez `Get` metody, gdy w czasie wykonywania odbicia typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.EventInfo> obiektów z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda przeszukuje zdarzenia ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład pobiera tablicę <xref:System.Reflection.EventInfo> obiektów, pobiera wszystkie zdarzenia dla `Button` klasy, a następnie wyświetla nazwy zdarzenia. Aby skompilować przykład Visual Basic, należy użyć następującego polecenia:  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wyszukuje zdarzenia, które są zadeklarowane lub dziedziczone przez bieżący <see cref="T:System.Type" />, korzystanie z określonymi ograniczeniami wiązania.</summary>
        <returns>Tablica <see cref="T:System.Reflection.EventInfo" /> obiekty reprezentujące wszystkie zdarzenia, które są zadeklarowane lub dziedziczone przez bieżący <see cref="T:System.Type" /> zgodnego z określonymi ograniczeniami wiązania.  - lub - pustą tablicę typu <see cref="T:System.Reflection.EventInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma zdarzenia, lub jeśli brak zdarzeń są zgodne z ograniczeniami wiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetEvents%2A> — Metoda nie zwraca zdarzeń w określonej kolejności, takich jak alfabetycznej lub deklaracji kolejności. Kod nie zależy od kolejności, w której zdarzenia są zwracane, ponieważ różniącą się kolejności.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania zdarzeń do wyszukiwania:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` aby można było pobrać typ zwracany.  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić zdarzenia publiczne.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić niepublicznych zdarzenia (to znaczy prywatnych, wewnętrznych i chronionych zdarzenia). Tylko chronione i zwracane są wewnętrzne zdarzenia na klas podstawowych; prywatne zdarzeń na klas podstawowych nie są zwracane.  
  
-   Określ `BindingFlags.FlattenHierarchy` uwzględnienie `public` i `protected` statycznych elementów członkowskich w hierarchii; `private` statycznych elementów członkowskich w klasach dziedziczonych nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikator można zmienić, jak działa wyszukiwanie:  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko zdarzenia, które są zadeklarowane w <xref:System.Type>, nie zdarzenia, które zostały odziedziczone po prostu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Zdarzenie jest uważane za publiczne odbicie, jeżeli ma co najmniej jedną metodę lub metodę dostępu, która jest publiczna. W przeciwnym razie zdarzenia jest uznawane za prywatne, i musi być <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic połączyć wartości przy użyciu `Or`) go.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.EventInfo> obiektów z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda przeszukuje zdarzenia ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład pobiera tablicę <xref:System.Reflection.EventInfo> obiektów spełniających określone powiązanie flagi, pobiera wszystkie zdarzenia dla `Button` klasy, a następnie wyświetla nazwy zdarzenia. Aby skompilować przykład Visual Basic, należy użyć następującego polecenia:  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określonego pola bieżącej <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę pola danych, które ma być pobrana.</param>
        <summary>Wyszukuje pole publiczne o określonej nazwie.</summary>
        <returns>Obiekt reprezentujący pole publiczne o określonej nazwie, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukiwanie `name` jest rozróżniana wielkość liter. Wyszukiwanie uwzględnia publiczne statyczne i publiczne pola wystąpień.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.FieldInfo> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda przeszukuje pola ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład pobiera `Type` obiektu dla określonej klasy, uzyskuje <xref:System.Reflection.FieldInfo> obiektu dla pola i wyświetla wartość pola.  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">To <see cref="T:System.Type" /> obiekt jest <see cref="T:System.Reflection.Emit.TypeBuilder" /> którego <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> — metoda nie została jeszcze wywołana.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę pola danych, które ma być pobrana.</param>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić <see langword="null" />.</param>
        <summary>Wyszukuje określonego pola, używając z określonymi ograniczeniami wiązania.</summary>
        <returns>Obiekt reprezentujący pola, które spełnia określonych wymagań, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono elementy członkowskie klasy podstawowej zwracanych przez `Get` metody, gdy w czasie wykonywania odbicia typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania pól do wyszukiwania:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` aby można było pobrać typ zwracany.  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić pola publiczne.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić niepubliczne pola (to znaczy prywatnych, wewnętrznych i chronionych).  
  
-   Określ `BindingFlags.FlattenHierarchy` uwzględnienie `public` i `protected` statycznych elementów członkowskich w hierarchii; `private` statycznych elementów członkowskich w klasach dziedziczonych nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikator można zmienić, jak działa wyszukiwanie:  
  
-   `BindingFlags.IgnoreCase` ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko pola zadeklarowana w <xref:System.Type>, nie pola, które zostały odziedziczone po prostu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.FieldInfo> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda przeszukuje pola ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład pobiera `Type` obiektu dla określonej klasy, uzyskuje <xref:System.Reflection.FieldInfo> obiektu pola, które odpowiada flagi określone powiązanie i wyświetla wartość pola.  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera pola bieżącej <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie pola publiczne bieżącego <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Reflection.FieldInfo" /> obiektów reprezentujących pola publiczne zdefiniowane dla bieżącego <see cref="T:System.Type" />.  - lub - pustą tablicę typu <see cref="T:System.Reflection.FieldInfo" />, jeśli nie ma publicznego pól zdefiniowanych dla bieżącej <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A> Metoda nie zwraca pola w określonej kolejności, takich jak alfabetycznej lub deklaracji kolejności. Kod nie zależy od kolejności, w której są zwracane pól, ponieważ różniącą się kolejności.  
  
 W poniższej tabeli przedstawiono elementy członkowskie klasy podstawowej zwracanych przez `Get` metody, gdy w czasie wykonywania odbicia typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.FieldInfo> obiektów z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda przeszukuje pola publiczne ograniczenia klasy.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono użycie `GetFields()` metody.  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wyszukuje pól zdefiniowanych dla bieżącej <see cref="T:System.Type" />, korzystanie z określonymi ograniczeniami wiązania.</summary>
        <returns>Tablica <see cref="T:System.Reflection.FieldInfo" /> obiekty reprezentujące wszystkich pól zdefiniowanych dla bieżącej <see cref="T:System.Type" /> zgodnego z określonymi ograniczeniami wiązania.  - lub - pustą tablicę typu <see cref="T:System.Reflection.FieldInfo" />, jeśli nie ma pól zdefiniowanych dla bieżącej <see cref="T:System.Type" />, lub jeśli żadna z określonych pól nie zgadza się z ograniczeniami wiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A> Metoda nie zwraca pola w określonej kolejności, takich jak alfabetycznej lub deklaracji kolejności. Kod nie zależy od kolejności, w której są zwracane pól, ponieważ różniącą się kolejności.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania pól do wyszukiwania:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` aby można było pobrać typ zwracany.  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić pola publiczne.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić niepubliczne pola (to znaczy prywatnych, wewnętrznych i chronionych). Tylko chronione i zwracane są wewnętrzne pola klas podstawowych; prywatne pola klas podstawowych nie są zwracane.  
  
-   Określ `BindingFlags.FlattenHierarchy` uwzględnienie `public` i `protected` statycznych elementów członkowskich w hierarchii; `private` statycznych elementów członkowskich w klasach dziedziczonych nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikator można zmienić, jak działa wyszukiwanie:  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko pola zadeklarowana w <xref:System.Type>, nie pola, które zostały odziedziczone po prostu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.FieldInfo> obiektów z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda przeszukuje pola publiczne ograniczenia klasy.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono użycie `GetFields(BindingFlags)` metody.  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę <see cref="T:System.Type" /> obiektów, które reprezentują argumentów typu ogólnego typu zamknięte lub parametrów typu w definicji typu ogólnego.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiektów, które reprezentują argumentów typu ogólnego typu. Zwraca pustą tablicę, jeśli bieżący typ nie jest typem ogólnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy tablicy są zwracane w kolejności, w którym są wyświetlane na liście argumentów typu dla typu ogólnego.  
  
-   W przypadku bieżącego typu zamkniętego skonstruowanego typu (oznacza to, <xref:System.Type.ContainsGenericParameters%2A> zwraca `false`), tablica zwrócona przez <xref:System.Type.GetGenericArguments%2A> metoda zawiera typy, które zostały przypisane do parametrów typu ogólnego w definicji typu ogólnego .  
  
-   Jeśli typ bieżącego jest definicją typu ogólnego, tablica zawiera parametry typu.  
  
-   Jeśli bieżący typ jest typem otwartym skonstruowane (oznacza to, <xref:System.Type.ContainsGenericParameters%2A> zwraca `true`), w których określonych typów nie zostały przypisane do wszystkich parametrów typu i parametrów typu w otaczającej ogólnego typach lub metodach, tablica zawiera typy i parametrów typu. Użyj <xref:System.Type.IsGenericParameter%2A> właściwości, aby wiedzieli, od siebie. Do pokazania w tym scenariuszu, zobacz przykład kodu <xref:System.Type.ContainsGenericParameters%2A> właściwości.  
  
 Lista niezmiennej warunki terminów używanych w ogólnym odbicia, zobacz <xref:System.Type.IsGenericType%2A> właściwości uwagi.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Type.GetGenericArguments%2A> metodę w celu wyświetlenia argumenty typu utworzony typ i parametry typu jego definicji typu ogólnego.  
  
 Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Type.IsGenericTypeDefinition%2A> właściwości. Zobacz przykład większych przykładowe dane wyjściowe.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej. Klasa pochodna musi zapewniać implementację.</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę <see cref="T:System.Type" /> obiekty reprezentujące ograniczenia dotyczące bieżącego ogólnego typu parametru.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiekty reprezentujące ograniczenia dotyczące bieżącego ogólnego typu parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy ograniczenia parametru typu ogólnego jest wyrażony jako <xref:System.Type> obiektu. Użyj <xref:System.Type.IsClass%2A> właściwości w celu określenia, czy ograniczenie jest ograniczenie klasy podstawowej; Jeśli właściwość zwraca `false`, ograniczenie jest ograniczeniem interfejsu. Jeśli parametr typu bez ograniczenia klasy i nie ograniczeń interfejsu, zwracana jest pusta tablica.  
  
 Lista niezmiennej warunki terminów używanych w ogólnym odbicia, zobacz <xref:System.Type.IsGenericType%2A> właściwości uwagi.  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje typu ogólnego `Test` z dwoma parametrami typu, które mają różne ograniczenia. Gdy program jest wykonywana, ograniczenia są sprawdzane przy użyciu <xref:System.Type.GenericParameterAttributes%2A> właściwości i <xref:System.Type.GetGenericParameterConstraints%2A> metody.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący <see cref="T:System.Type" /> obiektu nie jest parametrem typu ogólnego. Oznacza to <see cref="P:System.Type.IsGenericParameter" /> zwraca właściwość <see langword="false" />.</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Type" /> obiekt, który reprezentuje definicji typu ogólnego, z którego można skonstruować bieżącego typu ogólnego.</summary>
        <returns>A <see cref="T:System.Type" /> obiekt reprezentujący typu ogólnego, z którego można skonstruować bieżącego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definicji typu ogólnego jest szablonem, z którego można skonstruować innych typów. Na przykład z definicji typu ogólnego `G<T>` (wyrażony w języku C# składni; `G(Of T)` w języku Visual Basic lub `generic <typename T> ref class G` w języku C++) można utworzyć i utworzenia wystąpienia typu `G<int>` (`G(Of Integer)` w języku Visual Basic). Podane <xref:System.Type> typu skonstruowany obiekt reprezentujący to <xref:System.Type.GetGenericTypeDefinition%2A> metoda zwraca definicji typu ogólnego.  
  
 Jeśli dwa typy utworzone są tworzone na podstawie tej samej definicji typu ogólnego, używając te same argumenty typu <xref:System.Type.GetGenericTypeDefinition%2A> metoda zwraca takie same <xref:System.Type> obiektu dla obu typów.  
  
 Wywołanie <xref:System.Type.GetGenericTypeDefinition%2A> metoda <xref:System.Type> obiekt, który reprezentuje już definicji typu ogólnego, zwraca bieżącą <xref:System.Type>.  
  
> [!IMPORTANT]
>  Tablica typów ogólnych nie jest samego ogólnego. W kodzie języka C# `A<int>[] v;` lub kod Visual Basic `Dim v() As A(Of Integer)`, typ zmiennej `v` nie jest rodzajowa. Użyj <xref:System.Type.IsGenericType%2A> do ustalenia, czy typ jest rodzajowy przed wywołaniem <xref:System.Type.GetGenericTypeDefinition%2A>.  
  
 Lista niezmiennej warunki terminów używanych w ogólnym odbicia, zobacz <xref:System.Type.IsGenericType%2A> właściwości uwagi.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy wystąpienia typu utworzone przy użyciu utworzenie zwykłej wystąpienia, a następnie używa <xref:System.Type.GetType%2A> i <xref:System.Type.GetGenericTypeDefinition%2A> metody do pobierania utworzony typ i definicji typu ogólnego. W tym przykładzie użyto ogólnego <xref:System.Collections.Generic.Dictionary%602> typu; reprezentuje skonstruowanego typu <xref:System.Collections.Generic.Dictionary%602> z `Test` obiektów z kluczy będących ciągami.  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący typ nie jest typem ogólnym.  Oznacza to <see cref="P:System.Type.IsGenericType" /> zwraca <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej. Klasa pochodna musi zapewniać implementację.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego wystąpienia.</summary>
        <returns>Kod skrótu dla tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono skrótu `System.Windows.Forms.Button` klasy.  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określonego interfejsu zaimplementowano lub dziedziczone przez bieżący <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę interfejsu do pobrania. Interfejsy ogólne jest to nazwa zniekształcona.</param>
        <summary>Wyszukuje interfejsu o określonej nazwie.</summary>
        <returns>Obiekt reprezentujący interfejsu o określonej nazwie zaimplementowano lub dziedziczone przez bieżący <see cref="T:System.Type" />, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukiwanie `name` jest rozróżniana wielkość liter.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Type> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje ograniczeń interfejsu i wszelkie interfejsy dziedziczone z ograniczeniami klasy lub interfejsu.  
  
> [!NOTE]
>  Dla ogólnych interfejsów `name` parametru jest nazwa zniekształcona, kończąc akcent (\`) i liczba parametrów typu. Dotyczy to zarówno definicje interfejs ogólny, jak i skonstruowane interfejsach. Na przykład, aby znaleźć `IExample<T>` (`IExample(Of T)` w języku Visual Basic) lub `IExample<string>` (`IExample(Of String)` w języku Visual Basic), wyszukaj ``"IExample`1"``.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Type.GetInterface%28System.String%29> metodę wyszukiwania <xref:System.Collections.Hashtable> klasy dla <xref:System.Runtime.Serialization.IDeserializationCallback> interfejsu i listy metod interfejsu.  
  
 Przykład kodu pokazuje, również <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> przeciążenie metody i <xref:System.Type.GetInterfaceMap%2A> metody.  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Bieżący <see cref="T:System.Type" /> reprezentuje typ, który implementuje ten interfejs ogólny z argumentami innego typu.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę interfejsu do pobrania. Interfejsy ogólne jest to nazwa zniekształcona.</param>
        <param name="ignoreCase">
          <see langword="true" /> ignorowanie wielkości liter w tej części <c>nazwa</c> , który określa nazwę prostego interfejsu (element, który określa przestrzeń nazw musi być poprawnie z uwzględnieniem wielkości liter).  - lub - <see langword="false" /> Aby wykonać wyszukiwanie z uwzględnieniem wielkości liter dla wszystkich części <c>nazwa</c>.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej umożliwia wyszukiwanie określonego interfejsu, określająca, czy do wyszukiwania bez uwzględniania wielkości liter z nazwą interfejsu.</summary>
        <returns>Obiekt reprezentujący interfejsu o określonej nazwie zaimplementowano lub dziedziczone przez bieżący <see cref="T:System.Type" />, jeśli je znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ignoreCase` Parametr dotyczy tylko nazwę prosty interfejs, a nie do przestrzeni nazw. Część `name` , który określa przestrzeń nazw musi mieć poprawną wielkość lub interfejs nie zostaną znalezione. Na przykład ciąg "System.icomparable" znajdzie <xref:System.IComparable> interfejsu, ale ciąg "system.icomparable" nie ma.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Type> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje ograniczeń interfejsu i wszelkie interfejsy dziedziczone z ograniczeniami klasy lub interfejsu.  
  
> [!NOTE]
>  Dla ogólnych interfejsów `name` parametru jest nazwa zniekształcona, kończąc akcent (\`) i liczba parametrów typu. Dotyczy to zarówno definicje interfejs ogólny, jak i skonstruowane interfejsach. Na przykład, aby znaleźć `IExample<T>` (`IExample(Of T)` w języku Visual Basic) lub `IExample<string>` (`IExample(Of String)` w języku Visual Basic), wyszukaj `"IExample`1"".  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> metodę w celu wyszukiwania bez uwzględniania wielkości liter <xref:System.Collections.Hashtable> klasy dla <xref:System.Collections.IEnumerable> interfejsu.  
  
 Przykład kodu pokazuje, również <xref:System.Type.GetInterface%28System.String%29> przeciążenie metody i <xref:System.Type.GetInterfaceMap%2A> metody.  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Bieżący <see cref="T:System.Type" /> reprezentuje typ, który implementuje ten interfejs ogólny z argumentami innego typu.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">Typ interfejsu, który można pobrać mapowanie.</param>
        <summary>Zwraca interfejs mapowania dla typu określonego interfejsu.</summary>
        <returns>Obiekt reprezentujący mapowania interfejsu <paramref name="interfaceType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mapy interfejsu określa, jak interfejs jest mapowany do rzeczywistego elementów członkowskich klasy, który implementuje ten interfejs.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego typu parametry są zastępowane przez argumentów typu odpowiednie elementy <xref:System.Reflection.InterfaceMapping> zwracane przez tę metodę.  
  
   
  
## Examples  
 Poniższym przykładzie wywołuje <xref:System.Type.GetInterfaceMap%2A> metodę, aby określić sposób <xref:System.IFormatProvider> mapuje interfejsu <xref:System.Globalization.CultureInfo> metod i jak <xref:System.IAppDomainSetup> mapuje interfejsu <xref:System.AppDomainSetup> właściwości. Należy zauważyć, że ponieważ <xref:System.IAppDomainSetup> interfejs definiuje zestaw właściwości zwróconego <xref:System.Reflection.InterfaceMapping> zawiera oddzielny obiekt <xref:System.Reflection.MethodInfo> obiektów get właściwości i metody dostępu set.  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="interfaceType" /> nie jest zaimplementowana przez bieżący typ.  - lub - <paramref name="interfaceType" /> parametr odwołuje się do interfejsu.  - lub - <paramref name="interfaceType" /> jest ogólny interfejs, a bieżący typ jest typem tablicy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="interfaceType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżący <see cref="T:System.Type" /> reprezentuje parametr typu ogólnego; oznacza to, <see cref="P:System.Type.IsGenericParameter" /> jest <see langword="true" />.</exception>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej. Klasa pochodna musi zapewniać implementację.</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wszystkie interfejsy zaimplementowano lub dziedziczone przez bieżący <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiektów reprezentującą wszystkie interfejsy zaimplementowano lub dziedziczone przez bieżący <see cref="T:System.Type" />.  - lub - pustą tablicę typu <see cref="T:System.Type" />, jeśli nie interfejsy są zaimplementowano lub dziedziczone przez bieżące <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetInterfaces%2A> Metoda nie zwraca interfejsów w określonej kolejności, takich jak alfabetycznej lub deklaracji kolejności. Kod nie zależy od kolejności, w której są zwracane interfejsów, ponieważ różniącą się kolejności.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Type> obiektów z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje ograniczeń interfejsu i wszelkie interfejsy dziedziczone z ograniczeniami klasy lub interfejsu.  
  
   
  
## Examples  
 Pobiera typ określonej klasy, wyświetla wszystkich interfejsów, które typ implementuje lub dziedziczy w następującym przykładzie. Aby skompilować przykład Visual Basic, użyj następujących poleceń kompilatora:  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator statyczny jest wywoływany i zgłasza wyjątek.</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określony członków bieżącej <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę publiczne elementy członkowskie, aby uzyskać.</param>
        <summary>Wyszukuje publiczne elementy członkowskie o określonej nazwie.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące publiczne elementy członkowskie o określonej nazwie, jeśli je znaleziono; w przeciwnym razie, pustą tablicę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukiwanie `name` jest rozróżniana wielkość liter. Wyszukiwanie obejmuje elementy członkowskie static i public wystąpienia publicznego.  
  
 Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.  
  
 <xref:System.Type.GetMember%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takich jak alfabetycznej lub deklaracji kolejności. Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.  
  
 Przeciążenie tej metody nie będzie zawierał inicjatory klasy (.cctor). Aby znaleźć inicjatory klasy, użyj przeciążenia, które przyjmuje <xref:System.Reflection.BindingFlags>i określ <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic). Można również uzyskać za pomocą inicjatora klasy <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 W poniższej tabeli przedstawiono elementy członkowskie klasy podstawowej zwracanych przez `Get` metody, gdy w czasie wykonywania odbicia typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.MemberInfo> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje ograniczenie klasy elementów członkowskich lub elementów członkowskich <xref:System.Object> przypadku bez ograniczenia klasy.  
  
> [!NOTE]
>  Metod ogólnych nie dołączaj argumentów typu `name`. Na przykład kod C# `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` mający jeden argument typu ogólnego `int`.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono wszyscy członkowie `String` klasy, które zaczynają się na literę C.  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwy elementów członkowskich do pobrania.</param>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić pustą tablicę.</param>
        <summary>Wyszukuje określony elementy członkowskie przy użyciu z określonymi ograniczeniami wiązania.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące publiczne elementy członkowskie o określonej nazwie, jeśli je znaleziono; w przeciwnym razie, pustą tablicę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
 Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.  
  
 <xref:System.Type.GetMember%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takich jak alfabetycznej lub deklaracji kolejności. Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania członków do wyszukiwania:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` aby można było pobrać typ zwracany.  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić publiczne elementy członkowskie.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić niepublicznych elementów członkowskich (to znaczy prywatnych, wewnętrznych i chronionych elementów członkowskich).  
  
-   Określ `BindingFlags.FlattenHierarchy` uwzględnienie `public` i `protected` statycznych elementów członkowskich w hierarchii; `private` statycznych elementów członkowskich w klasach dziedziczonych nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikator można zmienić, jak działa wyszukiwanie:  
  
-   `BindingFlags.IgnoreCase` ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly` do wyszukiwania tylko do elementów członkowskich zadeklarowana w <xref:System.Type>, nie elementów członkowskich, które zostały odziedziczone po prostu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Można pobrać przy użyciu tego przeciążenia metody inicjatora — klasa (.cctor), należy określić ".cctor" dla `name`, i <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic) dla `bindingAttr`. Można również uzyskać za pomocą inicjatora klasy <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.MemberInfo> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje ograniczenie klasy elementów członkowskich lub elementów członkowskich <xref:System.Object> przypadku bez ograniczenia klasy.  
  
> [!NOTE]
>  Metod ogólnych nie dołączaj argumentów typu `name`. Na przykład kod C# `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` mający jeden argument typu ogólnego `int`.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono wszystkie publiczne statyczne elementy członkowskie `myString` klasy, które zaczynają się na literę C.  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwy elementów członkowskich do pobrania.</param>
        <param name="type">Wartość do wyszukania.</param>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić pustą tablicę.</param>
        <summary>Wyszukuje określony elementów członkowskich typu określonego elementu członkowskiego, korzystanie z określonymi ograniczeniami wiązania.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące publiczne elementy członkowskie o określonej nazwie, jeśli je znaleziono; w przeciwnym razie, pustą tablicę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.  
  
 <xref:System.Type.GetMember%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takich jak alfabetycznej lub deklaracji kolejności. Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania członków do wyszukiwania:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` aby można było pobrać typ zwracany.  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić publiczne elementy członkowskie.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić niepublicznych elementów członkowskich (to znaczy prywatnych, wewnętrznych i chronionych elementów członkowskich).  
  
-   Określ `BindingFlags.FlattenHierarchy` uwzględnienie `public` i `protected` statycznych elementów członkowskich w hierarchii; `private` statycznych elementów członkowskich w klasach dziedziczonych nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikator można zmienić, jak działa wyszukiwanie:  
  
-   `BindingFlags.IgnoreCase` ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly` do wyszukiwania tylko do elementów członkowskich zadeklarowana w <xref:System.Type>, nie elementów członkowskich, które zostały odziedziczone po prostu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Można pobrać przy użyciu tego przeciążenia metody inicjatora — klasa (.cctor), należy określić ".cctor" dla `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> dla `type`, i <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w Visual Basic) dla `bindingAttr`. Można również uzyskać za pomocą inicjatora klasy <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.MemberInfo> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje ograniczenie klasy elementów członkowskich lub elementów członkowskich <xref:System.Object> przypadku bez ograniczenia klasy.  
  
> [!NOTE]
>  Metod ogólnych nie dołączaj argumentów typu `name`. Na przykład kod C# `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` mający jeden argument typu ogólnego `int`.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono wszystkie metody `myString` klasy, które zaczynają się na literę C.  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Klasa pochodna musi zapewniać implementację.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera członków (właściwości, metody pola, zdarzeń i tak dalej) bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie publiczne elementy członkowskie bieżącego <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące wszystkie publiczne elementy członkowskie bieżącego <see cref="T:System.Type" />.  - lub - pustą tablicę typu <see cref="T:System.Reflection.MemberInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma publicznych elementów członkowskich.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.  
  
 <xref:System.Type.GetMembers%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takich jak alfabetycznej lub deklaracji kolejności. Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.  
  
 Przeciążenie tej metody wymaga <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> przeciążenie metody z <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> w języku Visual Basic). Nie będzie zawierał inicjatory klasy (.cctor). Aby znaleźć inicjatory klasy, użyj przeciążenia, które przyjmuje <xref:System.Reflection.BindingFlags>i określ <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic). Można również uzyskać za pomocą inicjatora klasy <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 W poniższej tabeli przedstawiono elementy członkowskie klasy podstawowej zwracanych przez `Get` metody, gdy w czasie wykonywania odbicia typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.MemberInfo> obiektów z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje ograniczenie klasy elementów członkowskich lub elementów członkowskich <xref:System.Object> przypadku bez ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Type.GetMembers> przeciążenie metody, aby zbierać informacje o wszystkich publicznych elementów członkowskich określonej klasy.  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero (<see cref="F:System.Reflection.BindingFlags.Default" />), aby zwrócić pustą tablicę.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wyszukuje elementów członkowskich zdefiniowanych dla bieżącej <see cref="T:System.Type" />, korzystanie z określonymi ograniczeniami wiązania.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiekty reprezentujące wszystkich elementów członkowskich zdefiniowanych dla bieżącej <see cref="T:System.Type" /> zgodnego z określonymi ograniczeniami wiązania.  - lub - pustą tablicę typu <see cref="T:System.Reflection.MemberInfo" />, jeśli dla bieżącej nie zdefiniowano żadnych elementów członkowskich <see cref="T:System.Type" />, lub jeśli żadna z określonych elementów członkowskich nie zgadza się z ograniczeniami wiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.  
  
 <xref:System.Type.GetMembers%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takich jak alfabetycznej lub deklaracji kolejności. Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania członków do wyszukiwania:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` aby można było pobrać typ zwracany.  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić publiczne elementy członkowskie.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić niepublicznych elementów członkowskich (to znaczy prywatnych, wewnętrznych i chronionych elementów członkowskich). Tylko chronione i zwracane są wewnętrzne elementy członkowskie na klas podstawowych; prywatne elementy członkowskie na klas podstawowych nie są zwracane.  
  
-   Określ `BindingFlags.FlattenHierarchy` uwzględnienie `public` i `protected` statycznych elementów członkowskich w hierarchii; `private` statycznych elementów członkowskich w klasach dziedziczonych nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikator można zmienić, jak działa wyszukiwanie:  
  
-   `BindingFlags.DeclaredOnly` do wyszukiwania tylko do elementów członkowskich zadeklarowana w <xref:System.Type>, nie elementów członkowskich, które zostały odziedziczone po prostu.  
  
 Wywołanie tej metody za pomocą tylko `Public` flagi lub tylko `NonPublic` flagi zwróci określone elementy członkowskie i nie wymaga inne flagi.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Aby uzyskać przy użyciu tego przeciążenia metody inicjatora — klasa (.cctor), należy określić <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w języku Visual Basic). Można również uzyskać za pomocą inicjatora klasy <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 Jeśli bieżący T:System.Type reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.MemberInfo> obiektów z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje ograniczenie klasy elementów członkowskich lub elementów członkowskich <xref:System.Object> przypadku bez ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> przeciążenie metody umożliwiają zbieranie informacji o wszystkich elementów członkowskich wystąpienia publicznego określonej klasy.  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określonej metody bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę metody publicznej do pobrania.</param>
        <summary>Wyszukuje metoda publiczna o określonej nazwie.</summary>
        <returns>Obiekt reprezentujący metoda publiczna o określonej nazwie, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukiwanie `name` jest rozróżniana wielkość liter. Wyszukiwanie obejmuje metody wystąpienia publicznego statyczny i publiczny.  
  
 Jeśli metody jest przeciążona i ma więcej niż jednej metody publicznej, <xref:System.Type.GetMethod%28System.String%29> metoda zgłasza <xref:System.Reflection.AmbiguousMatchException> wyjątku. W poniższym przykładzie jest zwracany wyjątek, ponieważ istnieje więcej niż jednego przeciążenia publicznego <xref:System.Int32.ToString%2A?displayProperty=nameWithType> metody.  Z drugiej strony ponieważ `Person.ToString` zamienników metod <xref:System.Object.ToString%2A?displayProperty=nameWithType> i dlatego nie jest przeciążona, <xref:System.Type.GetMethod%28System.String%29> metoda jest w stanie pobrać <xref:System.Reflection.MethodInfo> obiektu.  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 Możesz wybrać jedną z następujących czynności, aby pobrać określonej metody:  
  
-   Wywołania <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> metodę i określić `bindingAttr` argument, który unikatowo identyfikuje metodę. Na przykład, jeśli wyjątek jest zgłaszany, ponieważ typu statycznego oraz przeciążenia wystąpienia, można określić `bindingAttr` argument <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.  
  
-   Wywołania przeciążenia <xref:System.Type.GetMethod%2A> metodę, która obejmuje `types` parametr, który definiuje typy parametrów metody.  
  
-   Wywołanie <xref:System.Type.GetMethods> metoda pobierania tablica zawierająca wszystkie metod publicznych należących do typu. Następnie można przejść go, aby zidentyfikować zduplikowane metody o nazwie `name`.  
  
 Jeśli bieżący T:System.Type reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.MethodInfo> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje metody ograniczenie klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.  
  
> [!NOTE]
>  Metod ogólnych nie dołączaj argumentów typu `name`. Na przykład kod C# `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` mający jeden argument typu ogólnego `int`.  
  
   
  
## Examples  
 Poniższy przykład pobiera metodę o nazwie `MethodA`.  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną metodę o określonej nazwie.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę metody pobierania.</param>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić <see langword="null" />.</param>
        <summary>Wyszukuje określony metodę, przy użyciu z określonymi ograniczeniami wiązania.</summary>
        <returns>Obiekt reprezentujący metodę, która spełnia określonych wymagań, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania metod do wyszukiwania:  
  
-   Należy określić <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> lub <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> aby można było pobrać typ zwracany.  
  
-   Określ <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> aby w wyszukiwaniu uwzględnić metody publiczne.  
  
-   Określ <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> aby w wyszukiwaniu uwzględnić metody niepublicznej (to znaczy metod prywatnych, wewnętrznych i chronionych).  
  
-   Określ <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> uwzględnienie `public` i `protected` statycznych elementów członkowskich w hierarchii; `private` statycznych elementów członkowskich w klasach dziedziczonych nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikator można zmienić, jak działa wyszukiwanie:  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> ignorowanie wielkości liter `name`.  
  
-   <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> Aby wyszukać tylko metody zadeklarowane w <xref:System.Type>, nie metody, które zostały odziedziczone po prostu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Jeśli metody jest przeciążona i więcej niż jednego przeciążenia spełnia określone przez ograniczenia `bindingAttr` argumentu, metoda wygeneruje <xref:System.Reflection.AmbiguousMatchException> wyjątku. W poniższym przykładzie jest zwracany wyjątek, ponieważ:  
  
-   `TestClass` Typ ma dwa wystąpienia publicznego przeciążeń `DisplayValue` metody `DisplayValue(String)` i `DisplayValue(String, Object[])`.  
  
-   `TestClass` Typ ma dwa wystąpienia publicznego przeciążeń `Equals` metody, z których jeden jest odziedziczone <xref:System.Object>: `Equals(TestClass)` i `Equals(Object)`.  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 Możesz wybrać jedną z następujących czynności, aby pobrać określonej metody:  
  
-   Zmień ograniczeniami wiązania. W poprzednim przykładzie próby pobrania wystąpienia publicznego `Equals` pobiera metodę, która jest deklarowana przez typ, a nie odziedziczone pomyślnie `Equals(TestClass)`.  
  
-   Wywołania przeciążenia <xref:System.Type.GetMethod%2A> metodę, która obejmuje `types` parametr, który definiuje typy parametrów metody.  
  
-   Wywołanie <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> metoda pobierania tablicę zawierającą wszystkie metody należące do typu, których atrybuty określone powiązanie. Następnie można przejść go, aby zidentyfikować zduplikowane metody o nazwie `name`. Takie podejście jest zaprezentowana w poprzednim przykładzie obsługa <xref:System.Reflection.AmbiguousMatchException> wyjątku.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.MethodInfo> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje metody ograniczenie klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.  
  
> [!NOTE]
>  Metod ogólnych nie dołączaj argumentów typu `name`. Na przykład kod C# `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` mający jeden argument typu ogólnego `int`.  
  
   
  
## Examples  
 Poniższy przykład pobiera metodę, która odpowiada flagi określonego powiązania.  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną metodę o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę metody publicznej do pobrania.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentującą numer, kolejność i typy parametrów dla metody, aby uzyskać.  - lub - pustą tablicę <see cref="T:System.Type" /> obiektów (zgodnie z <see cref="F:System.Type.EmptyTypes" /> pola) można pobrać metody, która nie przyjmuje żadnych parametrów.</param>
        <summary>Wyszukuje określony publicznej metody, którego parametry są zgodne określone typy argumentów.</summary>
        <returns>Obiekt reprezentujący publicznej metody, której parametry są zgodne określone typy argumentów, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukiwanie `name` jest rozróżniana wielkość liter. Wyszukiwanie obejmuje metody wystąpienia publicznego statyczny i publiczny.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.MethodInfo> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje metody ograniczenie klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.  
  
> [!NOTE]
>  `name` Parametr nie może zawierać argumentów typu. Na przykład kod C# `GetMethod("MyGenericMethod<int>")` wyszukuje metodę o nazwie tekst "`MyGenericMethod<int>`", a nie dla metodę o nazwie `MyGenericMethod` mający jeden argument typu ogólnego `int`. Zamiast tego należy użyć `GetMethod("MyGenericMethod")` z odpowiedni parametr w `types` tablicy.  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie przeciążeń szczególne `MethodA`, określając różne typy argumentów.  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Przykład wymaga `/unsafe` — opcja kompilatora.  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 Poniższy przykład pobiera <xref:System.Reflection.MethodInfo> obiekty reprezentujące `Add` metod typu nieogólnego ( <xref:System.Collections.ArrayList> klasy), otwartym typem ogólnym ( <xref:System.Collections.Generic.List%601> klasy), a zamkniętego typu ogólnego ( `List(Of String)` typu.  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 W przykładzie zdefiniowano `GetAddMethod` metodę, która pobiera odpowiednie <xref:System.Reflection.MethodInfo> obiektu. Aby zapewnić `types` argument otwartym typem ogólnym, wywołuje <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metody. Aby zapewnić `types` argument dla zamkniętego typu ogólnego, pobiera wartość <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Więcej niż jednej metody odnaleziono o określonej nazwie i określone parametry.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  - lub - <paramref name="types" /> jest <see langword="null" />.  - lub - jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> jest wielowymiarowy.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę metody publicznej do pobrania.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentującą numer, kolejność i typy parametrów dla metody, aby uzyskać.  - lub - pustą tablicę <see cref="T:System.Type" /> obiektów (zgodnie z <see cref="F:System.Type.EmptyTypes" /> pola) można pobrać metody, która nie przyjmuje żadnych parametrów.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiadającego mu elementu w <c>typy</c> tablicy. Aby używać tylko podczas wywoływania metody za pomocą modelu COM interop i tylko parametry przekazywane przez odwołanie, są obsługiwane. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Wyszukuje określonej metody publiczny, którego parametry są zgodne modyfikatorów i określone typy argumentów.</summary>
        <returns>Obiekt reprezentujący metodę publiczną, która spełnia określonych wymagań, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że nie może przetwarzać domyślnego integratora <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> klasa umożliwiająca zapisanie integratora niestandardowej, która przetwarzać `modifiers`. `ParameterModifier` jest używana tylko podczas wywoływania metody za pomocą międzyoperacyjności COM i obsługiwane są tylko parametry, które są przekazywane przez odwołanie.  
  
 Wyszukiwanie `name` jest rozróżniana wielkość liter. Wyszukiwanie obejmuje metody wystąpienia publicznego statyczny i publiczny.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący T:System.Type reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.MethodInfo> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje metody ograniczenie klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.  
  
> [!NOTE]
>  Metod ogólnych nie dołączaj argumentów typu `name`. Na przykład kod C# `GetMethod("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` mający jeden argument typu ogólnego `int`. Zamiast tego należy użyć `GetMethod("MyMethod")` z odpowiedni parametr w `types` tablicy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Więcej niż jednej metody odnaleziono o określonej nazwie i określone parametry.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  - lub - <paramref name="types" /> jest <see langword="null" />.  - lub - jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> jest wielowymiarowy.  - lub - <paramref name="modifiers" /> jest wielowymiarowy.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę metody pobierania.</param>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić <see langword="null" />.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  - lub - odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentującą numer, kolejność i typy parametrów dla metody, aby uzyskać.  - lub - pustą tablicę <see cref="T:System.Type" /> obiektów (zgodnie z <see cref="F:System.Type.EmptyTypes" /> pola) można pobrać metody, która nie przyjmuje żadnych parametrów.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiadającego mu elementu w <c>typy</c> tablicy. Aby używać tylko podczas wywoływania metody za pomocą modelu COM interop i tylko parametry przekazywane przez odwołanie, są obsługiwane. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Wyszukuje określonej metody, której parametry są zgodne określone typy argumentów i Modyfikatory korzystanie z określonymi ograniczeniami wiązania.</summary>
        <returns>Obiekt reprezentujący metodę, która spełnia określonych wymagań, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że nie może przetwarzać domyślnego integratora <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> klasa umożliwiająca zapisanie integratora niestandardowej, która przetwarzać `modifiers`. `ParameterModifier` jest używana tylko podczas wywoływania metody za pomocą międzyoperacyjności COM i obsługiwane są tylko parametry, które są przekazywane przez odwołanie.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania metod do wyszukiwania:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` aby można było pobrać typ zwracany.  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić metody publiczne.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić niepubliczne metody (czyli metody prywatnych, wewnętrznych i chronionych).  
  
-   Określ `BindingFlags.FlattenHierarchy` uwzględnienie `public` i `protected` statycznych elementów członkowskich w hierarchii; `private` statycznych elementów członkowskich w klasach dziedziczonych nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikator można zmienić, jak działa wyszukiwanie:  
  
-   `BindingFlags.IgnoreCase` ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko metody zadeklarowane w <xref:System.Type>, nie metody, które zostały odziedziczone po prostu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący T:System.Type reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.MethodInfo> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje metody ograniczenie klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.  
  
> [!NOTE]
>  Metod ogólnych nie dołączaj argumentów typu `name`. Na przykład kod C# `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` mający jeden argument typu ogólnego `int`.  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie przeciążeń szczególne `MethodA`, określając ograniczeniami wiązania oraz różne typy argumentów.  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Przykład wymaga `/unsafe` — opcja kompilatora.  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną metodę o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  - lub - <paramref name="types" /> jest <see langword="null" />.  - lub - jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> jest wielowymiarowy.  - lub - <paramref name="modifiers" /> jest wielowymiarowy.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę metody pobierania.</param>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić <see langword="null" />.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  - lub - odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Obiekt, który określa zestaw reguł dotyczących kolejność i układ argumenty, jak wartość zwracana jest przekazywany, jakie rejestrów są używane dla argumentów i jak wyczyścić stosu.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentującą numer, kolejność i typy parametrów dla metody, aby uzyskać.  - lub - pustą tablicę <see cref="T:System.Type" /> obiektów (zgodnie z <see cref="F:System.Type.EmptyTypes" /> pola) można pobrać metody, która nie przyjmuje żadnych parametrów.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiadającego mu elementu w <c>typy</c> tablicy. Aby używać tylko podczas wywoływania metody za pomocą modelu COM interop i tylko parametry przekazywane przez odwołanie, są obsługiwane. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Wyszukuje określonej metody, której parametry są zgodne określone typy argumentów i Modyfikatory korzystanie z określonymi ograniczeniami wiązania i określonej konwencji wywoływania.</summary>
        <returns>Obiekt reprezentujący metodę, która spełnia określonych wymagań, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że nie może przetwarzać domyślnego integratora <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> klasa umożliwiająca zapisanie integratora niestandardowej, która przetwarzać `modifiers`. `ParameterModifier` jest używana tylko podczas wywoływania metody za pomocą międzyoperacyjności COM i obsługiwane są tylko parametry, które są przekazywane przez odwołanie.  
  
 W poniższej tabeli przedstawiono elementy członkowskie klasy podstawowej zwracanych przez `GetXXX` metody, gdy w czasie wykonywania odbicia typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania metod do wyszukiwania:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` aby można było pobrać typ zwracany.  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić metody publiczne.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić niepubliczne metody (czyli metody prywatnych, wewnętrznych i chronionych).  
  
-   Określ `BindingFlags.FlattenHierarchy` uwzględnienie `public` i `protected` statycznych elementów członkowskich w hierarchii; `private` statycznych elementów członkowskich w klasach dziedziczonych nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikator można zmienić, jak działa wyszukiwanie:  
  
-   `BindingFlags.IgnoreCase` ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko metody zadeklarowane w <xref:System.Type>, nie metody, które zostały odziedziczone po prostu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący T:System.Type reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.MethodInfo> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje metody ograniczenie klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.  
  
> [!NOTE]
>  Metod ogólnych nie dołączaj argumentów typu `name`. Na przykład kod C# `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekst "`MyMethod<int>`", a nie dla metodę o nazwie `MyMethod` mający jeden argument typu ogólnego `int`.  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie przeciążeń szczególne `MethodA`, określając ograniczeniami wiązania, Konwencje wywoływania oraz różne typy argumentów.  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Przykład wymaga `/unsafe` — opcja kompilatora.  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną metodę o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  - lub - <paramref name="types" /> jest <see langword="null" />.  - lub - jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> jest wielowymiarowy.  - lub - <paramref name="modifiers" /> jest wielowymiarowy.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę metody pobierania.</param>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić <see langword="null" />.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  - lub - odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Obiekt, który określa zestaw reguł dotyczących kolejności i układ argumenty, sposób przekazywania wartości zwracanej, jakie rejestrów są używane dla argumentów i jakie procesy czyści stosu.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentującą numer, kolejność i typy parametrów dla metody, aby uzyskać.  - lub - pustą tablicę typu <see cref="T:System.Type" /> (to znaczy wpisz typów [] = nowe Type[0]) można pobrać metody, która nie przyjmuje żadnych parametrów.  - lub - <see langword="null" />. Jeśli <c>typy</c> jest <see langword="null" />, argumenty są niezgodne.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiadającego mu elementu w <c>typy</c> tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej wyszukiwania dla określonej metody, której parametry są zgodne określone typy argumentów i modyfikatory, korzystanie z określonymi ograniczeniami wiązania i określonej konwencji wywoływania.</summary>
        <returns>Obiekt reprezentujący metodę, która spełnia określonych wymagań, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że nie może przetwarzać domyślnego integratora <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> klasa umożliwiająca zapisanie integratora niestandardowej, która przetwarzać `modifiers`. `ParameterModifier` jest używana tylko podczas wywoływania metody za pomocą międzyoperacyjności COM i obsługiwane są tylko parametry, które są przekazywane przez odwołanie.  
  
 Jeśli `types` jest `null`, argumenty są niezgodne.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania metod do wyszukiwania:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` aby można było pobrać typ zwracany.  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić metody publiczne.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić metody niepublicznej (to znaczy metod prywatnych, wewnętrznych i chronionych).  
  
-   Określ `BindingFlags.FlattenHierarchy` uwzględnienie `public` i `protected` statycznych elementów członkowskich w hierarchii; `private` statycznych elementów członkowskich w klasach dziedziczonych nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikator można zmienić, jak działa wyszukiwanie:  
  
-   `BindingFlags.IgnoreCase` ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko metody zadeklarowane w <xref:System.Type>, nie metody, które zostały odziedziczone po prostu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną metodę o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> jest wielowymiarowy.  - lub - <paramref name="modifiers" /> jest wielowymiarowy.  - lub - <paramref name="types" /> i <paramref name="modifiers" /> nie mają taką samą długość.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący typ <see cref="T:System.Reflection.Emit.TypeBuilder" /> lub <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera metody bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie metody publiczne bieżącego <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MethodInfo" /> obiekty reprezentujące metody publiczne zdefiniowane dla bieżącego <see cref="T:System.Type" />.  - lub - pustą tablicę typu <see cref="T:System.Reflection.MethodInfo" />, jeśli nie publicznej metody nie są definiowane dla bieżącego <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetMethods%2A> Metoda nie zwraca metod w określonej kolejności, takich jak alfabetycznej lub deklaracji kolejności. Kod nie zależy od kolejności, w której są zwracane metody, ponieważ różniącą się kolejności.  
  
 Konstruktory nie znajdują się w tablicy zwrócony przez wywołanie tej metody. Wywoływania oddzielnych `GetConstructors()` można pobrać metody konstruktora.  
  
 W poniższej tabeli przedstawiono elementy członkowskie klasy podstawowej zwracanych przez `Get` metody, gdy w czasie wykonywania odbicia typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący T:System.Type reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.MethodInfo> obiektów z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje metody ograniczenie klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wyszukuje metody zdefiniowane dla bieżącego <see cref="T:System.Type" />, korzystanie z określonymi ograniczeniami wiązania.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MethodInfo" /> obiekty reprezentujące wszystkie metody zdefiniowane dla bieżącego <see cref="T:System.Type" /> zgodnego z określonymi ograniczeniami wiązania.  - lub - pustą tablicę typu <see cref="T:System.Reflection.MethodInfo" />, jeśli nie metody nie są definiowane dla bieżącego <see cref="T:System.Type" />, lub jeśli żadna z określonych metod nie zgadza się z ograniczeniami wiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetMethods%2A> Metoda nie zwraca metod w określonej kolejności, takich jak alfabetycznej lub deklaracji kolejności. Kod nie zależy od kolejności, w której są zwracane metody, ponieważ różniącą się kolejności.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania metod do wyszukiwania:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` aby można było pobrać typ zwracany.  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić metody publiczne.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić metody niepublicznej (to znaczy metod prywatnych, wewnętrznych i chronionych). Tylko chronione i wewnętrznych metod klasy podstawowej są zwracane; prywatnych metod klas podstawowych nie są zwracane.  
  
-   Określ `BindingFlags.FlattenHierarchy` uwzględnienie `public` i `protected` statycznych elementów członkowskich w hierarchii; `private` statycznych elementów członkowskich w klasach dziedziczonych nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikator można zmienić, jak działa wyszukiwanie:  
  
-   `BindingFlags.DeclaredOnly` Aby wyszukać tylko metody zadeklarowane w <xref:System.Type>, nie metody, które zostały odziedziczone po prostu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący T:System.Type reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.MethodInfo> obiektów z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje metody ograniczenie klasy lub metody <xref:System.Object> przypadku bez ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę z dwóch metod publicznych i jedną metodę chronionych, tworzy `Type` obiekt odpowiadający `MyTypeClass`, pobiera wszystkie metody publiczne i niepublicznych i wyświetla ich nazwy.  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określonego typu zagnieżdżone w obrębie bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę typu zagnieżdżonego można pobrać.</param>
        <summary>Wyszukuje zagnieżdżonego typu publicznego o określonej nazwie.</summary>
        <returns>Obiekt reprezentujący zagnieżdżonego typu publicznego o określonej nazwie, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukiwanie `name` jest rozróżniana wielkość liter.  
  
 Użyj prosta nazwa klasy zagnieżdżonej dla `name`. Nie można rozwiązać go z nazwą klasy zewnętrzne. Dla klasy ogólnej zagnieżdżone, użyj nazwa zniekształcona — to znaczy dołącza akcent i liczbą argumentów rodzajowych. Na przykład użyć ciągu "wewnętrzny\`1" do pobrania ogólnego zagnieżdżone klasy `Inner<T>` (`Inner(Of T)` w języku Visual Basic). Nie dołączaj specyficzny dla języka składnia parametrów typu.  
  
 W poniższej tabeli przedstawiono elementy członkowskie klasy podstawowej zwracanych przez `Get` metody, gdy w czasie wykonywania odbicia typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda przeszukuje zagnieżdżone typy ograniczenia klasy.  
  
 Jeśli zagnieżdżony jest typ ogólny , metoda ta zwraca jego definicję typu ogólnego. Ta zasada obowiązuje, nawet jeśli otaczający typ ogólny jest skonstruowany jako zamknięty.  
  
> [!NOTE]
>  Jeśli bieżący <xref:System.Type> reprezentuje ogólny typ zdefiniowany w języku C#, Visual Basic lub C++, jego zagnieżdżone typy są wszystkie ogólne, nawet jeśli ich nie może mieć ogólnych parametrów we własnym. To niekoniecznie zagnieżdżonych typów zdefiniowanych w dynamicznych zestawach lub skompilowane z [Ilasm.exe (asembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Aby uzyskać informacje na zagnieżdżone typy ogólne i na utworzenie zagnieżdżonych typów ogólnych z ich definicje typu ogólnego, zobacz <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę typu zagnieżdżonego można pobrać.</param>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej umożliwia wyszukiwanie określonego typu zagnieżdżonego, korzystanie z określonymi ograniczeniami wiązania.</summary>
        <returns>Obiekt reprezentujący typu zagnieżdżonego, który spełnia określonych wymagań, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj prosta nazwa klasy zagnieżdżonej dla `name`. Nie można rozwiązać go z nazwą klasy zewnętrzne. Dla klasy ogólnej zagnieżdżone, użyj nazwa zniekształcona — to znaczy dołącza akcent i liczby parametrów ogólnych. Na przykład użyć ciągu "wewnętrzny\`1" do pobrania ogólnego zagnieżdżone klasy `Inner<T>` (`Inner(Of T)` w języku Visual Basic). Nie dołączaj specyficzny dla języka składnia parametrów typu.  
  
 Następujące <xref:System.Reflection.BindingFlags> filtru flagi może służyć do definiowania, które zagnieżdżone typów, aby w wyszukiwaniu uwzględnić:  
  
-   Należy określić <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> lub <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> uzyskać typ zwracany.  
  
-   Określ <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> aby w wyszukiwaniu uwzględnić zagnieżdżone typy publiczne.  
  
-   Określ <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> aby w wyszukiwaniu uwzględnić niepublicznych zagnieżdżone typy (to znaczy prywatnych, wewnętrznych i chronionych zagnieżdżone typy).  
  
 Ta metoda zwraca zagnieżdżone typy bieżącego typu. Wyszukiwanie nie jest bieżący typ klasy podstawowe. Aby znaleźć typy, które są zagnieżdżone w klasach podstawowych, musi zaprezentuje hierarchii dziedziczenia wywoływania <xref:System.Type.GetNestedType%2A> na każdym poziomie.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> i <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> są ignorowane.  
  
 Wywołanie tej metody za pomocą tylko <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flagi lub tylko <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flagi zwróci określonego zagnieżdżone typy i nie wymaga inne flagi.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda przeszukuje zagnieżdżone typy ograniczenia klasy.  
  
 Jeśli zagnieżdżony jest typ ogólny , metoda ta zwraca jego definicję typu ogólnego. Ta zasada obowiązuje, nawet jeśli otaczający typ ogólny jest skonstruowany jako zamknięty.  
  
> [!NOTE]
>  Jeśli bieżący <xref:System.Type> reprezentuje ogólny typ zdefiniowany w języku C#, Visual Basic lub C++, jego zagnieżdżone typy są wszystkie ogólne, nawet jeśli ich nie może mieć ogólnych parametrów we własnym. To niekoniecznie zagnieżdżonych typów zdefiniowanych w dynamicznych zestawach lub skompilowane z [Ilasm.exe (asembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Aby uzyskać informacje na zagnieżdżone typy ogólne i na utworzenie zagnieżdżonych typów ogólnych z ich definicje typu ogólnego, zobacz <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera typy zagnieżdżone w obrębie bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca zagnieżdżone typy publiczne w bieżącym <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiekty reprezentujące typy publiczne zagnieżdżone w bieżącym <see cref="T:System.Type" /> (wyszukiwanie nie jest cykliczne), lub pusta tablica typu <see cref="T:System.Type" /> Jeśli nie typy publiczne są zagnieżdżone w bieżącym <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetNestedTypes%2A> Metoda nie zwraca typów w określonej kolejności, takich jak alfabetycznej lub deklaracji kolejności. Kod nie zależy od kolejności, w której są zwracane typy, ponieważ różniącą się kolejności.  
  
 Zwracane są tylko typy publiczne bezpośrednio zagnieżdżony w bieżącym typie; Wyszukiwanie nie jest rekursywny.  
  
 W poniższej tabeli przedstawiono elementy członkowskie klasy podstawowej zwracanych przez `Get` metody, gdy w czasie wykonywania odbicia typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda przeszukuje zagnieżdżone typy ograniczenia klasy.  
  
 Jeśli zagnieżdżony jest typ ogólny , metoda ta zwraca jego definicję typu ogólnego. Ta zasada obowiązuje, nawet jeśli otaczający typ ogólny jest skonstruowany jako zamknięty.  
  
> [!NOTE]
>  Jeśli bieżący <xref:System.Type> reprezentuje ogólny typ zdefiniowany w języku C#, Visual Basic lub C++, jego zagnieżdżone typy są wszystkie ogólne, nawet jeśli ich nie może mieć ogólnych parametrów we własnym. To niekoniecznie zagnieżdżonych typów zdefiniowanych w dynamicznych zestawach lub skompilowane z [Ilasm.exe (asembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Aby uzyskać informacje na zagnieżdżone typy ogólne i na utworzenie zagnieżdżonych typów ogólnych z ich definicje typu ogólnego, zobacz <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano klasę zagnieżdżonych i `struct` w `MyClass`, a następnie uzyskuje obiekty zagnieżdżone typy przy użyciu typu `MyClass`.  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wyszukuje typy zagnieżdżone w bieżącym <see cref="T:System.Type" />, korzystanie z określonymi ograniczeniami wiązania.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiekty reprezentujący wszystkie typy zagnieżdżone w bieżącym <see cref="T:System.Type" /> zgodnego z określonymi ograniczeniami wiązania (wyszukiwanie nie jest cykliczne), albo być pustą tablicą typu <see cref="T:System.Type" />, jeśli nie zagnieżdżone są znaleźć typów zgodnych ze ograniczenia powiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukaj typy zagnieżdżone nie jest rekursywny.  
  
 <xref:System.Type.GetNestedTypes%2A> Metoda nie zwraca typów w określonej kolejności, takich jak alfabetycznej lub deklaracji kolejności. Kod nie zależy od kolejności, w której są zwracane typy, ponieważ różniącą się kolejności.  
  
 Następujące <xref:System.Reflection.BindingFlags> filtru flagi może służyć do definiowania, które zagnieżdżone typów, aby w wyszukiwaniu uwzględnić:  
  
-   Należy określić <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> lub <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> uzyskać typ zwracany.  
  
-   Określ <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> aby w wyszukiwaniu uwzględnić zagnieżdżone typy publiczne.  
  
-   Określ <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> aby w wyszukiwaniu uwzględnić niepublicznych zagnieżdżone typy (to znaczy prywatnych, wewnętrznych i chronionych zagnieżdżone typy).  
  
 Ta metoda zwraca zagnieżdżone typy bieżącego typu. Wyszukiwanie nie jest bieżący typ klasy podstawowe. Aby znaleźć typy, które są zagnieżdżone w klasach podstawowych, musi zaprezentuje hierarchii dziedziczenia wywoływania <xref:System.Type.GetNestedTypes%2A> na każdym poziomie.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> i <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> są ignorowane.  
  
 Wywołanie tej metody za pomocą tylko <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flagi lub tylko <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flagi zwróci określonego zagnieżdżone typy i nie wymaga inne flagi.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda przeszukuje zagnieżdżone typy ograniczenia klasy.  
  
 Jeśli zagnieżdżony jest typ ogólny , metoda ta zwraca jego definicję typu ogólnego. Ta zasada obowiązuje, nawet jeśli otaczający typ ogólny jest skonstruowany jako zamknięty.  
  
> [!NOTE]
>  Jeśli bieżący <xref:System.Type> reprezentuje ogólny typ zdefiniowany w języku C#, Visual Basic lub C++, jego zagnieżdżone typy są wszystkie ogólne, nawet jeśli ich nie może mieć ogólnych parametrów we własnym. To niekoniecznie zagnieżdżonych typów zdefiniowanych w dynamicznych zestawach lub skompilowane z [Ilasm.exe (asembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Aby uzyskać informacje na zagnieżdżone typy ogólne i na utworzenie zagnieżdżonych typów ogólnych z ich definicje typu ogólnego, zobacz <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 Poniższy przykład tworzy dwa zagnieżdżonych klas publicznych i dwóch zagnieżdżonych klas chronionych i wyświetla informacje o klasy, które są zgodne z określonymi ograniczeniami wiązania.  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera właściwości bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie właściwości publiczne bieżącego <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Reflection.PropertyInfo" /> obiekty reprezentujące wszystkie właściwości publiczne bieżącego <see cref="T:System.Type" />.  - lub - pustą tablicę typu <see cref="T:System.Reflection.PropertyInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma właściwości publicznej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tego przeciążenia jest odpowiednikiem wywołania <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> przeciążenia z `bindingAttr` argument równa `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` w języku C# i `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` w języku Visual Basic. Zwraca wszystkie wystąpienia publicznego i właściwości statyczne, zarówno tymi zdefiniowanymi przez typ reprezentowany przez bieżący <xref:System.Type> obiektu, a także tych dziedziczone z jego typów podstawowych.  
  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie wartość właściwości jest uznawane za prywatne, i musi być <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic połączyć wartości przy użyciu `Or`) go.  
  
 <xref:System.Type.GetProperties%2A> Metoda nie zwraca właściwości w określonej kolejności, takich jak alfabetycznej lub deklaracji kolejności. Kod nie zależy od kolejności, w której są zwracane właściwości, ponieważ różniącą się kolejności.  
  
 W poniższej tabeli przedstawiono elementy członkowskie klasy podstawowej zwracanych przez `Get` metody, gdy w czasie wykonywania odbicia typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący T:System.Type reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.PropertyInfo> obiektów z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje właściwości ograniczenia klasy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie `GetProperties` metody.  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić <see langword="null" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wyszukuje właściwości bieżącego <see cref="T:System.Type" />, korzystanie z określonymi ograniczeniami wiązania.</summary>
        <returns>Tablica <see cref="T:System.Reflection.PropertyInfo" /> obiekty reprezentujące wszystkie właściwości bieżącego <see cref="T:System.Type" /> zgodnego z określonymi ograniczeniami wiązania.  - lub - pustą tablicę typu <see cref="T:System.Reflection.PropertyInfo" />, jeśli bieżący <see cref="T:System.Type" /> nie ma właściwości, lub jeśli żadna z właściwości nie zgadza się z ograniczeniami wiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie wartość właściwości jest uznawane za prywatne, i musi być <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic połączyć wartości przy użyciu `Or`) go.  
  
 <xref:System.Type.GetProperties%2A> Metoda nie zwraca właściwości w określonej kolejności, takich jak alfabetycznej lub deklaracji kolejności. Kod nie zależy od kolejności, w której są zwracane właściwości, ponieważ różniącą się kolejności.  
  
 Następujące <xref:System.Reflection.BindingFlags> filtru flagi może służyć do definiowania, które zagnieżdżone typów, aby w wyszukiwaniu uwzględnić:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` aby można było pobrać typ zwracany.  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić właściwości publiczne.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić właściwości niepublicznych (to znaczy prywatnych, wewnętrznych i chronionych właściwości). Tylko chronione i zwracane są wewnętrzne właściwości klas podstawowych; prywatne właściwości klas podstawowych nie są zwracane.  
  
-   Określ `BindingFlags.FlattenHierarchy` uwzględnienie `public` i `protected` statycznych elementów członkowskich w hierarchii; `private` statycznych elementów członkowskich w klasach dziedziczonych nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikator można zmienić, jak działa wyszukiwanie:  
  
-   `BindingFlags.DeclaredOnly` tylko dla właściwości wyszukiwania <xref:System.Type>, nie właściwości, które zostały odziedziczone po prostu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie wartość właściwości jest uznawane za prywatne, i musi być <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic połączyć wartości przy użyciu `Or`) go.  
  
 Jeśli bieżący T:System.Type reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.PropertyInfo> obiektów z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje właściwości ograniczenia klasy.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano klasę o nazwie `PropertyClass` zawierającą sześć właściwości: dwa są publiczne, jedna jest prywatny, co jest chroniony, która jest wewnętrzny (`Friend` w języku Visual Basic), i jest chronionych wewnętrznych (`Protected Friend` w języku Visual Basic). Następnie wyświetla informacje dotyczące niektórych podstawowych właściwości (nazwa właściwości i typ, czy jest odczytu/zapisu i widoczność jego `get` i `set` metody dostępu) dla właściwości, które są zgodne z określonymi ograniczeniami wiązania.  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określoną właściwością bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości publicznej do pobrania.</param>
        <summary>Wyszukiwanie właściwości publicznej o określonej nazwie.</summary>
        <returns>Obiekt reprezentujący właściwość publiczna o określonej nazwie, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukiwanie `name` jest rozróżniana wielkość liter. Wyszukiwanie uwzględnia właściwości wystąpienia statycznego publicznego i publicznego.  
  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie wartość właściwości jest uznawane za prywatne, i musi być <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic połączyć wartości przy użyciu `Or`) go.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.PropertyInfo> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje właściwości ograniczenia klasy.  
  
 Sytuacje, w których <xref:System.Reflection.AmbiguousMatchException> występuje są następujące:  
  
-   Typ zawiera dwa indeksowanej właściwości, które mają takie same nazwy ale różne liczby parametrów. Aby usunąć niejednoznaczność, użyj przeciążenia <xref:System.Type.GetProperty%2A> metodę, która określa typy parametrów.  
  
-   Typ pochodny deklaruje właściwość, która ukrywa to właściwość dziedziczona o takiej samej nazwie, za pomocą `new` modyfikator (`Shadows` w języku Visual Basic). Aby usunąć niejednoznaczność, użyj <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> metoda przeciążenia i dodać <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> flagę, aby ograniczyć wyszukiwanie do elementów członkowskich, które nie są dziedziczone.  
  
## <a name="indexers-and-default-properties"></a>Indeksatory i domyślne właściwości  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], i [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczone składni do uzyskiwania dostępu do właściwości indeksowane i Zezwalaj na jedną właściwość indeksowana jako domyślny dla jego typu. Na przykład jeśli zmienna `myList` odwołuje się do <xref:System.Collections.ArrayList>, składnia `myList[3]` (`myList(3)` w języku Visual Basic) pobiera elementu o indeksie 3. Można doprowadzić do przeciążenia właściwości.  
  
 W języku C# ta funkcja nosi nazwę indeksatora i nie może być określona przez nazwę. Domyślnie indeksatora języka C# jest wyświetlana w metadanych jako indeksowanej właściwości o nazwie "Item". Jednak klasy biblioteki deweloper może użyć <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atrybutu, aby zmienić nazwę indeksatora w metadanych. Na przykład <xref:System.String> klasa ma indeksator o nazwie <xref:System.String.Chars%2A>. Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.  
  
 Aby określić, czy typ właściwości domyślnej, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metody do testowania dla <xref:System.Reflection.DefaultMemberAttribute> atrybutu. Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> właściwość zwraca nazwę domyślnej właściwości.  
  
   
  
## Examples  
 Poniższy przykład pobiera `Type` obiekt klasy zdefiniowanej przez użytkownika, pobiera właściwości tej klasy i wyświetla nazwę właściwości.  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 Wewnętrznie ta właściwość jest określana w metadanych o nazwie "Item". Próby pobrania `PropertyInfo` za pomocą odbicia należy określić to wewnętrzna nazwa celu poprawnie powrotu `PropertyInfo` właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną właściwość o podanej nazwie.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości do pobrania.</param>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić <see langword="null" />.</param>
        <summary>Wyszukuje określonej właściwości przy użyciu z określonymi ograniczeniami wiązania.</summary>
        <returns>Obiekt reprezentujący właściwość, która spełnia określonych wymagań, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie wartość właściwości jest uznawane za prywatne, i musi być <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic połączyć wartości przy użyciu `Or`) go.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania właściwości, które do wyszukiwania:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` aby można było pobrać typ zwracany.  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić właściwości publiczne.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić właściwości niepublicznych (to znaczy prywatnych, wewnętrznych i chronionych właściwości).  
  
-   Określ `BindingFlags.FlattenHierarchy` uwzględnienie `public` i `protected` statycznych elementów członkowskich w hierarchii; `private` statycznych elementów członkowskich w klasach dziedziczonych nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikator można zmienić, jak działa wyszukiwanie:  
  
-   `BindingFlags.IgnoreCase` ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly` tylko dla właściwości wyszukiwania <xref:System.Type>, nie właściwości, które zostały odziedziczone po prostu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.PropertyInfo> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje właściwości ograniczenia klasy.  
  
 Sytuacje, w których <xref:System.Reflection.AmbiguousMatchException> występuje są następujące:  
  
-   Typ zawiera dwa indeksowanej właściwości, które mają takie same nazwy ale różne liczby parametrów. Aby usunąć niejednoznaczność, użyj przeciążenia <xref:System.Type.GetProperty%2A> metodę, która określa typy parametrów.  
  
-   Typ pochodny deklaruje właściwość, która ukrywa to właściwość dziedziczona o takiej samej nazwie, za pomocą `new` modyfikator (`Shadows` w języku Visual Basic). Aby usunąć niejednoznaczność, obejmują <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> ograniczyć wyszukiwanie do elementów członkowskich, które nie są dziedziczone.  
  
## <a name="indexers-and-default-properties"></a>Indeksatory i domyślne właściwości  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], i [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczone składni do uzyskiwania dostępu do właściwości indeksowane i Zezwalaj na jedną właściwość indeksowana jako domyślny dla jego typu. Na przykład jeśli zmienna `myList` odwołuje się do <xref:System.Collections.ArrayList>, składnia `myList[3]` (`myList(3)` w języku Visual Basic) pobiera elementu o indeksie 3. Można doprowadzić do przeciążenia właściwości.  
  
 W języku C# ta funkcja nosi nazwę indeksatora i nie może być określona przez nazwę. Domyślnie indeksatora języka C# jest wyświetlana w metadanych jako indeksowanej właściwości o nazwie "Item". Jednak klasy biblioteki deweloper może użyć <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atrybutu, aby zmienić nazwę indeksatora w metadanych. Na przykład <xref:System.String> klasa ma indeksator o nazwie <xref:System.String.Chars%2A>. Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.  
  
 Aby określić, czy typ właściwości domyślnej, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metody do testowania dla <xref:System.Reflection.DefaultMemberAttribute> atrybutu. Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> właściwość zwraca nazwę domyślnej właściwości.  
  
   
  
## Examples  
 Poniższy przykład pobiera typ klasy zdefiniowanej przez użytkownika, pobiera właściwości tej klasy i wyświetla nazwę właściwości, zgodnie z określonymi ograniczeniami wiązania.  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną właściwość o określonej nazwie i z określonymi ograniczeniami wiązania.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości publicznej do pobrania.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <summary>Wyszukiwanie właściwości publicznej o określoną nazwę i typ zwracany.</summary>
        <returns>Obiekt reprezentujący właściwość publiczna o określonej nazwie, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie wartość właściwości jest uznawane za prywatne, i musi być <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic połączyć wartości przy użyciu `Or`) go.  
  
 Wyszukiwanie `name` jest rozróżniana wielkość liter. Wyszukiwanie uwzględnia właściwości wystąpienia statycznego publicznego i publicznego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.PropertyInfo> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje właściwości ograniczenia klasy.  
  
## <a name="indexers-and-default-properties"></a>Indeksatory i domyślne właściwości  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], i [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczone składni do uzyskiwania dostępu do właściwości indeksowane i Zezwalaj na jedną właściwość indeksowana jako domyślny dla jego typu. Na przykład jeśli zmienna `myList` odwołuje się do <xref:System.Collections.ArrayList>, składnia `myList[3]` (`myList(3)` w języku Visual Basic) pobiera elementu o indeksie 3. Można doprowadzić do przeciążenia właściwości.  
  
 W języku C# ta funkcja nosi nazwę indeksatora i nie może być określona przez nazwę. Domyślnie indeksatora języka C# jest wyświetlana w metadanych jako indeksowanej właściwości o nazwie "Item". Jednak klasy biblioteki deweloper może użyć <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atrybutu, aby zmienić nazwę indeksatora w metadanych. Na przykład <xref:System.String> klasa ma indeksator o nazwie <xref:System.String.Chars%2A>. Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.  
  
 Aby określić, czy typ właściwości domyślnej, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metody do testowania dla <xref:System.Reflection.DefaultMemberAttribute> atrybutu. Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> właściwość zwraca nazwę domyślnej właściwości.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano klasę z jedną właściwość i pobiera nazwę i typ właściwości.  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną właściwość o podanej nazwie.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />, lub <paramref name="returnType" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości publicznej do pobrania.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentującą numer, kolejność i typy parametrów indeksowane właściwości, aby uzyskać.  - lub - pustą tablicę typu <see cref="T:System.Type" /> (to znaczy wpisz typów [] = nowe Type[0]) można pobrać właściwości, która nie jest indeksowana.</param>
        <summary>Wyszukuje określony właściwość publiczna, którego parametry są zgodne określone typy argumentów.</summary>
        <returns>Obiekt reprezentujący właściwość publiczna, którego parametry są zgodne określone typy argumentów, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie wartość właściwości jest uznawane za prywatne, i musi być <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic połączyć wartości przy użyciu `Or`) go.  
  
 Wyszukiwanie `name` jest rozróżniana wielkość liter. Wyszukiwanie uwzględnia właściwości wystąpienia statycznego publicznego i publicznego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.PropertyInfo> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje właściwości ograniczenia klasy.  
  
## <a name="indexers-and-default-properties"></a>Indeksatory i domyślne właściwości  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], i [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczone składni do uzyskiwania dostępu do właściwości indeksowane i Zezwalaj na jedną właściwość indeksowana jako domyślny dla jego typu. Na przykład jeśli zmienna `myList` odwołuje się do <xref:System.Collections.ArrayList>, składnia `myList[3]` (`myList(3)` w języku Visual Basic) pobiera elementu o indeksie 3. Można doprowadzić do przeciążenia właściwości.  
  
 W języku C# ta funkcja nosi nazwę indeksatora i nie może być określona przez nazwę. Domyślnie indeksatora języka C# jest wyświetlana w metadanych jako indeksowanej właściwości o nazwie "Item". Jednak klasy biblioteki deweloper może użyć <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atrybutu, aby zmienić nazwę indeksatora w metadanych. Na przykład <xref:System.String> klasa ma indeksator o nazwie <xref:System.String.Chars%2A>. Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.  
  
 Aby określić, czy typ właściwości domyślnej, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metody do testowania dla <xref:System.Reflection.DefaultMemberAttribute> atrybutu. Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> właściwość zwraca nazwę domyślnej właściwości.  
  
   
  
## Examples  
 Poniższy przykład pobiera `Type` obiekt klasy zdefiniowanej przez użytkownika, pobiera właściwości tej klasy i wyświetla nazwę właściwości i typ właściwości zgodnie z Argumenty przekazane do `GetProperty`.  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną właściwość o określonej nazwie i dopasowywanie określone typy argumentów.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  - lub - <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> jest wielowymiarowy.</exception>
        <exception cref="T:System.NullReferenceException">Element <paramref name="types" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości publicznej do pobrania.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentującą numer, kolejność i typy parametrów indeksowane właściwości, aby uzyskać.  - lub - pustą tablicę typu <see cref="T:System.Type" /> (to znaczy wpisz typów [] = nowe Type[0]) można pobrać właściwości, która nie jest indeksowana.</param>
        <summary>Wyszukuje określony właściwość publiczna, którego parametry są zgodne określone typy argumentów.</summary>
        <returns>Obiekt reprezentujący właściwość publiczna, którego parametry są zgodne określone typy argumentów, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie wartość właściwości jest uznawane za prywatne, i musi być <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic połączyć wartości przy użyciu `Or`) go.  
  
 Wyszukiwanie `name` jest rozróżniana wielkość liter. Wyszukiwanie uwzględnia właściwości wystąpienia statycznego publicznego i publicznego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.PropertyInfo> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje właściwości ograniczenia klasy.  
  
## <a name="indexers-and-default-properties"></a>Indeksatory i domyślne właściwości  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], i [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczone składni do uzyskiwania dostępu do właściwości indeksowane i Zezwalaj na jedną właściwość indeksowana jako domyślny dla jego typu. Na przykład jeśli zmienna `myList` odwołuje się do <xref:System.Collections.ArrayList>, składnia `myList[3]` (`myList(3)` w języku Visual Basic) pobiera elementu o indeksie 3. Można doprowadzić do przeciążenia właściwości.  
  
 W języku C# ta funkcja nosi nazwę indeksatora i nie może być określona przez nazwę. Domyślnie indeksatora języka C# jest wyświetlana w metadanych jako indeksowanej właściwości o nazwie "Item". Jednak klasy biblioteki deweloper może użyć <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atrybutu, aby zmienić nazwę indeksatora w metadanych. Na przykład <xref:System.String> klasa ma indeksator o nazwie <xref:System.String.Chars%2A>. Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.  
  
 Aby określić, czy typ właściwości domyślnej, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metody do testowania dla <xref:System.Reflection.DefaultMemberAttribute> atrybutu. Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> właściwość zwraca nazwę domyślnej właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną właściwość o określonej nazwie i dopasowywanie określone typy argumentów.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  - lub - <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> jest wielowymiarowy.</exception>
        <exception cref="T:System.NullReferenceException">Element <paramref name="types" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości publicznej do pobrania.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentującą numer, kolejność i typy parametrów indeksowane właściwości, aby uzyskać.  - lub - pustą tablicę typu <see cref="T:System.Type" /> (to znaczy wpisz typów [] = nowe Type[0]) można pobrać właściwości, która nie jest indeksowana.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiadającego mu elementu w <c>typy</c> tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Wyszukuje dla określonej właściwości publiczne, którego parametry są zgodne modyfikatorów i określone typy argumentów.</summary>
        <returns>Obiekt reprezentujący właściwość publiczna, który spełnia określonych wymagań, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie wartość właściwości jest uznawane za prywatne, i musi być <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic połączyć wartości przy użyciu `Or`) go.  
  
 Mimo że nie może przetwarzać domyślnego integratora <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> klasa umożliwiająca zapisanie integratora niestandardowej, która przetwarzać `modifiers`. `ParameterModifier` jest używana tylko podczas wywoływania metody za pomocą międzyoperacyjności COM i obsługiwane są tylko parametry, które są przekazywane przez odwołanie.  
  
 Wyszukiwanie `name` jest rozróżniana wielkość liter. Wyszukiwanie uwzględnia właściwości wystąpienia statycznego publicznego i publicznego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.PropertyInfo> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje właściwości ograniczenia klasy.  
  
## <a name="indexers-and-default-properties"></a>Indeksatory i domyślne właściwości  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], i [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczone składni do uzyskiwania dostępu do właściwości indeksowane i Zezwalaj na jedną właściwość indeksowana jako domyślny dla jego typu. Na przykład jeśli zmienna `myList` odwołuje się do <xref:System.Collections.ArrayList>, składnia `myList[3]` (`myList(3)` w języku Visual Basic) pobiera elementu o indeksie 3. Można doprowadzić do przeciążenia właściwości.  
  
 W języku C# ta funkcja nosi nazwę indeksatora i nie może być określona przez nazwę. Domyślnie indeksatora języka C# jest wyświetlana w metadanych jako indeksowanej właściwości o nazwie "Item". Jednak klasy biblioteki deweloper może użyć <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atrybutu, aby zmienić nazwę indeksatora w metadanych. Na przykład <xref:System.String> klasa ma indeksator o nazwie <xref:System.String.Chars%2A>. Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.  
  
 Aby określić, czy typ właściwości domyślnej, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metody do testowania dla <xref:System.Reflection.DefaultMemberAttribute> atrybutu. Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> właściwość zwraca nazwę domyślnej właściwości.  
  
   
  
## Examples  
 Poniższy przykład uzyskuje `Type` obiekt odpowiadający `MyPropertyClass`, a indeksowanej właściwości tej klasy są pobierane przy użyciu argumentów przekazanych do `GetProperty` metody.  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną właściwość o określonej nazwie i dopasowywanie modyfikatorów i określone typy argumentów.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  - lub - <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> jest wielowymiarowy.  - lub - <paramref name="modifiers" /> jest wielowymiarowy.  - lub - <paramref name="types" /> i <paramref name="modifiers" /> nie mają taką samą długość.</exception>
        <exception cref="T:System.NullReferenceException">Element <paramref name="types" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości do pobrania.</param>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić <see langword="null" />.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  - lub - odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentującą numer, kolejność i typy parametrów indeksowane właściwości, aby uzyskać.  - lub - pustą tablicę typu <see cref="T:System.Type" /> (to znaczy wpisz typów [] = nowe Type[0]) można pobrać właściwości, która nie jest indeksowana.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiadającego mu elementu w <c>typy</c> tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Wyszukuje dla określonej właściwości, którego parametry są zgodne określone typy argumentów i Modyfikatory korzystanie z określonymi ograniczeniami wiązania.</summary>
        <returns>Obiekt reprezentujący właściwość, która spełnia określonych wymagań, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie wartość właściwości jest uznawane za prywatne, i musi być <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w języku Visual Basic połączyć wartości przy użyciu `Or`) go.  
  
 Mimo że nie może przetwarzać domyślnego integratora <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> klasa umożliwiająca zapisanie integratora niestandardowej, która przetwarzać `modifiers`. `ParameterModifier` jest używana tylko podczas wywoływania metody za pomocą międzyoperacyjności COM i obsługiwane są tylko parametry, które są przekazywane przez odwołanie.  
  
 W poniższej tabeli przedstawiono elementy członkowskie klasy podstawowej zwracanych przez `Get` metody, gdy w czasie wykonywania odbicia typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania właściwości, które do wyszukiwania:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` aby można było pobrać typ zwracany.  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić właściwości publiczne.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić właściwości niepublicznych (to znaczy prywatnych, wewnętrznych i chronionych właściwości).  
  
-   Określ `BindingFlags.FlattenHierarchy` uwzględnienie `public` i `protected` statycznych elementów członkowskich w hierarchii; `private` statycznych elementów członkowskich w klasach dziedziczonych nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikator można zmienić, jak działa wyszukiwanie:  
  
-   `BindingFlags.IgnoreCase` ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly` tylko dla właściwości wyszukiwania <xref:System.Type>, nie właściwości, które zostały odziedziczone po prostu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta metoda zwraca <xref:System.Reflection.PropertyInfo> z parametrami typu zastępuje argumenty odpowiedniego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda wyszukuje właściwości ograniczenia klasy.  
  
## <a name="indexers-and-default-properties"></a>Indeksatory i domyślne właściwości  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], i [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczone składni do uzyskiwania dostępu do właściwości indeksowane i Zezwalaj na jedną właściwość indeksowana jako domyślny dla jego typu. Na przykład jeśli zmienna `myList` odwołuje się do <xref:System.Collections.ArrayList>, składnia `myList[3]` (`myList(3)` w języku Visual Basic) pobiera elementu o indeksie 3. Można doprowadzić do przeciążenia właściwości.  
  
 W języku C# ta funkcja nosi nazwę indeksatora i nie może być określona przez nazwę. Domyślnie indeksatora języka C# jest wyświetlana w metadanych jako indeksowanej właściwości o nazwie "Item". Jednak klasy biblioteki deweloper może użyć <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atrybutu, aby zmienić nazwę indeksatora w metadanych. Na przykład <xref:System.String> klasa ma indeksator o nazwie <xref:System.String.Chars%2A>. Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.  
  
 Aby określić, czy typ właściwości domyślnej, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metody do testowania dla <xref:System.Reflection.DefaultMemberAttribute> atrybutu. Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> właściwość zwraca nazwę domyślnej właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną właściwość o określonej nazwie i z określonymi ograniczeniami wiązania.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  - lub - <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> jest wielowymiarowy.  - lub - <paramref name="modifiers" /> jest wielowymiarowy.  - lub - <paramref name="types" /> i <paramref name="modifiers" /> nie mają taką samą długość.</exception>
        <exception cref="T:System.NullReferenceException">Element <paramref name="types" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości do pobrania.</param>
        <param name="bindingAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie.  - lub - Zero, aby zwrócić <see langword="null" />.</param>
        <param name="binder">Obiekt, który definiuje zbiór właściwości, który umożliwia powiązanie, które obejmują wybór przeciążonego elementu członkowskiego, koercja typy argumentów i wywołanie elementu członkowskiego przy użyciu odbicia.  - lub - odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentującą numer, kolejność i typy parametrów indeksowane właściwości, aby uzyskać.  - lub - pustą tablicę typu <see cref="T:System.Type" /> (to znaczy wpisz typów [] = nowe Type[0]) można pobrać właściwości, która nie jest indeksowana.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiadającego mu elementu w <c>typy</c> tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, wyszukuje dla określonej właściwości, którego parametry są zgodne określone typy argumentów i Modyfikatory korzystanie z określonymi ograniczeniami wiązania.</summary>
        <returns>Obiekt reprezentujący właściwość, która spełnia określonych wymagań, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że nie może przetwarzać domyślnego integratora <xref:System.Reflection.ParameterModifier> ( `modifiers` parametru), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> klasa umożliwiająca zapisanie integratora niestandardowej, która przetwarzać `modifiers`. `ParameterModifier` jest używana tylko podczas wywoływania metody za pomocą międzyoperacyjności COM i obsługiwane są tylko parametry, które są przekazywane przez odwołanie.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania właściwości, które do wyszukiwania:  
  
-   Należy określić `BindingFlags.Instance` lub `BindingFlags.Static` aby można było pobrać typ zwracany.  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić właściwości publiczne.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić właściwości niepublicznych (to znaczy prywatnych, wewnętrznych i chronionych właściwości).  
  
-   Określ `BindingFlags.FlattenHierarchy` uwzględnienie `public` i `protected` statycznych elementów członkowskich w hierarchii; `private` statycznych elementów członkowskich w klasach dziedziczonych nie są uwzględniane.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikator można zmienić, jak działa wyszukiwanie:  
  
-   `BindingFlags.IgnoreCase` ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly` tylko dla właściwości wyszukiwania <xref:System.Type>, nie właściwości, które zostały odziedziczone po prostu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną właściwość o określonej nazwie i z określonymi ograniczeniami wiązania.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> jest <see langword="null" />.  - lub - <paramref name="types" /> jest <see langword="null" />.  - lub - jeden z elementów w <paramref name="types" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> jest wielowymiarowy.  - lub - <paramref name="modifiers" /> jest wielowymiarowy.  - lub - <paramref name="types" /> i <paramref name="modifiers" /> nie mają taką samą długość.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący typ <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" />, lub <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="T:System.Type" /> obiekt, który reprezentuje określonego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera bieżący <see cref="T:System.Type" />.</summary>
        <returns>Bieżący <see cref="T:System.Type" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa kwalifikowana zestawu typ do pobrania. Zobacz <see cref="P:System.Type.AssemblyQualifiedName" />. Jeśli typ jest obecnie wykonywany zestaw lub Mscorlib.dll, wystarczy podać nazwę typu kwalifikowana przez jego przestrzeni nazw.</param>
        <summary>Pobiera <see cref="T:System.Type" /> o określonej nazwie, wyszukując z uwzględnieniem wielkości liter.</summary>
        <returns>Typ o określonej nazwie, jeśli znaleziono; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć <xref:System.Type.GetType%2A> metodę, aby uzyskać <xref:System.Type> obiektu dla typu w innym zestawie, jeśli wiesz, jego nazwa kwalifikowana zestawu, który można uzyskać z <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A> powoduje, że ładowanie zestawu określonego w `typeName`. Można również załadowania zestawu przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody, a następnie użyć <xref:System.Type.GetType%2A> lub <xref:System.Reflection.Assembly.GetTypes%2A> metody <xref:System.Reflection.Assembly> klasy można pobrać <xref:System.Type> obiektów. Jeśli typ w zestawie znane programu w czasie kompilacji jest bardziej wydajne do użycia w języku C# <xref:System.Type.GetType%2A> w języku Visual Basic lub w języku C++.  
  
> [!NOTE]
>  Jeśli `typeName` nie można znaleźć, wywołanie <xref:System.Type.GetType%28System.String%29> metoda zwraca `null`. Nie zgłasza wyjątek. Do kontrolowania tego, czy jest zgłaszany wyjątek, wywoływać przeciążenia <xref:System.Type.GetType%2A> metodę, która ma `throwOnError` parametru.  
  
 <xref:System.Type.GetType%2A> działa tylko na zestawów ładowanych z dysku. Jeśli należy wywołać <xref:System.Type.GetType%2A> do odszukania typ zdefiniowany w zestawie dynamicznym zdefiniowane przy użyciu <xref:System.Reflection.Emit> usług, możesz uzyskać niespójne działanie. Zachowanie zależy, czy w zestawie dynamicznym jest trwała, to znaczy, utworzone za pomocą `RunAndSave` lub `Save` tryby dostępu <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> wyliczenia. Jeśli w zestawie dynamicznym jest trwałe i został zapisany na dysku przed `GetType` jest wywoływana, moduł ładujący znajduje zestawu zapisane na dysku, ten zestaw ładuje i pobiera typ z tego zestawu. Jeśli zestaw nie został zapisany na dysku po `GetType` jest wywoływana metoda zwraca `null`. `GetType` nie rozpoznaje przejściowej zestawów dynamicznych; w związku z tym wywołaniem `GetType` można pobrać typu na przejściowy zwraca zestawu dynamicznego `null`.  
  
 Aby użyć `GetType` na module dynamicznym subskrybować <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> zdarzeń i wywołanie `GetType` przed zapisaniem. W przeciwnym razie wystąpi dwie kopie zestawu w pamięci.  
  
 W poniższej tabeli przedstawiono elementy członkowskie klasy podstawowej zwracanych przez `Get` metody, gdy w czasie wykonywania odbicia typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Tablic lub typów COM nie są przeszukiwane przez, chyba że już zostały załadowane do tabeli dostępnych klas.  
  
 `typeName` może być nazwa typu kwalifikowana przez jego przestrzeni nazw lub kwalifikowana nazwa zestawu zawierającego specyfikacja nazwy zestawu. Zobacz <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Jeśli `typeName` zawiera przestrzeń nazw, ale nie nazwy zestawu metoda wyszukiwanie tylko zestawu obiektu wywołującego i Mscorlib.dll, w tej kolejności. Jeśli nazwa typu jest w pełni kwalifikowana nazwą zestawu częściowej lub pełnej, ta metoda wyszukuje w określonym zestawie. Jeśli zestaw ma silną nazwę, wymagana jest nazwa pełny zestaw.  
  
 <xref:System.Type.AssemblyQualifiedName%2A> Właściwość zwraca w pełni kwalifikowana nazwa typu w tym typy zagnieżdżone, nazwa zestawu i argumentów typu ogólnego. Wszystkie kompilatory, które obsługują aparat plików wykonywalnych języka wspólnego, w trakcie wykonania wyemitują prostą nazwę klasy zagnieżdżonej, a odbicie podczas kwerendy stworzy zniekształcone nazwy zgodnie z następującymi konwencjami.  
  
> [!NOTE]
>  W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw. Na przykład "ProcessorArchitecture = msil". Jednak nie jest uwzględnione w ciągu zwróconego przez <xref:System.Type.AssemblyQualifiedName%2A> właściwości ze względu na zgodność. Można również załadować typów, tworząc <xref:System.Reflection.AssemblyName> obiekt i przekazaniem ich do odpowiedniego przeciążenia <xref:System.Reflection.Assembly.Load%2A> metody. Następnie można użyć <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> metody można załadować typów z zestawu. Zobacz też <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Ogranicznik|Znaczenie|  
|---------------|-------------|  
|Ukośnik odwrotny (\\)|Znak ucieczki.|  
|Backtick (')|Poprzedza co najmniej jedną cyfrę reprezentujący liczbę parametrów typu, znajduje się na końcu nazwy typu ogólnego.|  
|Nawiasy kwadratowe ([])|Umieść listy argumentów typu ogólnego, do skonstruowanego typu ogólnego; w obrębie listy argumentów typu należy ująć typu kwalifikowanego zestawu.|  
|Przecinek (,)|Poprzedza nazwę zestawu.|  
|Kropka (.)|Wskazuje przestrzeń nazw identyfikatorów.|  
|Znak plus (+)|Poprzedza klasę zagnieżdżoną.|  
  
 Na przykład w pełni kwalifikowana nazwa klasy może wyglądać następująco:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Jeśli przestrzeń nazw zostały TopNamespace.Sub+Namespace, a następnie ciąg musi poprzedzać znak plus (+) ze znakiem anulowania (\\) aby zapobiec interpretowany jako separator zagnieżdżenia. Odbicie emituje ten ciąg w następujący sposób:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A "++" staje się "\\+\\+", a "\\"staje się"\\\\".  
  
 Utrwalenia i później użyć do załadowania tego kwalifikowana nazwa <xref:System.Type>. Aby wyszukać i załadować <xref:System.Type>, użyj <xref:System.Type.GetType%2A> albo z typem nazwy lub tylko o nazwie typu kwalifikowanej zestawu. <xref:System.Type.GetType%2A> z typem nazwę tylko będzie szukać <xref:System.Type> w zestawie wywołującego, a następnie w zestawu systemowego. <xref:System.Type.GetType%2A> z zestawu będzie szukać kwalifikowana nazwa typu <xref:System.Type> w dowolnym zestawie.  
  
 Nazwy typów mogą obejmować końcowe znaki, które wyznaczają dodatkowe informacje dotyczące typu, na przykład to, czy typ jest typem odwołania, typem wskaźnika lub typem tablicowym. Aby pobrać nazwę typu bez tych końcowych znaków, należy użyć `t.GetElementType().ToString()`, gdzie `t` jest typem.  
  
 Spacje są istotne we wszystkich składnikach nazwy z wyjątkiem nazwy zestawu. Spacje przed separatorem w nazwie zestawu ',' są istotne, ale spacje po separatorze ',' są ignorowane.  
  
 Nazwa typu ogólnego kończy się ciągiem backtick (\`) następuje cyfr reprezentujący liczbę argumentów typu ogólnego. Celem tego przekręcona nazwa jest umożliwienie kompilatory do obsługi typów ogólnych o takiej samej nazwie, ale różne liczby parametrów typu, występujących w tym samym zakresie. Na przykład odbicia zwraca zniekształcone nazwy `Tuple`1` and `krotki`2` z metody rodzajowe `Tuple(Of T)` i `Tuple(Of T0, T1)` w języku Visual Basic lub `Tuple<T>` i spójnej kolekcji`\<T0, T1>` języka Visual C#.  
  
 Dla typów ogólnych z listą argumentów typu jest ujęta w nawiasy, a argumenty typu są oddzielone przecinkami. Na przykład ogólnego <xref:System.Collections.Generic.Dictionary%602> zawiera dwa parametry typu. A <xref:System.Collections.Generic.Dictionary%602> z `MyType` z kluczami typu <xref:System.String> może być reprezentowany w następujący sposób:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Aby określić typu kwalifikowanego zestawu w obrębie listy argumentów typu, należy ująć typu kwalifikowanego zestawu w nawiasach kwadratowych. W przeciwnym razie przecinkami, które rozdzielić nazwa kwalifikowana zestawu są interpretowane jako oddzielającego argumentów typu dodatkowe. Na przykład <xref:System.Collections.Generic.Dictionary%602> z `MyType` fromMyAssembly.dll z kluczami typu <xref:System.String>, może być określony w następujący sposób:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Typu kwalifikowanego zestawu mogą być ujęte w nawiasy kwadratowe tylko wtedy, gdy pojawi się on w obrębie listy parametrów typu. Reguły dotyczące wyszukiwania zestawów dla typów kwalifikowaną i niekwalifikowane w liście parametrów typu są takie same jak reguły dla typów nierodzajowe kwalifikowaną i niekwalifikowane.  
  
 Typy dopuszczające wartości null są szczególnych przypadkach typów ogólnych. Na przykład nullable <xref:System.Int32> jest reprezentowany przez ciąg "System.Nullable'1[System.Int32]".  
  
> [!NOTE]
>  W języku C#, C++ i Visual Basic można również uzyskać przy użyciu operatorów typu typy dopuszczające wartości zerowe. Na przykład wartości null <xref:System.Boolean> typu zwracanego przez `typeof(Nullable<bool>)` w języku C#, przez `Nullable<Boolean>::typeid` w języku C++ i przez `GetType(Nullable(Of Boolean))` w języku Visual Basic.  
  
 W poniższej tabeli przedstawiono składnię korzystać z `GetType` dla różnych typów.  
  
|Aby uzyskać|Zastosowanie|  
|------------|---------|  
|Dopuszczające wartości zerowe <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|Niezarządzany wskaźnik do `MyType`|`Type.GetType("MyType*")`|  
|Niezarządzany wskaźnik na wskaźnik do `MyType`|`Type.GetType("MyType**")`|  
|Zarządzane wskaźnik lub odwołanie do `MyType`|`Type.GetType("MyType&")`. Należy pamiętać, że w przeciwieństwie do wskaźników, odwołania mogą zawierać maksymalnie jeden poziom.|  
|Klasy nadrzędnej i zagnieżdżone klasy|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Jednowymiarowa tablica z dolną granicą 0|`Type.GetType("MyType[]")`|  
|Jednowymiarowa tablica o nieznanym powiązaniem niższego|`Type.GetType("MyType[*]")`|  
|N wymiarową tablicą|Przecinka (,) wewnątrz nawiasów a sumę n-1 razy. Na przykład `System.Object[,,]` reprezentuje trójwymiarowy `Object` tablicy.|  
|Tablica tablice jednowymiarowe|`Type.GetType("MyType[][]")`|  
|Prostokątne tablicą dwuwymiarową z nieznanego dolne granice tablicy.|`Type.GetType("MyType[,]")`|  
|Typem ogólnym z argumentem typu|`Type.GetType("MyGenericType`1[MyType]")`|  
|Typem ogólnym z dwoma argumentami typu|`Type.GetType("MyGenericType`2[MyType,AnotherType]")`|  
|Typem ogólnym z dwoma argumentami typu kwalifikowanego zestawu|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")"|  
|Kwalifikowana zestawu typu ogólnego z argumentem typu kwalifikowanego zestawu|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")"|  
|Typu ogólnego, którego argument typu jest typem ogólnym z dwoma argumentami typu|`Type.GetType("MyGenericType`[AnotherGenericType 1`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 Poniższy przykład pobiera typ `System.Int32` i używa tego typu obiektu do wyświetlenia <xref:System.Type.FullName%2A> właściwość `System.Int32`.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> reprezentuje typu ogólnego, który ma typ wskaźnika <see langword="ByRef" /> typu, lub <see cref="T:System.Void" /> jako jeden z jego argumentów typu.  - lub - <paramref name="typeName" /> reprezentuje typu ogólnego, który ma nieprawidłową liczbę argumentów typu.  - lub - <paramref name="typeName" /> reprezentuje ogólnego typu, a jeden z jego argumentów typu nie spełnia warunków ograniczenia dla odpowiedniego parametru typu.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> reprezentuje tablicę <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para> [.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.IO.IOException" />, zamiast tego.  </para>
          </block>  Zestaw lub jeden z jego zależności został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i zestaw został skompilowany przy użyciu nowszej wersji.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa kwalifikowana zestawu typ do pobrania. Zobacz <see cref="P:System.Type.AssemblyQualifiedName" />. Jeśli typ jest obecnie wykonywany zestaw lub Mscorlib.dll, wystarczy podać nazwę typu kwalifikowana przez jego przestrzeni nazw.</param>
        <param name="throwOnError">
          <see langword="true" /> Aby zgłosić wyjątek, jeśli nie można odnaleźć typu; <see langword="false" /> do zwrócenia <see langword="null" />. Określanie <see langword="false" /> również pomija inne warunki wyjątek, ale nie wszystkie z nich. Zobacz sekcję Wyjątki.</param>
        <summary>Pobiera <see cref="T:System.Type" /> o określonej nazwie, wyszukując z uwzględnieniem wielkości liter i określenie, czy należy zgłosić wyjątek, jeśli typ nie zostanie znaleziony.</summary>
        <returns>Typ o określonej nazwie. Jeśli typ nie zostanie znaleziony, <paramref name="throwOnError" /> parametr określa, czy <see langword="null" /> jest zwracany lub jest zgłaszany wyjątek. W niektórych przypadkach, jest zwracany wyjątek, niezależnie od wartości <paramref name="throwOnError" />. Zobacz sekcję Wyjątki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć <xref:System.Type.GetType%2A> metodę, aby uzyskać <xref:System.Type> obiektu dla typu w innym zestawie, jeśli wiesz, jego nazwa kwalifikowana zestawu, który można uzyskać z <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A> powoduje, że ładowanie zestawu określonego w `typeName`. Można również załadowania zestawu przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody, a następnie użyć <xref:System.Type.GetType%2A> lub <xref:System.Reflection.Assembly.GetTypes%2A> metody <xref:System.Reflection.Assembly> klasy można pobrać <xref:System.Type> obiektów. Jeśli typ w zestawie znane programu w czasie kompilacji jest bardziej wydajne, aby użyć `typeof` w języku C# <xref:System.Type.GetType%2A> w języku Visual Basic lub `typeid` w języku C++.  
  
 `GetType` działa tylko na zestawów ładowanych z dysku. Jeśli należy wywołać `GetType` do odszukania typ zdefiniowany w zestawie dynamicznym zdefiniowane przy użyciu <xref:System.Reflection.Emit> usług, możesz uzyskać niespójne działanie. Zachowanie zależy, czy w zestawie dynamicznym jest trwała, to znaczy, utworzone za pomocą `RunAndSave` lub `Save` tryby dostępu <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> wyliczenia. Jeśli w zestawie dynamicznym jest trwałe i został zapisany na dysku przed `GetType` jest wywoływana, moduł ładujący znajduje zestawu zapisane na dysku, ten zestaw ładuje i pobiera typ z tego zestawu. Jeśli zestaw nie został zapisany na dysku po `GetType` jest wywoływana metoda zwraca `null`. `GetType` nie rozpoznaje przejściowej zestawów dynamicznych; w związku z tym wywołaniem `GetType` można pobrać typu na przejściowy zwraca zestawu dynamicznego `null`.  
  
 Aby użyć `GetType` na module dynamicznym subskrybować <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> zdarzeń i wywołanie `GetType` przed zapisaniem. W przeciwnym razie wystąpi dwie kopie zestawu w pamięci.  
  
 `throwOnError` Parametr określa, co się stanie, gdy typ nie zostanie znaleziony i również pomija określone inne warunki wyjątek, zgodnie z opisem w sekcji wyjątki. Niektóre wyjątki są zgłaszane niezależnie od wartości `throwOnError`. Na przykład, jeśli typ zostanie znaleziony, ale nie może zostać załadowany <xref:System.TypeLoadException> jest zgłaszany nawet wtedy, gdy `throwOnError` jest `false`.  
  
 W poniższej tabeli przedstawiono elementy członkowskie klasy podstawowej zwracanych przez `Get` metody, gdy w czasie wykonywania odbicia typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Tablic lub typów COM nie są przeszukiwane przez, chyba że już zostały załadowane do tabeli dostępnych klas.  
  
 `typeName` może być nazwa typu kwalifikowana przez jego przestrzeni nazw lub kwalifikowana nazwa zestawu zawierającego specyfikacja nazwy zestawu. Zobacz <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Jeśli `typeName` zawiera przestrzeń nazw, ale nie nazwy zestawu metoda wyszukiwanie tylko zestawu obiektu wywołującego i Mscorlib.dll, w tej kolejności. Jeśli nazwa typu jest w pełni kwalifikowana nazwą zestawu częściowej lub pełnej, ta metoda wyszukuje w określonym zestawie. Jeśli zestaw ma silną nazwę, wymagana jest nazwa pełny zestaw.  
  
 <xref:System.Type.AssemblyQualifiedName%2A> Właściwość zwraca w pełni kwalifikowana nazwa typu w tym typy zagnieżdżone, nazwa zestawu i argumentów ogólnych. Wszystkie kompilatory, które obsługują aparat plików wykonywalnych języka wspólnego, w trakcie wykonania wyemitują prostą nazwę klasy zagnieżdżonej, a odbicie podczas kwerendy stworzy zniekształcone nazwy zgodnie z następującymi konwencjami.  
  
> [!NOTE]
>  W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw. Na przykład "ProcessorArchitecture = msil". Jednak nie jest uwzględnione w ciągu zwróconego przez <xref:System.Type.AssemblyQualifiedName%2A> właściwości ze względu na zgodność. Można również załadować typów, tworząc <xref:System.Reflection.AssemblyName> obiekt i przekazaniem ich do odpowiedniego przeciążenia <xref:System.Reflection.Assembly.Load%2A> metody. Następnie można użyć <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> metody można załadować typów z zestawu. Zobacz też <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Ogranicznik|Znaczenie|  
|---------------|-------------|  
|Ukośnik odwrotny (\\)|Znak ucieczki.|  
|Backtick (')|Poprzedza co najmniej jedną cyfrę reprezentujący liczbę parametrów typu, znajduje się na końcu nazwy typu ogólnego.|  
|Nawiasy kwadratowe ([])|Umieść listy argumentów typu ogólnego, do skonstruowanego typu ogólnego; w obrębie listy argumentów typu należy ująć typu kwalifikowanego zestawu.|  
|Przecinek (,)|Poprzedza nazwę zestawu.|  
|Kropka (.)|Wskazuje przestrzeń nazw identyfikatorów.|  
|Znak plus (+)|Poprzedza klasę zagnieżdżoną.|  
  
 Na przykład w pełni kwalifikowana nazwa klasy może wyglądać następująco:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Jeśli przestrzeń nazw zostały TopNamespace.Sub+Namespace, a następnie ciąg musi poprzedzać znak plus (+) ze znakiem anulowania (\\) aby zapobiec interpretowany jako separator zagnieżdżenia. Odbicie emituje ten ciąg w następujący sposób:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A "++" staje się "\\+\\+", a "\\"staje się"\\\\".  
  
 Utrwalenia i później użyć do załadowania tego kwalifikowana nazwa <xref:System.Type>. Aby wyszukać i załadować <xref:System.Type>, użyj <xref:System.Type.GetType%2A> albo z typem nazwy lub tylko o nazwie typu kwalifikowanej zestawu. <xref:System.Type.GetType%2A> z typem nazwę tylko będzie szukać <xref:System.Type> w zestawie wywołującego, a następnie w zestawu systemowego. <xref:System.Type.GetType%2A> z zestawu będzie szukać kwalifikowana nazwa typu <xref:System.Type> w dowolnym zestawie.  
  
 Nazwy typów mogą obejmować końcowe znaki, które wyznaczają dodatkowe informacje dotyczące typu, na przykład to, czy typ jest typem odwołania, typem wskaźnika lub typem tablicowym. Aby pobrać nazwę typu bez tych końcowych znaków, należy użyć `t.GetElementType().ToString()`, gdzie `t` jest typem.  
  
 Spacje są istotne we wszystkich składnikach nazwy z wyjątkiem nazwy zestawu. Spacje przed separatorem w nazwie zestawu ',' są istotne, ale spacje po separatorze ',' są ignorowane.  
  
 Nazwa typu ogólnego kończy się ciągiem backtick (\`) następuje cyfr reprezentujący liczbę argumentów typu ogólnego. Celem tego przekręcona nazwa jest umożliwienie kompilatory do obsługi typów ogólnych o takiej samej nazwie, ale różne liczby parametrów typu, występujących w tym samym zakresie. Na przykład odbicia zwraca zniekształcone nazwy `Tuple`1` and `krotki`2` z metody rodzajowe `Tuple(Of T)` i `Tuple(Of T0, T1)` w języku Visual Basic lub `Tuple<T>` i spójnej kolekcji`\<T0, T1>` języka Visual C#.  
  
 Dla typów ogólnych z listą argumentów typu jest ujęta w nawiasy, a argumenty typu są oddzielone przecinkami. Na przykład ogólnego <xref:System.Collections.Generic.Dictionary%602> zawiera dwa parametry typu. A <xref:System.Collections.Generic.Dictionary%602> z `MyType` z kluczami typu <xref:System.String> może być reprezentowany w następujący sposób:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Aby określić typu kwalifikowanego zestawu w obrębie listy argumentów typu, należy ująć typu kwalifikowanego zestawu w nawiasach kwadratowych. W przeciwnym razie przecinkami, które rozdzielić nazwa kwalifikowana zestawu są interpretowane jako oddzielającego argumentów typu dodatkowe. Na przykład <xref:System.Collections.Generic.Dictionary%602> z `MyType` z MyAssembly.dll z kluczami typu <xref:System.String>, może być określony w następujący sposób:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Typu kwalifikowanego zestawu mogą być ujęte w nawiasy kwadratowe tylko wtedy, gdy pojawi się on w obrębie listy parametrów typu. Reguły dotyczące wyszukiwania zestawów dla typów kwalifikowaną i niekwalifikowane w liście parametrów typu są takie same jak reguły dla typów nierodzajowe kwalifikowaną i niekwalifikowane.  
  
 Typy dopuszczające wartości null są szczególnych przypadkach typów ogólnych. Na przykład nullable <xref:System.Int32> jest reprezentowany przez ciąg "System.Nullable'1[System.Int32]".  
  
> [!NOTE]
>  W języku C#, C++ i Visual Basic można również uzyskać przy użyciu operatorów typu typy dopuszczające wartości zerowe. Na przykład wartości null <xref:System.Boolean> typu zwracanego przez `typeof(Nullable<bool>)` w języku C#, przez `Nullable<Boolean>::typeid` w języku C++ i przez `GetType(Nullable(Of Boolean))` w języku Visual Basic.  
  
 W poniższej tabeli przedstawiono składnię korzystać z `GetType` dla różnych typów.  
  
|Aby uzyskać|Zastosowanie|  
|------------|---------|  
|Dopuszczające wartości zerowe <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|Niezarządzany wskaźnik do `MyType`|`Type.GetType("MyType*")`|  
|Niezarządzany wskaźnik na wskaźnik do `MyType`|`Type.GetType("MyType**")`|  
|Zarządzane wskaźnik lub odwołanie do `MyType`|`Type.GetType("MyType&")`. Należy pamiętać, że w przeciwieństwie do wskaźników, odwołania mogą zawierać maksymalnie jeden poziom.|  
|Klasy nadrzędnej i zagnieżdżone klasy|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Jednowymiarowa tablica z dolną granicą 0|`Type.GetType("MyArray[]")`|  
|Jednowymiarowa tablica o nieznanym powiązaniem niższego|`Type.GetType("MyArray[*]")`|  
|N wymiarową tablicą|Przecinka (,) wewnątrz nawiasów a sumę n-1 razy. Na przykład `System.Object[,,]` reprezentuje trójwymiarowy `Object` tablicy.|  
|Tablica jest tablicą dwuwymiarową|`Type.GetType("MyArray[][]")`|  
|Prostokątne tablicą dwuwymiarową z nieznanego dolne granice tablicy.|`Type.GetType("MyArray[,]")`|  
|Typem ogólnym z argumentem typu|`Type.GetType("MyGenericType`1[MyType]")`|  
|Typem ogólnym z dwoma argumentami typu|`Type.GetType("MyGenericType`2[MyType,AnotherType]")`|  
|Typem ogólnym z dwoma argumentami typu kwalifikowanego zestawu|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")"|  
|Kwalifikowana zestawu typu ogólnego z argumentem typu kwalifikowanego zestawu|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")"|  
|Typu ogólnego, którego argument typu jest typem ogólnym z dwoma argumentami typu|`Type.GetType("MyGenericType`[AnotherGenericType 1`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 Poniższy przykład pobiera typ `System.Int32` i używa tego typu obiektu do wyświetlenia <xref:System.Type.FullName%2A> właściwość `System.Int32`. Jeśli obiekt typu odwołuje się do zestawu, który nie istnieje, w tym przykładzie zgłasza wyjątek.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> jest <see langword="true" /> i nie znaleziono typu.  - lub - <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> zawiera nieprawidłowe znaki, takie jak karta osadzonych.  - lub - <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> jest pustym ciągiem.  - lub - <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> reprezentuje typ tablicowy z nieprawidłowym rozmiarem.  - lub - <paramref name="typeName" /> reprezentuje tablicę <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> zawiera nieprawidłową składnię. Na przykład "Mojtyp [, *,]".  - lub - <paramref name="typeName" /> reprezentuje typu ogólnego, który ma typ wskaźnika <see langword="ByRef" /> typu, lub <see cref="T:System.Void" /> jako jeden z jego argumentów typu.  - lub - <paramref name="typeName" /> reprezentuje typu ogólnego, który ma nieprawidłową liczbę argumentów typu.  - lub - <paramref name="typeName" /> reprezentuje ogólnego typu, a jeden z jego argumentów typu nie spełnia warunków ograniczenia dla odpowiedniego parametru typu.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> jest <see langword="true" /> i nie znaleziono zestawu lub jednej z jego zależności.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para> [.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.IO.IOException" />, zamiast tego.  </para>
          </block>  Zestaw lub jeden z jego zależności został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i zestaw został skompilowany przy użyciu nowszej wersji.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa kwalifikowana zestawu typ do pobrania. Zobacz <see cref="P:System.Type.AssemblyQualifiedName" />. Jeśli typ jest obecnie wykonywany zestaw lub Mscorlib.dll, wystarczy podać nazwę typu kwalifikowana przez jego przestrzeni nazw.</param>
        <param name="throwOnError">
          <see langword="true" /> Aby zgłosić wyjątek, jeśli nie można odnaleźć typu; <see langword="false" /> do zwrócenia <see langword="null" />. Określanie <see langword="false" /> również pomija inne warunki wyjątek, ale nie wszystkie z nich. Zobacz sekcję Wyjątki.</param>
        <param name="ignoreCase">
          <see langword="true" /> Aby wykonać wyszukiwanie bez uwzględniania wielkości liter dla <c>typeName</c>, <see langword="false" /> Aby wykonać wyszukiwanie z uwzględnieniem wielkości liter dla <c>typeName</c>.</param>
        <summary>Pobiera <see cref="T:System.Type" /> o określonej nazwie, określania, czy chcesz zgłosić wyjątek, jeśli typ nie zostanie znaleziony i wykonać wyszukiwanie z uwzględnieniem wielkości liter.</summary>
        <returns>Typ o określonej nazwie. Jeśli typ nie zostanie znaleziony, <paramref name="throwOnError" /> parametr określa, czy <see langword="null" /> jest zwracany lub jest zgłaszany wyjątek. W niektórych przypadkach, jest zwracany wyjątek, niezależnie od wartości <paramref name="throwOnError" />. Zobacz sekcję Wyjątki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć <xref:System.Type.GetType%2A> metodę, aby uzyskać <xref:System.Type> obiektu dla typu w innym zestawie, jeśli wiesz, jego nazwa kwalifikowana zestawu, który można uzyskać z <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A> powoduje, że ładowanie zestawu określonego w `typeName`. Można również załadowania zestawu przy użyciu <xref:System.Reflection.Assembly.Load%2A> metody, a następnie użyć <xref:System.Type.GetType%2A> lub <xref:System.Reflection.Assembly.GetTypes%2A> metody <xref:System.Reflection.Assembly> klasy można pobrać <xref:System.Type> obiektów. Jeśli typ w zestawie znane programu w czasie kompilacji jest bardziej wydajne, aby użyć `typeof` w języku C# <xref:System.Type.GetType%2A> w języku Visual Basic lub `typeid` w języku C++.  
  
 `GetType` działa tylko na zestawów ładowanych z dysku. Jeśli należy wywołać `GetType` do odszukania typ zdefiniowany w zestawie dynamicznym zdefiniowane przy użyciu <xref:System.Reflection.Emit> usług, możesz uzyskać niespójne działanie. Zachowanie zależy, czy w zestawie dynamicznym jest trwała, to znaczy, utworzone za pomocą `RunAndSave` lub `Save` tryby dostępu <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> wyliczenia. Jeśli w zestawie dynamicznym jest trwałe i został zapisany na dysku przed `GetType` jest wywoływana, moduł ładujący znajduje zestawu zapisane na dysku, ten zestaw ładuje i pobiera typ z tego zestawu. Jeśli zestaw nie został zapisany na dysku po `GetType` jest wywoływana metoda zwraca `null`. `GetType` nie rozpoznaje przejściowej zestawów dynamicznych; w związku z tym wywołaniem `GetType` można pobrać typu na przejściowy zwraca zestawu dynamicznego `null`.  
  
 Aby użyć `GetType` na module dynamicznym subskrybować <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> zdarzeń i wywołanie `GetType` przed zapisaniem. W przeciwnym razie wystąpi dwie kopie zestawu w pamięci.  
  
 `throwOnError` Parametr określa, co się stanie, gdy typ nie zostanie znaleziony i również pomija określone inne warunki wyjątek, zgodnie z opisem w sekcji wyjątki. Niektóre wyjątki są zgłaszane niezależnie od wartości `throwOnError`. Na przykład, jeśli typ zostanie znaleziony, ale nie może zostać załadowany <xref:System.TypeLoadException> jest zgłaszany nawet wtedy, gdy `throwOnError` jest `false`.  
  
 W poniższej tabeli przedstawiono elementy członkowskie klasy podstawowej zwracanych przez `Get` metody, gdy w czasie wykonywania odbicia typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Tablic lub typów COM nie są przeszukiwane przez, chyba że już zostały załadowane do tabeli dostępnych klas.  
  
 `typeName` może być nazwa typu kwalifikowana przez jego przestrzeni nazw lub kwalifikowana nazwa zestawu zawierającego specyfikacja nazwy zestawu. Zobacz <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Jeśli `typeName` zawiera przestrzeń nazw, ale nie nazwy zestawu metoda wyszukiwanie tylko zestawu obiektu wywołującego i Mscorlib.dll, w tej kolejności. Jeśli nazwa typu jest w pełni kwalifikowana nazwą zestawu częściowej lub pełnej, ta metoda wyszukuje w określonym zestawie. Jeśli zestaw ma silną nazwę, wymagana jest nazwa pełny zestaw.  
  
 <xref:System.Type.AssemblyQualifiedName%2A> Właściwość zwraca w pełni kwalifikowana nazwa typu w tym typy zagnieżdżone, nazwa zestawu i argumentów typu. Wszystkie kompilatory, które obsługują aparat plików wykonywalnych języka wspólnego, w trakcie wykonania wyemitują prostą nazwę klasy zagnieżdżonej, a odbicie podczas kwerendy stworzy zniekształcone nazwy zgodnie z następującymi konwencjami.  
  
> [!NOTE]
>  W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw. Na przykład "ProcessorArchitecture = msil". Jednak nie jest uwzględnione w ciągu zwróconego przez <xref:System.Type.AssemblyQualifiedName%2A> właściwości ze względu na zgodność. Można również załadować typów, tworząc <xref:System.Reflection.AssemblyName> obiekt i przekazaniem ich do odpowiedniego przeciążenia <xref:System.Reflection.Assembly.Load%2A> metody. Następnie można użyć <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> metody można załadować typów z zestawu. Zobacz też <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Ogranicznik|Znaczenie|  
|---------------|-------------|  
|Ukośnik odwrotny (\\)|Znak ucieczki.|  
|Backtick (')|Poprzedza co najmniej jedną cyfrę reprezentujący liczbę parametrów typu, znajduje się na końcu nazwy typu ogólnego.|  
|Nawiasy kwadratowe ([])|Umieść listy argumentów typu ogólnego, do skonstruowanego typu ogólnego; w obrębie listy argumentów typu należy ująć typu kwalifikowanego zestawu.|  
|Przecinek (,)|Poprzedza nazwę zestawu.|  
|Kropka (.)|Wskazuje przestrzeń nazw identyfikatorów.|  
|Znak plus (+)|Poprzedza klasę zagnieżdżoną.|  
  
 Na przykład w pełni kwalifikowana nazwa klasy może wyglądać następująco:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Jeśli przestrzeń nazw zostały TopNamespace.Sub+Namespace, a następnie ciąg musi poprzedzać znak plus (+) ze znakiem anulowania (\\) aby zapobiec interpretowany jako separator zagnieżdżenia. Odbicie emituje ten ciąg w następujący sposób:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A "++" staje się "\\+\\+", a "\\"staje się"\\\\".  
  
 Utrwalenia i później użyć do załadowania tego kwalifikowana nazwa <xref:System.Type>. Aby wyszukać i załadować <xref:System.Type>, użyj <xref:System.Type.GetType%2A> albo z typem nazwy lub tylko o nazwie typu kwalifikowanej zestawu. <xref:System.Type.GetType%2A> z typem nazwę tylko będzie szukać <xref:System.Type> w zestawie wywołującego, a następnie w zestawu systemowego. <xref:System.Type.GetType%2A> z zestawu będzie szukać kwalifikowana nazwa typu <xref:System.Type> w dowolnym zestawie.  
  
 Nazwy typów mogą obejmować końcowe znaki, które wyznaczają dodatkowe informacje dotyczące typu, na przykład to, czy typ jest typem odwołania, typem wskaźnika lub typem tablicowym. Aby pobrać nazwę typu bez tych końcowych znaków, należy użyć `t.GetElementType().ToString()`, gdzie `t` jest typem.  
  
 Spacje są istotne we wszystkich składnikach nazwy z wyjątkiem nazwy zestawu. Spacje przed separatorem w nazwie zestawu ',' są istotne, ale spacje po separatorze ',' są ignorowane.  
  
 Nazwa typu ogólnego kończy się ciągiem backtick (\`) następuje cyfr reprezentujący liczbę argumentów typu ogólnego. Celem tego przekręcona nazwa jest umożliwienie kompilatory do obsługi typów ogólnych o takiej samej nazwie, ale różne liczby parametrów typu, występujących w tym samym zakresie. Na przykład odbicia zwraca zniekształcone nazwy `Tuple`1` and `krotki`2` z metody rodzajowe `Tuple(Of T)` i `Tuple(Of T0, T1)` w języku Visual Basic lub `Tuple<T>` i spójnej kolekcji`\<T0, T1>` języka Visual C#.  
  
 Dla typów ogólnych z listą argumentów typu jest ujęta w nawiasy, a argumenty typu są oddzielone przecinkami. Na przykład ogólnego <xref:System.Collections.Generic.Dictionary%602> zawiera dwa parametry typu. A <xref:System.Collections.Generic.Dictionary%602> z `MyType` z kluczami typu <xref:System.String> może być reprezentowany w następujący sposób:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Aby określić typu kwalifikowanego zestawu w obrębie listy argumentów typu, należy ująć typu kwalifikowanego zestawu w nawiasach kwadratowych. W przeciwnym razie przecinkami, które rozdzielić nazwa kwalifikowana zestawu są interpretowane jako oddzielającego argumentów typu dodatkowe. Na przykład <xref:System.Collections.Generic.Dictionary%602> z `MyType` z MyAssembly.dll z kluczami typu <xref:System.String>, może być określony w następujący sposób:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Typu kwalifikowanego zestawu mogą być ujęte w nawiasy kwadratowe tylko wtedy, gdy pojawi się on w obrębie listy parametrów typu. Reguły dotyczące wyszukiwania zestawów dla typów kwalifikowaną i niekwalifikowane w liście parametrów typu są takie same jak reguły dla typów nierodzajowe kwalifikowaną i niekwalifikowane.  
  
 Typy dopuszczające wartości null są szczególnych przypadkach typów ogólnych. Na przykład nullable <xref:System.Int32> jest reprezentowany przez ciąg "System.Nullable'1[System.Int32]".  
  
> [!NOTE]
>  W języku C#, C++ i Visual Basic można również uzyskać przy użyciu operatorów typu typy dopuszczające wartości zerowe. Na przykład wartości null <xref:System.Boolean> typu zwracanego przez `typeof(Nullable<bool>)` w języku C#, przez `Nullable<Boolean>::typeid` w języku C++ i przez `GetType(Nullable(Of Boolean))` w języku Visual Basic.  
  
 W poniższej tabeli przedstawiono składnię korzystać z `GetType` dla różnych typów.  
  
|Aby uzyskać|Zastosowanie|  
|------------|---------|  
|Dopuszczające wartości zerowe <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|Niezarządzany wskaźnik do `MyType`|`Type.GetType("MyType*")`|  
|Niezarządzany wskaźnik na wskaźnik do `MyType`|`Type.GetType("MyType**")`|  
|Zarządzane wskaźnik lub odwołanie do `MyType`|`Type.GetType("MyType&")`. Należy pamiętać, że w przeciwieństwie do wskaźników, odwołania mogą zawierać maksymalnie jeden poziom.|  
|Klasy nadrzędnej i zagnieżdżone klasy|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Jednowymiarowa tablica z dolną granicą 0|`Type.GetType("MyArray[]")`|  
|Jednowymiarowa tablica o nieznanym powiązaniem niższego|`Type.GetType("MyArray[*]")`|  
|N wymiarową tablicą|Przecinka (,) wewnątrz nawiasów a sumę n-1 razy. Na przykład `System.Object[,,]` reprezentuje trójwymiarowy `Object` tablicy.|  
|Tablica jest tablicą dwuwymiarową|`Type.GetType("MyArray[][]")`|  
|Prostokątne tablicą dwuwymiarową z nieznanego dolne granice tablicy.|`Type.GetType("MyArray[,]")`|  
|Typem ogólnym z argumentem typu|`Type.GetType("MyGenericType`1[MyType]")`|  
|Typem ogólnym z dwoma argumentami typu|`Type.GetType("MyGenericType`2[MyType,AnotherType]")`|  
|Typem ogólnym z dwoma argumentami typu kwalifikowanego zestawu|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")"|  
|Kwalifikowana zestawu typu ogólnego z argumentem typu kwalifikowanego zestawu|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")"|  
|Typu ogólnego, którego argument typu jest typem ogólnym z dwoma argumentami typu|`Type.GetType("MyGenericType`[AnotherGenericType 1`2[MyType,AnotherType]]")`|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> jest <see langword="true" /> i nie znaleziono typu.  - lub - <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> zawiera nieprawidłowe znaki, takie jak karta osadzonych.  - lub - <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> jest pustym ciągiem.  - lub - <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> reprezentuje typ tablicowy z nieprawidłowym rozmiarem.  - lub - <paramref name="typeName" /> reprezentuje tablicę <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> zawiera nieprawidłową składnię. Na przykład "Mojtyp [, *,]".  - lub - <paramref name="typeName" /> reprezentuje typu ogólnego, który ma typ wskaźnika <see langword="ByRef" /> typu, lub <see cref="T:System.Void" /> jako jeden z jego argumentów typu.  - lub - <paramref name="typeName" /> reprezentuje typu ogólnego, który ma nieprawidłową liczbę argumentów typu.  - lub - <paramref name="typeName" /> reprezentuje ogólnego typu, a jeden z jego argumentów typu nie spełnia warunków ograniczenia dla odpowiedniego parametru typu.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> jest <see langword="true" /> i nie znaleziono zestawu lub jednej z jego zależności.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.  - lub - w wersji 2.0 lub nowszej środowisko uruchomieniowe języka wspólnego jest aktualnie załadowany i zestaw został skompilowany przy użyciu nowszej wersji.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa typu w celu pobrania. Jeśli <c>typeResolver</c> podano parametru, nazwa typu mogą być dowolnego ciągu, który <c>typeResolver</c> jest w stanie rozwiązywania. Jeśli <c>assemblyResolver</c> pod warunkiem, lub jeśli rozpoznawania typu Standardowy jest używany, parametr jest <c>typeName</c> musi być kwalifikowana nazwa zestawu (zobacz <see cref="P:System.Type.AssemblyQualifiedName" />), chyba że typ jest aktualnie wykonywanych zestaw lub w pliku Mscorlib.dll, w których przypadku wystarczy podać nazwę typu kwalifikowana przez jego przestrzeni nazw.</param>
        <param name="assemblyResolver">Metody, która lokalizuje i zwraca zestaw, który określono w <c>typeName</c>. Nazwa zestawu jest przekazywana do <c>assemblyResolver</c> jako <see cref="T:System.Reflection.AssemblyName" /> obiektu. Jeśli <c>typeName</c> nie zawiera nazwy zestawu <c>assemblyResolver</c> nie jest wywoływany. Jeśli <c>assemblyResolver</c> nie jest podany, standardowy zestaw rozpoznawania jest wykonywana.  Uwaga nie przekazuj z nieznaną lub niezaufaną wywoływania metod. W ten sposób może spowodować podniesienie uprawnień dla złośliwego kodu. Użyj tylko określonych przez siebie metod lub tych, które znasz.</param>
        <param name="typeResolver">Metody, która lokalizuje i zwraca typ, który jest określony przez <c>typeName</c> z zestawu, który jest zwracany przez <c>assemblyResolver</c> lub rozpoznawania zestawu standardowych. Jeśli zestaw nie zostanie podany, <c>typeResolver</c> zapewniają jednej metody. Metoda ma także parametr, który określa, czy do wyszukiwania bez uwzględniania wielkości liter; <see langword="false" /> została przekazana do tego parametru.  Uwaga nie przekazuj z nieznaną lub niezaufaną wywoływania metod.</param>
        <summary>Pobiera typ o określonej nazwie, opcjonalnie dostarczanie niestandardowych metod można rozpoznać zestawu i typu.</summary>
        <returns>Typ o określonej nazwie lub <see langword="null" /> Jeśli typ nie zostanie znaleziony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Scenariusze użycia tej metody i szczegółowe informacje o `assemblyResolver` i `typeResolver` parametrów można znaleźć w <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenie metody.  
  
> [!NOTE]
>  Jeśli `typeName` nie można znaleźć, wywołanie <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> metoda zwraca `null`. Nie zgłasza wyjątek. Do kontrolowania tego, czy jest zgłaszany wyjątek, wywoływać przeciążenia <xref:System.Type.GetType%2A> metodę, która ma `throwOnError` parametru.  
  
 Wywoływanie przeciążenie tej metody jest taka sama jak wywołanie <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenie metody i określając `false` dla `throwOnError` i `ignoreCase` parametrów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.ArgumentException">Błąd występuje, gdy <paramref name="typeName" /> jest analizowana na nazwę typu i nazwy zestawu (na przykład, jeśli nazwa typu prostego zawiera znaki specjalne niezmienionym znaczeniu).  - lub - <paramref name="typeName" /> reprezentuje typu ogólnego, który ma typ wskaźnika <see langword="ByRef" /> typu, lub <see cref="T:System.Void" /> jako jeden z jego argumentów typu.  - lub - <paramref name="typeName" /> reprezentuje typu ogólnego, który ma nieprawidłową liczbę argumentów typu.  - lub - <paramref name="typeName" /> reprezentuje ogólnego typu, a jeden z jego argumentów typu nie spełnia warunków ograniczenia dla odpowiedniego parametru typu.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> reprezentuje tablicę <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.  - lub - <paramref name="typeName" /> zawiera Nieprawidłowa nazwa zestawu.  - lub - <paramref name="typeName" /> jest prawidłową nazwą zestawu bez nazwy typu.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.  - lub - zestaw został skompilowany przy użyciu nowszej wersji środowiska CLR niż wersja, który jest aktualnie załadowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa typu w celu pobrania. Jeśli <c>typeResolver</c> podano parametru, nazwa typu mogą być dowolnego ciągu, który <c>typeResolver</c> jest w stanie rozwiązywania. Jeśli <c>assemblyResolver</c> pod warunkiem, lub jeśli rozpoznawania typu Standardowy jest używany, parametr jest <c>typeName</c> musi być kwalifikowana nazwa zestawu (zobacz <see cref="P:System.Type.AssemblyQualifiedName" />), chyba że typ jest aktualnie wykonywanych zestaw lub w pliku Mscorlib.dll, w których przypadku wystarczy podać nazwę typu kwalifikowana przez jego przestrzeni nazw.</param>
        <param name="assemblyResolver">Metody, która lokalizuje i zwraca zestaw, który określono w <c>typeName</c>. Nazwa zestawu jest przekazywana do <c>assemblyResolver</c> jako <see cref="T:System.Reflection.AssemblyName" /> obiektu. Jeśli <c>typeName</c> nie zawiera nazwy zestawu <c>assemblyResolver</c> nie jest wywoływany. Jeśli <c>assemblyResolver</c> nie jest podany, standardowy zestaw rozpoznawania jest wykonywana.  Uwaga nie przekazuj z nieznaną lub niezaufaną wywoływania metod. W ten sposób może spowodować podniesienie uprawnień dla złośliwego kodu. Użyj tylko określonych przez siebie metod lub tych, które znasz.</param>
        <param name="typeResolver">Metody, która lokalizuje i zwraca typ, który jest określony przez <c>typeName</c> z zestawu, który jest zwracany przez <c>assemblyResolver</c> lub rozpoznawania zestawu standardowych. Jeśli zestaw nie zostanie podany, metoda zapewnia jeden. Metoda ma także parametr, który określa, czy do wyszukiwania bez uwzględniania wielkości liter; <see langword="false" /> została przekazana do tego parametru.  Uwaga nie przekazuj z nieznaną lub niezaufaną wywoływania metod.</param>
        <param name="throwOnError">
          <see langword="true" /> Aby zgłosić wyjątek, jeśli nie można odnaleźć typu; <see langword="false" /> do zwrócenia <see langword="null" />. Określanie <see langword="false" /> również pomija inne warunki wyjątek, ale nie wszystkie z nich. Zobacz sekcję Wyjątki.</param>
        <summary>Pobiera typ o określonej nazwie, określająca, czy do zgłoszenia wyjątku, jeśli typ nie zostanie znaleziony, a opcjonalnie dostarczanie niestandardowych metod można rozpoznać zestawu i typu.</summary>
        <returns>Typ o określonej nazwie. Jeśli typ nie zostanie znaleziony, <paramref name="throwOnError" /> parametr określa, czy <see langword="null" /> jest zwracany lub jest zgłaszany wyjątek. W niektórych przypadkach, jest zwracany wyjątek, niezależnie od wartości <paramref name="throwOnError" />. Zobacz sekcję Wyjątki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Scenariusze użycia tej metody i szczegółowe informacje o `assemblyResolver` i `typeResolver` parametrów można znaleźć w <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenie metody.  
  
 Wywoływanie przeciążenie tej metody jest taka sama jak wywołanie <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenie metody i określając `false` dla `ignoreCase` parametru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> jest <see langword="true" /> i nie znaleziono typu.  - lub - <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> zawiera nieprawidłowe znaki, takie jak karta osadzonych.  - lub - <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> jest pustym ciągiem.  - lub - <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> reprezentuje typ tablicowy z nieprawidłowym rozmiarem.  - lub - <paramref name="typeName" /> reprezentuje tablicę <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">Błąd występuje, gdy <paramref name="typeName" /> jest analizowana na nazwę typu i nazwy zestawu (na przykład, jeśli nazwa typu prostego zawiera znaki specjalne niezmienionym znaczeniu).  - lub - <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> zawiera nieprawidłową składnię "(na przykład MyType[,*,]").  - lub - <paramref name="typeName" /> reprezentuje typu ogólnego, który ma typ wskaźnika <see langword="ByRef" /> typu, lub <see cref="T:System.Void" /> jako jeden z jego argumentów typu.  - lub - <paramref name="typeName" /> reprezentuje typu ogólnego, który ma nieprawidłową liczbę argumentów typu.  - lub - <paramref name="typeName" /> reprezentuje ogólnego typu, a jeden z jego argumentów typu nie spełnia warunków ograniczenia dla odpowiedniego parametru typu.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> jest <see langword="true" /> i nie znaleziono zestawu lub jednej z jego zależności.  - lub - <paramref name="typeName" /> zawiera Nieprawidłowa nazwa zestawu.  - lub - <paramref name="typeName" /> jest prawidłową nazwą zestawu bez nazwy typu.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.  - lub - zestaw został skompilowany przy użyciu nowszej wersji środowiska CLR niż wersja, który jest aktualnie załadowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa typu w celu pobrania. Jeśli <c>typeResolver</c> podano parametru, nazwa typu mogą być dowolnego ciągu, który <c>typeResolver</c> jest w stanie rozwiązywania. Jeśli <c>assemblyResolver</c> pod warunkiem, lub jeśli rozpoznawania typu Standardowy jest używany, parametr jest <c>typeName</c> musi być kwalifikowana nazwa zestawu (zobacz <see cref="P:System.Type.AssemblyQualifiedName" />), chyba że typ jest aktualnie wykonywanych zestaw lub w pliku Mscorlib.dll, w których przypadku wystarczy podać nazwę typu kwalifikowana przez jego przestrzeni nazw.</param>
        <param name="assemblyResolver">Metody, która lokalizuje i zwraca zestaw, który określono w <c>typeName</c>. Nazwa zestawu jest przekazywana do <c>assemblyResolver</c> jako <see cref="T:System.Reflection.AssemblyName" /> obiektu. Jeśli <c>typeName</c> nie zawiera nazwy zestawu <c>assemblyResolver</c> nie jest wywoływany. Jeśli <c>assemblyResolver</c> nie jest podany, standardowy zestaw rozpoznawania jest wykonywana.  Uwaga nie przekazuj z nieznaną lub niezaufaną wywoływania metod. W ten sposób może spowodować podniesienie uprawnień dla złośliwego kodu. Użyj tylko określonych przez siebie metod lub tych, które znasz.</param>
        <param name="typeResolver">Metody, która lokalizuje i zwraca typ, który jest określony przez <c>typeName</c> z zestawu, który jest zwracany przez <c>assemblyResolver</c> lub rozpoznawania zestawu standardowych. Jeśli zestaw nie zostanie podany, metoda zapewnia jeden. Metoda ma także parametr, który określa, czy do wyszukiwania bez uwzględniania wielkości liter; wartość <c>ignoreCase</c> została przekazana do tego parametru.  Uwaga nie przekazuj z nieznaną lub niezaufaną wywoływania metod.</param>
        <param name="throwOnError">
          <see langword="true" /> Aby zgłosić wyjątek, jeśli nie można odnaleźć typu; <see langword="false" /> do zwrócenia <see langword="null" />. Określanie <see langword="false" /> również pomija inne warunki wyjątek, ale nie wszystkie z nich. Zobacz sekcję Wyjątki.</param>
        <param name="ignoreCase">
          <see langword="true" /> Aby wykonać wyszukiwanie bez uwzględniania wielkości liter dla <c>typeName</c>, <see langword="false" /> Aby wykonać wyszukiwanie z uwzględnieniem wielkości liter dla <c>typeName</c>.</param>
        <summary>Pobiera typ o określonej nazwie, określania, czy do wyszukiwania, z uwzględnieniem wielkości liter i Zgłoś wyjątek, jeśli typ nie zostanie znaleziony i opcjonalnie dostarczanie niestandardowych metod można rozpoznać zestawu i typu.</summary>
        <returns>Typ o określonej nazwie. Jeśli typ nie zostanie znaleziony, <paramref name="throwOnError" /> parametr określa, czy <see langword="null" /> jest zwracany lub jest zgłaszany wyjątek. W niektórych przypadkach, jest zwracany wyjątek, niezależnie od wartości <paramref name="throwOnError" />. Zobacz sekcję Wyjątki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia metody i jego skojarzony przeciążenia (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> i <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) zastąpić domyślną implementację elementu <xref:System.Type.GetType%2A> metody z bardziej elastyczne implementacji. Podając własne metody, które rozpoznać nazwy typu i nazwy zestawy zawierające je, należy wykonać następujące:  
  
-   Kontrola wersji zestawu typu są ładowane z.  
  
-   Podaj inne miejsce do wyszukania nazwy typu, który nie zawiera nazwy zestawu.  
  
-   Ładowanie zestawów przy użyciu nazwy zestawu z częściowa.  
  
-   Zwraca podklasy <xref:System.Type?displayProperty=nameWithType> nie są tworzone przez środowisko uruchomieniowe języka wspólnego (CLR).  
  
 Na przykład w serializacji z tolerancją dla wersji ta metoda umożliwia wyszukiwanie w zestawie "optymalnie" korzystając z częściowa nazwa. Inne przeciążenia <xref:System.Type.GetType%2A> metoda wymaga zestawu kwalifikowaną nazwę typu, który zawiera numer wersji.  
  
 Alternatywnych implementacji system typów może być konieczne zwrócić podklasy <xref:System.Type?displayProperty=nameWithType> nie są tworzone przez środowisko CLR; wszystkie typy, które są zwracane przez inne przeciążenia <xref:System.Type.GetType%2A> metody są typów środowiska wykonawczego.  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>Uwagi dotyczące użytkowania  
 To przeciążenie metody i jego skojarzony przeciążenia przeanalizować `typeName` w nazwie typu i nazwy zestawu, a następnie rozpoznawania nazw. Rozpoznawanie nazwy zestawu występuje przed rozpoznawanie nazwy typu, ponieważ nazwa typu muszą zostać rozwiązane w kontekście zestawu.  
  
> [!NOTE]
>  Jeśli znasz koncepcji nazwy typu kwalifikowanego zestawu, zobacz <xref:System.Type.AssemblyQualifiedName%2A> właściwości.  
  
 Jeśli `typeName` nie jest nazwa kwalifikowana zestawu rozpoznawania zestawu jest pomijana. Można rozwiązać typu niekwalifikowane nazwy w kontekście Mscorlib.dll lub obecnie wykonywany zestaw lub opcjonalnie można podać zestawu w `typeResolver` parametru. Łącznie lub pominięcie nazwy zestawu dla różnych rodzajów rozpoznawania nazw są wyświetlane jako tabeli [mieszanych rozpoznawanie nazw](#mixed_name_resolution) sekcji.  
  
 Uwagi dotyczące użycia ogólne:  
  
-   Nie przekazuj metody `assemblyResolver` lub `typeResolver` jeśli pochodzą z nieznaną lub niezaufaną obiekty wywołujące. Użyj tylko określonych przez siebie metod lub tych, które znasz.  
  
    > [!CAUTION]
    >  Przy użyciu metod z nieznaną lub niezaufaną wywołań może spowodować podniesienie uprawnień dla złośliwego kodu.  
  
-   W przypadku pominięcia `assemblyResolver` i/lub `typeResolver` parametrów, wartość `throwOnError` parametr jest przekazywany do metody, które przeprowadzają rozpoznawanie domyślne.  
  
-   Jeśli `throwOnError` jest `true`, ta metoda zgłasza <xref:System.TypeLoadException> podczas `typeResolver` zwraca `null`, a <xref:System.IO.FileNotFoundException> podczas `assemblyResolver` zwraca `null`.  
  
-   Ta metoda nie przechwytuje wyjątków zgłaszanych przez `assemblyResolver` i `typeResolver`. Ponosisz odpowiedzialność za wszelkie wyjątki zwracane przez metody rozpoznawania nazw.  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>Rozpoznawanie zespołów  
 `assemblyResolver` Metoda <xref:System.Reflection.AssemblyName> obiektu, który jest generowany, analizując ciąg nazwy zestawu, który znajduje się w `typeName`. Jeśli `typeName` nie zawiera nazwy zestawu `assemblyResolver` nie jest wywoływany i `null` jest przekazywana do `typeResolver`.  
  
 Jeśli `assemblyResolver` nie jest podany, standardowy zestaw sondowanie jest używana do lokalizowania zestawu. Jeśli `assemblyResolver` podano, <xref:System.Type.GetType%2A> metody, które nie są standardowe sondowanie; w takim przypadku upewnij się, że Twoje `assemblyResolver` może obsługiwać wszystkie zestawy przekazywania do niej.  
  
 `assemblyResolver` Metoda powinna zwrócić `null` Jeśli nie można rozpoznać zestawu. Jeśli `assemblyResolver` zwraca `null`, `typeResolver` nie jest wywoływany i żadne dalsze przetwarzanie nie występuje; Ponadto, jeśli `throwOnError` jest `true`, <xref:System.IO.FileNotFoundException> jest generowany.  
  
 Jeśli <xref:System.Reflection.AssemblyName> przekazywany do `assemblyResolver` jest częściowym nazwy, co najmniej jedna z jego części `null`. Na przykład, jeśli go nie ma wersji <xref:System.Reflection.AssemblyName.Version%2A> jest właściwość `null`. Jeśli <xref:System.Reflection.AssemblyName.Version%2A> właściwości, <xref:System.Reflection.AssemblyName.CultureInfo%2A> właściwości i <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> wszystkie zwracany — metoda `null`, a następnie podano tylko prosta nazwa zestawu. `assemblyResolver` Metody można użyć lub Ignoruj wszystkie części nazwy zestawu.  
  
 Efekty opcje rozdzielczości w innym zestawie są wyświetlane jako tabeli [mieszanych rozpoznawanie nazw](#mixed_name_resolution) sekcji, aby nazwy typów prostych i kwalifikowaną dla zestawu.  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>Rozpoznawanie typów  
 Jeśli `typeName` nie określa nazwy zestawu `typeResolver` zawsze jest wywoływana. Jeśli `typeName` Określa nazwę zestawu `typeResolver` jest wywoływana tylko wtedy, gdy rozpoznać nazwy zestawu. Jeśli `assemblyResolver` lub standardowy zestaw sondowanie zwraca `null`, `typeResolver` nie jest wywoływany.  
  
 `typeResolver` Metody odbiera trzech argumentów:  
  
-   Zestaw do wyszukiwania lub `null` Jeśli `typeName` nie zawiera nazwy zestawu.  
  
-   Prosta nazwa tego typu. W przypadku typu zagnieżdżonego to najbardziej zewnętrznego typu zawierającego. W przypadku typu ogólnego to prosta nazwa typu ogólnego.  
  
-   Wartość logiczna, która jest `true` Jeśli wielkość liter w nazwach typów jest mają być ignorowane.  
  
 Implementacja określa sposób, używane są następujące argumenty. `typeResolver` Metoda powinna zwrócić `null` Jeśli nie można rozpoznać typu. Jeśli `typeResolver` zwraca `null` i `throwOnError` jest `true`, to przeciążenie metody <xref:System.Type.GetType%2A> zgłasza <xref:System.TypeLoadException>.  
  
 Skutków opcje rozpoznawania innego typu są wyświetlane jako tabeli [mieszanych rozpoznawanie nazw](#mixed_name_resolution) sekcji, aby nazwy typów prostych i kwalifikowaną dla zestawu.  
  
#### <a name="resolving-nested-types"></a>Rozpoznawanie zagnieżdżonych typów  
 Jeśli `typeName` jest typem zagnieżdżonym tylko nazwę peryferyjnych typ zawierający jest przekazywana do `typeResolver`. Gdy `typeResolver` zwraca tego typu <xref:System.Type.GetNestedType%2A> metoda jest wywoływana cyklicznie, dopóki najbardziej wewnętrznego typu zagnieżdżonego zostanie rozwiązany.  
  
#### <a name="resolving-generic-types"></a>Rozpoznawanie typów rodzajowych  
 <xref:System.Type.GetType%2A> Jest wywoływany rekursywnie do rozpoznawania typów ogólnych: aby rozpoznać typu ogólnego, a następnie Rozwiąż jego argumentów typu. W przypadku argumentu typu ogólnego, <xref:System.Type.GetType%2A> jest wywoływany rekursywnie rozwiązać jego argumentów typu, i tak dalej.  
  
 Kombinacja `assemblyResolver` i `typeResolver` musisz zapewnić musi umożliwiać wszystkie poziomy to rekursji. Załóżmy na przykład, możesz podać `assemblyResolver` steruje ładowania `MyAssembly`. Załóżmy, że chcesz usunąć typ ogólny `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` w języku Visual Basic). Następująca nazwa typu ogólnego może przekazać:  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 Zwróć uwagę, że `MyType` jest argumentem typu tylko kwalifikowanego zestawu. Nazwy <xref:System.Collections.Generic.Dictionary%602> i <xref:System.String> klasy nie są kwalifikowaną dla zestawu. Twoje `typeResolver` stanie dojścia musi być jednym z zestawów lub `null`, ponieważ odbieranie `null` dla <xref:System.Collections.Generic.Dictionary%602> i <xref:System.String>. Może obsługiwać tego przypadku wywołując przeciążenia <xref:System.Type.GetType%2A> metody pobierającej ciągu, ponieważ obie nazwy niekwalifikowanej typów znajdują się w pliku Mscorlib.dll:  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 `assemblyResolver` Metoda nie jest wywoływana dla typu słownika i ciąg, ponieważ te nazwy typów nie jest kwalifikowana zestawu.  
  
 Załóżmy, że zamiast `System.String`, w pierwszym typie argumentów ogólnych `YourType`, z `YourAssembly`:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 Ponieważ ten zestaw nie Mscorlib.dll ani obecnie wykonywany zestaw, nie można rozpoznać `YourType` bez kwalifikowana nazwa zestawu. Ponieważ Twoje `assemblyResolve` będzie wywoływany rekursywnie, musi być w stanie obsłużyć tego przypadku. Zamiast zwracać `null` dla zestawów innych niż `MyAssembly`, wykonuje obecnie ładowanie zestawu przy użyciu dostarczonego <xref:System.Reflection.AssemblyName> obiektu.  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 Powrót do [notatki dotyczące użytkowania](#usage_notes).  
  
#### <a name="resolving-type-names-with-special-characters"></a>Rozpoznawanie nazw typów ze znakami specjalnymi  
 Niektóre znaki mają specjalne znaczenie w kwalifikowana nazwa zestawu. Nazwa typu prostego zawiera tych znaków, znaków spowodować błędy analizy gdy prosta nazwa jest częścią kwalifikowana nazwa zestawu. Aby uniknąć błędów podczas analizowania, musi Usuń specjalne znaki kreski ułamkowej odwróconej, zanim można przekazać nazwa kwalifikowana zestawu <xref:System.Type.GetType%2A> metody. Na przykład, jeśli typ ma nazwę `Strange]Type`, znak ucieczki muszą zostać dodane przed nawiasem kwadratowym w następujący sposób: `Strange\]Type`.  
  
> [!NOTE]
>  Nazwy z tych znaków specjalnych nie można utworzyć w języku Visual Basic lub C#, ale można utworzyć przy użyciu języka pośredniego firmy Microsoft (MSIL) lub przez emitowanie dynamicznych zestawów.  
  
 W poniższej tabeli przedstawiono znaki specjalne dla nazwy typu.  
  
|Znak|Znaczenie|  
|---------------|-------------|  
|`,` (przecinek)|Ogranicznik dla nazwy kwalifikowanej zestawu.|  
|`[]` (nawiasy kwadratowe)|Jako pary sufiks wskazuje typ tablicowy; jako pary ogranicznik umieszcza listy argumentów ogólnych i kwalifikowana nazwa zestawu.|  
|`&` (ampersand)|Sufiks wskazuje, że typ jest typem referencyjnym.|  
|`*` (gwiazdkę)|Sufiks wskazuje, że typ jest typem wskaźnika.|  
|`+` (plus)|Ogranicznik dla typów zagnieżdżonych.|  
|`\` (ukośnik odwrotny)|Znak ucieczki.|  
  
 Właściwości, takie jak <xref:System.Type.AssemblyQualifiedName%2A> return prawidłowo wpisywany ciągów. Należy podać poprawnie zmienionym ciągi do <xref:System.Type.GetType%2A> metody. Z kolei <xref:System.Type.GetType%2A> metoda przekazuje poprawnie zmienionym nazwy do `typeResolver` oraz metody rozpoznawania typu domyślnego. Należy porównać nazwy do nazwy niezmienionym znaczeniu w `typeResolver`, należy usunąć znaki specjalne.  
  
 Powrót do [notatki dotyczące użytkowania](#usage_notes).  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>Rozpoznawanie nazw mieszanych  
 W poniższej tabeli przedstawiono interakcje między `assemblyResolver`, `typeResolver`i rozpoznawania nazw domyślnego dla wszystkich kombinacji nazwy typu i nazwy zestawu w `typeName`:  
  
|Nazwa typu zawartości|Metoda rozpoznawania zestawu|Metody rozpoznawania typu|Wynik|  
|---------------------------|------------------------------|--------------------------|------------|  
|typ, zestaw|null|null|Odpowiednikiem wywołania <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> przeciążenie metody.|  
|typ, zestaw|podano|null|`assemblyResolver` Zwraca zestaw i zwraca `null` Jeśli nie można rozpoznać zestawu. Jeśli nie zostanie rozwiązany, zestaw <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> przeciążenie metody można załadować typu z zestawu; w przeciwnym razie nie prób nie można rozpoznać typu.|  
|typ, zestaw|null|podano|Odpowiednikiem konwertowania nazwy zestawu do <xref:System.Reflection.AssemblyName> obiektów i wywoływania <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> przeciążenie metody można pobrać zestawu. Jeśli zestaw nie zostanie rozwiązany, są przekazywane do `typeResolver`; w przeciwnym razie `typeResolver` nie jest wywoływany i nie istnieje żadne dalsze próby rozwiązania typu.|  
|typ, zestaw|podano|podano|`assemblyResolver` Zwraca zestaw i zwraca `null` Jeśli nie można rozpoznać zestawu. Jeśli zestaw nie zostanie rozwiązany, są przekazywane do `typeResolver`; w przeciwnym razie `typeResolver` nie jest wywoływany i nie istnieje żadne dalsze próby rozwiązania typu.|  
|— typ|wartość NULL, podana|null|Odpowiednikiem wywołania <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> przeciążenie metody. Ponieważ nie podano nazwy zestawu, przeszukiwane są tylko Mscorlib.dll i obecnie wykonywany zestaw. Jeśli `assemblyResolver` została podana, zostanie zignorowany.|  
|— typ|wartość NULL, podana|podano|`typeResolver` Po wywołaniu i `null` została przekazana dla zestawu. `typeResolver` można podać typ z dowolnego zestawu, w tym zestawów, który ładuje do tego celu. Jeśli `assemblyResolver` została podana, zostanie zignorowany.|  
|zestaw|wartość NULL, podana|wartość NULL, podana|A <xref:System.IO.FileLoadException> jest zgłaszany, ponieważ nazwa zestawu jest analizowana, tak jakby był on nazwę typu kwalifikowanego zestawu. Powoduje to nieprawidłowa nazwa zestawu.|  
  
 Powrót do: [notatki dotyczące użytkowania](#usage_notes), [rozwiązywanie zestawów](#resolving_assemblies), [rozpoznawania typów](#resolving_types).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> jest <see langword="true" /> i nie znaleziono typu.  - lub - <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> zawiera nieprawidłowe znaki, takie jak karta osadzonych.  - lub - <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> jest pustym ciągiem.  - lub - <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> reprezentuje typ tablicowy z nieprawidłowym rozmiarem.  - lub - <paramref name="typeName" /> reprezentuje tablicę <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">Błąd występuje, gdy <paramref name="typeName" /> jest analizowana na nazwę typu i nazwy zestawu (na przykład, jeśli nazwa typu prostego zawiera znaki specjalne niezmienionym znaczeniu).  - lub - <paramref name="throwOnError" /> jest <see langword="true" /> i <paramref name="typeName" /> zawiera nieprawidłową składnię "(na przykład MyType[,*,]").  - lub - <paramref name="typeName" /> reprezentuje typu ogólnego, który ma typ wskaźnika <see langword="ByRef" /> typu, lub <see cref="T:System.Void" /> jako jeden z jego argumentów typu.  - lub - <paramref name="typeName" /> reprezentuje typu ogólnego, który ma nieprawidłową liczbę argumentów typu.  - lub - <paramref name="typeName" /> reprezentuje ogólnego typu, a jeden z jego argumentów typu nie spełnia warunków ograniczenia dla odpowiedniego parametru typu.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> jest <see langword="true" /> i nie znaleziono zestawu lub jednej z jego zależności.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.  - lub - <paramref name="typeName" /> zawiera Nieprawidłowa nazwa zestawu.  - lub - <paramref name="typeName" /> jest prawidłową nazwą zestawu bez nazwy typu.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.  - lub - zestaw został skompilowany przy użyciu nowszej wersji środowiska CLR niż wersja, który jest aktualnie załadowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">Tablicę obiektów, których typy można określić.</param>
        <summary>Pobiera typy obiektów w określonej tablicy.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiekty reprezentujące typy odpowiednich elementów w <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Type.GetTypeArray%2A> metody, aby wyświetlić listę typów elementów tablicy.  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> jest <see langword="null" />.  - lub - jedno lub więcej elementów w <paramref name="args" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjatory klasy są wywoływane i co najmniej jeden zgłasza wyjątek.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Typ, którego podstawowy wpisz kod w celu uzyskania.</param>
        <summary>Pobiera kod typu podstawowego określonego <see cref="T:System.Type" />.</summary>
        <returns>Kod źródłowy typ lub <see cref="F:System.TypeCode.Empty" /> Jeśli <paramref name="type" /> jest <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przy dziedziczeniu z <xref:System.Type>, aby zmienić zachowanie tej metody przez zastąpienie <xref:System.Type.GetTypeCodeImpl%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób <xref:System.TypeCode> można wyliczenia. W bloku decyzji wewnątrz `WriteObjectInfo` metody <xref:System.TypeCode> z <xref:System.Object> parametru się zbadana i odpowiedni komunikat jest wyświetlony w konsoli.  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca podstawowy kod typu to <see cref="T:System.Type" /> wystąpienia.</summary>
        <returns>Kod typu podstawowego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapewnia implementację `static` (w języku C#) lub `Shared` (w języku Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> metody. Przy dziedziczeniu z <xref:System.Type>, mogą przesłaniać tę metodę do własnych implementacji programu <xref:System.Type.GetTypeCode%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera typ skojarzony z identyfikatorem określonej klasy (CLSID).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">Identyfikator CLSID typu, który można pobrać.</param>
        <summary>Pobiera typ skojarzony z identyfikatorem określonej klasy (CLSID).</summary>
        <returns>
          <see langword="System.__ComObject" /> niezależnie od tego, czy identyfikator CLSID jest nieprawidłowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> — Metoda obsługuje późnym wiązaniem dostęp do niezarządzanego obiektów COM z aplikacji .NET Framework, gdy wiesz identyfikator klasy obiektu modelu COM (CLSID).  Identyfikator klasy dla klasy COM jest zdefiniowany w kluczu HKEY_CLASSES_ROOT\CLSID rejestru. Można pobrać wartość <xref:System.Type.IsCOMObject%2A> właściwości w celu określenia, czy obiekt modelu COM typ zwracany przez tę metodę.  
  
> [!TIP]
>  Możesz wywołać <xref:System.Type.GetTypeFromProgID%2A> metodę dostępu z późnym wiązaniem modelowi COM obiekty którego identyfikator programowy (ProgID) znasz.  
  
 Tworzenia wystąpienia obiektu COM niezarządzane z jego identyfikator CLSID jest procesem dwuetapowym:  
  
1.  Pobierz <xref:System.Type> obiekt, który reprezentuje`__ComObject` odpowiadający identyfikatora CLSID, wywołując <xref:System.Type.GetTypeFromCLSID%2A> metody.  
  
2.  Wywołanie <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metody do tworzenia wystąpienia obiektu COM.  
  
 Zapoznaj się z przykładem ilustrację.  
  
 <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> Przeciążenia ignoruje wszystkie wyjątki, które mogą wystąpić podczas tworzenia wystąpienia <xref:System.Type> na podstawie obiektu `clsid` argumentu. Należy pamiętać, że żaden wyjątek jest zgłaszany, jeśli `clsid` nie znaleziono w rejestrze.  
  
   
  
## Examples  
 W poniższym przykładzie użyto identyfikatora CLSID programu Microsoft Word [obiektu aplikacji](http://msdn.microsoft.com/library/office/ff838565.aspx) można pobrać typu modelu COM, który reprezentuje aplikację Microsoft Word. Następnie tworzy wystąpienie typu przez wywołanie metody <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metody i zamyka przez wywołanie metody [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) metody.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Ta metoda jest przeznaczona do użycia podczas pracy z obiektami COM, nie z obiektami środowiska .NET Framework. Wszystkie zarządzane obiekty, w tym te, które są widoczne dla modelu COM (to znaczy ich <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atrybutu <see langword="true" />) ma identyfikatora GUID, który jest zwracany przez <see cref="P:System.Type.GUID" /> właściwości. Mimo że metoda zwraca <see cref="T:System.Type" /> obiekty obiekt, który odpowiada identyfikator GUID dla programu .NET Framework, którego nie można użyć <see cref="T:System.Type" /> obiekt, aby utworzyć wystąpienie typu przez wywołanie metody <see cref="M:System.Activator.CreateInstance(System.Type)" /> metody, jak przedstawiono na poniższym przykładzie.  [! code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  Zamiast tego <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> należy używać tylko w celu pobrania identyfikatora GUID niezarządzanego obiektu modelu COM, a powstałe w ten sposób <see cref="T:System.Type" /> obiekt, który jest przekazywany do <see cref="M:System.Activator.CreateInstance(System.Type)" /> metoda musi reprezentować obiekt COM niezarządzane.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">Identyfikator CLSID typu, który można pobrać.</param>
        <param name="throwOnError">
          <see langword="true" /> Aby zgłosić wszelkie wyjątku, który występuje.  - lub - <see langword="false" /> ignoruje wszystkie wyjątku, który występuje.</param>
        <summary>Pobiera typ skojarzony z identyfikatorem określonej klasy (CLSID) określająca, czy do zgłoszenia wyjątku, jeśli wystąpi błąd podczas ładowania typu.</summary>
        <returns>
          <see langword="System.__ComObject" /> niezależnie od tego, czy identyfikator CLSID jest nieprawidłowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> — Metoda obsługuje późnym wiązaniem dostęp do niezarządzanego obiektów COM z aplikacji .NET Framework, gdy wiesz identyfikator klasy obiektu modelu COM (CLSID).  Identyfikator klasy dla klasy COM jest zdefiniowany w kluczu HKEY_CLASSES_ROOT\CLSID rejestru. Można pobrać wartość <xref:System.Type.IsCOMObject%2A> właściwości w celu określenia, czy obiekt modelu COM typ zwracany przez tę metodę.  
  
> [!TIP]
>  Możesz wywołać <xref:System.Type.GetTypeFromProgID%2A> metodę dostępu z późnym wiązaniem modelowi COM obiekty którego identyfikator programowy (ProgID) znasz.  
  
 Tworzenia wystąpienia obiektu COM niezarządzane z jego identyfikator CLSID jest procesem dwuetapowym:  
  
1.  Pobierz <xref:System.Type> obiekt, który reprezentuje `__ComObject` odpowiadający identyfikatora CLSID, wywołując <xref:System.Type.GetTypeFromCLSID%2A> metody.  
  
2.  Wywołanie <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metody do tworzenia wystąpienia obiektu COM.  
  
 Zapoznaj się z przykładem ilustrację.  
  
 Wyjątki, takie jak <xref:System.OutOfMemoryException> zostanie zgłoszony podczas określania `true` dla `throwOnError`, ale zakończy się niepowodzeniem dla niezarejestrowanych CLSID.  
  
   
  
## Examples  
 W poniższym przykładzie użyto identyfikatora CLSID programu Microsoft Word [obiektu aplikacji](http://msdn.microsoft.com/library/office/ff838565.aspx) można pobrać typu modelu COM, który reprezentuje aplikację Microsoft Word. Następnie tworzy wystąpienie typu przez wywołanie metody <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metody i zamyka przez wywołanie metody [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) metody. Jeśli wystąpi błąd podczas ładowania typu, jest zgłaszany wyjątek.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Ta metoda jest przeznaczona do użycia podczas pracy z obiektami COM, nie z obiektami środowiska .NET Framework. Wszystkie zarządzane obiekty, w tym te, które są widoczne dla modelu COM (to znaczy ich <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atrybutu <see langword="true" />) ma identyfikatora GUID, który jest zwracany przez <see cref="P:System.Type.GUID" /> właściwości. Mimo że metoda zwraca <see cref="T:System.Type" /> obiekty obiekt, który odpowiada identyfikator GUID dla programu .NET Framework, którego nie można użyć <see cref="T:System.Type" /> obiekt, aby utworzyć wystąpienie typu przez wywołanie metody <see cref="M:System.Activator.CreateInstance(System.Type)" /> metody, jak przedstawiono na poniższym przykładzie.  [! code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  Zamiast tego <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> należy używać tylko w celu pobrania identyfikatora GUID niezarządzanego obiektu modelu COM, a powstałe w ten sposób <see cref="T:System.Type" /> obiekt, który jest przekazywany do <see cref="M:System.Activator.CreateInstance(System.Type)" /> metoda musi reprezentować obiekt COM niezarządzane.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">Identyfikator CLSID typu, który można pobrać.</param>
        <param name="server">Serwer, z którego można załadować typ. Jeśli nazwa serwera jest <see langword="null" />, ta metoda automatycznie przywrócona na komputerze lokalnym.</param>
        <summary>Pobiera typ skojarzony z identyfikatorem określonej klasy (CLSID) na określonym serwerze.</summary>
        <returns>
          <see langword="System.__ComObject" /> niezależnie od tego, czy identyfikator CLSID jest nieprawidłowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> — Metoda obsługuje późnym wiązaniem dostęp do niezarządzanego obiektów COM z aplikacji .NET Framework, gdy wiesz identyfikator klasy obiektu modelu COM (CLSID).  Identyfikator klasy dla klasy COM jest zdefiniowany w kluczu HKEY_CLASSES_ROOT\CLSID rejestru. Można pobrać wartość <xref:System.Type.IsCOMObject%2A> właściwości w celu określenia, czy obiekt modelu COM typ zwracany przez tę metodę.  
  
> [!TIP]
>  Możesz wywołać <xref:System.Type.GetTypeFromProgID%2A> metodę dostępu z późnym wiązaniem modelowi COM obiekty którego identyfikator programowy (ProgID) znasz.  
  
 Tworzenia wystąpienia obiektu COM niezarządzane z jego identyfikator CLSID jest procesem dwuetapowym:  
  
1.  Pobierz <xref:System.Type> obiekt, który reprezentuje `__ComObject` odpowiadający identyfikatora CLSID, wywołując <xref:System.Type.GetTypeFromCLSID%2A> metody.  
  
2.  Wywołanie <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metody do tworzenia wystąpienia obiektu COM.  
  
   
  
## Examples  
 W poniższym przykładzie użyto identyfikatora CLSID programu Microsoft Word [obiektu aplikacji](http://msdn.microsoft.com/library/office/ff838565.aspx) można pobrać typu modelu COM, który reprezentuje aplikacji Microsoft Word z serwerem o nazwie computer17.central.contoso.com. Następnie tworzy wystąpienie typu przez wywołanie metody <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metody i zamyka przez wywołanie metody [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) metody.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Ta metoda jest przeznaczona do użycia podczas pracy z obiektami COM, nie z obiektami środowiska .NET Framework. Wszystkie zarządzane obiekty, w tym te, które są widoczne dla modelu COM (to znaczy ich <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atrybutu <see langword="true" />) ma identyfikatora GUID, który jest zwracany przez <see cref="P:System.Type.GUID" /> właściwości. Mimo że metoda zwraca <see cref="T:System.Type" /> obiekty obiekt, który odpowiada identyfikator GUID dla programu .NET Framework, którego nie można użyć <see cref="T:System.Type" /> obiekt, aby utworzyć wystąpienie typu przez wywołanie metody <see cref="M:System.Activator.CreateInstance(System.Type)" /> metody, jak przedstawiono na poniższym przykładzie.  [! code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  Zamiast tego <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> należy używać tylko w celu pobrania identyfikatora GUID niezarządzanego obiektu modelu COM, a powstałe w ten sposób <see cref="T:System.Type" /> obiekt, który jest przekazywany do <see cref="M:System.Activator.CreateInstance(System.Type)" /> metoda musi reprezentować obiekt COM niezarządzane.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">Identyfikator CLSID typu, który można pobrać.</param>
        <param name="server">Serwer, z którego można załadować typ. Jeśli nazwa serwera jest <see langword="null" />, ta metoda automatycznie przywrócona na komputerze lokalnym.</param>
        <param name="throwOnError">
          <see langword="true" /> Aby zgłosić wszelkie wyjątku, który występuje.  - lub - <see langword="false" /> ignoruje wszystkie wyjątku, który występuje.</param>
        <summary>Pobiera typ skojarzony z identyfikatorem określonej klasy (CLSID) na określonym serwerze Określanie, czy należy zgłosić wyjątek, jeśli wystąpi błąd podczas ładowania typu.</summary>
        <returns>
          <see langword="System.__ComObject" /> niezależnie od tego, czy identyfikator CLSID jest nieprawidłowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> — Metoda obsługuje późnym wiązaniem dostęp do niezarządzanego obiektów COM z aplikacji .NET Framework, gdy wiesz identyfikator klasy obiektu modelu COM (CLSID).  Identyfikator klasy dla klasy COM jest zdefiniowany w kluczu HKEY_CLASSES_ROOT\CLSID rejestru. Można pobrać wartość <xref:System.Type.IsCOMObject%2A> właściwości w celu określenia, czy obiekt modelu COM typ zwracany przez tę metodę.  
  
> [!TIP]
>  Możesz wywołać <xref:System.Type.GetTypeFromProgID%2A> metodę dostępu z późnym wiązaniem modelowi COM obiekty którego identyfikator programowy (ProgID) znasz.  
  
 Tworzenia wystąpienia obiektu COM niezarządzane z jego identyfikator CLSID jest procesem dwuetapowym:  
  
1.  Pobierz <xref:System.Type> obiekt, który reprezentuje `__ComObject` odpowiadający identyfikatora CLSID, wywołując <xref:System.Type.GetTypeFromCLSID%2A> metody.  
  
2.  Wywołanie <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metody do tworzenia wystąpienia obiektu COM.  
  
 Wyjątki, takie jak <xref:System.OutOfMemoryException> zostanie zgłoszony podczas określania `true` dla `throwOnError`, ale zakończy się niepowodzeniem dla niezarejestrowanych CLSID.  
  
   
  
## Examples  
 W poniższym przykładzie użyto identyfikatora CLSID programu Microsoft Word [obiektu aplikacji](http://msdn.microsoft.com/library/office/ff838565.aspx) można pobrać typu modelu COM, który reprezentuje aplikacji Microsoft Word z serwerem o nazwie computer17.central.contoso.com. Następnie tworzy wystąpienie typu przez wywołanie metody <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metody i zamyka przez wywołanie metody [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) metody. Jeśli wystąpi błąd podczas ładowania typu, jest zgłaszany wyjątek.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Ta metoda jest przeznaczona do użycia podczas pracy z obiektami COM, nie z obiektami środowiska .NET Framework. Wszystkie zarządzane obiekty, w tym te, które są widoczne dla modelu COM (to znaczy ich <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atrybutu <see langword="true" />) ma identyfikatora GUID, który jest zwracany przez <see cref="P:System.Type.GUID" /> właściwości. Mimo że <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> metoda zwraca <see cref="T:System.Type" /> obiekt, który odpowiada identyfikatora GUID dla konkretnego obiektu zarządzanego nie można użyć, który <see cref="T:System.Type" /> obiekt, aby utworzyć wystąpienie typu przez wywołanie metody <see cref="M:System.Activator.CreateInstance(System.Type)" /> metody, jak w poniższym przykładzie Pokazuje.  [! code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  Zamiast tego <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> należy używać tylko w celu pobrania identyfikatora GUID niezarządzanego obiektu modelu COM, a powstałe w ten sposób <see cref="T:System.Type" /> obiekt, który jest przekazywany do <see cref="M:System.Activator.CreateInstance(System.Type)" /> metoda musi reprezentować obiekt COM niezarządzane.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Obiekt, który odwołuje się do typu.</param>
        <summary>Pobiera typ odwołuje się określony typ dojścia.</summary>
        <returns>Odwołuje się określony typ <see cref="T:System.RuntimeTypeHandle" />, lub <see langword="null" /> Jeśli <see cref="P:System.RuntimeTypeHandle.Value" /> właściwość <paramref name="handle" /> jest <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uchwyty są prawidłowe tylko w domenie aplikacji, w którym zostały uzyskane.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Type.GetTypeFromHandle%2A> metody, aby uzyskać <xref:System.Type> obiekt z <xref:System.RuntimeTypeHandle> pochodzącymi <xref:System.Type.GetTypeHandle%2A> metody.  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera typ skojarzony z identyfikatorem określonego programu (ProgID).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">Identyfikator ProgID typ do pobrania.</param>
        <summary>Pobiera typ skojarzony z identyfikatorem określonego programu (ProgID), zwraca wartość null, jeśli wystąpi błąd podczas ładowania <see cref="T:System.Type" />.</summary>
        <returns>Typ skojarzony z określonym identyfikatorem ProgID, jeśli <paramref name="progID" /> jest prawidłowym wpisem w rejestrze, a typem jest skojarzony z nim; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia obsługę COM. ProgID nie są używane w programie Microsoft .NET Framework, ponieważ zostały zastąpione przez pojęcie przestrzeni nazw.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">Identyfikator ProgID typ do pobrania.</param>
        <param name="throwOnError">
          <see langword="true" /> Aby zgłosić wszelkie wyjątku, który występuje.  - lub - <see langword="false" /> ignoruje wszystkie wyjątku, który występuje.</param>
        <summary>Pobiera typ skojarzony z identyfikatorem określonego programu (ProgID) określająca, czy do zgłoszenia wyjątku, jeśli wystąpi błąd podczas ładowania typu.</summary>
        <returns>Typ skojarzony z identyfikatorem określonego programu (ProgID), jeśli <paramref name="progID" /> jest prawidłowym wpisem w rejestrze, a typem jest skojarzony z nim; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia obsługę COM. Identyfikatorów programu nie są używane w programie Microsoft .NET Framework, ponieważ zostały zastąpione przez pojęcie przestrzeni nazw.  
  
   
  
## Examples  
 Poniższy przykład pobiera typ przez przekazanie ProgID, określająca, czy do zgłoszenia wyjątku, jeśli identyfikator ProgID jest nieprawidłowy. W przykładzie przedstawiono następnie ClassID powiązany identyfikator ProgID wraz z dowolnym komunikat o wyjątku dotyczy.  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Określony identyfikator ProgID nie jest zarejestrowany.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">ProgID typu do pobrania.</param>
        <param name="server">Serwer, z którego można załadować typ. Jeśli nazwa serwera jest <see langword="null" />, ta metoda automatycznie przywrócona na komputerze lokalnym.</param>
        <summary>Pobiera typ skojarzony z identyfikatorem określonego programu (progID) na określonym serwerze, zwracając wartość null, jeśli Napotkano błąd podczas ładowania typu.</summary>
        <returns>Typ skojarzony z identyfikatorem określonego programu (progID), jeśli <paramref name="progID" /> jest prawidłowym wpisem w rejestrze, a typem jest skojarzony z nim; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia obsługę COM. Identyfikatorów programu nie są używane w programie Microsoft .NET Framework, ponieważ zostały zastąpione przez pojęcie przestrzeni nazw.  
  
   
  
## Examples  
 Poniższy przykład pobiera typ przez przekazanie nazwa identyfikatora ProgID i serwera. Przykład wyświetla ClassID związane z identyfikatora ProgID lub zgłasza wyjątek, jeśli identyfikator ProgID lub nazwa serwera jest nieprawidłowa.  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="prodID" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">ProgID z <see cref="T:System.Type" /> do pobrania.</param>
        <param name="server">Serwer, z którego można załadować typ. Jeśli nazwa serwera jest <see langword="null" />, ta metoda automatycznie przywrócona na komputerze lokalnym.</param>
        <param name="throwOnError">
          <see langword="true" /> Aby zgłosić wszelkie wyjątku, który występuje.  - lub - <see langword="false" /> ignoruje wszystkie wyjątku, który występuje.</param>
        <summary>Pobiera typ skojarzony z identyfikatorem określonego programu (progID) na określonym serwerze Określanie, czy należy zgłosić wyjątek, jeśli wystąpi błąd podczas ładowania typu.</summary>
        <returns>Typ skojarzony z identyfikatorem określonego programu (progID), jeśli <paramref name="progID" /> jest prawidłowym wpisem w rejestrze, a typem jest skojarzony z nim; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia obsługę COM. Identyfikatorów programu nie są używane w programie Microsoft .NET Framework, ponieważ zostały zastąpione przez pojęcie przestrzeni nazw.  
  
   
  
## Examples  
 Poniższy przykład pobiera typ przez przekazanie nazwa identyfikatora ProgID i serwera. W przykładzie przedstawiono następnie ClassID powiązany identyfikator ProgID określająca, czy do zgłoszenia wyjątku, jeśli identyfikator ProgID lub nazwa serwera jest nieprawidłowa.  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Określony identyfikator programu nie jest zarejestrowany.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt, dla którego można pobrać typu obsługi.</param>
        <summary>Pobiera dojście do <see cref="T:System.Type" /> określonego obiektu.</summary>
        <returns>Dojście do <see cref="T:System.Type" /> określonego <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uchwyty są prawidłowe tylko w domenie aplikacji, w którym zostały uzyskane.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano klasę `MyClass1`, pobiera wystąpienie i pobiera dojścia środowiska uruchomieniowego obiektu.  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator GUID skojarzony z <see cref="T:System.Type" />.</summary>
        <value>Identyfikator GUID skojarzony z <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator GUID jest skojarzony z typem przy użyciu <xref:System.Runtime.InteropServices.GuidAttribute> atrybutu.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę `MyClass1` w metodę publiczną, tworzy `Type` obiekt odpowiadający `MyClass1`i pobiera <xref:System.Guid> struktury, za pomocą `GUID` właściwość `Type` klasy.  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy bieżące <see cref="T:System.Type" /> obejmuje lub odwołuje się do innego typu; czy bieżący <see cref="T:System.Type" /> jest tablicą wskaźnik, lub jest przekazywana przez odwołanie.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest tablicą wskaźnik, lub jest przekazywana przez odwołanie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład Type.GetType("Int32[]"). Zwraca HasElementType `true`, ale Type.GetType("Int32"). Zwraca HasElementType `false`. Zwraca także HasElementType `true` dla "Int32 *" i "Int32 &".  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typu ogólnego lub parametrem typu w definicji typu ogólnego lub metody ogólnej, ta właściwość zawsze zwraca `false`.  
  
   
  
## Examples  
 Poniższy przykład zwraca `true` lub `false` w zależności od tego, czy obiekt jest tablicą, typu odwołania lub wskaźnik.  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, implementuje <see cref="P:System.Type.HasElementType" /> właściwości i określa, czy bieżący <see cref="T:System.Type" /> obejmuje lub odwołuje się do innego typu; czy bieżącego <see cref="T:System.Type" /> jest tablicą wskaźnik, lub jest przekazywana przez odwołanie.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest tablicą wskaźnik, lub jest przekazywana przez odwołanie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład Type.GetType("Int32[]"). Zwraca HasElementTypeImpl `true`, ale Type.GetType("Int32"). Zwraca HasElementTypeImpl `false`. Zwraca także HasElementTypeImpl `true` dla "Int32 *" i "Int32 &".  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano klasę `MyTypeDelegator`, co zastępuje `HasElementTypeImpl` metody. Sprawdza, czy klasy głównym `HasElementType` właściwości i wyświetla typ elementu.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wywołuje określonym elemencie członkowskim bieżącej <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę konstruktora, metoda, właściwość lub członek pola do wywołania.  - lub - ciąg pusty ("") do wywołania domyślny element członkowski.  - lub - <see langword="IDispatch" /> członków, ciąg reprezentujący identyfikator DispID, na przykład "[DispID = 3]".</param>
        <param name="invokeAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie. Dostęp może być jednym z <see langword="BindingFlags" /> takich jak <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />i tak dalej. Typ wyszukiwania nie muszą być określane. W przypadku pominięcia typ wyszukiwania <see langword="BindingFlags.Public" />  |  <see langword="BindingFlags.Instance" />  |  <see langword="BindingFlags.Static" /> są używane.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  - lub - odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />. Należy pamiętać, że jawnie definiowanie <see cref="T:System.Reflection.Binder" /> obiektu mogą być wymagane dla pomyślnie wywołania przeciążenia metody ze zmiennymi argumentami.</param>
        <param name="target">Obiekt do wywołania określonego elementu członkowskiego.</param>
        <param name="args">Tablica zawierająca argumenty do przekazania do elementu członkowskiego do wywołania.</param>
        <summary>Wywołuje określony element członkowski, dopasowanie określona lista argumentów i korzystanie z określonymi ograniczeniami wiązania.</summary>
        <returns>Obiekt reprezentujący wartość zwracaną wywołany element członkowski.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nie można użyć <xref:System.Type.InvokeMember%2A> do wywołania metody rodzajowej.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania członków do wyszukiwania:  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić publiczne elementy członkowskie.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić niepublicznych elementów członkowskich (to znaczy prywatnych i chronionych elementów członkowskich).  
  
-   Określ `BindingFlags.FlattenHierarchy` uwzględnienie statycznych elementów członkowskich w hierarchii.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikator można zmienić, jak działa wyszukiwanie:  
  
-   `BindingFlags.IgnoreCase` ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly` do wyszukiwania tylko do elementów członkowskich zadeklarowana w <xref:System.Type>, nie elementów członkowskich, które zostały odziedziczone po prostu.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi wywołanie może służyć do określenia, jaka akcja ma być z elementem członkowskim:  
  
-   `CreateInstance` Aby wywołać konstruktora. `name` jest ignorowana. Nie jest prawidłowa z innych flagi wywołania.  
  
-   `InvokeMethod` Aby wywołać metodę, ale nie konstruktorze lub inicjatorze typu. Nie jest prawidłowa z `SetField` lub `SetProperty`. Jeśli `InvokeMethod` jest określona przez samego siebie, `BindingFlags.Public`, `BindingFlags.Instance`, i `BindingFlags.Static` są automatycznie dołączane.  
  
-   `GetField` Aby uzyskać wartość pola. Nie jest prawidłowa z `SetField`.  
  
-   `SetField` Aby ustawić wartość pola. Nie jest prawidłowa z `GetField`.  
  
-   `GetProperty` Aby uzyskać właściwości. Nie jest prawidłowa z `SetProperty`.  
  
-   `SetProperty` można ustawić właściwości. Nie jest prawidłowa z `GetProperty`.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Metoda zostanie wywołany, gdy są spełnione oba poniższe warunki:  
  
-   Liczba parametrów w deklaracji metody jest równa liczbie argumentów `args` tablicy (chyba że argumenty domyślne są zdefiniowane w elemencie członkowskim i `BindingFlags.OptionalParamBinding` jest określony).  
  
-   Typ każdy argument może zostać przekonwertowany przez obiekt wiążący z typem parametru.  
  
 Obiekt wiążący znajdzie wszystkie metody dopasowania. Tych metod znajdują się oparte na typie powiązania żądanie (<xref:System.Reflection.BindingFlags> wartości `InvokeMethod`, `GetProperty`i tak dalej). Zbiór metod są filtrowane według nazwy, liczba argumentów i zestaw Modyfikatory wyszukiwania zdefiniowane w obiekt wiążący.  
  
 Po wybraniu metoda jest wywoływana. Ułatwienia dostępu, zostanie sprawdzony w tym momencie. Wyszukiwanie może kontrolować, które zestaw metod są przeszukiwane zależności atrybutu dostępności skojarzonego z metodą. <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Metody <xref:System.Reflection.Binder> klasy jest odpowiedzialny za wybranie wywoływanej metody. Domyślnego integratora wybierze najbardziej zgodne.  
  
 Ograniczenia dostępu są ignorowane w przypadku całkowicie zaufanego kodu; oznacza to, konstruktory prywatne, pola, metody i właściwości można uzyskać dostępu do i wywoływane przez <xref:System.Reflection> zawsze, gdy kod jest w pełni zaufany.  
  
 Można użyć `Type.InvokeMember` można ustawić pola do określonej wartości, określając <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Na przykład, jeśli chcesz ustawić pola wystąpienia publicznego o nazwie F klasy C i F jest `String`, można użyć kodu, takich jak:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 Jeśli jest F `String[]`, można użyć kodu, takich jak:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 które zainicjuje pole F do tej nowej tablicy. Można również użyć `Type.InvokeMember` próba ustawienia pozycji w tablicy, podając indeks wartość, a następnie następnej wartości przy użyciu następującego kodu:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 Spowoduje to zmianę ciąg "z" w tablicy, która F zawiera ciąg "b".  
  
 Gdy wywołanie `IDispatch` elementu członkowskiego, można określić identyfikator DispID zamiast nazwy elementu członkowskiego przy użyciu formatu ciągu "[DispID = ##]". Na przykład jeśli identyfikator DispID MyComMethod 3, można określić ciąg "[DispID = 3]" zamiast "MyComMethod". Wywoływanie składnika według DispID jest szybsze niż Wyszukiwanie elementu członkowskiego o nazwie. W scenariuszach złożoną agregację identyfikator DispID czasami jest jedynym sposobem, aby wywołać żądanego elementu.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda umożliwia dostęp do elementów członkowskich niepubliczne, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga i jeśli zestaw grant niepublicznych elementów członkowskich jest ograniczone do obiektu wywołującego udzielić zestawu lub być podzbiorem jej. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
   
  
## Examples  
 W poniższym przykładzie użyto `InvokeMember` do dostępu do elementów członkowskich typu.  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> nie zawiera <see langword="CreateInstance" /> i <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" /> nie jest prawidłową <see cref="T:System.Reflection.BindingFlags" /> atrybutu.  - lub - <paramref name="invokeAttr" /> nie zawiera jedną z następujących flag powiązań: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, lub <see langword="SetProperty" />.  - lub - <paramref name="invokeAttr" /> zawiera <see langword="CreateInstance" /> połączeniu z <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, lub <see langword="SetProperty" />.  - lub - <paramref name="invokeAttr" /> zawiera oba <see langword="GetField" /> i <see langword="SetField" />.  - lub - <paramref name="invokeAttr" /> zawiera oba <see langword="GetProperty" /> i <see langword="SetProperty" />.  - lub - <paramref name="invokeAttr" /> zawiera <see langword="InvokeMethod" /> połączeniu z <see langword="SetField" /> lub <see langword="SetProperty" />.  - lub - <paramref name="invokeAttr" /> zawiera <see langword="SetField" /> i <paramref name="args" /> ma więcej niż jeden element.  - lub - ta metoda jest wywoływana dla obiektu modelu COM i jedną z następujących flag powiązań nie przekazano: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, lub <see langword="BindingFlags.PutRefDispProperty" />.  - lub - jeden tablic nazwanego parametru zawiera ciąg, który jest <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">Określony element członkowski jest inicjatora klasy.</exception>
        <exception cref="T:System.MissingFieldException">Nie można odnaleźć pola lub właściwości.</exception>
        <exception cref="T:System.MissingMethodException">Nie może być znaleziono metody argumentów, które odpowiadają <paramref name="args" />.  - lub - bieżącego <see cref="T:System.Type" /> obiekt reprezentuje typ, który zawiera parametry typu otwartego, czyli <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">Nie można wywołać określonego elementu członkowskiego <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Więcej niż jednej metody kryteria powiązania.</exception>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework nie obsługuje obecnie tej metody.</exception>
        <exception cref="T:System.InvalidOperationException">Metodę reprezentowaną przez <paramref name="name" /> ma co najmniej jeden parametr typu ogólnego nieokreślony. Oznacza to, że metody <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> zwraca właściwość <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">W celu uzyskiwania dostępu do elementów członkowskich niepublicznych, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby wywoływać kod niezarządzany. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę konstruktora, metoda, właściwość lub członek pola do wywołania.  - lub - ciąg pusty ("") do wywołania domyślny element członkowski.  - lub - <see langword="IDispatch" /> członków, ciąg reprezentujący identyfikator DispID, na przykład "[DispID = 3]".</param>
        <param name="invokeAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie. Dostęp może być jednym z <see langword="BindingFlags" /> takich jak <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />i tak dalej. Typ wyszukiwania nie muszą być określane. W przypadku pominięcia typ wyszukiwania <see langword="BindingFlags.Public" />  |  <see langword="BindingFlags.Instance" />  |  <see langword="BindingFlags.Static" /> są używane.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  - lub - odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />. Należy pamiętać, że jawnie definiowanie <see cref="T:System.Reflection.Binder" /> obiektu mogą być wymagane dla pomyślnie wywołania przeciążenia metody ze zmiennymi argumentami.</param>
        <param name="target">Obiekt do wywołania określonego elementu członkowskiego.</param>
        <param name="args">Tablica zawierająca argumenty do przekazania do elementu członkowskiego do wywołania.</param>
        <param name="culture">Obiekt reprezentujący ustawień regionalnych globalizacji do użycia, które mogą być się niezbędne dla ustawień regionalnych konwersji, takie jak konwertowanie liczbową <see cref="T:System.String" /> do <see cref="T:System.Double" />.  - lub - odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic) Aby użyć bieżącego wątku <see cref="T:System.Globalization.CultureInfo" />.</param>
        <summary>Wywołuje określony element członkowski, korzystanie z określonymi ograniczeniami wiązania i dopasowywanie określona lista argumentów i kultury.</summary>
        <returns>Obiekt reprezentujący wartość zwracaną wywołany element członkowski.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że nie może przetwarzać domyślnego integratora <xref:System.Globalization.CultureInfo> ( `culture` parametru), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> klasa umożliwiająca zapisanie integratora niestandardowej, która przetwarzać `culture`.  
  
> [!NOTE]
>  Nie można użyć <xref:System.Type.InvokeMember%2A> do wywołania metody rodzajowej.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania członków do wyszukiwania:  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić publiczne elementy członkowskie.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić niepublicznych elementów członkowskich (to znaczy prywatnych, wewnętrznych i chronionych elementów członkowskich).  
  
-   Określ `BindingFlags.FlattenHierarchy` uwzględnienie statycznych elementów członkowskich w hierarchii.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikator można zmienić, jak działa wyszukiwanie:  
  
-   `BindingFlags.IgnoreCase` ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly` do wyszukiwania tylko do elementów członkowskich zadeklarowana w <xref:System.Type>, nie elementów członkowskich, które zostały odziedziczone po prostu.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi wywołanie może służyć do określenia, jaka akcja ma być z elementem członkowskim:  
  
-   `CreateInstance` Aby wywołać konstruktora. `name` jest ignorowana. Nie jest prawidłowa z innych flagi wywołania.  
  
-   `InvokeMethod` Aby wywołać metodę, ale nie konstruktorze lub inicjatorze typu. Nie jest prawidłowa z `SetField` lub `SetProperty`. Jeśli `InvokeMethod` jest określona przez samego siebie, `BindingFlags.Public`, `BindingFlags.Instance`, i `BindingFlags.Static` są automatycznie dołączane.  
  
-   `GetField` Aby uzyskać wartość pola. Nie jest prawidłowa z `SetField`.  
  
-   `SetField` Aby ustawić wartość pola. Nie jest prawidłowa z `GetField`.  
  
-   `GetProperty` Aby uzyskać właściwości. Nie jest prawidłowa z `SetProperty`.  
  
-   `SetProperty` można ustawić właściwości. Nie jest prawidłowa z `GetProperty`.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Metoda zostanie wywołany, gdy są spełnione oba poniższe warunki:  
  
-   Liczba parametrów w deklaracji metody jest równa liczbie argumentów `args` tablicy (chyba że argumenty domyślne są zdefiniowane w elemencie członkowskim i `BindingFlags.OptionalParamBinding` jest określony).  
  
-   Typ każdy argument może zostać przekonwertowany przez obiekt wiążący z typem parametru.  
  
 Obiekt wiążący znajdzie wszystkie metody dopasowania. Tych metod znajdują się oparte na typie powiązania żądanie (<xref:System.Reflection.BindingFlags> wartości `InvokeMethod`, `GetProperty`i tak dalej). Zbiór metod są filtrowane według nazwy, liczba argumentów i zestaw Modyfikatory wyszukiwania zdefiniowane w obiekt wiążący.  
  
 Po wybraniu metoda jest wywoływana. Ułatwienia dostępu, zostanie sprawdzony w tym momencie. Wyszukiwanie może kontrolować, które zestaw metod są przeszukiwane zależności atrybutu dostępności skojarzonego z metodą. <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Metody <xref:System.Reflection.Binder> klasy jest odpowiedzialny za wybranie wywoływanej metody. Domyślnego integratora wybierze najbardziej zgodne.  
  
 Ograniczenia dostępu są ignorowane w przypadku całkowicie zaufanego kodu; oznacza to konstruktory prywatne, pola, metody i właściwości można uzyskać dostępu do się wywołana przez odbicie w każdym przypadku, gdy kod jest w pełni zaufany.  
  
 Można użyć `Type.InvokeMember` można ustawić pola do określonej wartości, określając <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Na przykład, jeśli chcesz ustawić pola wystąpienia publicznego o nazwie F klasy C i F jest `String` można użyć kodu, takich jak:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 Jeśli jest F `String[]`, można użyć kodu, takich jak:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 które zainicjuje pole F do tej nowej tablicy. Można również użyć `Type.InvokeMember` próba ustawienia pozycji w tablicy, podając indeks wartość, a następnie następnej wartości przy użyciu następującego kodu:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 Spowoduje to zmianę ciąg "z" w tablicy, która F zawiera ciąg "b".  
  
 Gdy wywołanie `IDispatch` członka DispID zamiast nazwy elementu członkowskiego w formacie ciągu można określić "[DispID = ##]". Na przykład jeśli identyfikator DispID MyComMethod 3, można określić ciąg "[DispID = 3]" zamiast "MyComMethod". Wywoływanie składnika według DispID jest szybsze niż Wyszukiwanie elementu członkowskiego o nazwie. W scenariuszach złożoną agregację identyfikator DispID czasami jest jedynym sposobem, aby wywołać żądanego elementu.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda umożliwia dostęp do elementów członkowskich niepubliczne, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga i jeśli zestaw grant niepublicznych elementów członkowskich jest ograniczone do obiektu wywołującego udzielić zestawu lub być podzbiorem jej. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> nie zawiera <see langword="CreateInstance" /> i <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" /> nie jest prawidłową <see cref="T:System.Reflection.BindingFlags" /> atrybutu.  - lub - <paramref name="invokeAttr" /> nie zawiera jedną z następujących flag powiązań: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, lub <see langword="SetProperty" />.  - lub - <paramref name="invokeAttr" /> zawiera <see langword="CreateInstance" /> połączeniu z <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, lub <see langword="SetProperty" />.  - lub - <paramref name="invokeAttr" /> zawiera oba <see langword="GetField" /> i <see langword="SetField" />.  - lub - <paramref name="invokeAttr" /> zawiera oba <see langword="GetProperty" /> i <see langword="SetProperty" />.  - lub - <paramref name="invokeAttr" /> zawiera <see langword="InvokeMethod" /> połączeniu z <see langword="SetField" /> lub <see langword="SetProperty" />.  - lub - <paramref name="invokeAttr" /> zawiera <see langword="SetField" /> i <paramref name="args" /> ma więcej niż jeden element.  - lub - ta metoda jest wywoływana dla obiektu modelu COM i jedną z następujących flag powiązań nie przekazano: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, lub <see langword="BindingFlags.PutRefDispProperty" />.  - lub - jeden tablic nazwanego parametru zawiera ciąg, który jest <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">Określony element członkowski jest inicjatora klasy.</exception>
        <exception cref="T:System.MissingFieldException">Nie można odnaleźć pola lub właściwości.</exception>
        <exception cref="T:System.MissingMethodException">Nie może być znaleziono metody argumentów, które odpowiadają <paramref name="args" />.  - lub - bieżącego <see cref="T:System.Type" /> obiekt reprezentuje typ, który zawiera parametry typu otwartego, czyli <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">Nie można wywołać określonego elementu członkowskiego <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Więcej niż jednej metody kryteria powiązania.</exception>
        <exception cref="T:System.InvalidOperationException">Metodę reprezentowaną przez <paramref name="name" /> ma co najmniej jeden parametr typu ogólnego nieokreślony. Oznacza to, że metody <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> zwraca właściwość <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">W celu uzyskiwania dostępu do elementów członkowskich niepublicznych, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby wywoływać kod niezarządzany. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę konstruktora, metoda, właściwość lub członek pola do wywołania.  - lub - ciąg pusty ("") do wywołania domyślny element członkowski.  - lub - <see langword="IDispatch" /> członków, ciąg reprezentujący identyfikator DispID, na przykład "[DispID = 3]".</param>
        <param name="invokeAttr">Maska bitowa składającej się z co najmniej jeden <see cref="T:System.Reflection.BindingFlags" /> określające, jak jest prowadzone wyszukiwanie. Dostęp może być jednym z <see langword="BindingFlags" /> takich jak <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />i tak dalej. Typ wyszukiwania nie muszą być określane. W przypadku pominięcia typ wyszukiwania <see langword="BindingFlags.Public" />  |  <see langword="BindingFlags.Instance" />  |  <see langword="BindingFlags.Static" /> są używane.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  - lub - odwołanie o wartości null (Nothing w języku Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />. Należy pamiętać, że jawnie definiowanie <see cref="T:System.Reflection.Binder" /> obiektu mogą być wymagane dla pomyślnie wywołania przeciążenia metody ze zmiennymi argumentami.</param>
        <param name="target">Obiekt do wywołania określonego elementu członkowskiego.</param>
        <param name="args">Tablica zawierająca argumenty do przekazania do elementu członkowskiego do wywołania.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentujących atrybuty skojarzone z odpowiadającego mu elementu w <c>argumentów</c> tablicy. Parametr skojarzonych z nimi atrybutów są przechowywane w podpisie elementu członkowskiego.  Tylko wtedy, gdy wywołanie składnika modelu COM, domyślnego integratora przetwarza tego parametru.</param>
        <param name="culture">
          <see cref="T:System.Globalization.CultureInfo" /> Obiekt reprezentujący ustawień regionalnych globalizacji do użycia, które mogą być konieczne w przypadku konwersji specyficzne dla ustawień regionalnych, takie jak konwertowanie liczbowych ciągu na wartość o podwójnej precyzji.  - lub - odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic) Aby użyć bieżącego wątku <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="namedParameters">Tablica zawierająca nazwy parametrów, do której wartości w <c>argumentów</c> tablicy są przekazywane.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej wywołuje określonego elementu członkowskiego, korzystanie z określonymi ograniczeniami wiązania i dopasowywanie określona lista argumentów, Modyfikatory i kultury.</summary>
        <returns>Obiekt reprezentujący wartość zwracaną wywołany element członkowski.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember` wywołuje element członkowski w konstruktorze lub elementem członkowskim — metoda, pobiera lub ustawia element właściwości, pobiera lub ustawia element pola danych lub pobiera lub ustawia element elementu członkowskiego tablicy.  
  
> [!NOTE]
>  Nie można użyć <xref:System.Type.InvokeMember%2A> do wywołania metody rodzajowej.  
  
 Gdy wywołanie `IDispatch` członka DispID zamiast nazwy elementu członkowskiego w formacie ciągu można określić "[DispID = ##]". Na przykład jeśli identyfikator DispID MyComMethod 3, można określić ciąg "[DispID = 3]" zamiast "MyComMethod". Wywoływanie składnika według DispID jest szybsze niż Wyszukiwanie elementu członkowskiego o nazwie. W scenariuszach złożoną agregację identyfikator DispID czasami jest jedynym sposobem, aby wywołać żądanego elementu.  
  
 Mimo że nie może przetwarzać domyślnego integratora <xref:System.Reflection.ParameterModifier> lub <xref:System.Globalization.CultureInfo> ( `modifiers` i `culture` parametrów), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> klasa umożliwiająca zapisanie integratora niestandardowej, która przetwarzać `modifiers` i `culture`. `ParameterModifier` jest używana tylko podczas wywoływania metody za pomocą międzyoperacyjności COM i obsługiwane są tylko parametry, które są przekazywane przez odwołanie.  
  
 Każdego parametru w `namedParameters` tablicy pobiera wartość w odpowiadający mu element w `args` tablicy. Jeśli długość `args` jest większa niż długość `namedParameters`, pozostałe wartości argumentu są przekazywane w kolejności.  
  
 `namedParameters` Tablicy można zmienić kolejność argumentów w tablicy wejściowej. Przykładowo, podana metoda `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` w języku Visual Basic) i tablicy wejściowej `{ 42, "x" }`, tablicy wejściowej mogą zostać przekazane bez zmian do `args` Jeśli tablica `{ "b", "a" }` dostarczonej dla `namedParameters`.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi filtru może służyć do definiowania członków do wyszukiwania:  
  
-   Określ `BindingFlags.Public` aby w wyszukiwaniu uwzględnić publiczne elementy członkowskie.  
  
-   Określ `BindingFlags.NonPublic` aby w wyszukiwaniu uwzględnić niepublicznych elementów członkowskich (to znaczy prywatnych, wewnętrznych i chronionych elementów członkowskich).  
  
-   Określ `BindingFlags.FlattenHierarchy` uwzględnienie statycznych elementów członkowskich w hierarchii.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi modyfikator można zmienić, jak działa wyszukiwanie:  
  
-   `BindingFlags.IgnoreCase` ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly` do wyszukiwania tylko do elementów członkowskich zadeklarowana w <xref:System.Type>, nie elementów członkowskich, które zostały odziedziczone po prostu.  
  
 Następujące <xref:System.Reflection.BindingFlags> flagi wywołanie może służyć do określenia, jaka akcja ma być z elementem członkowskim:  
  
-   `CreateInstance` Aby wywołać konstruktora. `name` jest ignorowana. Nie jest prawidłowa z innych flagi wywołania.  
  
-   `InvokeMethod` Aby wywołać metodę, ale nie konstruktorze lub inicjatorze typu. Nie jest prawidłowa z `SetField` lub `SetProperty`. Jeśli `InvokeMethod` jest określona przez samego siebie, `BindingFlags.Public`, `BindingFlags.Instance`, i `BindingFlags.Static` są automatycznie dołączane.  
  
-   `GetField` Aby uzyskać wartość pola. Nie jest prawidłowa z `SetField`.  
  
-   `SetField` Aby ustawić wartość pola. Nie jest prawidłowa z `GetField`.  
  
-   `GetProperty` Aby uzyskać właściwości. Nie jest prawidłowa z `SetProperty`.  
  
-   `SetProperty` można ustawić właściwości. Nie jest prawidłowa z `GetProperty`.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Metoda zostanie wywołany, gdy są spełnione oba poniższe warunki:  
  
-   Liczba parametrów w deklaracji metody jest równa liczbie argumentów `args` tablicy (chyba że argumenty domyślne są zdefiniowane w elemencie członkowskim i `BindingFlags.OptionalParamBinding` jest określony).  
  
-   Typ każdy argument może zostać przekonwertowany przez obiekt wiążący z typem parametru.  
  
 Obiekt wiążący znajdzie wszystkie metody dopasowania. Tych metod znajdują się oparte na typie powiązania żądanie (<xref:System.Reflection.BindingFlags> wartości `InvokeMethod`, `GetProperty`i tak dalej). Zbiór metod są filtrowane według nazwy, liczba argumentów i zestaw Modyfikatory wyszukiwania zdefiniowane w obiekt wiążący.  
  
 Po wybraniu metoda jest wywoływana. Ułatwienia dostępu, zostanie sprawdzony w tym momencie. Wyszukiwanie może kontrolować, które zestaw metod są przeszukiwane zależności atrybutu dostępności skojarzonego z metodą. <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Metody <xref:System.Reflection.Binder> klasy jest odpowiedzialny za wybranie wywoływanej metody. Domyślnego integratora wybierze najbardziej zgodne.  
  
 `InvokeMember` może służyć do wywołania metody z parametrami, które mają przypisane wartości domyślne. Aby powiązać z tych metod, wymaga odbicia <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> należy określić. Dla parametru, który ma wartość domyślną, możesz podać inną wartość, lub podaj <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> można użyć wartości domyślnej.  
  
 Rozważmy na przykład metoda, takich jak MyMethod (int, x, float y = 2.0). Do wywołania tej metody za pomocą tylko pierwszy argument jako MyMethod(4), przekazać jeden z powyższych flag powiązań i przekazać dwa argumenty, a mianowicie 4 dla pierwszego argumentu oraz `Missing.Value` jako drugi argument. Jeśli nie używasz `Missing.Value`, nie może pominąć następujące parametry opcjonalne z `Invoke` — metoda. Jeśli należy to zrobić, użyj `InvokeMember` zamiast tego.  
  
 Ograniczenia dostępu są ignorowane w przypadku całkowicie zaufanego kodu; oznacza to, konstruktory prywatne, pola, metody i właściwości można uzyskać dostępu do i wywoływane przez <xref:System.Reflection> zawsze, gdy kod jest w pełni zaufany.  
  
 Można użyć `Type.InvokeMember` można ustawić pola do określonej wartości, określając <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Na przykład, jeśli chcesz ustawić pola wystąpienia publicznego o nazwie F klasy C i F jest `String`, można użyć kodu, takich jak:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 Jeśli jest F `String[]`, można użyć kodu, takich jak:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 które zainicjuje pole F do tej nowej tablicy. Można również użyć `Type.InvokeMember` próba ustawienia pozycji w tablicy, podając indeks wartość, a następnie następnej wartości przy użyciu następującego kodu:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 Spowoduje to zmianę ciąg "z" w tablicy, która F zawiera ciąg "b".  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda umożliwia dostęp do elementów członkowskich niepubliczne, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flaga i jeśli zestaw grant niepublicznych elementów członkowskich jest ograniczone do obiektu wywołującego udzielić zestawu lub być podzbiorem jej. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> nie zawiera <see langword="CreateInstance" /> i <paramref name="name" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="args" /> i <paramref name="modifiers" /> nie mają taką samą długość.  - lub - <paramref name="invokeAttr" /> nie jest prawidłową <see cref="T:System.Reflection.BindingFlags" /> atrybutu.  - lub - <paramref name="invokeAttr" /> nie zawiera jedną z następujących flag powiązań: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, lub <see langword="SetProperty" />.  - lub - <paramref name="invokeAttr" /> zawiera <see langword="CreateInstance" /> połączeniu z <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, lub <see langword="SetProperty" />.  - lub - <paramref name="invokeAttr" /> zawiera oba <see langword="GetField" /> i <see langword="SetField" />.  - lub - <paramref name="invokeAttr" /> zawiera oba <see langword="GetProperty" /> i <see langword="SetProperty" />.  - lub - <paramref name="invokeAttr" /> zawiera <see langword="InvokeMethod" /> połączeniu z <see langword="SetField" /> lub <see langword="SetProperty" />.  - lub - <paramref name="invokeAttr" /> zawiera <see langword="SetField" /> i <paramref name="args" /> ma więcej niż jeden element.  - lub - Tablica nazwanego parametru jest większa niż tablica argumentów.  - lub - ta metoda jest wywoływana dla obiektu modelu COM i jedną z następujących flag powiązań nie przekazano: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, lub <see langword="BindingFlags.PutRefDispProperty" />.  - lub - jeden tablic nazwanego parametru zawiera ciąg, który jest <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">Określony element członkowski jest inicjatora klasy.</exception>
        <exception cref="T:System.MissingFieldException">Nie można odnaleźć pola lub właściwości.</exception>
        <exception cref="T:System.MissingMethodException">Nie może być znaleziono metody argumentów, które odpowiadają <paramref name="args" />.  - lub - nieodnalezienia żaden element członkowski mający nazwy argumentów podane w <paramref name="namedParameters" />.  - lub - bieżącego <see cref="T:System.Type" /> obiekt reprezentuje typ, który zawiera parametry typu otwartego, czyli <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">Nie można wywołać określonego elementu członkowskiego <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Więcej niż jednej metody kryteria powiązania.</exception>
        <exception cref="T:System.InvalidOperationException">Metodę reprezentowaną przez <paramref name="name" /> ma co najmniej jeden parametr typu ogólnego nieokreślony. Oznacza to, że metody <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> zwraca właściwość <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">W celu uzyskiwania dostępu do elementów członkowskich niepublicznych, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby wywoływać kod niezarządzany. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest abstrakcyjny i musi zostać zastąpiona.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest abstrakcyjny, a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAbstract%2A> Zwraca `true` w następujących przypadkach:  
  
-   Bieżący typ jest abstrakcyjny; oznacza to, że ten nie można utworzyć wystąpienia, ale tylko może służyć jako klasę podstawową dla klas pochodnych. W języku C#, klas abstrakcyjnych są oznaczone ikoną z [abstrakcyjny](~/docs/csharp/language-reference/keywords/abstract.md) słowo kluczowe w języku Visual Basic, są oznaczone ikoną z [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) — słowo kluczowe.  
  
-   Bieżący typ jest interfejsem.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ parametru w definicji typu ogólnego lub metody ogólnej, ta właściwość zawsze zwraca `false`.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę <xref:System.Type> obiektów, które reprezentują następujących typów: zwraca typ zawiera `true` , jeśli określony obiekt jest `abstract`; w przeciwnym razie zwraca `false`.  
  
-   `AbstractClass`, klasy abstrakcyjnej (klasa jest oznaczona jako `abstract` w języku C# i `MustInherit` w języku Visual Basic).  
  
-   `DerivedClass`, który dziedziczy z klasy `AbstractClass`.  
  
-   `SingleClass`,-dziedziczne klasy. Jest on zdefiniowany jako `sealed` w języku C# i `NotInheritable` w języku Visual Basic.  
  
-   `ITypeInfo`, interfejs.  
  
-   `ImplementingClass`, klasy, która implementuje `ITypeInfo` interfejsu.  
  
 Metoda zwraca `true` tylko w przypadku `AbstractClass`, klasa abstrakcyjna, i `ITypeInfo`, interfejs.  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy ciąg formatu atrybutu <see langword="AnsiClass" /> został wybrany do <see cref="T:System.Type" />.</summary>
        <value>
          <see langword="true" /> ciąg formatowania atrybutu <see langword="AnsiClass" /> został wybrany do <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> Wybiera atrybuty formatu ciągu. Atrybuty formatu ciągu ulepszenia współdziałania, definiując interpretacji ciągów.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typu ogólnego, ta właściwość dotyczy definicji typu ogólnego, z którego został skonstruowany typu. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zawsze zwraca `false`.  
  
   
  
## Examples  
 Poniższy przykład pobiera pola informacje i sprawdza, czy `AnsiClass` atrybutu.  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy typ jest tablicą.</summary>
        <value>
          <see langword="true" /> Jeśli typ bieżącego jest tablicą; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsArray%2A> Zwraca `false` dla <xref:System.Array> klasy. Również zwraca `false` Jeśli bieżące wystąpienie jest <xref:System.Type> obiekt, który reprezentuje typ kolekcji lub interfejs zaprojektowane do pracy z kolekcji, takie jak <xref:System.Collections.IEnumerable> lub <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Aby sprawdzić, czy tablica, takich jak użyć kodu:  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 Jeśli typ bieżącego reprezentuje typu ogólnego lub parametrem typu w definicji typu ogólnego lub metody ogólnej, ta właściwość zawsze zwraca `false`.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, przy użyciu <xref:System.Type.IsArray%2A> właściwości.  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, implementuje <see cref="P:System.Type.IsArray" /> właściwości i określa, czy <see cref="T:System.Type" /> jest tablicą.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest tablicą; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie <xref:System.Array> klasy musi zwracać `false` ponieważ obiekt nie tablicy.  
  
   
  
## Examples  
 Poniższy przykład zastępuje `IsArrayImpl` metoda `MyTypeDelegator` klasy, sprawdzi, czy zmienna jest tablicą i wyświetla wyniki.  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Typ do porównania z bieżącym typem.</param>
        <summary>Określa, czy wystąpienia określonego typu można przypisać do typu bieżącego wystąpienia.</summary>
        <returns>
          <see langword="true" /> Jeśli dowolny z następujących warunków jest prawdziwy:- <paramref name="c" /> i bieżące wystąpienie reprezentują tego samego typu.  
  
-   <paramref name="c" /> pochodzi bezpośrednio lub pośrednio od bieżącego wystąpienia. <paramref name="c" /> pochodzi bezpośrednio z bieżącym wystąpieniem dziedziczy on z bieżącym wystąpieniem; <paramref name="c" /> jest pośrednio pochodzi od bieżącego wystąpienia Jeśli dziedziczy on z kolejnych co najmniej jednej klasy, które dziedziczą z bieżącego wystąpienia.  -Bieżące wystąpienie jest interfejsem, który <paramref name="c" /> implementuje.  
  
-   <paramref name="c" /> jest to parametr typu ogólnego, a bieżące wystąpienie reprezentuje jeden z warunków ograniczających <paramref name="c" />.  W poniższym przykładzie bieżące wystąpienie jest <see cref="T:System.Type" /> obiekt, który reprezentuje <see cref="T:System.IO.Stream" /> klasy. <c>GenericWithConstraint</c> jest typem ogólnym, którego parametr typu ogólnego musi być typu <see cref="T:System.IO.Stream" />. Przekazanie jej parametr typu ogólnego <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> wskazuje, że wystąpienia parametru typu ogólnego można przypisać do <see cref="T:System.IO.Stream" /> obiektu.  [! code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [! code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]- <paramref name="c" /> reprezentuje typ wartości, a bieżąca reprezentuje wystąpienie <c> Dopuszczające wartości zerowe&lt;c&gt; </c> (<c>Nullable (Of c)</c> w języku Visual Basic).  
  
 <see langword="false" /> Jeśli żaden z tych warunków nie jest spełniony, lub <paramref name="c" /> jest <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAssignableFrom%2A> Metody można użyć w celu określenia, czy wystąpienie `c` można przypisać do dowolnego wystąpienia bieżący typ, metoda jest najbardziej przydatne, gdy są obsługi obiektów, których typy nie są znane w czasie projektowania i umożliwia warunkowego przypisania jako poniższy przykład przedstawia.  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 Ta metoda w związku z tym zapewnia, że wiersz kodu, takie jak następujące będą wykonywane w czasie wykonywania bez generowania <xref:System.InvalidCastException> lub wyjątku podobnych wyjątek:  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
> [!NOTE]
>  Z zamkniętego skonstruowanego typu nie jest definicją typu ogólnego. Oznacza to, że nie można przypisać zamkniętego skonstruowanego typu `MyGenericList<int>` (`MyGenericList(Of Integer)` w języku Visual Basic) do zmiennej typu `MyGenericList<T>`.  
  
 Jeśli `c` parametr jest typu <xref:System.Reflection.Emit.TypeBuilder>, wynik jest oparty na typie, który ma zostać utworzony. Poniższy przykład kodu pokazuje, to przy użyciu wbudowanego typu o nazwie `B`.  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano `IsAssignableFrom` metody przy użyciu określonych klas, tablic całkowitą i typów ogólnych.  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy ciąg formatu atrybutu <see langword="AutoClass" /> został wybrany do <see cref="T:System.Type" />.</summary>
        <value>
          <see langword="true" /> ciąg formatowania atrybutu <see langword="AutoClass" /> został wybrany do <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> Wybiera atrybuty formatu ciągu. Atrybuty formatu ciągu ulepszenia współdziałania, definiując interpretacji ciągów.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta właściwość ma zastosowanie do definicji typu ogólnego, z którego został skonstruowany typu. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zawsze zwraca `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy pola typu bieżący układ automatycznie przez środowisko uruchomieniowe języka wspólnego.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="P:System.Type.Attributes" /> zawiera właściwości bieżącego typu <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest udostępniana jako udogodnienie. Alternatywnie można użyć <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> wartości wyliczenia, aby wybrać typ układu atrybutów, a następnie testować czy <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> jest ustawiona. <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, I <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> wartości wyliczenia wskazują sposób pól typu zostały przedstawione w pamięci.  
  
 W przypadku typów dynamicznych, można określić <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> po utworzeniu typu. W kodzie, zastosuj <xref:System.Runtime.InteropServices.StructLayoutAttribute> atrybutem <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> wartość wyliczenia na typ, aby określić odpowiedni sposób układ klasy środowiska uruchomieniowego.  
  
> [!NOTE]
>  Nie można użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metodę, aby określić, czy <xref:System.Runtime.InteropServices.StructLayoutAttribute> zostały zastosowane do typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta właściwość ma zastosowanie do definicji typu ogólnego, z którego został skonstruowany typu. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>.`  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ parametru w definicji typu ogólnego lub metody ogólnej, ta właściwość zawsze zwraca `false`.  
  
   
  
## Examples  
 Poniższy przykład powoduje utworzenie wystąpienia typu i wyświetla <xref:System.Type.IsAutoLayout%2A> właściwości.  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest przekazywana przez odwołanie.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest przekazywana przez odwołanie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać dostęp do typu rzeczywistego, należy usunąć odwołania do typu, który został przekazany przez odwołanie, a następnie wywołać <xref:System.Type.GetElementType%2A> tego typu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano korzystanie z `IsByRef` właściwość do sprawdzenia, czy określony typ jest przekazywana przez odwołanie. W przykładzie zdefiniowano klasę `MyTypeDelegator`, co zastępuje `HasElementTypeImpl` metody. Sprawdza, czy klasy głównym `HasElementType` właściwości i wyświetla typ elementu.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, implementuje <see cref="P:System.Type.IsByRef" /> właściwości i określa, czy <see cref="T:System.Type" /> jest przekazywana przez odwołanie.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest przekazywana przez odwołanie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> klasy lub delegata; oznacza to, nie jest typem wartości lub interfejs.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest klasą; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca `true` dla klasy, a także obiektów delegowanych. Zwraca `false` dla typów wartości (dla struktury i wyliczenia) nawet wtedy, gdy są one ramce.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ parametru w definicji typu ogólnego lub metody ogólnej, ta właściwość zawsze zwraca `true`. Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta właściwość zwraca `true` Jeśli definicji typu ogólnego jest definicję klasy; oznacza to, że nie definiuje interfejs lub typem wartości.  
  
> [!NOTE]
>  Ta właściwość zwraca `true` dla `Type` wystąpienia reprezentujące <xref:System.Enum> i <xref:System.ValueType> klasy. Te dwie klasy są odpowiednio typy podstawowe dla wyliczeń i typy wartości, ale nie są wyliczenia lub typu wartości, samodzielnie. Aby uzyskać więcej informacji, zobacz <xref:System.Type.IsValueType%2A> i <xref:System.Type.IsEnum%2A> właściwości.  
  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> Wartość wyliczenia odróżnia deklaracji typu klasy lub interfejsu. Jednak zarówno klas i typów wartości są oznaczone ikoną z <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> atrybutu. Jeśli pobierania wartości właściwości atrybutów i użyj typu <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> wartość, aby określić, czy typ jest klasą a typem wartości, musisz również wywołać <xref:System.Type.IsValueType%2A> właściwości. Przykład <xref:System.Reflection.TypeAttributes> wyliczenie zawiera dodatkowe informacje, a także anexample.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład powoduje utworzenie wystąpienia typu i wskazuje, czy typ jest klasą.  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest obiektem COM.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> obiektu modelu COM; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca `false` dla interfejsy modelu COM, ponieważ nie są obiektami. Interfejsy modelu COM może być zaimplementowany przez obiekty Microsoft .NET Framework.  
  
 Można załadować klasy COM i pobrać `Type` obiektu dla tej klasy COM za pomocą [Tlbimp.exe (Importer biblioteki typów)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) narzędzia.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta właściwość ma zastosowanie do definicji typu ogólnego, z którego został skonstruowany typu. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int`> (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ parametru w definicji typu ogólnego lub metody ogólnej, ta właściwość zawsze zwraca `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, implementuje <see cref="P:System.Type.IsCOMObject" /> właściwości i określa, czy <see cref="T:System.Type" /> jest obiektem COM.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> obiektu modelu COM; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca `false` dla interfejsy modelu COM, ponieważ nie są obiektami. Interfejsy modelu COM może być zaimplementowany przez obiekty Microsoft .NET Framework.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten obiekt reprezentuje skonstruowanego typu ogólnego. Można utworzyć wystąpienia typu ogólnego skonstruowane.</summary>
        <value>
          <see langword="true" /> Jeśli ten obiekt reprezentuje skonstruowanego typu ogólnego; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skonstruowanego typu ogólnego ma jawnie typów podane dla wszystkich parametrów typu ogólnego. Jest ona również określana jako zamknięte typu ogólnego.  
  
 Gdy ta właściwość jest `true`, można utworzyć wystąpienia typu bieżącego; gdy jest `false`, nie można wykonać.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> może znajdować się w kontekście.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> może być hostowana w kontekście, w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontekst przechwytuje wywołania do elementów członkowskich klasy i wymusza zasady, które są stosowane do klasy, takie jak synchronizacji. Aby uzyskać bardziej szczegółowe informacje dotyczące zdalnych kontekstów, zobacz <xref:System.Runtime.Remoting.Contexts.Context>.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ parametru w definicji typu ogólnego lub metody ogólnej, ta właściwość zawsze zwraca `false`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, i <xref:System.Type.IsPrimitive%2A> właściwości <xref:System.Type> klasy. Sprawdza, czy dany typ może znajdować się w kontekście, czy mogą być przekazywane przez odwołanie, oraz czy typ jest typem danych pierwotnych.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementuje <see cref="P:System.Type.IsContextful" /> właściwości i określa, czy <see cref="T:System.Type" /> może znajdować się w kontekście.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> może być hostowana w kontekście, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
 Kontekst przechwytuje wywołania do elementów członkowskich klasy i egzekwowanie zasad, które są stosowane do klasy, takie jak synchronizacji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano korzystanie z `IsContextfulImpl` metody.  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy bieżące <see cref="T:System.Type" /> reprezentuje wyliczenia.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący <see cref="T:System.Type" /> reprezentuje wyliczenia; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca `true` wyliczania, ale nie dla <xref:System.Enum> samego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta właściwość ma zastosowanie do definicji typu ogólnego, z którego został skonstruowany typu. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ parametru w definicji typu ogólnego lub metody ogólnej, ta właściwość zawsze zwraca `false`.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia `IsEnum` właściwości.  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Wartość, która ma zostać przetestowana.</param>
        <summary>Zwraca wartość wskazującą, czy określona wartość istnieje w bieżącym typem wyliczenia.</summary>
        <returns>
          <see langword="true" /> Jeśli określona wartość jest elementem członkowskim bieżącej typu wyliczenia; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Bieżący typ nie jest wyliczeniem.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> jest typu, który nie może być podstawowy typ wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">Typ modelu COM, który jest testowany do pełnienia roli równoważnika typu bieżącego.</param>
        <summary>Określa, czy dwa typy COM ma inną tożsamość i kwalifikują się do pełnienia roli równoważnika typu.</summary>
        <returns>
          <see langword="true" /> Jeśli typów COM są równoważne; w przeciwnym razie <see langword="false" />. Ta metoda zwraca również wartość <see langword="false" /> czy jeden typ w zestawie, który jest ładowany do wykonania, a drugą jest zestaw, który jest ładowany do kontekstu reflection-only.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], obsługuje środowisko uruchomieniowe języka wspólnego osadzanie informacji o typie dla typów COM bezpośrednio do zarządzanych zestawów, zwalniając zarządzanych zestawów można uzyskać informacji o typie dla typów COM z międzyoperacyjności zestawy. Ponieważ osadzony typ informacji obejmuje tylko typy i elementy członkowskie, które są rzeczywiście używane przez zestaw zarządzany, dwóch zestawów zarządzanych może być bardzo różne widoki tego samego typu COM. Każdy zestaw zarządzany ma inną <xref:System.Type> obiektu do reprezentowania jego widoku typu COM. Środowisko uruchomieniowe języka wspólnego obsługuje pełnienia roli równoważnika typu między tymi różne widoki dla interfejsów, struktury, wyliczenia i delegaty.  
  
 Pełnienia roli równoważnika typu oznacza, że obiekt COM, który jest przekazywany jeden zestaw zarządzany do innego, mogą być rzutowane na odpowiednie zarządzanego typu w zestawie odbierania. <xref:System.Type.IsEquivalentTo%2A> Metody umożliwia zestawu określić, czy obiekt COM uzyskane z innego zestawu ma taką samą tożsamość COM jako jeden z pierwszego zestawu własnych osadzone typy międzyoperacyjne i w związku z tym mogą być rzutowane na tego typu.  
  
 Aby uzyskać więcej informacji, zobacz [równoważność typów i osadzone typy międzyoperacyjne](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy pola typu bieżący układ przesunięcia jawnie określona.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="P:System.Type.Attributes" /> zawiera właściwości bieżącego typu <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest udostępniana jako udogodnienie. Alternatywnie można użyć <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> wartości wyliczenia, aby wybrać typ układu atrybutów, a następnie testować czy <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> jest ustawiona. <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, I <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> wartości wyliczenia wskazują sposób pól typu zostały przedstawione w pamięci.  
  
 W przypadku typów dynamicznych, można określić <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> po utworzeniu typu. W kodzie, zastosuj <xref:System.Runtime.InteropServices.StructLayoutAttribute> atrybutem <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> wartość wyliczenia typu, aby określić jawnie określono przesunięcia, w których polach Uruchom.  
  
> [!NOTE]
>  Nie można użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metodę, aby określić, czy <xref:System.Runtime.InteropServices.StructLayoutAttribute> zostały zastosowane do typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta właściwość ma zastosowanie do definicji typu ogólnego, z którego został skonstruowany typu. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ parametru w definicji typu ogólnego lub metody ogólnej, ta właściwość zawsze zwraca `false`.  
  
   
  
## Examples  
 Poniższy przykład powoduje utworzenie wystąpienia typu i wyświetla wartość jego <xref:System.Type.IsExplicitLayout%2A> właściwości. Używa `MySystemTime` klasy, która jest również w przykładzie kodu dla <xref:System.Runtime.InteropServices.StructLayoutAttribute>.  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy bieżące <see cref="T:System.Type" /> reprezentuje parametr typu w definicji typu ogólnego lub metody.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> obiekt reprezentuje parametr typu definicji typu ogólnego lub definicję metody rodzajowej; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> obiekty, które reprezentują parametry typu ogólnego można uzyskać przez wywołanie metody <xref:System.Type.GetGenericArguments%2A> metody <xref:System.Type> obiekt, który reprezentuje definicją typu ogólnego lub <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> metody <xref:System.Reflection.MethodInfo> obiekt, który reprezentuje Metoda ogólna Definicja.  
  
-   Dla typu ogólnego lub definicję metody <xref:System.Type.IsGenericParameter%2A> zwraca `true` dla każdego elementu w tablicy wynikowej.  
  
-   Zamknięte skonstruowanego typu lub metody <xref:System.Type.IsGenericParameter%2A> zwraca `false` dla każdego elementu tablicy zwracanej przez <xref:System.Type.GetGenericArguments%2A> metody.  
  
-   Otwórz skonstruowanego typu lub metody niektóre elementy tablicy mogą być określone typy, a inne mogą mieć parametrów typu. <xref:System.Type.IsGenericParameter%2A> Zwraca `false` dla typów i `true` dla parametrów typu. Przykład kodu dla <xref:System.Type.ContainsGenericParameters%2A> właściwości pokazuje klasy ogólnej mieszaniną typów i parametrów typu.  
  
 Lista niezmiennej warunki terminów używanych w ogólnym odbicia, zobacz <xref:System.Type.IsGenericType%2A> właściwości uwagi.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Type.IsGenericParameter%2A> właściwości do testowania dla ogólnych parametrów typu w typie ogólnym.  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący typ jest typem ogólnym.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący typ jest typem ogólnym; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Type.IsGenericType%2A> umożliwia określenie, czy <xref:System.Type> obiekt reprezentuje typu ogólnego. Użyj <xref:System.Type.ContainsGenericParameters%2A> umożliwia określenie, czy <xref:System.Type> obiekt reprezentuje skonstruowanego typu otwartego lub zamkniętego skonstruowanego typu.  
  
> [!NOTE]
>  <xref:System.Type.IsGenericType%2A> Zwraca `false` jeśli natychmiastowe typu nie jest rodzajowa. Na przykład tablicy, której elementy są typu `A<int>` (`A(Of Integer)` w języku Visual Basic) sam nie jest typem ogólnym.  
  
 Poniższa tabela zawiera podsumowanie niezmiennej warunki typowe terminy używane w ogólnym odbicia.  
  
|Termin|Niezmiennej|  
|----------|---------------|  
|Definicja typu ogólnego|<xref:System.Type.IsGenericTypeDefinition%2A> Jest właściwość `true`.<br /><br /> Definiuje typu ogólnego. Utworzony typ jest tworzony przez wywołanie metody <xref:System.Type.MakeGenericType%2A> metoda <xref:System.Type> obiekt, który reprezentuje definicji typu ogólnego i określając tablicę argumentów typu.<br /><br /> <xref:System.Type.MakeGenericType%2A> można wywołać tylko w definicji typu ogólnego.<br /><br /> Żadnych definicji typu ogólnego jest typu ogólnego ( <xref:System.Type.IsGenericType%2A> właściwość jest `true`), ale odwrotnej nie jest prawdziwe.|  
|Typ ogólny|<xref:System.Type.IsGenericType%2A> Jest właściwość `true`.<br /><br /> Może być definicją typu ogólnego, skonstruowanego typu otwartego lub zamkniętego skonstruowanego typu.<br /><br /> Należy pamiętać, że tablica typu o typie elementu jest rodzajowy sam nie jest typem ogólnym. To samo dotyczy z <xref:System.Type> obiekt reprezentujący wskaźnik do typu ogólnego.|  
|Otwórz utworzony typ|<xref:System.Type.ContainsGenericParameters%2A> Jest właściwość `true`.<br /><br /> Przykłady są typu ogólnego, który ma nieprzypisane parametrów typu, typu, który jest zagnieżdżony w definicji typu ogólnego lub skonstruowanego typu otwartego lub typem ogólnym, który ma argumentu typu, dla którego <xref:System.Type.ContainsGenericParameters%2A> jest właściwość `true`.<br /><br /> Nie jest możliwe utworzenie wystąpienia typu otwartego skonstruowane.<br /><br /> Należy zauważyć, że nie wszystkie otwarte typy utworzone ogólnego. Na przykład tablicy o typie elementu jest definicją typu ogólnego nie jest rodzajowa i nie jest rodzajowa wskaźnik do skonstruowanego typu otwartego.|  
|zamknięte utworzony typ|<xref:System.Type.ContainsGenericParameters%2A> Jest właściwość `false`.<br /><br /> Gdy rekursywnie zbadane, typ nie ma nieprzypisane ogólnych parametrów.|  
|Parametr typu ogólnego|<xref:System.Type.IsGenericParameter%2A> Jest właściwość `true`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> Jest właściwość `true`.<br /><br /> W definicji typu ogólnego jest symbolem zastępczym dla typu, który zostanie przypisany później.|  
|argument typu generycznego|Mogą być dowolnego typu, łącznie z parametru typu ogólnego.<br /><br /> Argumenty typu są określone jako tablicę <xref:System.Type> obiektów przekazany do <xref:System.Type.MakeGenericType%2A> metody podczas tworzenia skonstruowanego typu ogólnego. Jeśli wystąpienie typu Wynikowe mają zostać utworzone, <xref:System.Type.ContainsGenericParameters%2A> właściwość musi być `false` dla wszystkich argumentów typu.|  
  
 Następujący przykładowy kod i tabeli przedstawiono niektóre z tych warunków i invariants. `Derived` Klasa ma szczególne znaczenie, ponieważ jego typ podstawowy jest typem skonstruowane, który ma kombinację typów parametrów typu w jego listy argumentów typu.  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 W poniższej tabeli przykłady użycia i tworzenia klas `Base`, `Derived`, i `G`. Jeśli kod C++ i C# jest taki sam, jest wyświetlany tylko jeden wpis.  
  
|Przykład|Invariants|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|Dla tego typu:<br /><br /> <xref:System.Type.IsGenericType%2A> jest `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> jest `true`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> jest `true`.|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|Dla tego typu:<br /><br /> <xref:System.Type.IsGenericType%2A> jest `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> jest `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> jest `true`.|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|Dla typu zmienną `d`:<br /><br /> <xref:System.Type.IsGenericType%2A> jest `false` ponieważ `d` jest tablicą.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> jest `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> jest `false`.|  
|`T`, `U`, i `V` (wszędzie pojawią się one)|<xref:System.Type.IsGenericParameter%2A> jest `true`.<br /><br /> <xref:System.Type.IsGenericType%2A> jest `false` , ponieważ nie istnieje sposób ograniczyć parametr typu do typów ogólnych.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> jest `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> jest `true` ponieważ `T`, `U`, i `V` są same parametry typu ogólnego. Nie oznacza dowolne argumentów typu, które są przypisane do ich później.|  
|Typ pola `F`|<xref:System.Type.IsGenericType%2A> jest `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> jest `false` ponieważ typu przypisany do parametru typu metody `G`. Należy pamiętać, że jest to równoważne wywołaniem <xref:System.Type.MakeGenericType%2A> metody.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> jest `true` ponieważ typ pola `F` ma argumentu typu, który jest typem otwartym skonstruowane. Utworzony typ jest otwarty ponieważ jej argument Typ (czyli `Base`) jest definicją typu ogólnego. Przedstawiono to cykliczne rodzaj <xref:System.Type.IsGenericType%2A> właściwości.|  
|Klasy zagnieżdżone `Nested`|<xref:System.Type.IsGenericType%2A> jest `true`, mimo że `Nested` klasa nie ma typu ogólnego parametrów własnych, ponieważ jest zagnieżdżony w typie ogólnym.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> jest `true`. Oznacza to, że można wywołać <xref:System.Type.MakeGenericType%2A> — metoda i podaj parametr typu otaczającego typu `Derived`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> jest `true` ponieważ typ otaczający, `Derived`, ma parametry typu ogólnego. Przedstawiono to cykliczne rodzaj <xref:System.Type.ContainsGenericParameters%2A> właściwości.|  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, i <xref:System.Type.ContainsGenericParameters%2A> właściwości typów opisane w sekcji uwag. Wyjaśnień wartości właściwości Zobacz tabelę towarzyszący w uwagi.  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy bieżące <see cref="T:System.Type" /> reprezentuje definicji typu ogólnego, z którego można skonstruować innych typów ogólnych.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> obiekt reprezentuje definicji typu ogólnego; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definicji typu ogólnego jest szablonem, z którego można skonstruować innych typów. Na przykład z definicji typu ogólnego `G<T>` (wyrażony w języku C# składni; `G(Of T)` w języku Visual Basic lub `generic <typename T> ref class G` w języku C++) można utworzyć i utworzenia wystąpienia typu `G<int>` (`G(Of Integer)` w języku Visual Basic), przez wywołanie metody <xref:System.Type.MakeGenericType%2A> metodę z listy argumentów ogólnych zawierający <xref:System.Int32> typu. Podane <xref:System.Type> typu skonstruowany obiekt reprezentujący to <xref:System.Type.GetGenericTypeDefinition%2A> metoda pobiera definicji typu ogólnego ponownie ponownie.  
  
 Użyj <xref:System.Type.IsGenericTypeDefinition%2A> właściwości w celu określenia, czy można tworzyć nowe typy z bieżącego typu. Jeśli <xref:System.Type.IsGenericTypeDefinition%2A> zwraca `true`, można wywołać <xref:System.Type.MakeGenericType%2A> metodę w celu utworzenia nowych typów ogólnych.  
  
 Lista niezmiennej warunki terminów używanych w ogólnym odbicia, zobacz <xref:System.Type.IsGenericType%2A> właściwości uwagi.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono informacje o typie, włączając lub nie jest definicją typu ogólnego. Informacje są wyświetlane skonstruowanego typu, jego definicji typu ogólnego i zwykłe typu.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> ma <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> atrybut, wskazujący, że został zaimportowany z biblioteki typów COM.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> ma <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta właściwość ma zastosowanie do definicji typu ogólnego, z którego został skonstruowany typu. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>.`  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ parametru w definicji typu ogólnego lub metody ogólnej, ta właściwość zawsze zwraca `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt do porównania z bieżącym typem.</param>
        <summary>Określa, czy określony obiekt jest wystąpieniem bieżącego <see cref="T:System.Type" />.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący <see langword="Type" /> znajduje się w hierarchii dziedziczenia obiektu reprezentowanego przez <paramref name="o" />, lub, jeśli bieżący <see langword="Type" /> jest interfejsem który <paramref name="o" /> implementuje. <see langword="false" /> Jeśli oba te warunki sprawy, jeśli jest <paramref name="o" /> jest <see langword="null" />, lub, jeśli bieżący <see langword="Type" /> jest otwartym typem ogólnym (to znaczy <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
> [!NOTE]
>  Utworzony typ nie jest wystąpieniem jego definicji typu ogólnego. Oznacza to `MyGenericList<int>` (`MyGenericList(Of Integer)` w języku Visual Basic) nie jest wystąpieniem `MyGenericList<T>` (`MyGenericList(Of T)` w języku Visual Basic).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie `IsInstanceOfType` metody.  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> interfejsu; nie jest klasą ani typem wartości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest interfejsem, a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> Odróżnia deklaracji typu jako typu klasą, interfejsem lub wartość.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ parametru w definicji typu ogólnego lub metody ogólnej, ta właściwość zawsze zwraca `false`.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład tworzy interfejs, sprawdza, czy typ interfejsu i wskazuje, czy klasa `IsInterface` zestawu właściwości.  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy pola bieżącego typu są ułożone sekwencyjnie, w kolejności, że zostały zdefiniowane lub wysyłanego do metadanych.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="P:System.Type.Attributes" /> zawiera właściwości bieżącego typu <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest udostępniana jako udogodnienie. Alternatywnie można użyć <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> wartości wyliczenia, aby wybrać typ układu atrybutów, a następnie testować czy <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> jest ustawiona. <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, I <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> wartości wyliczenia wskazują sposób pól typu zostały przedstawione w pamięci.  
  
 W przypadku typów dynamicznych, można określić <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> po utworzeniu typu. W kodzie, zastosuj <xref:System.Runtime.InteropServices.StructLayoutAttribute> atrybutem <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> wartość wyliczenia na typ, aby określić taki układ jest Sekwencyjna.  
  
> [!NOTE]
>  Nie można użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metodę, aby określić, czy <xref:System.Runtime.InteropServices.StructLayoutAttribute> zostały zastosowane do typu.  
  
 Aby uzyskać więcej informacji zobacz sekcję 9.1.2 specyfikacji dokumentacji infrastruktury języka wspólnego (CLI), "Partycji II: metadane definicji i semantyki". Dokumentacja jest dostępna w trybie online; zobacz [ECMA C# i wspólne normy infrastruktury języka](http://go.microsoft.com/fwlink/?LinkID=99212) w witrynie MSDN i [standardowe ECMA-335 - infrastruktury języka wspólnego (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) w witrynie sieci Web międzynarodowej Ecma.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta właściwość ma zastosowanie do definicji typu ogólnego, z którego został skonstruowany typu. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ parametru w definicji typu ogólnego lub metody ogólnej, ta właściwość zawsze zwraca `false`.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie klasy, dla którego <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> wartość wyliczenia w <xref:System.Runtime.InteropServices.StructLayoutAttribute> klasy został ustawiony, sprawdza, czy <xref:System.Type.IsLayoutSequential%2A> właściwości oraz wyświetla wyniki.  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest przekazywane przez odwołanie.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> organizowane przez odwołanie, a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, i <xref:System.Type.IsPrimitive%2A> właściwości <xref:System.Type> klasy. Sprawdza, czy dany typ może znajdować się w kontekście, czy mogą być przekazywane przez odwołanie, oraz czy typ jest typem danych pierwotnych.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementuje <see cref="P:System.Type.IsMarshalByRef" /> właściwości i określa, czy <see cref="T:System.Type" /> jest przekazywane przez odwołanie.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> organizowane przez odwołanie, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
   
  
## Examples  
 Poniższy przykład określa, czy dany typ jest przekazywane przez odwołanie i wyświetla wyniki.  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy bieżące <see cref="T:System.Type" /> obiekt reprezentuje typ, którego definicja jest zagnieżdżona w definicji innego typu.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> zagnieżdżone wewnątrz innego typu, a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsNested%2A> Zwraca `true` dla wszystkich zagnieżdżonych typów, niezależnie od widoczności. Aby przetestować zagnieżdżenia i wgląd w tym samym czasie, należy użyć powiązane właściwości <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, lub <xref:System.Type.IsNestedPublic%2A>.  
  
> [!NOTE]
>  <xref:System.Reflection.TypeAttributes.VisibilityMask> Wyliczeniowego wybiera atrybutów widoczności dla typu.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę zewnętrzne z liczbą zagnieżdżonych klas, które mają różne rodzaje widoczności. Następnie pobiera wartość Liczba związanych z widocznością <xref:System.Type> właściwości dla typu nadrzędnego i każdego z jego typów zagnieżdżonych.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest zagnieżdżony i są widoczne tylko w obrębie własnego zestawu.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> zagnieżdżonych i widoczne tylko w obrębie własnego zestawu, a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zawsze zwraca `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wybiera atrybutów widoczności.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę zewnętrzne z liczbą zagnieżdżonych klas, które mają różne rodzaje widoczności. Następnie pobiera wartość Liczba związanych z widocznością <xref:System.Type> właściwości dla typu nadrzędnego i każdego z jego typów zagnieżdżonych.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest zagnieżdżone i są widoczne tylko dla klas, które należą do jego własnej rodziny i jego własny zestaw.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> zagnieżdżonych i są widoczne tylko dla klas, które należą do jego własnej rodziny i jego własny zestaw a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zawsze zwraca `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wybiera atrybutów widoczności.  
  
> [!NOTE]
>  Języki C# i Visual Basic nie dołączaj semantyki, które umożliwiają definiowanie typu zagnieżdżonego widocznego tylko dla chronionych typów w zestawie własny. `protected internal` widoczność w języku C# i `Protected Friend` widoczność w języku Visual Basic zdefiniować typu zagnieżdżonego nie jest widoczny, typy chronione i typy w tym samym zestawie.  
  
 A <xref:System.Type> rodziny obiektu jest zdefiniowana jako wszystkie obiekty tego samego <xref:System.Type> i jego podtypach.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę zewnętrzne z liczbą zagnieżdżonych klas, które mają różne rodzaje widoczności. Następnie pobiera wartość Liczba związanych z widocznością <xref:System.Type> właściwości dla typu nadrzędnego i każdego z jego typów zagnieżdżonych.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest zagnieżdżony i są widoczne tylko w obrębie własnej rodziny.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> zagnieżdżonych i widoczne tylko w obrębie własnej rodziny, a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zawsze zwraca `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wybiera atrybutów widoczności.  
  
 A <xref:System.Type> rodziny obiektu jest zdefiniowana jako wszystkich obiektów dokładnie tego samego <xref:System.Type> i jego podtypach.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę zewnętrzne z liczbą zagnieżdżonych klas, które mają różne rodzaje widoczności. Następnie pobiera wartość Liczba związanych z widocznością <xref:System.Type> właściwości dla typu nadrzędnego i każdego z jego typów zagnieżdżonych.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest zagnieżdżony i są widoczne tylko dla klas, które należą do jednej własnej rodziny lub ich własnych zestawach.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> zagnieżdżonych i są widoczne tylko dla klas, które należą do jego własnej rodziny lub ich własnych zestawach a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku widoczności typu `protected internal` w języku C# lub `Protected Friend` w języku Visual Basic <xref:System.Type.IsNestedFamORAssem%2A> zwraca właściwość `true`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zawsze zwraca `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wybiera atrybutów widoczności.  
  
 A <xref:System.Type> rodziny obiektu jest zdefiniowana jako wszystkich obiektów dokładnie tego samego <xref:System.Type> i jego podtypach.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę zewnętrzne z liczbą zagnieżdżonych klas, które mają różne rodzaje widoczności. Następnie pobiera wartość Liczba związanych z widocznością <xref:System.Type> właściwości dla typu nadrzędnego i każdego z jego typów zagnieżdżonych.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest zagnieżdżony i zadeklarowana jako private.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zagnieżdżony i zadeklarowany prywatnej; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zawsze zwraca `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wybiera atrybutów widoczności.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę zewnętrzne z liczbą zagnieżdżonych klas, które mają różne rodzaje widoczności. Następnie pobiera wartość Liczba związanych z widocznością <xref:System.Type> właściwości dla typu nadrzędnego i każdego z jego typów zagnieżdżonych.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy klasa jest zagnieżdżony i zadeklarowany jako publiczny.</summary>
        <value>
          <see langword="true" /> Jeśli klasa jest publiczny zagnieżdżony i zadeklarowane; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zawsze zwraca `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wybiera atrybutów widoczności.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę zewnętrzne z liczbą zagnieżdżonych klas, które mają różne rodzaje widoczności. Następnie pobiera wartość Liczba związanych z widocznością <xref:System.Type> właściwości dla typu nadrzędnego i każdego z jego typów zagnieżdżonych.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> nie jest zadeklarowany jako publiczny.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> nie jest zadeklarowany jako publiczny i nie jest typem zagnieżdżonym; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy używać tej właściwości z typów zagnieżdżonych. Użyj <xref:System.Type.IsNestedPublic%2A> właściwości zamiast tego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zwraca `false`.  
  
   
  
## Examples  
 Ten przykład usesthe `IsNotPublic` właściwości, aby uzyskać informacje o typie.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 Poniższy przykład kodu pokazuje, dlaczego nie można użyć `IsPublic` i `IsNotPublic` dla klas zagnieżdżonych.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 Dla klas zagnieżdżonych Ignoruj wyników `IsPublic` i `IsNotPublic` i należy zwrócić uwagę tylko do wyników `IsNestedPublic` i `IsNestedPrivate`. Dane wyjściowe odbicia dla fragmentu kodu będzie w następujący sposób:  
  
|Class|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|ELEMENT|FAŁSZ|WARTOŚĆ TRUE|FAŁSZ|FAŁSZ|  
|B|FAŁSZ|FAŁSZ|WARTOŚĆ TRUE|FAŁSZ|  
|C|FAŁSZ|FAŁSZ|FAŁSZ|WARTOŚĆ TRUE|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> wskaźnik.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> wskaźnik; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje typu ogólnego lub parametrem typu w definicji typu ogólnego lub metody ogólnej, ta właściwość zawsze zwraca `false`.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono użycie `IsPointer` właściwości.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, implementuje <see cref="P:System.Type.IsPointer" /> właściwości i określa, czy <see cref="T:System.Type" /> wskaźnik.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> wskaźnik; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest jednym z typów pierwotnych.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest jednym z typów pierwotnych; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typy pierwotne są <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, i <xref:System.Single>.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typu ogólnego lub parametrem typu w definicji typu ogólnego lub metody ogólnej, ta właściwość zawsze zwraca `false`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, i <xref:System.Type.IsPrimitive%2A> właściwości <xref:System.Type> klasy. Sprawdza, czy dany typ może znajdować się w kontekście, czy mogą być przekazywane przez odwołanie, oraz czy typ jest typem danych pierwotnych.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, implementuje <see cref="P:System.Type.IsPrimitive" /> właściwości i określa, czy <see cref="T:System.Type" /> jest jednym z typów pierwotnych.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest jednym z typów pierwotnych; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typy pierwotne są <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, i <xref:System.Single>.  
  
   
  
## Examples  
 Poniższy przykład określa, czy dany typ jest typem pierwotnym i wyświetla wyniki.  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest zadeklarowany jako publiczny.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zadeklarowany jako publiczny i nie jest typem zagnieżdżonym; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy używać z zagnieżdżone typy; Użyj <xref:System.Type.IsNestedPublic%2A> zamiast tego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zwraca `true`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wybiera atrybutów widoczności.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie `MyTestClass`, sprawdza, czy `IsPublic` właściwości oraz wyświetla wynik.  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 Dla klas zagnieżdżonych Ignoruj wyników `IsPublic` i `IsNotPublic` i należy zwrócić uwagę tylko do wyników <xref:System.Type.IsNestedPublic%2A> i <xref:System.Type.IsNestedPrivate%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest zadeklarowany jako sealed.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest zadeklarowany jako sealed; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zawsze zwraca `true`.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie `sealed` klasy sprawdza, czy `IsSealed` właściwości oraz wyświetla wynik.  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący typ jest krytyczny dla zabezpieczeń lub bezpieczny krytyczny dla zabezpieczeń na bieżącym poziomie zaufania i dlatego mogą wykonywać operacje krytyczne.</summary>
        <value>
          <see langword="true" /> w przypadku bieżącego typu zabezpieczeń krytyczne lub zabezpieczeń — bezpieczne krytyczne na bieżącym poziomie zaufania; <see langword="false" /> Jeśli jest niewidoczne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, I <xref:System.Type.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości typu na bieżącym poziomie zaufania określone przez środowisko uruchomieniowe języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Przy użyciu tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu i jego typów, sprawdzania na bieżącym poziomie zaufania i próby zduplikowane reguły środowiska uruchomieniowego.  
  
> [!IMPORTANT]
>  Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu. Jeżeli zestaw jest ładowany do domeny aplikacji częściowo zaufanej (na przykład w domenie aplikacji w trybie piaskownicy), środowisko wykonawcze ignoruje adnotacje zabezpieczeń zestawu. Zestaw i wszystkie jego typy są traktowane jako przezroczyste. Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu). Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany. Można określić bieżącego poziomy zaufania zestawów i domen aplikacji przy użyciu <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> i <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości.  
  
 Aby uzyskać więcej informacji na temat odbicia i przejrzystości, zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Informacje o przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący typ jest bezpieczny krytyczny dla zabezpieczeń na bieżącym poziomie zaufania; oznacza to, czy go mogą wykonywać operacje krytyczne i można uzyskać, sprawdzając kod przezroczysty.</summary>
        <value>
          <see langword="true" /> w przypadku bieżącego typu zabezpieczeń — bezpieczne krytyczne na bieżącym poziomie zaufania; <see langword="false" /> przypadku zabezpieczeń krytyczny ani przezroczysty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, I <xref:System.Type.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości typu na bieżącym poziomie zaufania określone przez środowisko uruchomieniowe języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Przy użyciu tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu i jego typów, sprawdzania na bieżącym poziomie zaufania i próby zduplikowane reguły środowiska uruchomieniowego.  
  
> [!IMPORTANT]
>  Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu. Jeżeli zestaw jest ładowany do domeny aplikacji częściowo zaufanej (na przykład w domenie aplikacji w trybie piaskownicy), środowisko wykonawcze ignoruje adnotacje zabezpieczeń zestawu. Zestaw i wszystkie jego typy są traktowane jako przezroczyste. Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu). Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany. Można określić bieżącego poziomy zaufania zestawów i domen aplikacji przy użyciu <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> i <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości.  
  
 Aby uzyskać więcej informacji na temat odbicia i przejrzystości, zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Informacje o przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która wskazuje, czy bieżący typ jest niewidoczny na bieżącym poziomie zaufania i dlatego nie można wykonać operacji krytyczne.</summary>
        <value>
          <see langword="true" /> Jeśli typ znajduje przejrzysty zabezpieczeń na bieżącym poziomie zaufania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość zwraca `true`, <xref:System.Type.IsSecurityCritical%2A> i <xref:System.Type.IsSecuritySafeCritical%2A> return właściwości `false`.  
  
 <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, I <xref:System.Type.IsSecurityTransparent%2A> właściwości raportu poziom przezroczystości typu na bieżącym poziomie zaufania określone przez środowisko uruchomieniowe języka wspólnego (CLR). Przy użyciu tych właściwości jest znacznie prostsze niż badanie adnotacje zabezpieczeń zestawu i jego typów, sprawdzania na bieżącym poziomie zaufania i próby zduplikowane reguły środowiska uruchomieniowego.  
  
> [!IMPORTANT]
>  Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu. Jeżeli zestaw jest ładowany do domeny aplikacji częściowo zaufanej (na przykład w domenie aplikacji w trybie piaskownicy), środowisko wykonawcze ignoruje adnotacje zabezpieczeń zestawu. Zestaw i wszystkie jego typy są traktowane jako przezroczyste. Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu). Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany. Można określić bieżącego poziomy zaufania zestawów i domen aplikacji przy użyciu <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> i <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości.  
  
 Aby uzyskać więcej informacji na temat odbicia i przejrzystości, zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Informacje o przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest możliwy do serializacji.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest możliwy do serializacji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Typy, które są zdefiniowane w normie .NET nie są oznaczone ikoną z <xref:System.SerializableAttribute>. Zamiast tego każda implementacja .NET określa, czy typ jest możliwy do serializacji. W czasie wykonywania, można użyć <xref:System.Type.IsSerializable%2A> właściwości w celu określenia, czy tę implementację obsługuje serializacji wystąpienia typu. Aby uzyskać więcej informacji i przykład zobacz [jak ustalić, czy obiekt .NET Standard jest możliwy do serializacji](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta właściwość ma zastosowanie do definicji typu ogólnego, z którego został skonstruowany typu. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ parametru w definicji typu ogólnego lub metody ogólnej, ta właściwość zawsze zwraca `false`.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie `MyTestClass` klasy, ustawia atrybut [Serializable] i sprawdza `IsSerializable` właściwość `true` lub `false`.  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy typ ma nazwę, która wymaga specjalnej obsługi.</summary>
        <value>
          <see langword="true" /> Jeśli typ ma nazwę, która wymaga specjalnej obsługi; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwy zaczynać ani zawierać znaku podkreślenia (_), metod dostępu do właściwości i metod przeładowanie operatora są przykładowe typy, które mogą wymagać specjalnego przetwarzania przez niektóre kompilatory.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta właściwość ma zastosowanie do definicji typu ogólnego, z którego został skonstruowany typu. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ parametru w definicji typu ogólnego lub metody ogólnej, ta właściwość zawsze zwraca `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Typ do porównania z bieżącym typem.</param>
        <summary>Określa, czy bieżący <see cref="T:System.Type" /> pochodzi z określonego <see cref="T:System.Type" />.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący <see langword="Type" /> pochodną <paramref name="c" />; w przeciwnym razie <see langword="false" />. Ta metoda zwraca również wartość <see langword="false" /> Jeśli <paramref name="c" /> i obecnie <see langword="Type" /> są takie same.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz wywołać <xref:System.Type.IsSubclassOf%2A> metodę, aby określić jedną z następujących czynności:  
  
-   Określa, czy jedna klasa pochodzi z innego.  
  
-   Czy typ pochodzi z <xref:System.ValueType>. Jednak <xref:System.Type.IsValueType%2A> jest bardziej wydajny sposób, aby określić, czy typ jest typem wartości.  
  
-   Czy typ pochodzi z <xref:System.Enum>. Jednak <xref:System.Type.IsEnum%2A> metoda jest bardziej wydajny sposób, aby określić, czy typ jest wyliczeniem.  
  
-   Określa, czy typ jest delegatem, oznacza to, czy pochodzi od albo <xref:System.Delegate> lub <xref:System.MulticastDelegate>.  
  
 <xref:System.Type.IsSubclassOf%2A> — Metoda nie może służyć do określenia, czy interfejs pochodzi z innego interfejsu, lub określa, czy klasa implementuje interfejs. Użyj <xref:System.Type.IsAssignableFrom%2A> metody w tym celu, jak przedstawiono na poniższym przykładzie.  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, pochodzi z jego ograniczenia klasy lub <xref:System.Object?displayProperty=nameWithType> Jeśli go nie ma ograniczenia klasy.  
  
> [!NOTE]
>  Z wyjątkiem sytuacji, gdy jest używany z interfejsów, <xref:System.Type.IsSubclassOf%2A> jest odwrotnej z <xref:System.Type.IsAssignableFrom%2A>. Oznacza to, że jeśli `t1.IsSubclassOf(t2)` jest `true`, następnie `t2.IsAssignableFrom(t1)` jest również `true`.  
  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę o nazwie `Class1` i pochodne klasy o nazwie `DerivedC1`. Wywołuje <xref:System.Type.IsSubclassOf%2A> pokazują, że metoda `DerivedC1` jest podklasą `Class1`.  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="c" /> jest <see langword="null" />.</exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy ciąg formatu atrybutu <see langword="UnicodeClass" /> został wybrany do <see cref="T:System.Type" />.</summary>
        <value>
          <see langword="true" /> ciąg formatowania atrybutu <see langword="UnicodeClass" /> został wybrany do <see cref="T:System.Type" />; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> Służy do wybierania atrybuty formatu ciągu. Atrybuty formatu ciągu ulepszenia współdziałania, definiując interpretacji ciągów.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta właściwość ma zastosowanie do definicji typu ogólnego, z którego został skonstruowany typu. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ parametru w definicji typu ogólnego lub metody ogólnej, ta właściwość zawsze zwraca `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> jest typem wartości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest typem wartości; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typy wartości są typy, które są prezentowane w postaci sekwencji bitów; typy wartości nie są interfejsów lub klas. Typy wartości są określane jako "struktur" w przypadku niektórych języków programowania. Typy wyliczeniowe są szczególnych przypadkach typów wartości.  
  
 Ta właściwość zwraca `false` dla <xref:System.ValueType> klasy, ponieważ <xref:System.ValueType> nie jest typem wartości samej siebie. Jest klasą bazową dla wszystkich typów wartości i dlatego dowolnego typu wartości można przypisać do niej. To nie jest możliwe Jeśli <xref:System.ValueType> sam ma typ wartości. Typy wartości są opakowany przy ich przypisywaniu do pola typu <xref:System.ValueType>.  
  
 Ta właściwość zwraca `true` dla wyliczenia, ale nie dla <xref:System.Enum> samego typu. Na przykład, który pokazuje tego zachowania, zobacz <xref:System.Type.IsEnum%2A>.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład tworzy zmienną typu `MyEnum`, sprawdza, czy `IsValueType` właściwości oraz wyświetla wynik.  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementuje <see cref="P:System.Type.IsValueType" /> właściwości i określa, czy <see cref="T:System.Type" /> typ wartości; oznacza to, nie jest klasą lub interfejsem.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Type" /> jest typem wartości; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest umożliwiające implementacji alternatywnych typu systemów. Jest nie on zwykle używany w kodzie aplikacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Type" /> można uzyskać, sprawdzając kod poza zestaw.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący <see cref="T:System.Type" /> jest typem publicznym lub publiczny zagnieżdżony typ tak, aby były otaczającego typy publiczne; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia określenie, czy typ jest częścią interfejs publiczny zestaw składników.  
  
   
  
## Examples  
 Poniższy przykład kodu testy dwie klasy, z których tylko jedna jest widoczna poza zestaw.  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca <see cref="T:System.Type" /> obiekt, który reprezentuje tablicę bieżącego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Type" /> obiekt reprezentujący tablicą jednowymiarową bieżącego typu z dolną granicą zero.</summary>
        <returns>A <see cref="T:System.Type" /> obiekt reprezentujący tablicą jednowymiarową bieżącego typu z dolną granicą zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A> Metody umożliwia generowanie typy tablic, których typy elementu są obliczane w czasie wykonywania.  
  
 **Uwaga** środowisko uruchomieniowe języka wspólnego rozróżnia wektorów (to znaczy tablice jednowymiarowe które są zawsze liczony od zera) i tablic wielowymiarowych. Wektor, która zawsze ma tylko jeden wymiar, nie jest taka sama jak tablicy wielowymiarowej, która będzie mieć tylko jeden wymiar. Przeciążenie tej metody może służyć tylko do tworzenia typów wektora i jest jedynym sposobem, aby utworzyć typ wektora. Użyj <xref:System.Type.MakeArrayType%28System.Int32%29> przeciążenie metody, aby utworzyć typy tablicy wielowymiarowej.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tablicę `ref` (`ByRef` w języku Visual Basic) oraz typów wskaźnika `Test` klasy.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej. Klasa pochodna musi zapewniać implementację.</exception>
        <exception cref="T:System.TypeLoadException">Bieżący typ <see cref="T:System.TypedReference" />.  - lub - bieżący typ <see langword="ByRef" /> typu. Oznacza to <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">Liczba wymiarów tablicy. Ta liczba musi być mniejsza lub równa 32.</param>
        <summary>Zwraca <see cref="T:System.Type" /> obiekt reprezentujący bieżącego typu o określoną liczbę wymiarów tablicy.</summary>
        <returns>Obiekt reprezentujący bieżącego typu o określoną liczbę wymiarów tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A> Metody umożliwia generowanie typy tablic, których typy elementu są obliczane w czasie wykonywania.  
  
> [!NOTE]
>  Środowisko uruchomieniowe języka wspólnego rozróżnia wektorów (to znaczy tablice jednowymiarowe które są zawsze liczony od zera) i tablic wielowymiarowych. Wektor, która zawsze ma tylko jeden wymiar, nie jest taka sama jak tablicy wielowymiarowej, która będzie mieć tylko jeden wymiar. Przeciążenie tej metody nie można użyć do utworzenia typu wektora; Jeśli `rank` 1, przeciążenie metody zwraca typ tablicy wielowymiarowej, która ma jeden wymiar. Użyj <xref:System.Type.MakeArrayType> przeciążenie metody do tworzenia typów wektora.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tablicę `ref` (`ByRef` w języku Visual Basic) oraz typów wskaźnika `Test` klasy.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="rank" /> jest nieprawidłowy. Na przykład 0 ani ujemna.</exception>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</exception>
        <exception cref="T:System.TypeLoadException">Bieżący typ <see cref="T:System.TypedReference" />.  - lub - bieżący typ <see langword="ByRef" /> typu. Oznacza to <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.  - lub - <paramref name="rank" /> jest większa niż 32.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Type" /> obiekt, który reprezentuje bieżącego typu, gdy dane są przekazywane jako <see langword="ref" /> parametr (<see langword="ByRef" /> parametru w języku Visual Basic).</summary>
        <returns>A <see cref="T:System.Type" /> obiekt, który reprezentuje bieżącego typu, gdy dane są przekazywane jako <see langword="ref" /> parametr (<see langword="ByRef" /> parametru w języku Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeByRefType%2A> Metody umożliwia generowanie `ref` typów (`ByRef` w języku Visual Basic) dla parametru listy.  
  
 Przy użyciu składni języka pośredniego firmy Microsoft (MSIL), jeśli bieżący <xref:System.Type> obiekt reprezentuje <xref:System.Int32>, ta metoda zwraca <xref:System.Type> reprezentujący obiekt `Int32&`.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tablicę `ref` (`ByRef` w języku Visual Basic) oraz typów wskaźnika `Test` klasy.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</exception>
        <exception cref="T:System.TypeLoadException">Bieżący typ <see cref="T:System.TypedReference" />.  - lub - bieżący typ <see langword="ByRef" /> typu. Oznacza to <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Tablica typów mają być zastępowane dla parametrów typu bieżącego typu ogólnego.</param>
        <summary>Zastępuje elementy tablicą typów parametrów typu bieżącej definicji typu ogólnego i zwraca <see cref="T:System.Type" /> obiekt reprezentujący powstałe w ten sposób skonstruować typu.</summary>
        <returns>A <see cref="T:System.Type" /> reprezentujący utworzony typ sformułowany, zastępując elementy <paramref name="typeArguments" /> parametrów typu bieżącego typu ogólnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeGenericType%2A> Metoda służy do pisania kodu, który przypisuje określone typy parametrów typu w definicji typu ogólnego, co powoduje utworzenie <xref:System.Type> obiekt, który reprezentuje skonstruowane określonego typu. Możesz użyć tej funkcji <xref:System.Type> obiekt do tworzenia wystąpień skonstruowanego typu czasu wykonywania.  
  
 Typy utworzone z <xref:System.Type.MakeGenericType%2A> może być otwarty, oznacza to, że niektóre z jego argumentów typu można otaczającej metod ogólnych lub typów parametrów typu. Można na przykład takie Otwórz typy utworzone podczas emitowanie dynamicznych zestawów. Rozważmy na przykład klasy `Base` i `Derived` w poniższym kodzie.  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 Aby wygenerować `Derived` w zestawie dynamicznym, należy utworzyć jego typ podstawowy. Aby to zrobić, należy wywołać <xref:System.Type.MakeGenericType%2A> metoda <xref:System.Type> obiekt reprezentujący klasę `Base`, przy użyciu argumentów typu ogólnego <xref:System.Int32> i parametr typu `V` z `Derived`. Ponieważ parametry typu ogólnego i typy są reprezentowane przez <xref:System.Type> obiekty, tablica zawierająca zarówno mogą zostać przekazane do <xref:System.Type.MakeGenericType%2A> metody.  
  
> [!NOTE]
>  Utworzony typ, takich jak `Base<int, V>` jest przydatne w przypadku gdy emitowanie kodu, ale nie można wywołać <xref:System.Type.MakeGenericType%2A> metody dla tego typu, ponieważ nie jest definicją typu ogólnego. Aby utworzyć zamkniętego skonstruowanego typu, który można utworzyć wystąpienia, należy najpierw wywołać <xref:System.Type.GetGenericTypeDefinition%2A> metodę, aby pobrać <xref:System.Type> obiekt reprezentujący definicji typu ogólnego, a następnie wywołać <xref:System.Type.MakeGenericType%2A> z argumentami odpowiedniego typu.  
  
 <xref:System.Type> Obiektu zwróconego przez <xref:System.Type.MakeGenericType%2A> jest taka sama jak <xref:System.Type> można uzyskać przez wywołanie <xref:System.Object.GetType%2A> metody powstałe w ten sposób tworzony typ, lub <xref:System.Object.GetType%2A> metody dowolnego skonstruować typu, który został utworzony z tej samej ogólny Definicja typu przy użyciu tego samego argumentów typu.  
  
> [!NOTE]
>  Tablica typów ogólnych sam nie jest typem ogólnym. Nie można wywołać <xref:System.Type.MakeGenericType%2A> na tablicy wpisz na przykład `C<T>[]` (`Dim ac() As C(Of T)` w języku Visual Basic). Do utworzenia zamkniętego typu ogólnego z `C<T>[]`, wywołaj <xref:System.Type.GetElementType%2A> uzyskanie definicji typu ogólnego `C<T>`; wywołać <xref:System.Type.MakeGenericType%2A> w definicji typu ogólnego utworzyć utworzony typ; i na koniec wywołać <xref:System.Type.MakeArrayType%2A> metody w utworzony typ można utworzyć typu tablicy. To samo dotyczy typów wskaźnika i `ref` typów (`ByRef` w języku Visual Basic).  
  
 Lista niezmiennej warunki terminów używanych w ogólnym odbicia, zobacz <xref:System.Type.IsGenericType%2A> właściwości uwagi.  
  
## <a name="nested-types"></a>Zagnieżdżone typy  
 Jeśli ogólny typ został zdefiniowany przy użyciu języka C#, C++ lub Visual Basic, jego zagnieżdżone typy są wszystkie ogólne. Dotyczy to nawet, jeśli typy zagnieżdżone nie może mieć typu parametrów we własnym, ponieważ parametry typu otaczającej w liście parametrów typu, typów zagnieżdżonych typów zawiera wszystkich trzech językach. Należy wziąć pod uwagę następujące klasy:  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 Lista parametrów typu klasy zagnieżdżonej `Inner` ma dwa parametry typu `T` i `U`, z których pierwszy jest parametr typu klasy otaczającej jej. Podobnie, lista parametrów typu klasy zagnieżdżonej `Innermost1` ma trzy parametrów typu, `T`, `U`, i `V`, z `T` i `U` pochodzące z jej klas otaczającej. Zagnieżdżona klasa `Innermost2` ma dwa parametry typu `T` i `U`, które pochodzą z jej klas otaczającej.  
  
 Jeśli lista parametrów typu otaczającego ma więcej niż jeden parametr typu, wszystkie parametry typu w kolejności znajdują się na liście parametrów typu typu zagnieżdżonego.  
  
 Aby skonstruować typu ogólnego z definicji typu ogólnego typu zagnieżdżonego, należy wywołać <xref:System.Type.MakeGenericType%2A> metody z tablicą utworzone przez łączenie tablic argumentu typu wszystkich otaczającej typów, począwszy od najbardziej zewnętrznego typu ogólnego i zakończone Wpisz tablica argumentów typu zagnieżdżonego, jeśli ma parametry typu własnych. Można utworzyć wystąpienia `Innermost1`, wywołaj <xref:System.Type.MakeGenericType%2A> metody z tablicą zawierającą trzy typy do przypisania do T, U i V. Można utworzyć wystąpienia `Innermost2`, wywołaj <xref:System.Type.MakeGenericType%2A> metody z tablica zawierająca dwa typy, można przypisać do T i U.  
  
 Języki propagować parametrów typu w otaczającej typów w ten sposób, aby parametry typu typu otaczającego umożliwia definiowanie pól zagnieżdżonych typów. W przeciwnym razie wartość parametrów typu nie można się w zakresie w treści zagnieżdżonych typów. Można zdefiniować zagnieżdżone typy bez propagowanie parametrów typu w otaczającej typów, za emitowanie kodu w dynamicznych zestawach lub za pomocą [Ilasm.exe (asembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md). Rozważmy następujący kod do asemblera MSIL:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 W tym przykładzie nie jest możliwe określenie pola typu `T` lub `U` w klasie `Innermost`, ponieważ te parametry typu nie są w zakresie. W poniższym kodzie asemblera zdefiniowano zagnieżdżonych klas, które zachowują się w sposób gdyby zdefiniowany w języku C++, Visual Basic i C#:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 Można użyć [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do badania zagnieżdżonych klas zdefiniowanych w językach wysokiego poziomu i obserwować ten schemat nazewnictwa.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Type.MakeGenericType%2A> metodę w celu utworzenia skonstruowanego typu z definicji typu ogólnego <xref:System.Collections.Generic.Dictionary%602> typu. Reprezentuje utworzony typ <xref:System.Collections.Generic.Dictionary%602> z `Test` obiektów z kluczy będących ciągami.  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący typ nie reprezentuje definicji typu ogólnego. Oznacza to <see cref="P:System.Type.IsGenericTypeDefinition" /> zwraca <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArguments" /> jest <see langword="null" />.  - lub - żadnym elementem <paramref name="typeArguments" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w <paramref name="typeArguments" /> nie jest taka sama jak liczba parametrów typu w bieżącej definicji typu ogólnego.  - lub - żadnym elementem <paramref name="typeArguments" /> nie spełnia ograniczenia odpowiedniego parametru typu bieżącego typu ogólnego.  - lub - <paramref name="typeArguments" /> zawiera element, który jest typem wskaźnika (<see cref="P:System.Type.IsPointer" /> zwraca <see langword="true" />), typ przez odwołanie (<see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />), lub <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej. Klasa pochodna musi zapewniać implementację.</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Type" /> obiekt, który reprezentuje wskaźnik do typu bieżącej.</summary>
        <returns>A <see cref="T:System.Type" /> obiekt, który reprezentuje wskaźnik do typu bieżącej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakePointerType%2A> Metody umożliwia generowanie typów wskaźnika do listy parametrów.  
  
 Przy użyciu składni języka pośredniego firmy Microsoft (MSIL), jeśli bieżący <xref:System.Type> obiekt reprezentuje <xref:System.Int32>, ta metoda zwraca <xref:System.Type> reprezentujący obiekt `Int32*`.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tablicę `ref` (`ByRef` w języku Visual Basic) oraz typów wskaźnika `Test` klasy.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</exception>
        <exception cref="T:System.TypeLoadException">Bieżący typ <see cref="T:System.TypedReference" />.  - lub - bieżący typ <see langword="ByRef" /> typu. Oznacza to <see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Reflection.MemberTypes" /> wartość wskazującą, czy ten element członkowski jest typu lub typu zagnieżdżonego.</summary>
        <value>A <see cref="T:System.Reflection.MemberTypes" /> wartość wskazującą, czy ten element członkowski jest typu lub typu zagnieżdżonego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zastępuje <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>. W związku z tym podczas badania zestawu <xref:System.Reflection.MemberInfo> obiektów — na przykład tablicy zwracanej przez <xref:System.Type.GetMembers%2A>— <xref:System.Reflection.MemberInfo.MemberType%2A> zwraca <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> gdy dany element jest typu zagnieżdżonego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta właściwość ma zastosowanie do definicji typu ogólnego, z którego został skonstruowany typu. Na przykład jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w języku Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ parametru w definicji typu ogólnego lub metody ogólnej, ta właściwość zawsze zwraca <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład `MemberType` pole jako parametr `GetMember` metody:  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje wartość Brak w <see cref="T:System.Type" /> informacji. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `Missing` dla wywołania przez odbicie można uzyskać wartości domyślnej parametru pole. Jeśli `Missing` przekazać pola w wartości parametru i nie ma wartości domyślnej dla tego parametru <xref:System.ArgumentException> jest generowany.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia `Missing` pola można wywołać metody z argumentami domyślne.  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 Ten kod generuje następujące dane wyjściowe:  
  
 = 10 b = 55.3 c = 12  
  
 = 10 b = 1,3 c = 1  
  
 = 10 b = 1.2 c = 1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł (DLL), w którym bieżącego <see cref="T:System.Type" /> jest zdefiniowany.</summary>
        <value>Moduł, w którym bieżącego <see cref="T:System.Type" /> jest zdefiniowany.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowanego typu ogólnego, ta właściwość zwraca modułu, w którym zdefiniowano definicji typu ogólnego. Na przykład w przypadku utworzenia wystąpienia `MyGenericStack<int>`, <xref:System.Type.Module%2A> właściwość skonstruowanego typu zwraca modułu, w którym `MyGenericStack<T>` jest zdefiniowany.  
  
 Podobnie jeśli bieżący <xref:System.Type> reprezentuje parametr ogólny `T`, ta właściwość zwraca zestaw zawierający typ ogólny, który definiuje `T`.  
  
   
  
## Examples  
 Poniższy przykład przedstawia korzystanie z <xref:System.Type.Namespace%2A> i `Module` właściwości i <xref:System.Type.ToString%2A> metody <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obszar nazw <see cref="T:System.Type" />.</summary>
        <value>Przestrzeń nazw <see cref="T:System.Type" />; <see langword="null" /> Jeśli bieżące wystąpienie nie ma obszaru nazw lub reprezentuje parametr ogólny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przestrzeń nazw jest logiczną czasu projektowania nazewnictwa wygody używane głównie w celu zdefiniowania zakresu w aplikacji i organizowanie klas i innych typów w strukturze hierarchicznej pojedynczego. Z punktu widzenia środowiska uruchomieniowego nie ma żadnych obszarów nazw.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowane ogólny typ, ta właściwość zwraca obszar nazw, który zawiera definicję typu ogólnego. Podobnie jeśli bieżący <xref:System.Type> reprezentuje parametr ogólny `T`, ta właściwość zwraca obszar nazw, który zawiera definicję typu ogólnego, który definiuje `T`.  
  
 Jeśli bieżący <xref:System.Type> obiekt reprezentuje parametr ogólny, ta właściwość zwraca `null`.  
  
   
  
## Examples  
 Poniższy przykład przedstawia korzystanie z `Namespace` i <xref:System.Type.Module%2A> właściwości i <xref:System.Type.ToString%2A> metody <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="right">Drugi obiekt, który będzie porównywany.</param>
        <summary>Wskazuje, czy dwa <see cref="T:System.Type" /> obiekty są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> jest równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="right">Drugi obiekt, który będzie porównywany.</param>
        <summary>Wskazuje, czy dwa <see cref="T:System.Type" /> obiekty nie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> nie jest równa <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt klasy, które zostało użyte do uzyskania tego elementu członkowskiego.</summary>
        <value>
          <see langword="Type" /> Obiektu, do której ta <see cref="T:System.Type" /> obiekt został uzyskany.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać <xref:System.Type> obiekty, wartość tej właściwości jest zawsze taki sam, jak wartość <xref:System.Type.DeclaringType%2A> właściwości.  
  
   
  
## Examples  
 W tym przykładzie wyświetla odbite typ klasy zagnieżdżonej.  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa kwalifikowana zestawu <see cref="T:System.Type" /> do pobrania.</param>
        <param name="throwIfNotFound">
          <see langword="true" /> Aby zgłosić <see cref="T:System.TypeLoadException" /> Jeśli nie można odnaleźć typu; <see langword="false" /> do zwrócenia <see langword="null" /> Jeśli nie można odnaleźć typu. Określanie <see langword="false" /> również pomija inne warunki wyjątek, ale nie wszystkie z nich. Zobacz sekcję Wyjątki.</param>
        <param name="ignoreCase">
          <see langword="true" /> Aby wykonać wyszukiwanie bez uwzględniania wielkości liter dla <c>typeName</c>; <see langword="false" /> Aby wykonać wyszukiwanie z uwzględnieniem wielkości liter dla <c>typeName</c>.</param>
        <summary>Pobiera <see cref="T:System.Type" /> o określonej nazwie, określania, czy do wyszukiwania, z uwzględnieniem wielkości liter i Zgłoś wyjątek, jeśli typ nie zostanie znaleziony. Typ jest ładowany w celu odbicia, nie do wykonania.</summary>
        <returns>Typ o określonej nazwie, jeśli znaleziono; w przeciwnym razie <see langword="null" />. Jeśli typ nie zostanie znaleziony, <paramref name="throwIfNotFound" /> parametr określa, czy <see langword="null" /> jest zwracany lub jest zgłaszany wyjątek. W niektórych przypadkach, jest zwracany wyjątek, niezależnie od wartości <paramref name="throwIfNotFound" />. Zobacz sekcję Wyjątki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw zawierający ten typ nie jest już załadowane do kontekstu reflection-only, za pomocą <xref:System.Type.ReflectionOnlyGetType%2A> metoda jest odpowiednikiem pierwszy podczas ładowania zestawu w celu odbicia tylko przy użyciu <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> metody, a następnie ładowania typu przez wywołanie metody zestawu <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> metody. Aby uzyskać informacje o kwalifikowana nazwa zestawu, zobacz <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> właściwości. Aby uzyskać więcej informacji na temat określania nazwy typów, zobacz <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenie metody.  
  
 Jeśli zestaw jest już załadowany do wykonania, inna kopia została załadowana do kontekstu reflection-only.  
  
 `throwIfNotFound` Parametr określa, co się stanie, gdy typ nie zostanie znaleziony i również pomija określone inne warunki wyjątek, zgodnie z opisem w sekcji wyjątki. Niektóre wyjątki są zgłaszane niezależnie od wartości `throwIfNotFound`. Na przykład, jeśli zestaw nie jest prawidłowy <xref:System.BadImageFormatException> jest zgłaszany nawet wtedy, gdy `throwIfNotFound` jest `false`.  
  
 Aby uzyskać więcej informacji o korzystaniu z kontekstu reflection-only, zobacz [porady: zestawy obciążenia w kontekście Reflection-Only](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwIfNotFound" /> jest <see langword="true" /> i nie znaleziono typu.  - lub - <paramref name="throwIfNotFound" /> jest <see langword="true" /> i <paramref name="typeName" /> zawiera nieprawidłowe znaki, takie jak karta osadzonych.  - lub - <paramref name="throwIfNotFound" /> jest <see langword="true" /> i <paramref name="typeName" /> jest pustym ciągiem.  - lub - <paramref name="throwIfNotFound" /> jest <see langword="true" /> i <paramref name="typeName" /> reprezentuje typ tablicowy z nieprawidłowym rozmiarem.  - lub - <paramref name="typeName" /> reprezentuje tablicę <see cref="T:System.TypedReference" /> obiektów.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> nie ma nazwy zestawu.  - lub - <paramref name="throwIfNotFound" /> jest <see langword="true" /> i <paramref name="typeName" /> zawiera nieprawidłową składnię, np. "Mojtyp [, *,]".  - lub - <paramref name="typeName" /> reprezentuje typu ogólnego, który ma typ wskaźnika <see langword="ByRef" /> typu, lub <see cref="T:System.Void" /> jako jeden z jego argumentów typu.  - lub - <paramref name="typeName" /> reprezentuje typu ogólnego, który ma nieprawidłową liczbę argumentów typu.  - lub - <paramref name="typeName" /> reprezentuje ogólnego typu, a jeden z jego argumentów typu nie spełnia warunków ograniczenia dla odpowiedniego parametru typu.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwIfNotFound" /> jest <see langword="true" /> i nie znaleziono zestawu lub jednej z jego zależności.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.  - lub - zestaw został skompilowany przy użyciu nowszej wersji środowiska CLR niż wersja, który jest aktualnie załadowany.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> opisujący układ bieżącego typu.</summary>
        <value>Pobiera <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> opisujący funkcje brutto układu bieżącego typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute> nie są zwracane przez <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metody. Użyj tej właściwości można go pobrać.  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje najpierw klasą, strukturą i struktury z atrybutami specjalnego układu (struktur są zagnieżdżone w obrębie klasy). W przykładzie następnie użyto <xref:System.Type.StructLayoutAttribute%2A> właściwości w celu uzyskania <xref:System.Runtime.InteropServices.StructLayoutAttribute> dla każdego typu i wyświetla właściwości atrybutów.  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="rgszNames">Przekazana tablica nazw ma być mapowana.</param>
        <param name="cNames">Liczba nazw, które mają być mapowane.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</param>
        <param name="rgDispId">Tablica przydzielana przez obiekt wywołujący, który otrzymuje numery identyfikacyjne odpowiadających nazw.</param>
        <summary>Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetIDsOfNames`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informacje o typie, który będzie zwracany.</param>
        <param name="lcid">Identyfikator regionalny dla informacji o typie.</param>
        <param name="ppTInfo">Wskaźnik do obiektu informacji żądanego typu.</param>
        <summary>Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfo`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Wskazuje lokalizację, która odbiera informację o liczbie typów dostarczanych przez obiekt.</param>
        <summary>Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfoCount`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Określa element członkowski.</param>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</param>
        <param name="wFlags">Flagi opisujące kontekst wywołania.</param>
        <param name="pDispParams">Wskaźnik do struktury zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</param>
        <param name="pVarResult">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</param>
        <param name="pExcepInfo">Wskaźnik do struktury, która zawiera informacje o wyjątku.</param>
        <param name="puArgErr">Indeks pierwszego argumentu, który zawiera błąd.</param>
        <summary>Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::Invoke`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see langword="String" /> reprezentujący nazwę bieżącej <see langword="Type" />.</summary>
        <returns>A <see cref="T:System.String" /> reprezentujący nazwę bieżącej <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca pełną wspólnego języka środowiska uruchomieniowego przestrzeni nazw i nazwę dla wszystkich typów pierwotnych. Na przykład C# instrukcji, `(long)0.Type().ToString()` zwraca "System.Int64", a nie tylko "Int64".  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typu ogólnego, typ i jego argumentów typu kwalifikowana według przestrzeni nazw i typ zagnieżdżony, ale nie przez zestaw. Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody ogólnej, ta metoda zwraca niekwalifikowana nazwa parametru typu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia korzystanie z <xref:System.Type.Namespace%2A> i <xref:System.Type.Module%2A> właściwości i `ToString` metody <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 Poniższy przykład porównuje ciągi zwrócony przez <xref:System.Type.ToString%2A> — metoda i `Name`, <xref:System.Type.FullName%2A>, i <xref:System.Type.AssemblyQualifiedName%2A> właściwości.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dojście dla bieżącego <see cref="T:System.Type" />.</summary>
        <value>Dojście do bieżącego <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle` hermetyzuje wskaźnik do struktury danych wewnętrznych, reprezentujący typ. Ta dojścia jest unikatowa w okresie istnienia procesu. Dojście jest prawidłowy tylko w domenie aplikacji, w którym został uzyskany.  
  
   
  
## Examples  
 Poniższy przykład zwraca dojście danego typu i przekazuje dojścia do metody, która pobiera typ dojścia i wyświetla je.  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework nie obsługuje obecnie tej właściwości.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera inicjator dla typu.</summary>
        <value>Obiekt, który zawiera nazwę Konstruktor klasy <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa inicjatory są również dostępne za pośrednictwem <xref:System.Type.FindMembers%2A> metody, lub za pomocą przeciążenia <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, i <xref:System.Type.GetConstructors%2A> metod, które przyjmują <xref:System.Reflection.BindingFlags> jako parametr.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ parametru w definicji typu ogólnego lub metody ogólnej, ta właściwość zwraca `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje typ udostępniane przez środowisko uruchomieniowe języka wspólnego reprezentujący tego typu.</summary>
        <value>Typ podstawowy system dla <see cref="T:System.Type" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>
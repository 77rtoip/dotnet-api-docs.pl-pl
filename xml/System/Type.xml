<Type Name="Type" FullName="System.Type">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2d69eac39d76ab4f6abbe8aed3f1f8243ed3e998" /><Meta Name="ms.sourcegitcommit" Value="406d23aba879fbb482c6da0f64c8ef9494f6a944" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/31/2019" /><Meta Name="ms.locfileid" Value="68685996" /></Metadata><TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje deklaracje typu: typy klas, typy interfejsów, typy tablic, typy wartości, typy wyliczeniowe, parametry typu, definicje typów ogólnych i otwarte lub zamknięte skonstruowane typy ogólne.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Type`jest katalogiem głównym <xref:System.Reflection> funkcji i jest podstawowym sposobem uzyskiwania dostępu do metadanych. Użyj elementów członkowskich programu <xref:System.Type> , aby uzyskać informacje o deklaracji typu, o elementach członkowskich typu (takich jak konstruktory, metody, pola, właściwości i zdarzenia klasy), a także modułu i zestawu, w którym została wdrożona Klasa.  
  
 Żadne uprawnienia nie są wymagane do użycia odbicia w celu uzyskania informacji na temat typów i ich członków, niezależnie od ich poziomów dostępu. Nie są wymagane żadne uprawnienia do kodu, aby użyć odbicia w celu uzyskania dostępu do publicznych elementów członkowskich lub innych członków, których poziomy dostępu byłyby widoczne podczas normalnej kompilacji. Jednak aby kod używał odbicia w celu uzyskania dostępu do elementów członkowskich, które zwykle są niedostępne, takich jak metody prywatne lub wewnętrzne, lub chronione pola typu Klasa nie dziedziczy, kod musi mieć <xref:System.Security.Permissions.ReflectionPermission>. Zapoznaj się z [zagadnieniami dotyczącymi zabezpieczeń odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).  
  
 `Type`jest abstrakcyjną klasą bazową, która umożliwia wiele implementacji. System zawsze udostępnia klasę `RuntimeType`pochodną. W odbiciu wszystkie klasy, zaczynające się na środowisko uruchomieniowe programu Word, są tworzone tylko raz dla każdego obiektu w systemie i obsługują operacje porównania.  
  
> [!NOTE]
>  W scenariuszach wielowątkowości nie należy blokować <xref:System.Type> obiektów w celu synchronizowania dostępu do `static` danych. Inny kod, nad którym nie masz kontroli, może także zablokować typ klasy. Może to spowodować zakleszczenie. Zamiast tego należy synchronizować dostęp do danych statycznych przez zablokowanie obiektu prywatnego `static` .  
  
> [!NOTE]
>  Klasa pochodna może uzyskać dostęp do chronionych elementów członkowskich klas bazowych kodu wywołującego. Ponadto dostęp jest dozwolony do zestawów elementów członkowskich zestawu kodu wywołującego. Jako regułę, jeśli masz zezwolenie na dostęp w kodzie wczesnym, możesz również uzyskać dostęp w kodzie z późnym wiązaniem.  
  
> [!NOTE]
>  Interfejsy rozszerzające inne interfejsy nie dziedziczą metod zdefiniowanych w rozszerzonych interfejsach.  
  
 W tej sekcji:  
  
 [Jakie typy reprezentuje obiekt typu?](#WhatTypes)   
 [Pobieranie obiektu typu](#Retrieve)   
 [Porównywanie obiektów typu dla równości](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>Jakie typy reprezentuje obiekt typu?  
 Ta klasa jest bezpieczna wątkowo; wiele wątków może jednocześnie odczytać z wystąpienia tego typu. Wystąpienie <xref:System.Type> klasy może reprezentować dowolny z następujących typów:  
  
-   Klasy  
  
-   Typy wartości  
  
-   Tablice  
  
-   Interfejsy  
  
-   Wyliczenia  
  
-   Delegaty  
  
-   Skonstruowane typy ogólne i definicje typów ogólnych  
  
-   Argumenty typu i parametry typu skonstruowanych typów ogólnych, definicje typów ogólnych i definicje metod ogólnych  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>Pobieranie obiektu typu  
 <xref:System.Type> Obiekt skojarzony z określonym typem można uzyskać w następujący sposób:  
  
-   Metoda instance <xref:System.Object.GetType%2A?displayProperty=nameWithType> <xref:System.Type> zwraca obiekt, który reprezentuje typ wystąpienia. Ponieważ wszystkie typy zarządzane pochodzą z <xref:System.Object> <xref:System.Object.GetType%2A> , Metoda może być wywoływana dla wystąpienia dowolnego typu.  
  
     Poniższy przykład wywołuje metodę, <xref:System.Object.GetType%2A?displayProperty=nameWithType> aby określić typ środowiska uruchomieniowego każdego obiektu w tablicy obiektów.  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   Metody statyczne <xref:System.Type.GetType%2A?displayProperty=nameWithType> <xref:System.Type> zwracają obiekt, który reprezentuje typ określony przez jego w pełni kwalifikowaną nazwę.  
  
-   Metody <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>i zwracająobiekty`Type` reprezentujące typy zdefiniowane w module. <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> Pierwsza metoda może służyć do uzyskania tablicy <xref:System.Type> obiektów dla wszystkich typów publicznych i prywatnych zdefiniowanych w module. `Module` (Można uzyskać wystąpienie <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> za pomocą metody lub <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> lub przez <xref:System.Type.Module%2A?displayProperty=nameWithType> Właściwość).  
  
-   Obiekt zawiera kilka metod do pobrania klas zdefiniowanych w zestawie, w tym <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>i <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>. <xref:System.Reflection.Assembly?displayProperty=nameWithType>  
  
-   <xref:System.Type.FindInterfaces%2A> Metoda zwraca filtrowaną listę typów interfejsów obsługiwanych przez typ.  
  
-   <xref:System.Type.GetElementType%2A> Metoda`Type` zwraca obiekt, który reprezentuje element.  
  
-   Metody <xref:System.Type.GetInterfaces%2A> i <xref:System.Type.GetInterface%2A> zwracają<xref:System.Type> obiekty reprezentujące typy interfejsów obsługiwane przez typ.  
  
-   Metoda zwraca tablicę obiektów reprezentujących typy określone przez dowolny zestaw obiektów. <xref:System.Type> <xref:System.Type.GetTypeArray%2A> Obiekty są określone z tablicą typu <xref:System.Object>.  
  
-   Metody <xref:System.Type.GetTypeFromProgID%2A> i<xref:System.Type.GetTypeFromCLSID%2A> są dostępne dla współdziałania modelu com. Zwracają <xref:System.Type> one obiekt, który reprezentuje typ określony `ProgID` przez lub `CLSID`.  
  
-   <xref:System.Type.GetTypeFromHandle%2A> Metoda jest zapewniana pod kątem współdziałania. Zwraca `Type` obiekt, który reprezentuje typ określony przez dojście do klasy.  
  
-   C# C++ Operator,`GetType`operatori operator Visual Basic uzyskują`Type`obiektdlatypu. `typeof` `typeid`  
  
-   Metoda zwraca obiekt reprezentujący skonstruowany typ ogólny, który jest otwartym typem skonstruowanym, jeśli <xref:System.Type.ContainsGenericParameters%2A> jego właściwość `true`zwraca, a w przeciwnym razie zamknięty typ skonstruowany. <xref:System.Type> <xref:System.Type.MakeGenericType%2A> Typ ogólny można utworzyć tylko wtedy, gdy jest zamknięty.  
  
-   `ref` Metody <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>i zwracają<xref:System.Type.MakeByRefType%2A> C#obiekty, które reprezentują odpowiednio tablicę określonego typu, wskaźnik do określonego typu i typ parametru odwołania (w, <xref:System.Type> `ByRef` w Visual Basic).  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>Porównywanie obiektów typu dla równości  
 Obiekt, który reprezentuje typ jest unikatowy. oznacza to, że dwa <xref:System.Type> odwołania do obiektów odwołują się do tego samego obiektu, jeśli i tylko wtedy, gdy reprezentują ten sam typ. <xref:System.Type> Umożliwia to porównywanie <xref:System.Type> obiektów przy użyciu równości odwołań. Poniższy przykład porównuje <xref:System.Type> obiekty reprezentujące wiele wartości całkowitych, aby określić, czy są one tego samego typu.  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono kilka reprezentatywnych funkcji programu <xref:System.Type>. C# <xref:System.String>Operator ( operatorw<xref:System.Type> Visual Basic) służy do pobierania obiektu reprezentującego.`GetType` `typeof` Z tego <xref:System.Type> <xref:System.Type.GetMethod%2A> obiektu Metoda <xref:System.Reflection.MethodInfo> jest używana<xref:System.String.Substring%2A?displayProperty=nameWithType> w celu uzyskania reprezentowania przeciążenia, które przyjmuje lokalizację początkową i długość.
  
 Aby zidentyfikować sygnaturę przeciążenia, przykład kodu tworzy tablicę tymczasową zawierającą <xref:System.Type> dwa obiekty `int` reprezentujące (`Integer` w Visual Basic).  
  
> [!NOTE]
>  Aby była precyzyjna, tablica zawiera dwa odwołania do wystąpienia <xref:System.Type> , które reprezentuje `int` w bieżącej domenie aplikacji. Dla dowolnego typu istnieje tylko jedno wystąpienie <xref:System.Type> dla każdej domeny aplikacji.  
  
 W przykładzie kodu używa <xref:System.Reflection.MethodInfo> się do <xref:System.String.Substring%2A> wywołania metody w ciągu "Hello, World!" i wyświetla wynik.  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny wątkowo.</threadsafe>
    <block subset="none" type="overrides"><para>W przypadku dziedziczenia <see langword="Type" />z należy zastąpić następujące elementy członkowskie: 
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para></block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="~/docs/framework/reflection-and-codedom/viewing-type-information.md">Wyświetlanie informacji o typie</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Type" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływany przez klasy pochodne podczas konstruowania obiektów typu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, w której jest zadeklarowany typ. <see cref="T:System.Reflection.Assembly" /> <see cref="T:System.Reflection.Assembly" /> W przypadku typów ogólnych Pobiera wartość, w której jest zdefiniowany typ ogólny.</summary>
        <value><see cref="T:System.Reflection.Assembly" /> Wystąpienie opisujące zestaw zawierający bieżący typ. W przypadku typów ogólnych wystąpienie opisuje zestaw, który zawiera definicję typu ogólnego, a nie zestawu, który tworzy i używa określonego typu złożonego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> obiekt reprezentuje skonstruowany typ ogólny, ta właściwość zwraca zestaw, który zawiera definicję typu ogólnego. Załóżmy na przykład, że tworzysz zestaw o nazwie `MyGenericStack<T>` moje generyczne. dll, który zawiera definicję typu ogólnego (`MyGenericStack(Of T)` w Visual Basic, `generic<T> ref class MyGenericStack` in C++). Jeśli tworzysz wystąpienie `MyGenericStack<int>` (`MyGenericStack(Of Integer)` w Visual Basic) <xref:System.Type.Assembly%2A> w innym zestawie, właściwość dla konstruowanego typu zwraca <xref:System.Reflection.Assembly> obiekt, który reprezentuje generyczne. dll.  
  
 Podobnie, jeśli bieżący <xref:System.Type> obiekt reprezentuje nieprzypisany parametr `T`ogólny, ta właściwość zwraca zestaw, który zawiera typ ogólny, który definiuje `T`.  
  
 Jeśli właściwość nie jest dostępna w określonej implementacji platformy .NET, takiej jak .NET Core lub platforma uniwersalna systemu Windows, zamiast tego <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> Użyj właściwości. <xref:System.Type.Assembly%2A?displayProperty=nameWithType>      
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład wyświetla nazwę zestawu skojarzonego z klasą i w pełni kwalifikowaną nazwą typu.  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kwalifikowaną dla zestawu nazwę typu, który zawiera nazwę zestawu, z którego ten <see cref="T:System.Type" /> obiekt został załadowany.</summary>
        <value>Kwalifikowana nazwa <see cref="T:System.Type" />zestawu, która zawiera nazwę zestawu, z <see cref="T:System.Type" /> którego została załadowana, lub <see langword="null" /> Jeśli bieżące wystąpienie reprezentuje parametr typu ogólnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kwalifikowana dla zestawu nazwa typu składa się z nazwy typu, w tym jej przestrzeni nazw, a następnie przecinka, po którym następuje nazwa wyświetlana zestawu. Nazwa wyświetlana zestawu jest uzyskiwana przy użyciu <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> właściwości.  
  
> [!NOTE]
>  W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw. Na przykład "ProcessorArchitecture = msil". Nie jest on jednak uwzględniony w ciągu zwracanym przez <xref:System.Type.AssemblyQualifiedName%2A> właściwość, ze względu na zgodność. Zobacz <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 Wszystkie kompilatory obsługujące środowisko uruchomieniowe języka wspólnego emitują prostą nazwę klasy zagnieżdżonej, a odbicie tworzy nazwę zniekształcona podczas wykonywania zapytania, zgodnie z poniższymi konwencjami.  
  
|Ogranicznik|Znaczenie|  
|---------------|-------------|  
|Ukośnik odwrotny\\()|Znak ucieczki.|  
|Przecinek (,)|Poprzedza nazwę zestawu.|  
|Znak plus (+)|Poprzedza klasę zagnieżdżoną.|  
|Kropka (.)|Wskazuje przestrzeń nazw identyfikatorów.|  
|Nawiasy kwadratowe ([])|Po nazwie typu oznacza tablicę tego typu.<br /><br /> —lub—<br /><br /> W przypadku typu ogólnego należy ująć listę argumentów typu ogólnego.<br /><br /> —lub—<br /><br /> Wewnątrz listy argumentów typu, należy ująć Typ kwalifikowana zestawu.|  
  
 Na przykład nazwa kwalifikowana dla zestawu klasy może wyglądać następująco:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 Jeśli przestrzeń nazw zawierała znak plus, na przykład TopNamespace. Sub + Namespace, a następnie znak plus (+) zostałby poprzedzony znakiem ucieczki (\\), aby zapobiec interpretowaniu go jako separatora zagnieżdżania. Odbicie wyemituje ten ciąg w następujący sposób:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 "+ +" Przyjmuje wartość "\\+\\\\+\\",a""zmienia\\się "".  
  
 Ta kwalifikowana nazwa może zostać utrwalona i później użyta do <xref:System.Type>załadowania. Aby wyszukać i załadować <xref:System.Type>obiekt, <xref:System.Type.GetType%2A> Użyj albo z nazwą typu lub z kwalifikowaną nazwą typu zestawu. <xref:System.Type.GetType%2A>Nazwa typu będzie wyglądała tylko <xref:System.Type> w odniesieniu do zestawu wywołującego, a następnie w zestawie systemowym. <xref:System.Type.GetType%2A>z nazwą typu kwalifikowanego zestawu będzie wyglądała <xref:System.Type> w dowolnym zestawie.  
  
 Nazwy typów mogą obejmować końcowe znaki, które wyznaczają dodatkowe informacje dotyczące typu, na przykład to, czy typ jest typem odwołania, typem wskaźnika lub typem tablicowym. Aby pobrać nazwę typu bez znaków końcowych, należy użyć `t.GetElementType().ToString()`, gdzie `t` jest typem.  
  
 Spacje są istotne we wszystkich składnikach nazwy z wyjątkiem nazwy zestawu. Spacje przed separatorem w nazwie zestawu ',' są istotne, ale spacje po separatorze ',' są ignorowane.  
  
 Argumenty ogólne typów ogólnych są zakwalifikowane według nazwy zestawu. Na przykład, w nazwie typu kwalifikowana dla zestawu `MyGenericClass<int>` dla (`MyGenericClass(Of Integer)` w Visual Basic), `int` jest rozwinięty do nazwy typu kwalifikowanego dla <xref:System.Int32>zestawu.  
  
 Jeśli bieżący <xref:System.Type> obiekt reprezentuje parametr generyczny, ta właściwość zwraca `null`.  
  
   
  
## Examples  
 Poniższy przykład wyświetla nazwę zestawu skojarzonego z klasą i w pełni kwalifikowaną nazwą typu.  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 Poniższy przykład <xref:System.Type.ToString%2A> porównuje ciągi zwracane przez metodę `Name`oraz właściwości, <xref:System.Type.FullName%2A>i <xref:System.Type.AssemblyQualifiedName%2A> .  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Określanie w pełni kwalifikowanych nazw typów</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera atrybuty skojarzone z <see cref="T:System.Type" />.</summary>
        <value>Obiekt reprezentujący zestaw <see cref="T:System.Type" />atrybutów, chyba że <see cref="T:System.Type" /> reprezentuje parametr typu generycznego, w tym przypadku wartość jest nieokreślona. <see cref="T:System.Reflection.TypeAttributes" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre elementy członkowskie <xref:System.Reflection.TypeAttributes> wyliczenia to maski, które reprezentują grupę wartości. Każda grupa zawiera jeden element członkowski, którego wartość podstawowa to zero. Na <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> przykład podstawową wartością elementu członkowskiego <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> w grupie jest <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> zero, co <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> jest członkiem grupy. Z tego względu należy użyć maski przed przetestowaniem tych wartości. Przykład stanowi ilustrację.  
  
> [!TIP]
>  W większości przypadków właściwości, takie <xref:System.Type.IsClass%2A>jak<xref:System.Type.IsAutoLayout%2A>, i <xref:System.Type.IsSpecialName%2A> są łatwiejsze w użyciu niż atrybuty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, ta właściwość zwraca atrybuty definicji typu ogólnego. Na przykład atrybuty zwracane `MyGenericClass<int>` dla (`MyGenericClass(Of Integer)` w Visual Basic `MyGenericClass<T>` ) są atrybutami (`MyGenericClass(Of T)` w Visual Basic).  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu generycznego — to oznacza, że w <xref:System.Type.IsGenericParameter%2A> przypadku zwrócenia `true` właściwości — <xref:System.Reflection.TypeAttributes> wartość zwrócona przez tę właściwość jest nieokreślona.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Type.Attributes%2A> właściwość.  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ, z którego dziedziczy bieżący <see cref="T:System.Type" /> bezpośredni.</summary>
        <value><see cref="T:System.Type" /> <see langword="null" /> <see langword="Type" /> Z którego dziedziczy bieżąca bezpośrednio, lub jeśli bieżąca reprezentuje <see cref="T:System.Object" /> klasę lub interfejs. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ podstawowy jest typem, z którego bezpośredni dziedziczy typ bieżący. <xref:System.Object>jest jedynym typem, który nie ma typu podstawowego, dlatego `null` jest zwracany jako <xref:System.Object>typ podstawowy.  
  
 Interfejsy dziedziczą z zero lub więcej interfejsów podstawowych; w związku z tym ta `null` Właściwość zwraca `Type` wartość, jeśli obiekt reprezentuje interfejs. Interfejsy podstawowe można określić za pomocą <xref:System.Type.GetInterfaces%2A> lub. <xref:System.Type.FindInterfaces%2A>  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, typ podstawowy odzwierciedla argumenty ogólne. Rozważmy na przykład następujące deklaracje:  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 Dla typu `C<int>` konstruowanego (`C(Of Integer)` <xref:System.Type.BaseType%2A> w Visual Basic) Właściwość zwraca `B<int>`.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu definicji typu ogólnego, <xref:System.Type.BaseType%2A> zwraca ograniczenie klasy, czyli klasy, parametr typu musi dziedziczyć. W <xref:System.Type.BaseType%2A> przypadku braku ograniczenia klasy zwraca wartość <xref:System.Object?displayProperty=nameWithType>.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Type.BaseType%2A> właściwości.  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 W poniższym przykładzie zastosowano rekursję, aby wyświetlić pełną hierarchię dziedziczenia dla każdej klasy, która znajduje się w zestawie. W przykładzie zdefiniowano klasę o `C` nazwie, która dziedziczy z klasy `B`o nazwie, która z kolei dziedziczy z klasy o nazwie `A`.  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący <see cref="T:System.Type" /> obiekt ma parametry typu, które nie zostały zastąpione przez określone typy.</summary>
        <value><see langword="true" />Jeśli obiekt jest własnym parametrem typu ogólnego lub ma parametry typu, dla których określone typy nie zostały dostarczone; <see langword="false" />w przeciwnym razie. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby można było utworzyć wystąpienie typu, nie mogą istnieć definicje typów ogólnych ani otwierać typów skonstruowanych w argumentach typu samego typu, w żadnym z typów ogólnych lub w jakichkolwiek elementach typu. Innym sposobem wymawiania tego jest to, że w przypadku zweryfikowania cyklicznie typ nie może zawierać parametrów typu ogólnego.  
  
 Ponieważ typy mogą być arbitralnie złożone, to oznaczanie jest trudne. Dla wygody i zmniejszenia prawdopodobieństwa wystąpienia błędu <xref:System.Type.ContainsGenericParameters%2A> Właściwość zapewnia standardowy sposób odróżnienia od zamkniętych typów skonstruowanych, które można utworzyć, i otworzyć typy skonstruowane, które nie mogą. Jeśli właściwość zwróci wartość `true`, nie można utworzyć wystąpienia typu. <xref:System.Type.ContainsGenericParameters%2A>  
  
 <xref:System.Type.ContainsGenericParameters%2A> Właściwość przeszukuje rekursywnie dla parametrów typu. Na przykład zwraca `true` dla tablicy, której elementy są typu `A<T>` (`A(Of T)` w Visual Basic), nawet jeśli tablica nie jest sama ogólna. Jest to kontrast z zachowaniem <xref:System.Type.IsGenericType%2A> właściwości, która zwraca `false` dla tablic.  
  
 Aby uzyskać zestaw przykładowych klas i tabelę pokazującą wartości <xref:System.Type.ContainsGenericParameters%2A> właściwości, zobacz. <xref:System.Type.IsGenericType%2A>  
  
   
  
## Examples  
 Poniższy przykład definiuje klasę generyczną z dwoma parametrami typu, a następnie definiuje drugą klasę generyczną pochodzącą od pierwszej klasy. Klasa bazowa klasy pochodnej ma dwa argumenty typu: pierwszy to <xref:System.Int32> , a drugi to parametr typu pochodnego. W przykładzie przedstawiono informacje o tych klasach ogólnych, w tym pozycje zgłoszone <xref:System.Type.GenericParameterPosition%2A> przez właściwość.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera, <see cref="T:System.Type" /> który reprezentuje metodę deklarującą, jeśli bieżąca reprezentuje parametr typu metody generycznej. <see cref="T:System.Reflection.MethodBase" /></summary>
        <value>Jeśli bieżąca <see cref="T:System.Type" /> reprezentuje parametr typu metody generycznej <see cref="T:System.Reflection.MethodBase" /> , która reprezentuje metodę <see langword="null" />deklarującą; w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda deklarująca jest definicją metody ogólnej. Oznacza to, że <xref:System.Type.DeclaringMethod%2A> Jeśli nie zwraca `null`, a `DeclaringMethod.IsGenericMethodDefinition` następnie `true`zwraca.  
  
 Właściwości <xref:System.Type.DeclaringType%2A> i<xref:System.Type.DeclaringMethod%2A> identyfikują definicję typu ogólnego lub definicję metody generycznej, w której pierwotnie zdefiniowano parametr typu generycznego:  
  
-   Jeśli właściwość zwraca obiekt <xref:System.Reflection.MethodInfo>, który <xref:System.Reflection.MethodInfo> reprezentuje definicję metody ogólnej, a bieżący <xref:System.Type> obiekt reprezentuje parametr typu tej definicji metody ogólnej. <xref:System.Type.DeclaringMethod%2A>  
  
-   `null` <xref:System.Type.DeclaringType%2A> Jeśli właściwość zwraca, wówczas właściwość zawsze zwraca <xref:System.Type> obiekt reprezentujący definicję typu ogólnego, a bieżący <xref:System.Type> obiekt reprezentuje parametr typu tego typu ogólnego <xref:System.Type.DeclaringMethod%2A> definicji.  
  
-   Pobieranie właściwości dla typu, którego <xref:System.Type.IsGenericParameter%2A> Właściwość `false` zwraca <xref:System.InvalidOperationException>. <xref:System.Type.DeclaringMethod%2A>  
  
 Wartość zwracana przez właściwość jest <xref:System.Reflection.MethodInfo> w<xref:System.Reflection.ConstructorInfo> przypadku metody generycznej lub w przypadku konstruktora generycznego. <xref:System.Type.DeclaringMethod%2A> <xref:System.Reflection.MethodBase>  
  
> [!NOTE]
>  W .NET Framework w wersji 2,0 konstruktory generyczne nie są obsługiwane.  
  
 Aby zapoznać się z listą warunków niewariantów dla terminów używanych w odbiciu ogólnym <xref:System.Type.IsGenericType%2A> , zobacz uwagi dotyczące właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu definiuje klasę, która ma metodę rodzajową, przypisuje argument typu do metody i wywołuje uzyskaną metodę ogólną. Wyświetla również informacje o definicji metody ogólnej i skonstruowanej metodzie. Podczas wyświetlania informacji o parametrach typu definicji metody ogólnej, w `DisplayGenericMethodInfo` metodzie przykładowy kod pokazuje wartość <xref:System.Type.DeclaringMethod%2A> właściwości dla parametru typu ogólnego metody.  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ, który deklaruje bieżący typ zagnieżdżony lub parametr typu ogólnego.</summary>
        <value><see cref="T:System.Type" /> Obiekt reprezentujący typ otaczający, jeśli bieżący typ jest typem zagnieżdżonym lub definicją typu ogólnego, jeśli bieżący typ jest parametrem typu ogólnego lub typem, który deklaruje metodę rodzajową, jeśli bieżący typ jest parametrem typu metody ogólnej; w przeciwnym razie. <see langword="null" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> obiekt reprezentuje parametr typu generycznego, ta właściwość zwraca definicję typu ogólnego.  
  
 Jeśli bieżący <xref:System.Type> obiekt reprezentuje parametr typu metody generycznej, ta właściwość zwraca typ, który zawiera definicję metody ogólnej. Jeśli typ jest ogólny, zwracana jest definicja typu ogólnego. Oznacza to, że Poniższy kod zwraca definicję <xref:System.Collections.Generic.List%601> typu ogólnego klasy generycznej, która <xref:System.Collections.Generic.List%601.ConvertAll%2A> zawiera metodę rodzajową:  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej <xref:System.Type.DeclaringType%2A> , właściwości i <xref:System.Type.DeclaringMethod%2A> identyfikują definicję typu ogólnego lub definicję metody ogólnej, gdzie parametr typu ogólnego pierwotnie zdefiniowane:  
  
-   Jeśli właściwość zwraca obiekt <xref:System.Reflection.MethodInfo>, który <xref:System.Reflection.MethodInfo> reprezentuje definicję metody ogólnej, a bieżący <xref:System.Type> obiekt reprezentuje parametr typu tej definicji metody ogólnej. <xref:System.Type.DeclaringMethod%2A>  
  
-   `null` <xref:System.Type.DeclaringType%2A> Jeśli właściwość zwraca, wówczas właściwość zawsze zwraca <xref:System.Type> obiekt reprezentujący definicję typu ogólnego, a bieżący <xref:System.Type> obiekt reprezentuje parametr typu tego typu ogólnego <xref:System.Type.DeclaringMethod%2A> definicji.  
  
-   Pobieranie właściwości dla typu, którego <xref:System.Type.IsGenericParameter%2A> Właściwość `false` zwraca <xref:System.InvalidOperationException>. <xref:System.Type.DeclaringType%2A>  
  
   
  
## Examples  
 W tym przykładzie przedstawiono typ deklarujący metody w klasie pochodnej.  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odwołanie do domyślnego spinacza, który implementuje reguły wewnętrzne do wybierania odpowiednich członków do wywołania przez <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</summary>
        <value>Odwołanie do domyślnego spinacza używanego przez system.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślny spinacz dostarczany ze środowiskiem uruchomieniowym języka wspólnego dotyczy wszystkich, ale najbardziej wyspecjalizowanych okoliczności. Jeśli potrzebujesz spinacza, który jest zgodny z regułami, które różnią się od podanego domyślnego spinacza, <xref:System.Reflection.Binder> Zdefiniuj typ pochodny klasy i przekaż wystąpienie tego typu `binder` przy użyciu <xref:System.Type.InvokeMember%2A> parametru jednego z przeciążeń.  
  
 Model odbicia reguł ułatwień dostępu dla wspólnego systemu typu. Na przykład jeśli obiekt wywołujący znajduje się w tym samym zestawie, obiekt wywołujący nie potrzebuje specjalnych uprawnień dla wewnętrznych elementów członkowskich. W przeciwnym razie obiekt wywołujący musi być wymagany <xref:System.Security.Permissions.ReflectionPermission>. Jest to zgodne z wyszukiwaniem elementów członkowskich chronionych, prywatnych i tak dalej.  
  
 Ogólna zasada polega na tym <xref:System.Reflection.Binder.ChangeType%2A> , że należy wykonać wyłącznie konwersje rozszerzające, które nigdy nie tracą danych. Przykładem konwersji rozszerzającej jest konwertowanie wartości, która jest 32-bitową ze znakiem liczby całkowitej, do wartości, która jest 64-bitową cyfrą ze znakiem. Różni się to od konwersji zawężania, która może spowodować utratę danych. Przykładem konwersji wąskiej jest konwertowanie 64-bitowej podpisanej liczby całkowitej na 32-bitową liczbę całkowitą ze znakiem.  
  
 W poniższej tabeli wymieniono konwersje obsługiwane przez domyślny spinacz.  
  
|Typ źródła|Typ docelowy|  
|-----------------|-----------------|  
|Dowolny typ|Jego typ podstawowy.|  
|Dowolny typ|Interfejs, który implementuje.|  
|Char|Unt16, UInt32, Int32, UInt64, Int64, Single, Double|  
|Byte|Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double|  
|SByte|Int16, Int32, Int64, Single, Double|  
|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  
|Int16|Int32, Int64, Single, Double|  
|UInt32|UInt64, Int64, Single, Double|  
|Int32|Int64, pojedyncze, podwójne|  
|UInt64|Pojedyncza, Podwójna|  
|Int64|Pojedyncza, Podwójna|  
|Single|Double|  
|Brak odwołania|Przez odwołanie.|  
  
   
  
## Examples  
 Poniższy przykład Pobiera domyślny spinacz z `DefaultBinder` właściwości i wywołuje element członkowski klasy MyClass przez `DefaultBinder` przekazanie wartości jako parametru do <xref:System.Type.InvokeMember%2A>.  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Oddziela nazwy w przestrzeni nazw <see cref="T:System.Type" />. To pole jest tylko do odczytu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje pustą tablicę typu <see cref="T:System.Type" />. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje `EmptyTypes` pole używane w jednej `GetConstructor` z metod, aby uzyskać konstruktora, który nie przyjmuje żadnych parametrów.  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy bazowy typ <see cref="T:System.Type" /> systemu jest taki sam jak typ systemu bazowego określonego <see cref="T:System.Object" /> lub <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt, którego bazowy typ systemu ma być porównywany z bazowym typem systemu bieżącego <see cref="T:System.Type" />. Aby porównanie zakończyło się <paramref name="o" /> pomyślnie, musi być możliwe rzutowanie lub przekonwertowanie do obiektu typu <see cref="T:System.Type" />.</param>
        <summary>Określa, czy bazowy typ systemu bieżącego <see cref="T:System.Type" /> obiektu jest taki sam jak źródłowy typ systemu określonego. <see cref="T:System.Object" /></summary>
        <returns><see langword="true" />Jeśli typ <paramref name="o" /> systemu bazowego jest taki sam jak bazowy typ <see cref="T:System.Type" />systemu; w przeciwnym razie, <see langword="false" />. Ta metoda zwraca również <see langword="false" /> wartość, jeśli:.  
  
-   <paramref name="o" />jest <see langword="null" />.  
  
-   <paramref name="o" />nie można rzutować ani przekonwertować na <see cref="T:System.Type" /> obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Rzutuje `o` to obiekt typu <xref:System.Type> i wywołuje <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> metodę.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Type.Equals%28System.Object%29> do porównywania różnych <xref:System.Type> wystąpień obiektów z różnymi <xref:System.Object> wystąpieniami.  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 Poniżej znajdują się szczególnie kwestie dotyczące przykładu:  
  
-   Porównanie <xref:System.Type> obiektu, który reprezentuje liczbę całkowitą <xref:System.Reflection.TypeInfo> z obiektem, który reprezentuje zwracaną `true` liczbę całkowitą, <xref:System.Reflection.TypeInfo> ponieważ pochodzi od <xref:System.Type>.  
  
-   Porównanie <xref:System.Type> obiektu, który <xref:System.Collections.Generic.IList%601> reprezentuje obiekt (otwarty typ `List(Of String)` ogólny) z obiektem (zamknięty typ ogólny) zwraca `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt, którego bazowy typ systemu ma być porównywany z bazowym typem systemu bieżącego <see cref="T:System.Type" />.</param>
        <summary>Określa, czy bazowy typ <see cref="T:System.Type" /> systemu jest taki sam jak źródłowy typ systemu określonego. <see cref="T:System.Type" /></summary>
        <returns><see langword="true" />Jeśli typ <paramref name="o" /> systemu bazowego jest taki sam jak bazowy typ <see cref="T:System.Type" />systemu; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład używa `Equals` do porównywania dwóch typów.  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje filtr elementu członkowskiego używany w atrybutach. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To pole zawiera odwołanie do delegata używanego przez <xref:System.Type.FindMembers%2A> metodę. Metoda hermetyzowana przez tego delegata przyjmuje dwa parametry: pierwszy jest <xref:System.Reflection.MemberInfo> obiektem, a drugi `Object`to. Metoda określa, czy obiekt `MemberInfo` jest zgodny z kryteriami określonymi `Object`przez. Może być przypisana wartość jednego z pól w klasach <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>lub <xref:System.Reflection.MethodImplAttributes>. `Object`  
  
 Na przykład `Object` można przypisać wartości `FieldAttributes` pola, takie jak Public. W takim przypadku, gdy `FilterAttribute` obiekt delegowany jest wywoływany, `true` zwróci tylko wtedy, gdy metoda reprezentowana przez `MemberInfo` obiekt jest dekoracyjna z atrybutem pola publicznego w metadanych.  
  
   
  
## Examples  
 Poniższy przykład pobiera `FilterAttribute` delegata, przekazuje go jako parametr <xref:System.Type.FindMembers%2A> do metody i wyświetla określone elementy członkowskie oraz ich atrybuty.  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje filtr elementu członkowskiego z rozróżnianiem wielkości liter używany dla nazw. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To pole zawiera odwołanie do delegata używanego przez <xref:System.Type.FindMembers%2A> metodę. Metoda hermetyzowana przez tego delegata przyjmuje dwa parametry: pierwszy jest <xref:System.Reflection.MemberInfo> obiektem, a drugi `Object`to. Metoda określa, czy obiekt `MemberInfo` jest zgodny z kryteriami określonymi `Object`przez. `Object` Ma przypisaną wartość ciągu, która może zawierać końcowy symbol wieloznaczny "*". Obsługiwane są tylko symbole wieloznacznego ciągu kończącego.  
  
 Na przykład `Object` może być przypisana wartość "Byte *". W takim przypadku, gdy `FilterName` obiekt delegowany jest wywoływany, `true` zwróci tylko wtedy, gdy metoda reprezentowana przez `MemberInfo` obiekt ma nazwę rozpoczynającą się od "Byte".  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera metody skojarzone z typem zdefiniowanym `Application` przez użytkownika.  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje filtr elementu członkowskiego bez uwzględniania wielkości liter używany dla nazw. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To pole zawiera odwołanie do delegata używanego przez <xref:System.Type.FindMembers%2A> metodę. Metoda hermetyzowana przez tego delegata przyjmuje dwa parametry: pierwszy jest <xref:System.Reflection.MemberInfo> obiektem, a drugi `Object`to. Metoda określa, czy obiekt `MemberInfo` jest zgodny z kryteriami określonymi `Object`przez. `Object` Ma przypisaną wartość ciągu, która może zawierać końcowy symbol wieloznaczny "*". Obsługiwane są tylko symbole wieloznacznego ciągu kończącego.  
  
 Na przykład `Object` może być przypisana wartość "ByTe *". W takim przypadku, gdy `FilterName` obiekt delegowany jest wywoływany, zwróci wartość true tylko wtedy, gdy metoda reprezentowana `MemberInfo` przez obiekt ma nazwę rozpoczynającą się od "Byte", bez uwzględnienia wielkości liter.  
  
   
  
## Examples  
 Poniższy przykład pobiera `MemberFilter` delegata, przekazuje go jako parametr <xref:System.Type.FindMembers%2A> do metody i wyświetla metody `String` oraz ich atrybuty klasy rozpoczynającej się od litery "c", w odróżnieniu od wielkości liter.  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="filter">Delegat, który porównuje interfejsy <paramref name="filterCriteria" />z.</param>
        <param name="filterCriteria">Kryteria wyszukiwania, które określają, czy interfejs powinien być uwzględniony w zwracanej tablicy.</param>
        <summary>Zwraca tablicę <see cref="T:System.Type" /> obiektów reprezentujących filtrowaną listę interfejsów implementowanych lub dziedziczonych przez bieżące <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiektów reprezentująca filtrowaną listę interfejsów zaimplementowanych lub dziedziczonych przez bieżącą <see cref="T:System.Type" />lub pustą tablicę, jeśli żadne interfejsy pasujące do filtru nie są implementowane lub dziedziczone przez <see cref="T:System.Type" />bieżące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
 W miejsce delegata<xref:System.Reflection.TypeFilter?displayProperty=nameWithType> można również <xref:System.Reflection.Module?displayProperty=nameWithType> użyć delegatówdostarczonychprzezklasę.<xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType>  
  
 Wszystkie interfejsy implementowane przez tę klasę są brane pod uwagę podczas wyszukiwania, niezależnie od tego, czy zostały zadeklarowane przez klasę bazową, czy przez tę klasę.  
  
 Ta metoda przeszukuje hierarchię klas podstawowych, zwracając każdy z zgodnych interfejsów każda klasa implementuje, a także wszystkie zgodne interfejsy, które implementuje każdy z tych interfejsów (to oznacza, że jest zwracany przechodnie zamknięcie pasujących interfejsów). Nie są zwracane żadne zduplikowane interfejsy.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, <xref:System.Type.FindInterfaces%2A> przeszukuje wszystkie interfejsy zadeklarowane w ograniczeniach dla parametru typu i wszystkie interfejsy Odziedziczone za pomocą interfejsów zadeklarowane w ograniczeniach. Jeśli bieżący <xref:System.Type> reprezentuje argument typu ogólnego, <xref:System.Type.FindInterfaces%2A> przeszukuje wszystkie interfejsy zaimplementowane przez typ, niezależnie od tego, czy są one zgodne z ograniczeniami.  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A>może zwracać interfejsy ogólne, nawet w przypadku typów, które nie są ogólne. Na przykład typ nieogólny może zaimplementować `IEnumerable<int>` (`IEnumerable(Of Integer)` w Visual Basic).  
  
   
  
## Examples  
 Poniższy przykład odnajduje określony interfejs zaimplementowany lub dziedziczony przez określony typ, a następnie wyświetla nazwy interfejsów.  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator statyczny jest wywoływany i zgłasza wyjątek.</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="memberType">Bitowa kombinacja wartości wyliczenia wskazująca typ elementu członkowskiego do wyszukania.</param>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.  
  
—lub— 
 <see cref="System.Reflection.BindingFlags.Default" />do zwrócenia <see langword="null" />.</param>
        <param name="filter">Delegat, który wykonuje porównania, zwracając <see langword="true" /> , czy element członkowski, który jest obecnie sprawdzany, jest zgodny z <paramref name="filterCriteria" /> i <see langword="false" /> w inny sposób.</param>
        <param name="filterCriteria">Kryteria wyszukiwania, które określają, czy element członkowski jest zwracany w tablicy <see langword="MemberInfo" /> obiektów.  
  
Pola <see langword="FieldAttributes" />, <see langword="MethodAttributes" />i <see langword="FilterAttribute" /> mogą być używane w połączeniu z delegatem dostarczonym przez tę klasę. <see langword="MethodImplAttributes" /></param>
        <summary>Zwraca filtrowaną tablicę <see cref="T:System.Reflection.MemberInfo" /> obiektów określonego typu elementu członkowskiego.</summary>
        <returns>Odfiltrowana tablica <see cref="T:System.Reflection.MemberInfo" /> obiektów określonego typu elementu członkowskiego.  
  
—lub— 
Pusta tablica, jeśli bieżąca <see cref="T:System.Type" /> nie ma składowych typu <paramref name="memberType" /> , które pasują do kryteriów filtrowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Metoda ta może być zastąpiona przez klasę pochodną.  
  
Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.  

<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `bindingAttr` <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>Aby metoda pomyślnie pobierała informacje o elemencie członkowskim, argument musi zawierać co najmniej jedną z i, a także co najmniej jeden z i. `FindMembers` 

 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania, które elementy członkowskie mają być uwzględnione w wyszukiwaniu:  
  
-   Określ `BindingFlags.Instance` , aby uwzględnić elementy członkowskie wystąpienia w wyszukiwaniu.  
  
-   Określ `BindingFlags.Static` , aby uwzględnić statyczne elementy członkowskie w wyszukiwaniu.  
  
-   Określ `BindingFlags.Public` , aby uwzględnić publiczne składowe w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu niepubliczne składowe (czyli prywatne, wewnętrzne i chronione).  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi modyfikatorów mogą służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.DeclaredOnly`Aby przeszukać tylko członków zadeklarowanych <xref:System.Type>w, a nie na elementach, które były po prostu dziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
Aby uzyskać inicjatora klasy (Konstruktor statyczny) przy użyciu tej metody, należy <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> określić<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w Visual Basic). Można również uzyskać inicjator klasy przy użyciu <xref:System.Type.TypeInitializer%2A> właściwości.  
  
Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego lub metody generycznej, <xref:System.Type.FindMembers%2A> przetwarza wszystkie składowe zadeklarowane przez ograniczenie klasy i ograniczenia interfejsu parametru typu.  

Argument może być niestandardowym delegatem typu <xref:System.Reflection.MemberFilter>lub może być jednym z następujących wstępnie zdefiniowanych delegatów: `filter`

- <xref:System.Type.FilterAttribute?displayProperty=nameWithType>, który używa<xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes> <xref:System.Reflection.MethodImplAttributes>,lub maski bitowej jako wartości.`filterCriteria`

- <xref:System.Type.FilterName?displayProperty=nameWithType>, która wykonuje porównanie z uwzględnieniem wielkości liter każdej nazwy elementu członkowskiego z ciągiem przekazaną do `filterCriteria`.

- <xref:System.Type.FilterNameIgnoreCase?displayProperty=nameWithType>, która wykonuje porównanie z wielkością liter dla każdej nazwy elementu członkowskiego ciągiem, który przeszedł do `filterCriteria`.

## Examples  
 Poniższy przykład znajduje wszystkie elementy członkowskie klasy, które pasują do określonych kryteriów wyszukiwania, a następnie wyświetla pasujących członków.  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera w pełni kwalifikowaną nazwę typu, w tym jego przestrzeń nazw, ale nie jego zestaw.</summary>
        <value>W pełni kwalifikowana nazwa typu, w tym jej przestrzeń nazw, ale nie jej zestaw; lub <see langword="null" /> Jeśli bieżące wystąpienie reprezentuje parametr typu ogólnego, typ tablicy, typ wskaźnika lub <see langword="byref" /> typ na podstawie parametru typu, lub typ ogólny, który nie jest definicją typu ogólnego, ale zawiera nierozpoznane parametry typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład w pełni kwalifikowana nazwa <xref:System.String> typu to. `System.String` Jest to kontrast z nazwą kwalifikowaną dla zestawu zwracaną przez <xref:System.Type.AssemblyQualifiedName%2A> właściwość, która składa się z pełnej nazwy i pełnej nazwy zestawu.  
  
 Jeśli bieżący typ reprezentuje zamknięty typ ogólny, argumenty typu w ciągu zwracanym przez <xref:System.Type.FullName%2A> właściwość są kwalifikowane przez ich pełną nazwę zestawu, nawet jeśli ciąg reprezentujący sam typ ogólny nie jest kwalifikowany przez pełny Nazwa zestawu. Poniższy przykład ilustruje różnicę we właściwości FullName dla typu, który reprezentuje definicję typu ogólnego i który reprezentuje zamknięty typ ogólny.  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 Ta właściwość zwraca `null` wartość, jeśli:  
  
-   Bieżący <xref:System.Type> obiekt reprezentuje parametr typu ogólnego.  
  
     Poniższy przykład pobiera parametr <xref:System.Nullable%601> typu i podejmuje próbę wyświetlenia jego <xref:System.Type.FullName%2A> właściwości.  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   Bieżący <xref:System.Type> obiekt reprezentuje typ tablicy, typ wskaźnika `byref` lub typ, który jest oparty na parametrze typu ogólnego.  
  
     Poniższy przykład definiuje typ ogólny, `Generictype1<T>`, z trzema metodami: `Display(T[])`, który jest przekazywać tablicę typu T; , który przeszedł obiekt t; i `ChangeValue(ref T)`, który jest przekazywać obiekt t przez odwołanie. `HandleT(T)` Ponieważ C# i Visual Basic nie Zezwalaj nam na definiowanie T jako wskaźnika w `HandleT` metodzie, <xref:System.Type.MakePointerType%2A> musimy wywołać metodę dla <xref:System.Type> obiektu, który reprezentuje typ parametru metody, aby utworzyć wskaźnik do typu ogólnego. Dane wyjściowe z przykładu pokazują, że we wszystkich trzech przypadkach <xref:System.Type.FullName%2A> właściwość jest. `null`  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   Bieżący typ zawiera parametry typu ogólnego, które nie zostały zastąpione przez określone typy (oznacza to, <xref:System.Type.ContainsGenericParameters%2A> że właściwość zwraca `true`), ale typ nie jest definicją typu ogólnego <xref:System.Type.IsGenericTypeDefinition%2A> (oznacza to, że właściwość zwraca`false`  
  
     W poniższym przykładzie `Derived<T>` dziedziczy po `Base<T>`. <xref:System.Type> `Derived<T>` <xref:System.Type.FullName%2A> Właściwość uzyskuje obiekt, który reprezentuje typ podstawowy, a jego właściwość zwraca `null`. <xref:System.Type.BaseType%2A>  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     Aby <xref:System.Type.FullName%2A> tozrobić<xref:System.Type.GetGenericTypeDefinition%2A> , można użyć metody w celu uzyskania definicji typu ogólnego, jak pokazano w przykładzie. `null`  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład wyświetla pełną nazwę określonego typu.  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 Poniższy przykład <xref:System.Type.ToString%2A> porównuje ciągi zwracane przez metodę `Name`oraz właściwości, <xref:System.Type.FullName%2A>i <xref:System.Type.AssemblyQualifiedName%2A> .  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Określanie w pełni kwalifikowanych nazw typów</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kombinację <see cref="T:System.Reflection.GenericParameterAttributes" /> flag, które opisują kowariancję i specjalne ograniczenia bieżącego parametru typu ogólnego.</summary>
        <value>Bitowa kombinacja <see cref="T:System.Reflection.GenericParameterAttributes" /> wartości opisujących kowariancję i specjalne ograniczenia bieżącego parametru typu ogólnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości zawiera flagi opisujące, czy bieżący parametr typu generycznego jest niezmienny, oraz flagi opisujące ograniczenia specjalne. Użyj wartości, aby wybrać flagi kowariancji i <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> użyć wartości, aby wybrać flagi ograniczenia. <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType>  
  
 Aby zapoznać się z listą warunków niewariantów dla terminów używanych w odbiciu ogólnym <xref:System.Type.IsGenericType%2A> , zobacz uwagi dotyczące właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu definiuje typ `Test` ogólny z dwoma parametrami typu, które mają różne ograniczenia. Gdy program jest wykonywany, ograniczenia są badane przy użyciu <xref:System.Type.GenericParameterAttributes%2A> właściwości <xref:System.Type.GetGenericParameterConstraints%2A> i metody.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący <see cref="T:System.Type" /> obiekt nie jest parametrem typu ogólnego. Oznacza to, <see cref="P:System.Type.IsGenericParameter" /> że właściwość zwraca <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pozycję parametru typu z listy parametrów typu ogólnego typu lub metody, która deklaruje parametr, gdy <see cref="T:System.Type" /> obiekt reprezentuje parametr typu ogólnego lub metody generycznej.</summary>
        <value>Pozycja parametru typu na liście parametrów typu ogólnego typu lub metody definiującej parametr. Numery pozycji zaczynają się od 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GenericParameterPosition%2A> Właściwość zwraca pozycję parametru typu na liście parametrów definicji typu ogólnego lub definicji metody generycznej, w której został pierwotnie zdefiniowany parametr typu. Właściwości <xref:System.Type.DeclaringType%2A> i<xref:System.Type.DeclaringMethod%2A> identyfikują typ ogólny lub definicję metody:  
  
-   Jeśli właściwość zwraca obiekt <xref:System.Reflection.MethodInfo>, który <xref:System.Reflection.MethodInfo> reprezentuje definicję metody ogólnej, a bieżący <xref:System.Type> obiekt reprezentuje parametr typu tej definicji metody ogólnej. <xref:System.Type.DeclaringMethod%2A>  
  
-   `null` <xref:System.Type.DeclaringType%2A> Jeśli właściwość zwraca, wówczas właściwość zawsze zwraca <xref:System.Type> obiekt reprezentujący definicję typu ogólnego, a bieżący <xref:System.Type> obiekt reprezentuje parametr typu tego typu ogólnego <xref:System.Type.DeclaringMethod%2A> definicji.  
  
 Aby zapewnić prawidłowy kontekst dla wartości <xref:System.Type.GenericParameterPosition%2A> właściwości, należy zidentyfikować typ ogólny lub metodę, do której należy parametr typu. Na przykład rozważmy wartość zwracaną metody `GetSomething` generycznej w następującym kodzie:  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 Typ zwracany przez `GetSomething` zależy od argumentów typu dostarczonych do klasy `A` i do `GetSomething` samego siebie. Możesz uzyskać wartość <xref:System.Reflection.MethodInfo> dla `GetSomething`i od, aby można było uzyskać typ zwracany. Podczas badania parametrów typu zwracanego <xref:System.Type.GenericParameterPosition%2A> zwraca wartość 0 dla obu. Pozycja `V` jest równa 0, `V` ponieważ jest pierwszym parametrem typu na liście parametrów typu dla klasy `A`. Pozycja `X` jest równa 0, `X` ponieważ jest pierwszym parametrem typu na liście parametrów typu dla `GetSomething`.  
  
> [!NOTE]
>  Wywołanie właściwości powoduje wyjątek, jeśli bieżąca <xref:System.Type> nie reprezentuje parametru typu. <xref:System.Type.GenericParameterPosition%2A> Podczas badania argumentów typu otwartego typu skonstruowanego Użyj <xref:System.Type.IsGenericParameter%2A> właściwości, aby określić, które typy parametrów są typu. <xref:System.Type.DeclaringType%2A> <xref:System.Type.DeclaringMethod%2A> <xref:System.Type.GenericParameterPosition%2A> Właściwość zwraca `true` dla parametru typu; można następnie użyć metody w celu uzyskania jej pozycji i użycia właściwości i do określenia metody ogólnej lub definicji typu, która definiuje go <xref:System.Type.IsGenericParameter%2A> .  
  
   
  
## Examples  
 Poniższy przykład definiuje klasę generyczną z dwoma parametrami typu i definiuje drugą klasę generyczną pochodzącą od pierwszej klasy. Klasa bazowa klasy pochodnej ma dwa argumenty typu: pierwszy to <xref:System.Int32>, a drugi to parametr typu pochodnego. W przykładzie przedstawiono informacje o tych klasach ogólnych, w tym pozycje zgłoszone <xref:System.Type.GenericParameterPosition%2A> przez właściwość.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący typ nie reprezentuje parametru typu. Oznacza to, <see cref="P:System.Type.IsGenericParameter" /> że <see langword="false" />zwraca.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera tablicę argumentów typu ogólnego dla tego typu.</summary>
        <value>Tablica argumentów typu ogólnego dla tego typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość pobiera tylko argumenty typu ogólnego; oznacza to, że typy, które zostały określone dla parametrów typu ogólnego bieżącego typu. Jeśli bieżący typ jest definicją typu ogólnego, ta właściwość zwraca pustą tablicę.  
  
> [!NOTE]
>  Jeśli typ ogólny jest używany w metodzie ogólnej lub w innym typie ogólnym, niektóre jego argumenty typu ogólnego mogą być parametrami typu ogólnego otaczającej metody lub typu.  
  
 Aby uzyskać parametry typu ogólnego typu, który reprezentuje definicję typu ogólnego, użyj <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> właściwości. Aby uzyskać <xref:System.Reflection.TypeInfo> obiekt dla bieżącego <xref:System.Type> obiektu, użyj <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> metody rozszerzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera liczbę wymiarów w tablicy.</summary>
        <returns>Liczba całkowita, która zawiera liczbę wymiarów w bieżącym typie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wyświetla liczbę wymiarów w tablicy.  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Funkcja tej metody nie jest obsługiwana w klasie bazowej i musi być zaimplementowana w klasie pochodnej.</exception>
        <exception cref="T:System.ArgumentException">Bieżący typ nie jest tablicą.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, implementuje <see cref="P:System.Type.Attributes" /> Właściwość i pobiera bitową kombinację wartości wyliczenia, które wskazują atrybuty skojarzone <see cref="T:System.Type" />z.</summary>
        <returns>Obiekt reprezentujący zestaw <see cref="T:System.Type" />atrybutów. <see cref="T:System.Reflection.TypeAttributes" /></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określony Konstruktor dla bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla żądanego konstruktora.  
  
—lub— 
Pusta tablica <see cref="T:System.Type" /> obiektów, aby uzyskać konstruktora, który nie przyjmuje żadnych parametrów. Taka pusta tablica jest dostarczana przez <see langword="static" /> pole. <see cref="F:System.Type.EmptyTypes" /></param>
        <summary>Wyszukuje Konstruktor wystąpienia publicznego, którego parametry pasują do typów w określonej tablicy.</summary>
        <returns>Obiekt reprezentujący Konstruktor wystąpienia publicznego, którego parametry pasują do typów w tablicy typu parametru, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie metody wyszukuje konstruktorów wystąpień publicznych i nie można ich użyć do uzyskania inicjatora klasy (Konstruktor statyczny). Aby uzyskać inicjator klasy, należy użyć przeciążenia, które przyjmuje <xref:System.Reflection.BindingFlags>, i określić <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w Visual Basic). Można również uzyskać inicjator klasy przy użyciu <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 Jeśli żądany Konstruktor nie jest publiczny, Metoda ta zwraca wartość `null`.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.ConstructorInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu. Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda zawsze zwraca wartość `null`.  
  
   
  
## Examples  
 Poniższy przykład uzyskuje typ `MyClass`, <xref:System.Reflection.ConstructorInfo> pobiera obiekt i wyświetla sygnaturę konstruktora.  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" />jest <see langword="null" />.  
  
—lub— 
Jeden z elementów w programie <paramref name="types" /> ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />jest wielowymiarowych.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.  
  
—lub— 
 <see cref="System.Reflection.BindingFlags.Default" />do zwrócenia <see langword="null" />.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
Odwołanie o wartości null<see langword="Nothing" /> (w Visual Basic), aby <see cref="P:System.Type.DefaultBinder" />użyć.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla konstruktora do pobrania.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (czyli typ [] typy = nowy typ [0]), aby uzyskać konstruktora, który nie przyjmuje żadnych parametrów.  
  
—lub— 
 <see cref="F:System.Type.EmptyTypes" />.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentująca atrybuty skojarzone z odpowiednim elementem w tablicy typu parametru. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Wyszukuje Konstruktor, którego parametry pasują do określonych typów argumentów i modyfikatorów, przy użyciu określonych ograniczeń powiązania.</summary>
        <returns>Obiekt reprezentujący konstruktora, który odpowiada określonym wymaganiom, jeśli został znaleziony; <see langword="null" />w przeciwnym razie. <see cref="T:System.Reflection.ConstructorInfo" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dokładne dopasowanie nie istnieje, `binder` program podejmie próbę wykonania wymuszonych typów parametrów określonych `types` w tablicy w celu wybrania dopasowania. Jeśli nie można wybrać dopasowania `null` , zwracana jest wartość. `binder`  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania konstruktorów, które mają być uwzględnione w wyszukiwaniu:  
  
-   Musisz określić albo `BindingFlags.Instance` `BindingFlags.Static` , aby uzyskać zwracaną wartość.  
  
-   Określ `BindingFlags.Public` , aby uwzględnić w wyszukiwaniu publiczne konstruktory.  
  
-   Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu konstruktory niepubliczne (czyli prywatne, wewnętrzne i chronione).  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Aby uzyskać inicjatora klasy (Konstruktor statyczny) przy użyciu tego przeciążenia metody, należy <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> określić<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w Visual Basic). Można również uzyskać inicjator klasy przy użyciu <xref:System.Type.TypeInitializer%2A> właściwości.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.ConstructorInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu. Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda zawsze zwraca wartość `null`.  
  
   
  
## Examples  
 Następujący program uzyskuje typ `MyClass1` klasy, <xref:System.Reflection.ConstructorInfo> pobiera obiekt pasujący do określonych flag powiązań i wyświetla podpis konstruktora.  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" />jest <see langword="null" />.  
  
—lub— 
Jeden z elementów w programie <paramref name="types" /> ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />jest wielowymiarowych.  
  
—lub— 
 <paramref name="modifiers" />jest wielowymiarowych.  
  
—lub— 
 <paramref name="types" />i <paramref name="modifiers" /> nie mają tej samej długości.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.  
  
—lub— 
 <see cref="System.Reflection.BindingFlags.Default" />do zwrócenia <see langword="null" />.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
Odwołanie o wartości null<see langword="Nothing" /> (w Visual Basic), aby <see cref="P:System.Type.DefaultBinder" />użyć.</param>
        <param name="callConvention">Obiekt, który określa zestaw reguł do użycia w odniesieniu do kolejności i układu argumentów, sposób przekazywania wartości zwracanej, jakie rejestry są używane dla argumentów, a stos jest czyszczony.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla konstruktora do pobrania.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (czyli typ [] typy = nowy typ [0]), aby uzyskać konstruktora, który nie przyjmuje żadnych parametrów.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentująca atrybuty skojarzone z odpowiednim elementem <paramref name="types" /> w tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Wyszukuje Konstruktor, którego parametry pasują do określonych typów argumentów i modyfikatorów, przy użyciu określonych ograniczeń powiązania i określonej konwencji wywoływania.</summary>
        <returns>Obiekt reprezentujący konstruktora, który odpowiada określonym wymaganiom, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chociaż <xref:System.Reflection.ParameterModifier> domyślny spinacz nie przetwarza `modifiers` (parametr), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> , aby napisać niestandardowy spinacz, który przetwarza `modifiers`. `ParameterModifier`jest używany tylko podczas wywoływania za pomocą międzyoperacyjności modelu COM i obsługiwane są tylko parametry, które są przesyłane przez odwołanie.  
  
 Jeśli dokładne dopasowanie nie istnieje, `binder` program podejmie próbę wykonania wymuszonych typów parametrów określonych `types` w tablicy w celu wybrania dopasowania. Jeśli nie można wybrać dopasowania `null` , zwracana jest wartość. `binder`  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania konstruktorów, które mają być uwzględnione w wyszukiwaniu:  
  
-   Musisz określić albo `BindingFlags.Instance` `BindingFlags.Static` , aby uzyskać zwracaną wartość.  
  
-   Określ `BindingFlags.Public` , aby uwzględnić w wyszukiwaniu publiczne konstruktory.  
  
-   Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu konstruktory niepubliczne (czyli prywatne, wewnętrzne i chronione).  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Aby uzyskać inicjatora klasy (Konstruktor statyczny) przy użyciu tej metody, należy <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> określić<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w Visual Basic). Można również uzyskać inicjator klasy przy użyciu <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy bazowej są zwracane przez `Get` metody podczas odzwierciedlania typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.ConstructorInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu. Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda zawsze zwraca wartość `null`.  
  
   
  
## Examples  
 Poniższy przykład uzyskuje typ `MyClass1`, <xref:System.Reflection.ConstructorInfo> pobiera obiekt, który pasuje do określonych flag powiązań i wyświetla sygnaturę konstruktora.  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" />jest <see langword="null" />.  
  
—lub— 
Jeden z elementów w programie <paramref name="types" /> ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />jest wielowymiarowych.  
  
—lub— 
 <paramref name="modifiers" />jest wielowymiarowych.  
  
—lub— 
 <paramref name="types" />i <paramref name="modifiers" /> nie mają tej samej długości.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.  
  
—lub— 
<see cref="System.Reflection.BindingFlags.Default" />do zwrócenia <see langword="null" />.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
Odwołanie o wartości null<see langword="Nothing" /> (w Visual Basic), aby <see cref="P:System.Type.DefaultBinder" />użyć.</param>
        <param name="callConvention">Obiekt, który określa zestaw reguł do użycia w odniesieniu do kolejności i układu argumentów, sposób przekazywania wartości zwracanej, jakie rejestry są używane dla argumentów, a stos jest czyszczony.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla konstruktora do pobrania.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (czyli typ [] typy = nowy typ [0]), aby uzyskać konstruktora, który nie przyjmuje żadnych parametrów.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentująca atrybuty skojarzone z odpowiednim elementem <paramref name="types" /> w tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, poszukuje konstruktora, którego parametry pasują do określonych typów argumentów i modyfikatorów, przy użyciu określonych ograniczeń powiązania i określonej konwencji wywoływania.</summary>
        <returns>Obiekt reprezentujący konstruktora, który odpowiada określonym wymaganiom, jeśli został znaleziony; <see langword="null" />w przeciwnym razie. <see cref="T:System.Reflection.ConstructorInfo" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chociaż <xref:System.Reflection.ParameterModifier> domyślny spinacz nie przetwarza `modifiers` (parametr), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> , aby napisać niestandardowy spinacz, który przetwarza `modifiers`. `ParameterModifier`jest używany tylko podczas wywoływania za pomocą międzyoperacyjności modelu COM i obsługiwane są tylko parametry, które są przesyłane przez odwołanie.  
  
 Jeśli dokładne dopasowanie nie istnieje, `binder` program podejmie próbę wykonania wymuszonych typów parametrów określonych `types` w tablicy w celu wybrania dopasowania. Jeśli nie można wybrać dopasowania `null` , zwracana jest wartość. `binder`  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania konstruktorów, które mają być uwzględnione w wyszukiwaniu:  
  
-   Musisz określić albo `BindingFlags.Instance` `BindingFlags.Static` , aby uzyskać zwracaną wartość.  
  
-   Określ `BindingFlags.Public` , aby uwzględnić w wyszukiwaniu publiczne konstruktory.  
  
-   Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu konstruktory niepubliczne (czyli prywatne, wewnętrzne i chronione).  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Ta metoda implementuje <xref:System.Type.GetConstructor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" />jest <see langword="null" />.  
  
—lub— 
Jeden z elementów w programie <paramref name="types" /> ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />jest wielowymiarowych.  
  
—lub— 
 <paramref name="modifiers" />jest wielowymiarowych.  
  
—lub— 
 <paramref name="types" />i <paramref name="modifiers" /> nie mają tej samej długości.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący typ to <see cref="T:System.Reflection.Emit.TypeBuilder" /> lub <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera konstruktory bieżącego <see cref="T:System.Type" />elementu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie publiczne konstruktory zdefiniowane dla bieżącego <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Reflection.ConstructorInfo" /> obiektów reprezentująca wszystkie publiczne konstruktory wystąpień zdefiniowane dla bieżącego <see cref="T:System.Type" />, ale nie z uwzględnieniem inicjatora typu (Konstruktor statyczny). Jeśli dla bieżącego <see cref="T:System.Type" />elementu nie są zdefiniowane żadne konstruktory wystąpień publicznych lub jeśli bieżąca <see cref="T:System.Type" /> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, zwracana jest pusta tablica typu. <see cref="T:System.Reflection.ConstructorInfo" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A> Metoda nie zwraca konstruktorów w określonej kolejności, np. w kolejności deklaracji. Kod nie może zależeć od kolejności, w której są zwracane konstruktory, ponieważ ta kolejność jest różna.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy bazowej są zwracane przez `Get` metody podczas odzwierciedlania typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 To Przeciążenie <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> metody wywołuje Przeciążenie metody z &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> wVisualBasic)<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> .`Or` Nie odnajdzie inicjatorów klas (Konstruktor statyczny). Aby znaleźć inicjatory klasy, Użyj przeciążenia, które przyjmuje <xref:System.Reflection.BindingFlags>, i określ <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w Visual Basic). Można również uzyskać inicjator klasy przy użyciu <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.ConstructorInfo> zwraca obiekty z parametrami typu zamienionymi przez odpowiednie argumenty typu. `C<T>` Na przykład jeśli klasa ma Konstruktor C# `Sub New(ByVal t1 As Integer)` <xref:System.Reflection.ConstructorInfo> <xref:System.Type.GetConstructors%2A> `Sub New(ByVal t1 As T)` `C(T t1)` (w Visual Basic), wywoływanie `C<int>` zwraca wartość, która reprezentuje `C(int t1)` element (w wizualizacji Podstawowa).  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego <xref:System.Type.GetConstructors%2A> , metoda zwraca pustą tablicę.  
  
   
  
## Examples  
 Ten przykład przedstawia dane wyjściowe <xref:System.Type.GetConstructors%2A> przeciążenia z klasy, która ma dwa konstruktory wystąpień i jeden Konstruktor statyczny.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 Dane wyjściowe tego kodu są następujące:  
  
 2  
  
 False  
  
 False  
  
 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `for` Ponieważ przeciążenia używa tylko i, Konstruktor statyczny nie jest liczony przez wyrażenie ani nie jest obliczany `IsStatic`przez. <xref:System.Type.GetConstructors>  
  
 Aby znaleźć konstruktory statyczne, użyj <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> przeciążenia i przekaż kombinację (logiczną <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `OR`) z <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>,,, jak pokazano w poniższym przykładzie kodu:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Teraz dane wyjściowe są następujące:  
  
 3  
  
 False  
  
 Prawda  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.  
  
—lub— 
<see cref="F:System.Reflection.BindingFlags.Default" />Aby zwrócić pustą tablicę.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, wyszukuje konstruktory zdefiniowane dla bieżącego <see cref="T:System.Type" />przy użyciu określonego. <see langword="BindingFlags" /></summary>
        <returns>Tablica <see cref="T:System.Reflection.ConstructorInfo" /> obiektów reprezentująca wszystkie konstruktory zdefiniowane dla bieżącego <see cref="T:System.Type" /> , które pasują do określonych ograniczeń powiązań, w tym inicjatora typu, jeśli jest zdefiniowany. Zwraca pustą tablicę typu <see cref="T:System.Reflection.ConstructorInfo" /> , jeśli nie zdefiniowano konstruktorów dla <see cref="T:System.Type" />bieżącego, jeśli żaden z zdefiniowanych konstruktorów nie pasuje do ograniczeń powiązań lub jeśli bieżący <see cref="T:System.Type" /> reprezentuje parametr typu w definicji typ ogólny lub metoda ogólna.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
`bindingAttr`może służyć do określenia, czy zwrócić tylko konstruktory publiczne, czy konstruktory publiczne i niepubliczne.  
  
Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania konstruktorów, które mają być uwzględnione w wyszukiwaniu:  
  
- Określ `BindingFlags.Static` wraz z `BindingFlags.NonPublic` , aby pobrać inicjatora klasy (Konstruktor statyczny). Można również uzyskać inicjator klasy przy użyciu <xref:System.Type.TypeInitializer%2A> właściwości.

- Określ `BindingFlags.Instance` wraz z jednym lub `BindingFlags.Public` obu i, `BindingFlags.NonPublic` aby pobrać konstruktory wystąpień.   
  
Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  

<xref:System.Type.GetConstructors%2A> Metoda nie zwraca konstruktorów w określonej kolejności, np. w kolejności deklaracji. Kod nie może zależeć od kolejności, w której są zwracane konstruktory, ponieważ ta kolejność jest różna.  

Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.ConstructorInfo> zwraca obiekty z parametrami typu zamienionymi przez odpowiednie argumenty typu. `C<T>` Na przykład jeśli klasa ma Konstruktor C# `Sub New(ByVal t1 As Integer)` <xref:System.Reflection.ConstructorInfo> <xref:System.Type.GetConstructors%2A> `Sub New(ByVal t1 As T)` `C(T t1)` (w Visual Basic), wywoływanie `C<int>` zwraca wartość, która reprezentuje `C(int t1)` element (w wizualizacji Podstawowa).  
  
Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego <xref:System.Type.GetConstructors%2A> , metoda zwraca pustą tablicę.  
  
## Examples  

Ten przykład przedstawia dane wyjściowe <xref:System.Type.GetConstructors> przeciążenia z klasy, która ma dwa konstruktory wystąpień i jeden Konstruktor statyczny.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 Dane wyjściowe tego kodu są następujące:  
  
 2  
  
 False  
  
 False  
  
 <xref:System.Reflection.BindingFlags.Public> <xref:System.Reflection.BindingFlags.Instance> `for` Ponieważ przeciążenia używa tylko i, Konstruktor statyczny nie jest liczony przez wyrażenie ani nie jest obliczany `IsStatic`przez. <xref:System.Type.GetConstructors%2A>  
  
 Aby znaleźć konstruktory statyczne, użyj <xref:System.Type.GetConstructors%2A> przeciążenia i przekaż go do kombinacji (logicznej lub) z <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>,, jak pokazano w poniższym przykładzie kodu:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Teraz dane wyjściowe są następujące:  
  
 3  
  
 False  
  
 Prawda  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyszukuje elementy członkowskie zdefiniowane dla bieżącego <see cref="T:System.Type" /> elementu, którego <see cref="T:System.Reflection.DefaultMemberAttribute" /> ustawiono.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiektów reprezentująca wszystkie domyślne elementy członkowskie bieżącego <see cref="T:System.Type" />elementu.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.MemberInfo" />, jeśli bieżąca <see cref="T:System.Type" /> nie ma domyślnych elementów członkowskich.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetDefaultMembers%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takich jak kolejność alfabetyczna lub Deklaracja. Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.  
  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
 Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy bazowej są zwracane przez `Get` metody podczas odzwierciedlania typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.MemberInfo> zwraca obiekty z parametrami typu zamienionymi przez odpowiednie argumenty typu. Na przykład, jeśli Klasa `C<T>` ma właściwość `P` , która zwraca `T`, wywołanie <xref:System.Type.GetDefaultMembers%2A> na `C<int>` zwraca `int P` wartość C# (`Property P As Integer` w Visual Basic).  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje elementy członkowskie ograniczenia klasy lub <xref:System.Object> składowych w przypadku braku ograniczenia klasy.  
  
   
  
## Examples  
 W poniższym przykładzie są pobierane informacje o `MyClass` domyślnej składowej i są wyświetlane domyślne elementy członkowskie.  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, zwraca <see cref="T:System.Type" /> obiekt, do którego odnosi się odwołanie lub którego dotyczy bieżąca tablica, wskaźnik lub typ referencyjny.</summary>
        <returns>Obiekt, do którego odnosi się lub odwołuje się bieżąca tablica, wskaźnik lub typ referencyjny lub <see langword="null" /> Jeśli bieżąca <see cref="T:System.Type" /> nie jest tablicą lub wskaźnikiem albo nie jest przekazana przez odwołanie lub reprezentuje typ ogólny lub parametr typu w <see cref="T:System.Type" /> Definicja typu ogólnego lub metody ogólnej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca `null` wartość <xref:System.Array> dla klasy.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `GetElementType` metody.  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Wartość, której nazwa ma zostać pobrana.</param>
        <summary>Zwraca nazwę stałej, która ma określoną wartość dla bieżącego typu wyliczenia.</summary>
        <returns>Nazwa elementu członkowskiego bieżącego typu wyliczeniowego, który ma określoną wartość, lub <see langword="null" /> Jeśli nie zostanie znaleziona taka stała.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Bieżący typ nie jest wyliczeniem.  
  
—lub— 
 <paramref name="value" />nie jest żadnym z bieżącego typu ani nie ma tego samego typu podstawowego co bieżący typ.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca nazwy elementów członkowskich bieżącego typu wyliczeniowego.</summary>
        <returns>Tablica zawierająca nazwy elementów członkowskich wyliczenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy tablicy wartości zwracanej są sortowane według wartości binarnych (czyli wartości bez znaku) dla stałych wyliczeniowych. Jeśli tablica zawiera stałe mające taką samą wartość, kolejność odpowiadających im nazw jest nieokreślona.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżący typ nie jest wyliczeniem.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca typ podstawowy bieżącego typu wyliczeniowego.</summary>
        <returns>Typ podstawowy bieżącego wyliczania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie typem podstawowym wyliczenia w C# i Visual Basic jest. <xref:System.Int32> Można określić inne typy całkowite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżący typ nie jest wyliczeniem.  
  
 —lub—  
  
 Typ wyliczenia jest nieprawidłowy, ponieważ zawiera więcej niż jedno pole wystąpienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę wartości stałych w bieżącym typie wyliczeniowy.</summary>
        <returns>Tablica zawierająca wartości. Elementy tablicy są sortowane według wartości binarnych (czyli wartości bez znaku) dla stałych wyliczeniowych.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Bieżący typ nie jest wyliczeniem.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określone zdarzenie zadeklarowane lub dziedziczone przez bieżące <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę zdarzenia zadeklarowanego lub dziedziczonego przez bieżące <see cref="T:System.Type" />.</param>
        <summary><see cref="T:System.Reflection.EventInfo" /> Zwraca obiekt reprezentujący określone zdarzenie publiczne.</summary>
        <returns>Obiekt reprezentujący określone zdarzenie publiczne, które jest zadeklarowane lub dziedziczone przez bieżące <see cref="T:System.Type" />, jeśli znaleziono; <see langword="null" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenie jest uważane za publiczne odbicie, jeżeli ma co najmniej jedną metodę lub metodę dostępu, która jest publiczna. W przeciwnym razie zdarzenie jest uznawane za prywatne i musisz <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> użyć &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w Visual Basic, połączyć wartości przy `Or`użyciu), aby je pobrać.  
  
 W wyszukiwaniu `name` jest rozróżniana wielkość liter. Wyszukiwanie obejmuje publiczne i publiczne zdarzenia wystąpienia.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy bazowej są zwracane przez `Get` metody podczas odzwierciedlania typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.EventInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje zdarzenia z ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Reflection.EventInfo> obiekt i pobiera zdarzenie dla klasy Button dla określonego zdarzenia.  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę zdarzenia, które jest zadeklarowane lub dziedziczone przez bieżące <see cref="T:System.Type" />.</param>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.  
  
—lub— 
 <see cref="System.Reflection.BindingFlags.Default" />do zwrócenia <see langword="null" />.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, zwraca <see cref="T:System.Reflection.EventInfo" /> obiekt reprezentujący określone zdarzenie, przy użyciu określonych ograniczeń powiązania.</summary>
        <returns>Obiekt reprezentujący określone zdarzenie, które jest zadeklarowane lub dziedziczone przez bieżące <see cref="T:System.Type" />, jeśli znaleziono; <see langword="null" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania zdarzeń do uwzględnienia w wyszukiwaniu:  
  
-   Musisz określić albo `BindingFlags.Instance` `BindingFlags.Static` , aby uzyskać zwracaną wartość.  
  
-   Określ `BindingFlags.Public` , aby uwzględnić w wyszukiwaniu zdarzenia publiczne.  
  
-   Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu zdarzenia niepubliczne (czyli prywatne, wewnętrzne i chronione).  
  
-   Określ `BindingFlags.FlattenHierarchy` , aby `public` uwzględnić `protected` i statyczne składowe w hierarchii; `private` statyczne składowe w klasach dziedziczonych nie są uwzględniane.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi modyfikatorów mogą służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase`ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly`Aby wyszukać tylko zdarzenia zadeklarowane <xref:System.Type>w, a nie zdarzenia, które były po prostu dziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Zdarzenie jest uważane za publiczne odbicie, jeżeli ma co najmniej jedną metodę lub metodę dostępu, która jest publiczna. W przeciwnym razie zdarzenie jest uznawane za prywatne i musisz <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> użyć &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w Visual Basic, połączyć wartości przy `Or`użyciu), aby je pobrać.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.EventInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje zdarzenia z ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> metody do wyszukiwania typu dla zdarzenia publicznego lub niepublicznego o nazwie "kliknij", które nie `static` jest (`Shared` w Visual Basic).  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera zdarzenia, które są zadeklarowane lub dziedziczone przez bieżące <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie zdarzenia publiczne, które są zadeklarowane lub dziedziczone przez bieżące <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Reflection.EventInfo" /> obiektów reprezentująca wszystkie zdarzenia publiczne, które są zadeklarowane lub dziedziczone przez bieżące <see cref="T:System.Type" />.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.EventInfo" />, jeśli bieżąca <see cref="T:System.Type" /> nie ma zdarzeń publicznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenie jest uważane za publiczne odbicie, jeżeli ma co najmniej jedną metodę lub metodę dostępu, która jest publiczna. W przeciwnym razie zdarzenie jest uznawane za prywatne i musisz <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> użyć &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w Visual Basic, połączyć wartości przy `Or`użyciu), aby je pobrać.  
  
 <xref:System.Type.GetEvents%2A> Metoda nie zwraca zdarzeń w określonej kolejności, takich jak kolejność alfabetyczna lub Deklaracja. Kod nie może zależeć od kolejności, w której są zwracane zdarzenia, ponieważ ta kolejność jest różna.  
  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy bazowej są zwracane przez `Get` metody podczas odzwierciedlania typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.EventInfo> zwraca obiekty z parametrami typu zamienionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje zdarzenia z ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład uzyskuje tablicę <xref:System.Reflection.EventInfo> obiektów, pobiera wszystkie zdarzenia `Button` dla klasy i wyświetla nazwy zdarzeń. Aby skompilować przykład Visual Basic, użyj następującego wiersza polecenia:  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.

—lub—

 <see cref="F:System.Reflection.BindingFlags.Default" />Aby zwrócić pustą tablicę.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, wyszukuje zdarzenia, które są zadeklarowane lub dziedziczone <see cref="T:System.Type" />przez bieżące, przy użyciu określonych ograniczeń powiązania.</summary>
        <returns>Tablica <see cref="T:System.Reflection.EventInfo" /> obiektów reprezentująca wszystkie zdarzenia zadeklarowane lub dziedziczone przez bieżące <see cref="T:System.Type" /> , które pasują do określonych ograniczeń powiązania.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.EventInfo" />, jeśli bieżąca <see cref="T:System.Type" /> nie ma zdarzeń lub jeśli żadne z tych zdarzeń nie pasuje do ograniczeń powiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetEvents%2A> Metoda nie zwraca zdarzeń w określonej kolejności, takich jak kolejność alfabetyczna lub Deklaracja. Kod nie może zależeć od kolejności, w której są zwracane zdarzenia, ponieważ ta kolejność jest różna.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania zdarzeń do uwzględnienia w wyszukiwaniu:  
  
-   Musisz określić albo `BindingFlags.Instance` `BindingFlags.Static` , aby uzyskać zwracaną wartość.  
  
-   Określ `BindingFlags.Public` , aby uwzględnić w wyszukiwaniu zdarzenia publiczne.  
  
-   Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu zdarzenia niepubliczne (czyli prywatne, wewnętrzne i chronione). Zwracane są tylko zdarzenia chronione i wewnętrzne w klasach bazowych; zdarzenia prywatne w klasach bazowych nie są zwracane.  
  
-   Określ `BindingFlags.FlattenHierarchy` , aby `public` uwzględnić `protected` i statyczne składowe w hierarchii; `private` statyczne składowe w klasach dziedziczonych nie są uwzględniane.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi modyfikatorów mogą służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.DeclaredOnly`Aby wyszukać tylko zdarzenia zadeklarowane <xref:System.Type>w, a nie zdarzenia, które były po prostu dziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Zdarzenie jest uważane za publiczne odbicie, jeżeli ma co najmniej jedną metodę lub metodę dostępu, która jest publiczna. W przeciwnym razie zdarzenie jest uznawane za prywatne i musisz <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> użyć &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w Visual Basic, połączyć wartości przy `Or`użyciu), aby je pobrać.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.EventInfo> zwraca obiekty z parametrami typu zamienionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje zdarzenia z ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład uzyskuje tablicę <xref:System.Reflection.EventInfo> obiektów, które pasują do określonych flag powiązań, pobiera wszystkie zdarzenia `Button` dla klasy i wyświetla nazwy zdarzeń. Aby skompilować przykład Visual Basic, użyj następującego wiersza polecenia:  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określone pole bieżącego <see cref="T:System.Type" />elementu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę pola danych do pobrania.</param>
        <summary>Wyszukuje pole publiczne o podanej nazwie.</summary>
        <returns>Obiekt reprezentujący pole publiczne o podanej nazwie, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wyszukiwaniu `name` jest rozróżniana wielkość liter. Wyszukiwanie obejmuje pola publiczne i publiczne wystąpienia.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.FieldInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje pola ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład pobiera `Type` obiekt dla określonej klasy, uzyskuje <xref:System.Reflection.FieldInfo> obiekt dla pola i wyświetla wartość pola.  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Ten <see cref="T:System.Type" /> obiekt jest, <see cref="T:System.Reflection.Emit.TypeBuilder" /> którego <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> Metoda nie została jeszcze wywołana.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę pola danych do pobrania.</param>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.  
  
—lub— 
 <see cref="System.Reflection.BindingFlags.Default" />do zwrócenia <see langword="null" />.</param>
        <summary>Wyszukuje określone pole przy użyciu określonych ograniczeń powiązania.</summary>
        <returns>Obiekt reprezentujący pole, które jest zgodne z określonymi wymaganiami, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy bazowej są zwracane przez `Get` metody podczas odzwierciedlania typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania pól do uwzględnienia w wyszukiwaniu:  
  
-   Musisz określić albo `BindingFlags.Instance` `BindingFlags.Static` , aby uzyskać zwracaną wartość.  
  
-   Określ `BindingFlags.Public` , aby uwzględnić w wyszukiwaniu pola publiczne.  
  
-   Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu pola niepubliczne (czyli prywatne, wewnętrzne i chronione).  
  
-   Określ `BindingFlags.FlattenHierarchy` , aby `public` uwzględnić `protected` i statyczne składowe w hierarchii; `private` statyczne składowe w klasach dziedziczonych nie są uwzględniane.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi modyfikatorów mogą służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase`ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly`Aby przeszukać tylko pola zadeklarowane <xref:System.Type>w, a nie pola, które były po prostu dziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.FieldInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje pola ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład pobiera `Type` obiekt dla określonej klasy, uzyskuje <xref:System.Reflection.FieldInfo> obiekt dla pola, które pasuje do określonych flag powiązań i wyświetla wartość pola.  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera pola bieżącego <see cref="T:System.Type" />elementu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie pola publiczne bieżącego <see cref="T:System.Type" />elementu.</summary>
        <returns>Tablica <see cref="T:System.Reflection.FieldInfo" /> obiektów reprezentująca wszystkie pola publiczne zdefiniowane dla bieżącego <see cref="T:System.Type" />.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.FieldInfo" />, jeśli dla bieżącego <see cref="T:System.Type" />elementu nie są zdefiniowane żadne pola publiczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A> Metoda nie zwraca pól w określonej kolejności, takich jak kolejność alfabetyczna lub Deklaracja. Kod nie może zależeć od kolejności, w której są zwracane pola, ponieważ ta kolejność jest różna.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy bazowej są zwracane przez `Get` metody podczas odzwierciedlania typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.FieldInfo> zwraca obiekty z parametrami typu zamienionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje pola publiczne ograniczenia klasy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie `GetFields()` metody.  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.

—lub—

 <see cref="F:System.Reflection.BindingFlags.Default" />Aby zwrócić pustą tablicę.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, wyszukuje pola zdefiniowane dla bieżącego <see cref="T:System.Type" />przy użyciu określonych ograniczeń powiązania.</summary>
        <returns>Tablica <see cref="T:System.Reflection.FieldInfo" /> obiektów reprezentująca wszystkie pola, które są zdefiniowane dla <see cref="T:System.Type" /> bieżącego, które pasują do określonych ograniczeń powiązania.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.FieldInfo" />, jeśli żadne pola nie są zdefiniowane dla bieżącego <see cref="T:System.Type" />lub jeśli żadne ze zdefiniowanych pól nie pasuje do ograniczeń powiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `bindingAttr` <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>Aby Przeciążenie powiodło się pobranie informacji o właściwościach, argument musi zawierać co najmniej jeden z i, wraz z co najmniej jedną z i. `GetFields(BindingFlags)` 

Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania pól do uwzględnienia w wyszukiwaniu:  
  
- Określ `BindingFlags.Instance` , aby uwzględnić metody wystąpienia. 

- Określ `BindingFlags.Static` , aby uwzględnić metody statyczne. 
    
- Określ `BindingFlags.Public` , aby uwzględnić w wyszukiwaniu pola publiczne.  
  
- Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu pola niepubliczne (czyli prywatne, wewnętrzne i chronione). Zwracane są tylko pola chronione i wewnętrzne w klasach bazowych; pola prywatne w klasach bazowych nie są zwracane.  
  
- Określ `BindingFlags.FlattenHierarchy` , aby `public` uwzględnić `protected` i statyczne składowe w hierarchii; `private` statyczne składowe w klasach dziedziczonych nie są uwzględniane.  

- Określ `BindingFlags.Default` same, aby zwrócić pustą <xref:System.Reflection.PropertyInfo> tablicę.

Poniższe <xref:System.Reflection.BindingFlags> flagi modyfikatorów mogą służyć do zmiany sposobu działania wyszukiwania:  
  
- `BindingFlags.DeclaredOnly`Aby przeszukać tylko pola zadeklarowane <xref:System.Type>w, a nie pola, które były po prostu dziedziczone.  
  
Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
<xref:System.Type.GetFields%2A> Metoda nie zwraca pól w określonej kolejności, takich jak kolejność alfabetyczna lub Deklaracja. Kod nie może zależeć od kolejności, w której są zwracane pola, ponieważ ta kolejność jest różna.  

 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.FieldInfo> zwraca obiekty z parametrami typu zamienionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje pola publiczne ograniczenia klasy.  
  
## Examples  
 W poniższym przykładzie pokazano użycie `GetFields(BindingFlags)` metody.  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę <see cref="T:System.Type" /> obiektów reprezentujących argumenty typu zamkniętego typu ogólnego lub parametry typu definicji typu ogólnego.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiektów, która reprezentuje argumenty typu typu ogólnego. Zwraca pustą tablicę, jeśli bieżący typ nie jest typem ogólnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy tablicy są zwracane w kolejności, w jakiej występują na liście argumentów typu dla typu ogólnego.  
  
-   Jeśli bieżący typ jest zamkniętym skonstruowanym typem (oznacza to, <xref:System.Type.ContainsGenericParameters%2A> że właściwość zwraca `false`), tablica zwracana przez <xref:System.Type.GetGenericArguments%2A> metodę zawiera typy, które zostały przypisane do parametrów typu ogólnego definicji typu ogólnego. .  
  
-   Jeśli bieżący typ jest definicją typu ogólnego, tablica zawiera parametry typu.  
  
-   Jeśli bieżący typ jest otwartym typem skonstruowanym (oznacza to, <xref:System.Type.ContainsGenericParameters%2A> że właściwość zwraca `true`), w którym określone typy nie zostały przypisane do wszystkich parametrów typu i parametrów typu otaczających typy ogólne lub metody, tablica zawiera Oba typy i parametry typu. Użyj właściwości <xref:System.Type.IsGenericParameter%2A> , aby odróżnić je od siebie. Aby zapoznać się z prezentacją tego scenariusza, zobacz przykład kodu dla <xref:System.Type.ContainsGenericParameters%2A> właściwości.  
  
 Aby zapoznać się z listą warunków niewariantów dla terminów używanych w odbiciu ogólnym <xref:System.Type.IsGenericType%2A> , zobacz uwagi dotyczące właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Type.GetGenericArguments%2A> metody do wyświetlania argumentów typu konstruowanego typu i parametrów typu jego definicji typu ogólnego.  
  
 Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Type.IsGenericTypeDefinition%2A> właściwości. Zobacz większy przykład dla przykładowych danych wyjściowych.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej. Klasy pochodne muszą dostarczać implementację.</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę <see cref="T:System.Type" /> obiektów, która reprezentuje ograniczenia dotyczące bieżącego parametru typu ogólnego.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiektów, która reprezentuje ograniczenia dotyczące bieżącego parametru typu ogólnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każde ograniczenie dla parametru typu ogólnego jest wyrażone jako <xref:System.Type> obiekt. Użyj właściwości, aby określić, czy ograniczenie jest ograniczeniem klasy bazowej; Jeśli zwraca `false`właściwość, ograniczenie jest ograniczeniem do interfejsu. <xref:System.Type.IsClass%2A> Jeśli parametr typu nie ma ograniczenia klasy i nie ma ograniczeń interfejsu, zwracana jest pusta tablica.  
  
 Aby zapoznać się z listą warunków niewariantów dla terminów używanych w odbiciu ogólnym <xref:System.Type.IsGenericType%2A> , zobacz uwagi dotyczące właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu definiuje typ `Test` ogólny z dwoma parametrami typu, które mają różne ograniczenia. Gdy program jest wykonywany, ograniczenia są badane przy użyciu <xref:System.Type.GenericParameterAttributes%2A> właściwości <xref:System.Type.GetGenericParameterConstraints%2A> i metody.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący <see cref="T:System.Type" /> obiekt nie jest parametrem typu ogólnego. Oznacza to, <see cref="P:System.Type.IsGenericParameter" /> że właściwość zwraca <see langword="false" />.</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Type" /> Zwraca obiekt, który reprezentuje definicję typu ogólnego, z którego można utworzyć bieżący typ ogólny.</summary>
        <returns><see cref="T:System.Type" /> Obiekt reprezentujący typ ogólny, z którego można utworzyć bieżący typ.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definicja typu ogólnego to szablon, na podstawie którego można utworzyć inne typy. Na przykład, z definicji `G<T>` typu ogólnego (wyrażona w C# składni; `G<int>` `G(Of Integer)` w Visual Basic lub `generic <typename T> ref class G` in C++) można skonstruować i utworzyć wystąpienie typu (w Visual Basic). `G(Of T)` Obiekt reprezentujący ten skonstruowany typ <xref:System.Type.GetGenericTypeDefinition%2A> Metoda zwraca definicję typu ogólnego. <xref:System.Type>  
  
 Jeśli dwa skonstruowane typy są tworzone na podstawie tej samej definicji typu ogólnego, przy użyciu tych samych argumentów <xref:System.Type.GetGenericTypeDefinition%2A> typu metoda zwraca ten sam <xref:System.Type> obiekt dla obu typów.  
  
 Jeśli wywołasz <xref:System.Type.GetGenericTypeDefinition%2A> metodę <xref:System.Type> dla obiektu, który już reprezentuje definicję typu ogólnego, zwraca bieżącą <xref:System.Type>.  
  
> [!IMPORTANT]
>  Tablica typów ogólnych nie jest sama ogólna. W C# kodzie `A<int>[] v;` lub kodzie `Dim v() As A(Of Integer)`Visual Basic typ zmiennej `v` nie jest ogólny. Użyj <xref:System.Type.IsGenericType%2A> , aby określić, czy typ ma być ogólny <xref:System.Type.GetGenericTypeDefinition%2A>przed wywołaniem.  
  
 Aby zapoznać się z listą warunków niewariantów dla terminów używanych w odbiciu ogólnym <xref:System.Type.IsGenericType%2A> , zobacz uwagi dotyczące właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy wystąpienie konstruowanego typu za pomocą zwykłego tworzenia wystąpienia, a następnie używa <xref:System.Type.GetType%2A> metody i <xref:System.Type.GetGenericTypeDefinition%2A> do pobrania typu konstruowanego i definicji typu ogólnego. W tym przykładzie używa typu <xref:System.Collections.Generic.Dictionary%602> ogólnego; skonstruowany typ <xref:System.Collections.Generic.Dictionary%602> reprezentuje `Test` obiekt z kluczami ciągu.  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący typ nie jest typem ogólnym.  Oznacza to, <see cref="P:System.Type.IsGenericType" /> że <see langword="false" />zwraca.</exception>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej. Klasy pochodne muszą dostarczać implementację.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego wystąpienia.</summary>
        <returns>Kod skrótu dla tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład wyświetla kod `System.Windows.Forms.Button` skrótu klasy.  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określony interfejs zaimplementowany lub dziedziczony przez bieżące <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę interfejsu, który ma zostać pobrany. W przypadku interfejsów ogólnych jest to nazwa zniekształcona.</param>
        <summary>Wyszukuje interfejs o określonej nazwie.</summary>
        <returns>Obiekt reprezentujący interfejs o określonej nazwie, zaimplementowany lub dziedziczony przez bieżące <see cref="T:System.Type" />, jeśli został znaleziony; <see langword="null" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wyszukiwaniu `name` jest rozróżniana wielkość liter.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Type> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje ograniczenia interfejsu i wszystkie interfejsy dziedziczone z ograniczeń klasy lub interfejsu.  
  
> [!NOTE]
>  Dla interfejsów `name` ogólnych parametr jest nazwą zniekształcona, kończąc z akcentem słabym (\`) i liczbą parametrów typu. Dotyczy to zarówno ogólnych definicji interfejsu, jak i konstruowanych interfejsów ogólnych. Na przykład aby znaleźć `IExample<T>` (`IExample(Of T)` w Visual Basic) lub `IExample<string>` (`IExample(Of String)` w Visual Basic), wyszukaj ciąg ``"IExample`1"``.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Type.GetInterface%28System.String%29> metody do <xref:System.Collections.Hashtable> przeszukiwania klasy <xref:System.Runtime.Serialization.IDeserializationCallback> interfejsu i wyświetla listę metod interfejsu.  
  
 Przykład kodu demonstruje <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> również Przeciążenie metody <xref:System.Type.GetInterfaceMap%2A> i metodę.  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Bieżący <see cref="T:System.Type" /> reprezentuje typ, który implementuje ten sam interfejs generyczny z różnymi argumentami typu.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę interfejsu, który ma zostać pobrany. W przypadku interfejsów ogólnych jest to nazwa zniekształcona.</param>
        <param name="ignoreCase"><see langword="true" />Aby zignorować wielkość liter tej części <paramref name="name" /> , która określa prostą nazwę interfejsu (część określającą przestrzeń nazw musi być poprawnie uwzględniana).  
  
—lub— 
 <see langword="false" />Aby wykonać wyszukiwanie z uwzględnieniem wielkości liter dla wszystkich części <paramref name="name" />programu.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, wyszukuje określony interfejs, określając, czy należy wykonać wyszukiwanie z uwzględnieniem wielkości liter dla nazwy interfejsu.</summary>
        <returns>Obiekt reprezentujący interfejs o określonej nazwie, zaimplementowany lub dziedziczony przez bieżące <see cref="T:System.Type" />, jeśli został znaleziony; <see langword="null" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ignoreCase` Parametr dotyczy tylko prostej nazwy interfejsu, a nie do przestrzeni nazw. Część `name` określająca przestrzeń nazw musi mieć poprawną wielkość, lub interfejs nie zostanie znaleziony. Na przykład ciąg "System. IComparable" odnajduje <xref:System.IComparable> interfejs, ale ciąg "System. IComparable" nie.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Type> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje ograniczenia interfejsu i wszystkie interfejsy dziedziczone z ograniczeń klasy lub interfejsu.  
  
> [!NOTE]
>  Dla interfejsów `name` ogólnych parametr jest nazwą zniekształcona, kończąc z akcentem słabym (\`) i liczbą parametrów typu. Dotyczy to zarówno ogólnych definicji interfejsu, jak i konstruowanych interfejsów ogólnych. Na przykład aby znaleźć `IExample<T>` (`IExample(Of T)` w Visual Basic) lub `IExample<string>` (`IExample(Of String)` w Visual Basic), Wyszukaj `"IExample`1 "".  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> metody do wykonywania wyszukiwania <xref:System.Collections.Hashtable> bez uwzględniania wielkości liter klasy dla <xref:System.Collections.IEnumerable> interfejsu.  
  
 Przykład kodu demonstruje <xref:System.Type.GetInterface%28System.String%29> również Przeciążenie metody <xref:System.Type.GetInterfaceMap%2A> i metodę.  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Bieżący <see cref="T:System.Type" /> reprezentuje typ, który implementuje ten sam interfejs generyczny z różnymi argumentami typu.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="interfaceType">Typ interfejsu, dla którego ma zostać pobrane mapowanie.</param>
        <summary>Zwraca mapowanie interfejsu dla określonego typu interfejsu.</summary>
        <returns>Obiekt, który reprezentuje mapowanie interfejsu dla <paramref name="interfaceType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mapa interfejsu wskazuje, jak interfejs jest mapowany na rzeczywiste elementy członkowskie klasy, która implementuje ten interfejs.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, parametry typu są zastępowane odpowiednimi argumentami typu w elementach <xref:System.Reflection.InterfaceMapping> zwracanych przez tę metodę.  
  
   
  
## Examples  
 Poniższy przykład <xref:System.Type.GetInterfaceMap%2A> wywołuje metodę, aby określić, <xref:System.IAppDomainSetup> <xref:System.IFormatProvider> jak interfejs mapuje na <xref:System.Globalization.CultureInfo> metody i jak interfejs mapuje na <xref:System.AppDomainSetup> właściwości. Należy zauważyć, że ponieważ <xref:System.IAppDomainSetup> interfejs definiuje zestaw właściwości, zwracany <xref:System.Reflection.InterfaceMapping> obiekt zawiera oddzielne <xref:System.Reflection.MethodInfo> obiekty dla metod dostępu get i set właściwości.  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="interfaceType" />nie jest zaimplementowany przez bieżący typ.  
  
—lub— 
<paramref name="interfaceType" /> Argument nie odwołuje się do interfejsu.  
  
—lub—

Bieżące wystąpienie lub <paramref name="interfaceType" /> argument jest otwartym typem ogólnym; oznacza to <see cref="P:System.Type.ContainsGenericParameters" /> , że właściwość zwraca <see langword="true" />.

—lub—


 <paramref name="interfaceType" />jest interfejsem ogólnym, a bieżący typ jest typem tablicy.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="interfaceType" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżący <see cref="T:System.Type" /> reprezentuje parametr typu ogólnego <see langword="true" />, <see cref="P:System.Type.IsGenericParameter" /> czyli.</exception>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej. Klasy pochodne muszą dostarczać implementację.</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera wszystkie interfejsy zaimplementowane lub dziedziczone przez bieżące <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiektów reprezentująca wszystkie interfejsy zaimplementowane lub dziedziczone przez bieżące <see cref="T:System.Type" />.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" />, jeśli żadne interfejsy nie są implementowane lub dziedziczone przez bieżące <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetInterfaces%2A> Metoda nie zwraca interfejsów w określonej kolejności, takich jak kolejność alfabetyczna lub Deklaracja. Kod nie może zależeć od kolejności, w jakiej są zwracane interfejsy, ponieważ ta kolejność jest różna.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Type> zwraca obiekty z parametrami typu zamienionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje ograniczenia interfejsu i wszystkie interfejsy dziedziczone z ograniczeń klasy lub interfejsu.  
  
   
  
## Examples  
 Poniższy przykład pobiera typ określonej klasy i wyświetla wszystkie interfejsy, które typ implementuje lub dziedziczy. Aby skompilować przykład Visual Basic, użyj następujących poleceń kompilatora:  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator statyczny jest wywoływany i zgłasza wyjątek.</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określonych członków bieżącego <see cref="T:System.Type" />elementu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę publicznych elementów członkowskich do pobrania.</param>
        <summary>Wyszukuje publiczne elementy członkowskie o podanej nazwie.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiektów reprezentujących publiczną składową o określonej nazwie, jeśli została znaleziona; w przeciwnym razie pusta tablica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wyszukiwaniu `name` jest rozróżniana wielkość liter. Wyszukiwanie zawiera publiczne, statyczne i publiczne składowe wystąpienia.  
  
 Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.  
  
 <xref:System.Type.GetMember%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takich jak kolejność alfabetyczna lub Deklaracja. Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.  
  
 To Przeciążenie metody nie odnajdzie inicjatorów klasy (Konstruktor statyczny). Aby znaleźć inicjatory klasy, Użyj przeciążenia, które przyjmuje <xref:System.Reflection.BindingFlags>, i określ <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w Visual Basic). Można również uzyskać inicjator klasy przy użyciu <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy bazowej są zwracane przez `Get` metody podczas odzwierciedlania typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.MemberInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje elementy członkowskie ograniczenia klasy lub <xref:System.Object> składowych w przypadku braku ograniczenia klasy.  
  
> [!NOTE]
>  W przypadku metod ogólnych nie należy uwzględniać argumentów typu w `name`. C# Na przykład kod `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekstowej "`MyMethod<int>`", a nie dla metody o nazwie `MyMethod` , która ma jeden argument rodzajowy typu `int`.  
  
   
  
## Examples  
 Poniższy przykład wyświetla wszystkie elementy członkowskie `String` klasy, które zaczynają się od litery C.  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę członków do pobrania.</param>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.  
  
—lub— 
 <see cref="System.Reflection.BindingFlags.Default" />Aby zwrócić pustą tablicę.</param>
        <summary>Wyszukuje określone elementy członkowskie przy użyciu określonych ograniczeń powiązania.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiektów reprezentujących publiczną składową o określonej nazwie, jeśli została znaleziona; w przeciwnym razie pusta tablica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
 Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.  
  
 <xref:System.Type.GetMember%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takich jak kolejność alfabetyczna lub Deklaracja. Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania, które elementy członkowskie mają być uwzględnione w wyszukiwaniu:  
  
-   Musisz określić albo `BindingFlags.Instance` `BindingFlags.Static` , aby uzyskać zwracaną wartość.  
  
-   Określ `BindingFlags.Public` , aby uwzględnić publiczne składowe w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu niepubliczne składowe (czyli prywatne, wewnętrzne i chronione).  
  
-   Określ `BindingFlags.FlattenHierarchy` , aby `public` uwzględnić `protected` i statyczne składowe w hierarchii; `private` statyczne składowe w klasach dziedziczonych nie są uwzględniane.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi modyfikatorów mogą służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase`ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly`Aby przeszukać tylko członków zadeklarowanych <xref:System.Type>w, a nie na elementach, które były po prostu dziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Aby uzyskać inicjatora klasy (Konstruktor statyczny) przy użyciu tego przeciążenia metody, należy określić "Konstruktor statyczny `name`" dla <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> i<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w Visual Basic) dla `bindingAttr`. Można również uzyskać inicjator klasy przy użyciu <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.MemberInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje elementy członkowskie ograniczenia klasy lub <xref:System.Object> składowych w przypadku braku ograniczenia klasy.  
  
> [!NOTE]
>  W przypadku metod ogólnych nie należy uwzględniać argumentów typu w `name`. C# Na przykład kod `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekstowej "`MyMethod<int>`", a nie dla metody o nazwie `MyMethod` , która ma jeden argument rodzajowy typu `int`.  
  
   
  
## Examples  
 Poniższy przykład wyświetla wszystkie publiczne statyczne elementy członkowskie `myString` klasy, która rozpoczyna się od litery C.  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę członków do pobrania.</param>
        <param name="type">Wartość do wyszukania.</param>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.  
  
—lub— 
 <see cref="System.Reflection.BindingFlags.Default" />Aby zwrócić pustą tablicę.</param>
        <summary>Wyszukuje określony element członkowski określonego typu elementu członkowskiego przy użyciu określonych ograniczeń powiązania.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiektów reprezentujących publiczną składową o określonej nazwie, jeśli została znaleziona; w przeciwnym razie pusta tablica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy członkowskie zawierają właściwości, metody, pola, zdarzenia i tak dalej.  
  
 <xref:System.Type.GetMember%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takich jak kolejność alfabetyczna lub Deklaracja. Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania, które elementy członkowskie mają być uwzględnione w wyszukiwaniu:  
  
-   Musisz określić albo `BindingFlags.Instance` `BindingFlags.Static` , aby uzyskać zwracaną wartość.  
  
-   Określ `BindingFlags.Public` , aby uwzględnić publiczne składowe w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu niepubliczne składowe (czyli prywatne, wewnętrzne i chronione).  
  
-   Określ `BindingFlags.FlattenHierarchy` , aby `public` uwzględnić `protected` i statyczne składowe w hierarchii; `private` statyczne składowe w klasach dziedziczonych nie są uwzględniane.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi modyfikatorów mogą służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase`ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly`Aby przeszukać tylko członków zadeklarowanych <xref:System.Type>w, a nie na elementach, które były po prostu dziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Aby uzyskać inicjatora klasy (Konstruktor statyczny) przy użyciu tego przeciążenia metody, należy określić "Konstruktor statyczny `name`" <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> dla `type`, dla <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> i<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or`w Visual Basic) dla `bindingAttr`. <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Można również uzyskać inicjator klasy przy użyciu <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.MemberInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje elementy członkowskie ograniczenia klasy lub <xref:System.Object> składowych w przypadku braku ograniczenia klasy.  
  
> [!NOTE]
>  W przypadku metod ogólnych nie należy uwzględniać argumentów typu w `name`. C# Na przykład kod `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekstowej "`MyMethod<int>`", a nie dla metody o nazwie `MyMethod` , która ma jeden argument rodzajowy typu `int`.  
  
   
  
## Examples  
 Poniższy przykład wyświetla wszystkie metody `myString` klasy, która rozpoczyna się od litery C.  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Klasa pochodna musi zapewniać implementację.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera elementy członkowskie (właściwości, metody, pola, zdarzenia itd.) bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie publiczne elementy członkowskie bieżącego <see cref="T:System.Type" />elementu.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiektów reprezentująca wszystkie publiczne elementy członkowskie bieżącego <see cref="T:System.Type" />elementu.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.MemberInfo" />, jeśli bieżąca <see cref="T:System.Type" /> nie ma publicznych składowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Elementy członkowskie obejmują właściwości, metody, konstruktory, pola, zdarzenia i typy zagnieżdżone.
  
 <xref:System.Type.GetMembers%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takich jak kolejność alfabetyczna lub Deklaracja. Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.  
  
 To Przeciążenie metody <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> wywołuje Przeciążenie metody z <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (`Or` wVisualBasic).<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> Nie znajdzie inicjatorów klas (konstruktorów statycznych). Aby znaleźć inicjatory klasy, wywołaj <xref:System.Type.GetMembers(System.Reflection.BindingFlags)> Przeciążenie i określ &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w Visual Basic). Można również uzyskać inicjator klasy przy użyciu <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy bazowej są zwracane przez `Get` metody podczas odzwierciedlania typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.MemberInfo> zwraca obiekty z parametrami typu zamienionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje elementy członkowskie ograniczenia klasy lub <xref:System.Object> składowych w przypadku braku ograniczenia klasy. 
  
## Examples  
 Poniższy przykład kodu demonstruje, <xref:System.Type.GetMembers> jak używać przeciążenia metody do zbierania informacji o wszystkich publicznych elementach członkowskich określonej klasy.  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.  
  
—lub— 
 <see cref="F:System.Reflection.BindingFlags.Default" />Aby zwrócić pustą tablicę.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, wyszukuje elementy członkowskie zdefiniowane dla bieżącego <see cref="T:System.Type" />przy użyciu określonych ograniczeń powiązania.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MemberInfo" /> obiektów reprezentująca wszystkie elementy członkowskie zdefiniowane dla bieżącego <see cref="T:System.Type" /> , które pasują do określonych ograniczeń powiązania.  
  
—lub— 
Pusta tablica, jeśli żaden element członkowski nie jest zdefiniowany dla <see cref="T:System.Type" />bieżącego lub jeśli żaden z zdefiniowanych elementów członkowskich nie jest zgodny z ograniczeniami powiązań.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Elementy członkowskie obejmują właściwości, metody, konstruktory, pola, zdarzenia i typy zagnieżdżone.

<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `bindingAttr` <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>Aby Przeciążenie powiodło się pobranie informacji o metodzie, argument musi zawierać co najmniej jeden z i, wraz z co najmniej jedną z i. `GetMethods(BindingFlags)` Jedynym wyjątkiem jest wywołanie metody z <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, która zwraca informacje o elemencie członkowskim dotyczącym zagnieżdżonych typów.

Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania, które elementy członkowskie mają być uwzględnione w wyszukiwaniu: 

- Określ `BindingFlags.Instance` , aby uwzględnić metody wystąpienia. 

- Określ `BindingFlags.Static` , aby uwzględnić metody statyczne. 
  
- Określ `BindingFlags.Public` , aby uwzględnić w wyszukiwaniu metody publiczne.  
  
- Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu metody niepubliczne (czyli prywatne, wewnętrzne i chronione). Zwracane są tylko metody chronione i wewnętrzne w klasach bazowych; Metody prywatne w klasach bazowych nie są zwracane.  
  
- Określ `BindingFlags.FlattenHierarchy` , aby `public` uwzględnić `protected` i statyczne składowe w hierarchii; `private` statyczne składowe w klasach dziedziczonych nie są uwzględniane.  

- Określ `BindingFlags.Default` same, aby zwrócić pustą <xref:System.Reflection.MethodInfo> tablicę.

Poniższe <xref:System.Reflection.BindingFlags> flagi modyfikatorów mogą służyć do zmiany sposobu działania wyszukiwania:  
  
- `BindingFlags.DeclaredOnly`Aby przeszukać tylko członków zadeklarowanych <xref:System.Type>w, a nie na elementach, które były po prostu dziedziczone.  
  
Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  

<xref:System.Type.GetMembers%2A> Metoda nie zwraca elementów członkowskich w określonej kolejności, takich jak kolejność alfabetyczna lub Deklaracja. Kod nie może zależeć od kolejności, w której są zwracane elementy członkowskie, ponieważ kolejność się zmienia.  

 Aby uzyskać inicjatora klasy (Konstruktor statyczny) przy użyciu tego przeciążenia metody, należy <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> określić<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> w Visual Basic). Można również uzyskać inicjator klasy przy użyciu <xref:System.Type.TypeInitializer%2A> właściwości.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.MemberInfo> zwraca obiekty z parametrami typu zamienionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje elementy członkowskie ograniczenia klasy lub <xref:System.Object> składowych w przypadku braku ograniczenia klasy.  

## Examples  
 Poniższy przykład kodu demonstruje, <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> jak używać przeciążenia metody do zbierania informacji o wszystkich elementach publicznych wystąpień określonej klasy.  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określoną metodę bieżącej <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę metody publicznej do pobrania.</param>
        <summary>Wyszukuje metodę publiczną o podanej nazwie.</summary>
        <returns>Obiekt, który reprezentuje metodę publiczną o podanej nazwie, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wyszukiwaniu `name` jest rozróżniana wielkość liter. Wyszukiwanie obejmuje publiczne i publiczne metody wystąpień.  
  
 Jeśli metoda jest przeciążona i ma więcej niż jedną metodę publiczną, <xref:System.Type.GetMethod%28System.String%29> Metoda <xref:System.Reflection.AmbiguousMatchException> zgłasza wyjątek. W poniższym przykładzie jest zgłaszany wyjątek, ponieważ istnieje więcej niż jedno publiczne Przeciążenie <xref:System.Int32.ToString%2A?displayProperty=nameWithType> metody.  Z drugiej strony, ponieważ metoda przesłania `Person.ToString` <xref:System.Object.ToString%2A?displayProperty=nameWithType> i w związku z tym nie <xref:System.Type.GetMethod%28System.String%29> jest przeciążona, metoda jest w stanie pobrać <xref:System.Reflection.MethodInfo> obiekt.  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 Aby pobrać konkretną metodę, można wykonać jedną z następujących czynności:  
  
-   Wywołaj `bindingAttr` metodę i określ argument, który jednoznacznie identyfikuje metodę. <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> Na przykład jeśli wyjątek `bindingAttr` jest zgłaszany, ponieważ typ ma element statyczny i Przeciążenie wystąpienia, można określić <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>argument.  
  
-   Wywołaj Przeciążenie <xref:System.Type.GetMethod%2A> metody, która `types` zawiera parametr, który definiuje typy parametrów metody.  
  
-   Wywołaj <xref:System.Type.GetMethods> metodę, aby pobrać tablicę zawierającą wszystkie metody publiczne należące do typu. Następnie można wykonać iterację, aby zidentyfikować zduplikowane metody `name`o nazwie.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.MethodInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje metody ograniczenia klasy lub <xref:System.Object> metody w przypadku braku ograniczenia klasy.  
  
> [!NOTE]
>  W przypadku metod ogólnych nie należy uwzględniać argumentów typu w `name`. C# Na przykład kod `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekstowej "`MyMethod<int>`", a nie dla metody o nazwie `MyMethod` , która ma jeden argument rodzajowy typu `int`.  
  
   
  
## Examples  
 Poniższy przykład pobiera metodę o nazwie `MethodA`.  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną metodę o określonej nazwie.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę metody pobierania.</param>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.  
  
—lub— 
 <see cref="System.Reflection.BindingFlags.Default" />do zwrócenia <see langword="null" />.</param>
        <summary>Wyszukuje określoną metodę przy użyciu określonych ograniczeń powiązania.</summary>
        <returns>Obiekt reprezentujący metodę, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania, które metody mają być uwzględnione w wyszukiwaniu:  
  
-   Musisz określić albo <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> , aby uzyskać zwracaną wartość.  
  
-   Określ <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> , aby uwzględnić w wyszukiwaniu metody publiczne.  
  
-   Określ <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> , aby uwzględnić w wyszukiwaniu metody niepubliczne (czyli prywatne, wewnętrzne i chronione).  
  
-   Określ <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> , aby `public` uwzględnić `protected` i statyczne składowe w hierarchii; `private` statyczne składowe w klasach dziedziczonych nie są uwzględniane.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi modyfikatorów mogą służyć do zmiany sposobu działania wyszukiwania:  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType>ignorowanie wielkości liter `name`.  
  
-   <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>Aby przeszukać tylko metody zadeklarowane <xref:System.Type>w, a nie metody, które były po prostu dziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Jeśli metoda jest przeciążona i więcej niż jedno Przeciążenie spełnia ograniczenia określone przez `bindingAttr` argument, Metoda <xref:System.Reflection.AmbiguousMatchException> zgłasza wyjątek. W poniższym przykładzie jest zgłaszany wyjątek, ponieważ:  
  
-   Typ ma dwa przeciążenia `DisplayValue` wystąpienia publicznego metody `DisplayValue(String)` i `DisplayValue(String, Object[])`. `TestClass`  
  
-   <xref:System.Object> `Equals` `Equals(Object)` `Equals(TestClass)` Typ ma dwa przeciążenia wystąpieniem publicznym metody, z których jedna jest dziedziczona z: i. `TestClass`  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 Aby pobrać konkretną metodę, można wykonać jedną z następujących czynności:  
  
-   Zmień ograniczenia powiązania. W poprzednim przykładzie próba pobrania metody wystąpienia `Equals` publicznego zadeklarowanej przez typ i niedziedziczonego elementu nie zostanie pomyślnie pobrany. `Equals(TestClass)`  
  
-   Wywołaj Przeciążenie <xref:System.Type.GetMethod%2A> metody, która `types` zawiera parametr, który definiuje typy parametrów metody.  
  
-   Wywołaj <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> metodę, aby pobrać tablicę zawierającą wszystkie metody należące do typu, który ma określone atrybuty powiązania. Następnie można wykonać iterację, aby zidentyfikować zduplikowane metody `name`o nazwie. To podejście jest zilustrowane w powyższym przykładzie procedury obsługi <xref:System.Reflection.AmbiguousMatchException> wyjątku.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.MethodInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje metody ograniczenia klasy lub <xref:System.Object> metody w przypadku braku ograniczenia klasy.  
  
> [!NOTE]
>  W przypadku metod ogólnych nie należy uwzględniać argumentów typu w `name`. C# Na przykład kod `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekstowej "`MyMethod<int>`", a nie dla metody o nazwie `MyMethod` , która ma jeden argument rodzajowy typu `int`.  
  
   
  
## Examples  
 Poniższy przykład pobiera metodę, która pasuje do określonych flag powiązań.  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną metodę o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę metody publicznej do pobrania.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla metody do pobrania.  
  
—lub— 
Pusta tablica <see cref="T:System.Type" /> obiektów (podana <see cref="F:System.Type.EmptyTypes" /> przez pole) do uzyskania metody, która nie przyjmuje żadnych parametrów.</param>
        <summary>Wyszukuje określoną metodę publiczną, której parametry pasują do określonych typów argumentów.</summary>
        <returns>Obiekt reprezentujący metodę publiczną, której parametry pasują do określonych typów argumentów, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wyszukiwaniu `name` jest rozróżniana wielkość liter. Wyszukiwanie obejmuje publiczne i publiczne metody wystąpień.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.MethodInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje metody ograniczenia klasy lub <xref:System.Object> metody w przypadku braku ograniczenia klasy.  
  
> [!NOTE]
>  `name` Parametr nie może zawierać argumentów typu. C# Na przykład kod `GetMethod("MyGenericMethod<int>")` wyszukuje metodę o nazwie tekstowej "`MyGenericMethod<int>`", a nie dla metody o nazwie `MyGenericMethod` , która ma jeden argument rodzajowy typu `int`. Zamiast tego należy `GetMethod("MyGenericMethod")` użyć z odpowiednimi parametrami `types` w tablicy.  
  
   
  
## Examples  
 Poniższy przykład wyszukuje określone przeciążenia `MethodA`, określając różne typy argumentów.  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Przykład wymaga opcji kompilatora. `/unsafe`  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 <xref:System.Reflection.MethodInfo> Poniższy przykład pobiera obiekty, które <xref:System.Collections.ArrayList> `Add` reprezentują metody typu nieogólnego (Klasa <xref:System.Collections.Generic.List%601> ), otwarty typ ogólny (Klasa) i zamknięty typ ogólny ( `List(Of String)` typ.  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 W przykładzie zdefiniowano `GetAddMethod` metodę, która pobiera odpowiedni <xref:System.Reflection.MethodInfo> obiekt. Aby podać `types` argument dla otwartego typu ogólnego, <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> wywołuje metodę. Aby podać `types` argument zamkniętego typu ogólnego, pobiera wartość <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną metodę o określonej nazwie i określonych parametrach.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="types" />jest <see langword="null" />.  
  
—lub— 
Jeden z elementów w programie <paramref name="types" /> ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />jest wielowymiarowych.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę metody publicznej do pobrania.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla metody do pobrania.  
  
—lub— 
Pusta tablica <see cref="T:System.Type" /> obiektów (podana <see cref="F:System.Type.EmptyTypes" /> przez pole) do uzyskania metody, która nie przyjmuje żadnych parametrów.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentująca atrybuty skojarzone z odpowiednim elementem <paramref name="types" /> w tablicy. Do użycia tylko podczas wywoływania za pomocą międzyoperacyjności modelu COM i obsługiwane są tylko parametry, które są przesyłane przez odwołanie. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Wyszukuje określoną metodę publiczną, której parametry pasują do określonych typów argumentów i modyfikatorów.</summary>
        <returns>Obiekt reprezentujący metodę publiczną zgodną z określonymi wymaganiami, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chociaż <xref:System.Reflection.ParameterModifier> domyślny spinacz nie przetwarza `modifiers` (parametr), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> , aby napisać niestandardowy spinacz, który przetwarza `modifiers`. `ParameterModifier`jest używany tylko podczas wywoływania za pomocą międzyoperacyjności modelu COM i obsługiwane są tylko parametry, które są przesyłane przez odwołanie.  
  
 W wyszukiwaniu `name` jest rozróżniana wielkość liter. Wyszukiwanie obejmuje publiczne i publiczne metody wystąpień.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.MethodInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje metody ograniczenia klasy lub <xref:System.Object> metody w przypadku braku ograniczenia klasy.  
  
> [!NOTE]
>  W przypadku metod ogólnych nie należy uwzględniać argumentów typu w `name`. C# Na przykład kod `GetMethod("MyMethod<int>")` wyszukuje element członkowski o nazwie tekstowej "`MyMethod<int>`", a nie dla metody o nazwie `MyMethod` , która ma jeden argument rodzajowy typu `int`. Zamiast tego należy `GetMethod("MyMethod")` użyć z odpowiednimi parametrami `types` w tablicy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną metodę o określonej nazwie i określonych parametrach.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="types" />jest <see langword="null" />.  
  
—lub— 
Jeden z elementów w programie <paramref name="types" /> ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />jest wielowymiarowych.  
  
—lub— 
 <paramref name="modifiers" />jest wielowymiarowych.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę metody pobierania.</param>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.  
  
—lub— 
 <see cref="System.Reflection.BindingFlags.Default" />do zwrócenia <see langword="null" />.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
Odwołanie o wartości null<see langword="Nothing" /> (w Visual Basic), aby <see cref="P:System.Type.DefaultBinder" />użyć.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla metody do pobrania.  
  
—lub— 
Pusta tablica <see cref="T:System.Type" /> obiektów (podana <see cref="F:System.Type.EmptyTypes" /> przez pole) do uzyskania metody, która nie przyjmuje żadnych parametrów.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentująca atrybuty skojarzone z odpowiednim elementem <paramref name="types" /> w tablicy. Do użycia tylko podczas wywoływania za pomocą międzyoperacyjności modelu COM i obsługiwane są tylko parametry, które są przesyłane przez odwołanie. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Wyszukuje określoną metodę, której parametry pasują do określonych typów argumentów i modyfikatorów, przy użyciu określonych ograniczeń powiązania.</summary>
        <returns>Obiekt reprezentujący metodę, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chociaż <xref:System.Reflection.ParameterModifier> domyślny spinacz nie przetwarza `modifiers` (parametr), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> , aby napisać niestandardowy spinacz, który przetwarza `modifiers`. `ParameterModifier`jest używany tylko podczas wywoływania za pomocą międzyoperacyjności modelu COM i obsługiwane są tylko parametry, które są przesyłane przez odwołanie.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania, które metody mają być uwzględnione w wyszukiwaniu:  
  
-   Musisz określić albo `BindingFlags.Instance` `BindingFlags.Static` , aby uzyskać zwracaną wartość.  
  
-   Określ `BindingFlags.Public` , aby uwzględnić w wyszukiwaniu metody publiczne.  
  
-   Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu metody niepubliczne (czyli prywatne, wewnętrzne i chronione).  
  
-   Określ `BindingFlags.FlattenHierarchy` , aby `public` uwzględnić `protected` i statyczne składowe w hierarchii; `private` statyczne składowe w klasach dziedziczonych nie są uwzględniane.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi modyfikatorów mogą służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase`ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly`Aby przeszukać tylko metody zadeklarowane <xref:System.Type>w, a nie metody, które były po prostu dziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.MethodInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje metody ograniczenia klasy lub <xref:System.Object> metody w przypadku braku ograniczenia klasy.  
  
> [!NOTE]
>  W przypadku metod ogólnych nie należy uwzględniać argumentów typu w `name`. C# Na przykład kod `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekstowej "`MyMethod<int>`", a nie dla metody o nazwie `MyMethod` , która ma jeden argument rodzajowy typu `int`.  
  
   
  
## Examples  
 Poniższy przykład wyszukuje określone przeciążenia `MethodA`, określając ograniczenia powiązania i różne typy argumentów.  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Przykład wymaga opcji kompilatora. `/unsafe`  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną metodę o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="types" />jest <see langword="null" />.  
  
—lub— 
Jeden z elementów w programie <paramref name="types" /> ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />jest wielowymiarowych.  
  
—lub— 
 <paramref name="modifiers" />jest wielowymiarowych.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę metody pobierania.</param>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.  
  
—lub— 
 <see cref="System.Reflection.BindingFlags.Default" />do zwrócenia <see langword="null" />.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
Odwołanie o wartości null<see langword="Nothing" /> (w Visual Basic), aby <see cref="P:System.Type.DefaultBinder" />użyć.</param>
        <param name="callConvention">Obiekt, który określa zestaw reguł do użycia względem kolejności i układu argumentów, sposobu przekazywania wartości zwracanej, rejestrów używanych dla argumentów oraz sposobu czyszczenia stosu.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla metody do pobrania.  
  
—lub— 
Pusta tablica <see cref="T:System.Type" /> obiektów (podana <see cref="F:System.Type.EmptyTypes" /> przez pole) do uzyskania metody, która nie przyjmuje żadnych parametrów.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentująca atrybuty skojarzone z odpowiednim elementem <paramref name="types" /> w tablicy. Do użycia tylko podczas wywoływania za pomocą międzyoperacyjności modelu COM i obsługiwane są tylko parametry, które są przesyłane przez odwołanie. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Wyszukuje określoną metodę, której parametry pasują do określonych typów argumentów i modyfikatorów, przy użyciu określonych ograniczeń powiązania i określonej konwencji wywoływania.</summary>
        <returns>Obiekt reprezentujący metodę, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chociaż <xref:System.Reflection.ParameterModifier> domyślny spinacz nie przetwarza `modifiers` (parametr), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> , aby napisać niestandardowy spinacz, który przetwarza `modifiers`. `ParameterModifier`jest używany tylko podczas wywoływania za pomocą międzyoperacyjności modelu COM i obsługiwane są tylko parametry, które są przesyłane przez odwołanie.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy bazowej są zwracane przez `GetXXX` metody podczas odzwierciedlania typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania, które metody mają być uwzględnione w wyszukiwaniu:  
  
-   Musisz określić albo `BindingFlags.Instance` `BindingFlags.Static` , aby uzyskać zwracaną wartość.  
  
-   Określ `BindingFlags.Public` , aby uwzględnić w wyszukiwaniu metody publiczne.  
  
-   Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu metody niepubliczne (czyli prywatne, wewnętrzne i chronione).  
  
-   Określ `BindingFlags.FlattenHierarchy` , aby `public` uwzględnić `protected` i statyczne składowe w hierarchii; `private` statyczne składowe w klasach dziedziczonych nie są uwzględniane.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi modyfikatorów mogą służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase`ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly`Aby przeszukać tylko metody zadeklarowane <xref:System.Type>w, a nie metody, które były po prostu dziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.MethodInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje metody ograniczenia klasy lub <xref:System.Object> metody w przypadku braku ograniczenia klasy.  
  
> [!NOTE]
>  W przypadku metod ogólnych nie należy uwzględniać argumentów typu w `name`. C# Na przykład kod `GetMember("MyMethod<int>")` wyszukuje element członkowski o nazwie tekstowej "`MyMethod<int>`", a nie dla metody o nazwie `MyMethod` , która ma jeden argument rodzajowy typu `int`.  
  
   
  
## Examples  
 Poniższy przykład umożliwia znalezienie określonych przeciążeń `MethodA`, określanie ograniczeń powiązania, konwencje wywoływania i różne typy argumentów.  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Przykład wymaga opcji kompilatora. `/unsafe`  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną metodę o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="types" />jest <see langword="null" />.  
  
—lub— 
Jeden z elementów w programie <paramref name="types" /> ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />jest wielowymiarowych.  
  
—lub— 
 <paramref name="modifiers" />jest wielowymiarowych.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę metody pobierania.</param>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.  
  
—lub— 
 <see cref="System.Reflection.BindingFlags.Default" />do zwrócenia <see langword="null" />.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
Odwołanie o wartości null<see langword="Nothing" /> (w Visual Basic), aby <see cref="P:System.Type.DefaultBinder" />użyć.</param>
        <param name="callConvention">Obiekt, który określa zestaw reguł do użycia w odniesieniu do kolejności i układu argumentów, sposób przekazywania wartości zwracanej, jakie rejestry są używane dla argumentów, a proces czyści stos.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów dla metody do pobrania.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Type" /> (czyli typ [] typy = nowy typ [0]), aby uzyskać metodę, która nie przyjmuje żadnych parametrów.  
  
—lub— 
 <see langword="null" />. Jeśli <paramref name="types" /> jest<see langword="null" />, argumenty nie są zgodne.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentująca atrybuty skojarzone z odpowiednim elementem <paramref name="types" /> w tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, wyszukuje określoną metodę, której parametry pasują do określonych typów argumentów i modyfikatorów, przy użyciu określonych ograniczeń powiązania i określonej konwencji wywoływania.</summary>
        <returns>Obiekt reprezentujący metodę, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chociaż <xref:System.Reflection.ParameterModifier> domyślny spinacz nie przetwarza `modifiers` (parametr), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> , aby napisać niestandardowy spinacz, który przetwarza `modifiers`. `ParameterModifier`jest używany tylko podczas wywoływania za pomocą międzyoperacyjności modelu COM i obsługiwane są tylko parametry, które są przesyłane przez odwołanie.  
  
 Jeśli `types` jest`null`, argumenty nie są zgodne.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania, które metody mają być uwzględnione w wyszukiwaniu:  
  
-   Musisz określić albo `BindingFlags.Instance` `BindingFlags.Static` , aby uzyskać zwracaną wartość.  
  
-   Określ `BindingFlags.Public` , aby uwzględnić w wyszukiwaniu metody publiczne.  
  
-   Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu metody niepubliczne (czyli prywatne, wewnętrzne i chronione).  
  
-   Określ `BindingFlags.FlattenHierarchy` , aby `public` uwzględnić `protected` i statyczne składowe w hierarchii; `private` statyczne składowe w klasach dziedziczonych nie są uwzględniane.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi modyfikatorów mogą służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase`ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly`Aby przeszukać tylko metody zadeklarowane <xref:System.Type>w, a nie metody, które były po prostu dziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną metodę o określonej nazwie i pasującą do ograniczeń w określonym powiązaniu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />jest wielowymiarowych.  
  
—lub— 
 <paramref name="modifiers" />jest wielowymiarowych.  
  
—lub— 
 <paramref name="types" />i <paramref name="modifiers" /> nie mają tej samej długości.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący typ to <see cref="T:System.Reflection.Emit.TypeBuilder" /> lub <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera metody bieżącego <see cref="T:System.Type" />elementu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie metody publiczne obecne <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MethodInfo" /> obiektów reprezentujących wszystkie metody publiczne zdefiniowane dla bieżącego <see cref="T:System.Type" />.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.MethodInfo" />, jeśli dla bieżącej <see cref="T:System.Type" />nie są zdefiniowane żadne metody publiczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.Type.GetMethods%2A> Metoda nie zwraca metod w określonej kolejności, takich jak kolejność alfabetyczna lub Deklaracja. Kod nie może zależeć od kolejności, w jakiej są zwracane metody, ponieważ ta kolejność jest różna.  
  
 Konstruktory nie są uwzględnione w tablicy metod zwracanych przez to wywołanie. Wykonaj oddzielne wywołanie `GetConstructors()` w celu uzyskania metod konstruktora.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy bazowej są zwracane przez `Get` metody podczas odzwierciedlania typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
> [!NOTE]
>  Nie można pominąć parametrów przy wyszukiwaniu konstruktorów i metod. Parametry można pominąć jedynie podczas wywoływania.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.MethodInfo> zwraca obiekty z parametrami typu zamienionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje metody ograniczenia klasy lub <xref:System.Object> metody w przypadku braku ograniczenia klasy.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.

—lub—

 <see cref="F:System.Reflection.BindingFlags.Default" />Aby zwrócić pustą tablicę.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, wyszukuje metody zdefiniowane dla bieżącego <see cref="T:System.Type" />przy użyciu określonych ograniczeń powiązania.</summary>
        <returns>Tablica <see cref="T:System.Reflection.MethodInfo" /> obiektów reprezentujących wszystkie metody, które są zdefiniowane dla <see cref="T:System.Type" /> bieżącego, które pasują do określonych ograniczeń powiązania.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.MethodInfo" />, jeśli żadna metoda nie jest zdefiniowana dla bieżącego <see cref="T:System.Type" />lub jeśli żadna z zdefiniowanych metod nie pasuje do ograniczeń powiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `bindingAttr` <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>Aby Przeciążenie powiodło się pobranie informacji o metodzie, argument musi zawierać co najmniej jeden z i, wraz z co najmniej jedną z i. `GetMethods(BindingFlags)` 
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania, które metody mają być uwzględnione w wyszukiwaniu:  
  
- Określ `BindingFlags.Instance` , aby uwzględnić metody wystąpienia. 

- Określ `BindingFlags.Static` , aby uwzględnić metody statyczne. 
  
- Określ `BindingFlags.Public` , aby uwzględnić w wyszukiwaniu metody publiczne.  
  
- Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu metody niepubliczne (czyli prywatne, wewnętrzne i chronione). Zwracane są tylko metody chronione i wewnętrzne w klasach bazowych; Metody prywatne w klasach bazowych nie są zwracane.  
  
- Określ `BindingFlags.FlattenHierarchy` , aby `public` uwzględnić `protected` i statyczne składowe w hierarchii; `private` statyczne składowe w klasach dziedziczonych nie są uwzględniane.  

- Określ `BindingFlags.Default` same, aby zwrócić pustą <xref:System.Reflection.MethodInfo> tablicę.
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi modyfikatorów mogą służyć do zmiany sposobu działania wyszukiwania:  
  
- `BindingFlags.DeclaredOnly`Aby przeszukać tylko metody zadeklarowane <xref:System.Type>w, a nie metody, które były po prostu dziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  

<xref:System.Type.GetMethods%2A> Metoda nie zwraca metod w określonej kolejności, takich jak kolejność alfabetyczna lub Deklaracja. Kod nie może zależeć od kolejności, w jakiej są zwracane metody, ponieważ ta kolejność jest różna.  

Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.MethodInfo> zwraca obiekty z parametrami typu zamienionymi przez odpowiednie argumenty typu.  
  
Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje metody ograniczenia klasy lub <xref:System.Object> metody w przypadku braku ograniczenia klasy. 
  
## Examples  
 Poniższy przykład tworzy klasę z dwiema metodami publicznymi i jedną metodą chronioną, tworzy `Type` obiekt `MyTypeClass`odpowiadający, pobiera wszystkie metody publiczne i niepubliczne oraz wyświetla ich nazwy.  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określony typ zagnieżdżony w bieżącym <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę typu zagnieżdżonego do pobrania.</param>
        <summary>Wyszukuje publiczny zagnieżdżony typ o podanej nazwie.</summary>
        <returns>Obiekt reprezentujący publiczny Typ zagnieżdżony o określonej nazwie, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wyszukiwaniu `name` jest rozróżniana wielkość liter.  
  
 Użyj prostej nazwy klasy zagnieżdżonej dla `name`. Nie kwalifikuj go do nazwy klasy zewnętrznej. W przypadku generycznej klasy zagnieżdżonej Użyj nazwy zniekształcona, czyli dołączenia akcentu słabego i liczby argumentów ogólnych. Na przykład użyj ciągu "wewnętrzny\`1", aby uzyskać generyczną klasę `Inner<T>` zagnieżdżoną (`Inner(Of T)` w Visual Basic). Nie uwzględniaj składni charakterystycznej dla języka dla parametrów typu.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy bazowej są zwracane przez `Get` metody podczas odzwierciedlania typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje zagnieżdżone typy ograniczenia klasy.  
  
 Jeśli zagnieżdżony jest typ ogólny , metoda ta zwraca jego definicję typu ogólnego. Ta zasada obowiązuje, nawet jeśli otaczający typ ogólny jest skonstruowany jako zamknięty.  
  
> [!NOTE]
>  Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny zdefiniowany w C#, Visual Basic lub C++, jego typy zagnieżdżone są wszystkie rodzajowe, nawet jeśli nie mają własnych parametrów ogólnych. Jest to niekoniecznie prawdziwe dla zagnieżdżonych typów zdefiniowanych w zestawach dynamicznych lub skompilowanych za pomocą [Ilasm. exe (ASEMBLER Il)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Aby uzyskać informacje na temat zagnieżdżonych typów ogólnych i na konstruowaniu zagnieżdżonych typów ogólnych z ich definicji typów <xref:System.Type.MakeGenericType%2A>ogólnych, zobacz.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę typu zagnieżdżonego do pobrania.</param>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.  
  
—lub— 
 <see cref="System.Reflection.BindingFlags.Default" />do zwrócenia <see langword="null" />.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, wyszukuje określony typ zagnieżdżony przy użyciu określonych ograniczeń powiązania.</summary>
        <returns>Obiekt reprezentujący zagnieżdżony typ, który odpowiada określonym wymaganiom, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj prostej nazwy klasy zagnieżdżonej dla `name`. Nie kwalifikuj go do nazwy klasy zewnętrznej. W przypadku generycznej klasy zagnieżdżonej Użyj nazwy zniekształcona, czyli dołączenia akcentu słabego i liczby parametrów ogólnych. Na przykład użyj ciągu "wewnętrzny\`1", aby uzyskać generyczną klasę `Inner<T>` zagnieżdżoną (`Inner(Of T)` w Visual Basic). Nie uwzględniaj składni charakterystycznej dla języka dla parametrów typu.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania, które typy zagnieżdżone mają być uwzględnione w wyszukiwaniu:  
  
-   Należy określić <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> lub <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> , aby uzyskać zwracaną wartość.  
  
-   Określ <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> , aby uwzględnić w wyszukiwaniu publiczne typy zagnieżdżone.  
  
-   Określ <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> , aby uwzględnić typy zagnieżdżone niepubliczne (czyli prywatne, wewnętrzne i chronione zagnieżdżonych typów) w wyszukiwaniu.  
  
 Ta metoda zwraca tylko zagnieżdżone typy bieżącego typu. Nie przeszukuje klas bazowych bieżącego typu. Aby znaleźć typy, które są zagnieżdżone w klasach bazowych, należy zademonstrować hierarchię dziedziczenia, wywołując <xref:System.Type.GetNestedType%2A> na każdym poziomie.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>i <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> są ignorowane.  
  
 Wywołanie tej metody z tylko <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flagą lub <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> tylko flagi zwróci określone typy zagnieżdżone i nie wymaga żadnych innych flag.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje zagnieżdżone typy ograniczenia klasy.  
  
 Jeśli zagnieżdżony jest typ ogólny , metoda ta zwraca jego definicję typu ogólnego. Ta zasada obowiązuje, nawet jeśli otaczający typ ogólny jest skonstruowany jako zamknięty.  
  
> [!NOTE]
>  Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny zdefiniowany w C#, Visual Basic lub C++, jego typy zagnieżdżone są wszystkie rodzajowe, nawet jeśli nie mają własnych parametrów ogólnych. Jest to niekoniecznie prawdziwe dla zagnieżdżonych typów zdefiniowanych w zestawach dynamicznych lub skompilowanych za pomocą [Ilasm. exe (ASEMBLER Il)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Aby uzyskać informacje na temat zagnieżdżonych typów ogólnych i na konstruowaniu zagnieżdżonych typów ogólnych z ich definicji typów <xref:System.Type.MakeGenericType%2A>ogólnych, zobacz.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera typy zagnieżdżone w bieżącym <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca typy publiczne zagnieżdżone w bieżącym <see cref="T:System.Type" />.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiektów reprezentujących typy publiczne zagnieżdżone w bieżącym <see cref="T:System.Type" /> (wyszukiwanie nie jest cykliczne) lub pustą tablicę typu <see cref="T:System.Type" /> , jeśli w bieżącym <see cref="T:System.Type" />nie są zagnieżdżone typy publiczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetNestedTypes%2A> Metoda nie zwraca typów w określonej kolejności, takich jak kolejność alfabetyczna lub Deklaracja. Kod nie może zależeć od kolejności, w której zwracane są typy, ponieważ ta kolejność jest różna.  
  
 Zwracane są tylko typy publiczne, które są od razu zagnieżdżone w bieżącym typie; Wyszukiwanie nie jest cykliczne.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy bazowej są zwracane przez `Get` metody podczas odzwierciedlania typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje zagnieżdżone typy ograniczenia klasy.  
  
 Jeśli zagnieżdżony jest typ ogólny , metoda ta zwraca jego definicję typu ogólnego. Ta zasada obowiązuje, nawet jeśli otaczający typ ogólny jest skonstruowany jako zamknięty.  
  
> [!NOTE]
>  Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny zdefiniowany w C#, Visual Basic lub C++, jego typy zagnieżdżone są wszystkie rodzajowe, nawet jeśli nie mają własnych parametrów ogólnych. Jest to niekoniecznie prawdziwe dla zagnieżdżonych typów zdefiniowanych w zestawach dynamicznych lub skompilowanych za pomocą [Ilasm. exe (ASEMBLER Il)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Aby uzyskać informacje na temat zagnieżdżonych typów ogólnych i na konstruowaniu zagnieżdżonych typów ogólnych z ich definicji typów <xref:System.Type.MakeGenericType%2A>ogólnych, zobacz.  
  
   
  
## Examples  
 Poniższy przykład definiuje klasę zagnieżdżoną i `struct` w `MyClass`, a następnie uzyskuje obiekty zagnieżdżonych `MyClass`typów przy użyciu typu.  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.  
  
—lub— 
 <see cref="System.Reflection.BindingFlags.Default" />do zwrócenia <see langword="null" />.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, wyszukuje typy zagnieżdżone w bieżącym <see cref="T:System.Type" />, używając określonych ograniczeń powiązania.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiektów reprezentująca wszystkie typy zagnieżdżone w bieżącym <see cref="T:System.Type" /> , które pasują do określonych ograniczeń powiązania (wyszukiwanie nie jest cykliczne) lub pustą tablicę typu <see cref="T:System.Type" />, jeśli nie znaleziono zagnieżdżonych typów, które pasują do ograniczenia powiązań.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukiwanie typów zagnieżdżonych nie jest cykliczne.  
  
 <xref:System.Type.GetNestedTypes%2A> Metoda nie zwraca typów w określonej kolejności, takich jak kolejność alfabetyczna lub Deklaracja. Kod nie może zależeć od kolejności, w której zwracane są typy, ponieważ ta kolejność jest różna.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania, które typy zagnieżdżone mają być uwzględnione w wyszukiwaniu:  
  
-   Należy określić <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> lub <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> , aby uzyskać zwracaną wartość.  
  
-   Określ <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> , aby uwzględnić w wyszukiwaniu publiczne typy zagnieżdżone.  
  
-   Określ <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> , aby uwzględnić typy zagnieżdżone niepubliczne (czyli prywatne, wewnętrzne i chronione zagnieżdżonych typów) w wyszukiwaniu.  
  
 Ta metoda zwraca tylko zagnieżdżone typy bieżącego typu. Nie przeszukuje klas bazowych bieżącego typu. Aby znaleźć typy, które są zagnieżdżone w klasach bazowych, należy zademonstrować hierarchię dziedziczenia, wywołując <xref:System.Type.GetNestedTypes%2A> na każdym poziomie.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>i <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> są ignorowane.  
  
 Wywołanie tej metody z tylko <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flagą lub <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> tylko flagi zwróci określone typy zagnieżdżone i nie wymaga żadnych innych flag.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje zagnieżdżone typy ograniczenia klasy.  
  
 Jeśli zagnieżdżony jest typ ogólny , metoda ta zwraca jego definicję typu ogólnego. Ta zasada obowiązuje, nawet jeśli otaczający typ ogólny jest skonstruowany jako zamknięty.  
  
> [!NOTE]
>  Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny zdefiniowany w C#, Visual Basic lub C++, jego typy zagnieżdżone są wszystkie rodzajowe, nawet jeśli nie mają własnych parametrów ogólnych. Jest to niekoniecznie prawdziwe dla zagnieżdżonych typów zdefiniowanych w zestawach dynamicznych lub skompilowanych za pomocą [Ilasm. exe (ASEMBLER Il)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Aby uzyskać informacje na temat zagnieżdżonych typów ogólnych i na konstruowaniu zagnieżdżonych typów ogólnych z ich definicji typów <xref:System.Type.MakeGenericType%2A>ogólnych, zobacz.  
  
   
  
## Examples  
 Poniższy przykład tworzy dwie zagnieżdżone klasy publiczne i dwie zagnieżdżone klasy chronione i wyświetla informacje dotyczące klas, które pasują do określonych ograniczeń powiązania.  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera właściwości bieżącego <see cref="T:System.Type" />elementu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie właściwości publiczne bieżącego <see cref="T:System.Type" />elementu.</summary>
        <returns>Tablica <see cref="T:System.Reflection.PropertyInfo" /> obiektów reprezentująca wszystkie właściwości publiczne bieżącego <see cref="T:System.Type" />elementu.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.PropertyInfo" />, jeśli bieżąca <see cref="T:System.Type" /> nie ma właściwości publicznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tego przeciążenia jest <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> równoznaczne z wywołaniem przeciążenia `bindingAttr` z argumentem `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` równym C# i `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` w Visual Basic. Zwraca wszystkie wystąpienia publiczne i statyczne właściwości, zarówno te, które zostały zdefiniowane przez typ reprezentowane przez bieżący <xref:System.Type> obiekt, jak i te dziedziczone z typów podstawowych.  
  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie właściwość jest uznawana za prywatną i <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> musisz użyć &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w Visual Basic, połączyć wartości `Or`przy użyciu), aby je pobrać.  
  
 <xref:System.Type.GetProperties%2A> Metoda nie zwraca właściwości w określonej kolejności, takiej jak kolejność alfabetyczna lub Deklaracja. Kod nie może zależeć od kolejności, w której są zwracane właściwości, ponieważ ta kolejność jest różna.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy bazowej są zwracane przez `Get` metody podczas odzwierciedlania typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.PropertyInfo> zwraca obiekty z parametrami typu zamienionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje właściwości ograniczenia klasy.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie `GetProperties` metody.  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.

—lub—

 <see cref="F:System.Reflection.BindingFlags.Default" />Aby zwrócić pustą tablicę.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, wyszukuje właściwości bieżącego <see cref="T:System.Type" />, przy użyciu określonych ograniczeń powiązania.</summary>
        <returns>Tablica obiektów reprezentująca wszystkie właściwości bieżącego <see cref="T:System.Type" /> , które pasują do określonych ograniczeń powiązania.  
  
—lub— 
Pusta tablica typu <see cref="T:System.Reflection.PropertyInfo" />, jeśli bieżąca <see cref="T:System.Type" /> nie ma właściwości lub jeśli żadna z właściwości nie pasuje do ograniczeń powiązania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `bindingAttr` <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>Aby Przeciążenie powiodło się pobranie informacji o właściwościach, argument musi zawierać co najmniej jeden z i, wraz z co najmniej jedną z i. `GetProperties(BindingFlags)` 

Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania właściwości, które mają być uwzględnione w wyszukiwaniu:  
  
- Określ `BindingFlags.Instance` , aby uwzględnić metody wystąpienia. 

- Określ `BindingFlags.Static` , aby uwzględnić metody statyczne. 
  
- Określ `BindingFlags.Public` , aby uwzględnić w wyszukiwaniu właściwości publiczne. Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. 
  
- Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu właściwości niepubliczne (czyli prywatne, wewnętrzne i chronione). Zwracane są tylko właściwości chronione i wewnętrzne w klasach bazowych; Właściwości prywatne w klasach bazowych nie są zwracane.  
  
- Określ `BindingFlags.FlattenHierarchy` , aby `public` uwzględnić `protected` i statyczne składowe w hierarchii; `private` statyczne składowe w klasach dziedziczonych nie są uwzględniane.  

- Określ `BindingFlags.Default` same, aby zwrócić pustą <xref:System.Reflection.PropertyInfo> tablicę.

 Poniższe <xref:System.Reflection.BindingFlags> flagi modyfikatorów mogą służyć do zmiany sposobu działania wyszukiwania:  
  
- `BindingFlags.DeclaredOnly`Aby przeszukać tylko właściwości zadeklarowane <xref:System.Type>w, a nie właściwości, które były po prostu dziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
<xref:System.Type.GetProperties%2A> Metoda nie zwraca właściwości w określonej kolejności, takiej jak kolejność alfabetyczna lub Deklaracja. Kod nie może zależeć od kolejności, w której są zwracane właściwości, ponieważ ta kolejność jest różna.  

 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.PropertyInfo> zwraca obiekty z parametrami typu zamienionymi przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje właściwości ograniczenia klasy.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano klasę o `PropertyClass` nazwie, która zawiera sześć właściwości: dwa są publiczne, jeden jest prywatny, jeden jest chroniony, jeden jest`Friend` wewnętrzny (w Visual Basic), a drugi jest chroniony`Protected Friend` wewnętrznie (w Visual Basic). Następnie są wyświetlane podstawowe informacje o właściwościach (nazwa właściwości i typ, niezależnie od tego, czy jest to odczyt i zapis, oraz `get` widoczność `set` elementów i metod dostępu) dla właściwości, które pasują do określonych ograniczeń powiązania.  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera określoną właściwość bieżącej <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości publicznej do pobrania.</param>
        <summary>Wyszukuje Właściwość publiczną o podanej nazwie.</summary>
        <returns>Obiekt reprezentujący właściwość publiczną o podanej nazwie, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wyszukiwaniu `name` jest rozróżniana wielkość liter. Wyszukiwanie uwzględnia właściwości wystąpienia statycznego publicznego i publicznego.  
  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie właściwość jest uznawana za prywatną i <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> musisz użyć &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w Visual Basic, połączyć wartości `Or`przy użyciu), aby je pobrać.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.PropertyInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje właściwości ograniczenia klasy.  
  
 W <xref:System.Reflection.AmbiguousMatchException> takim przypadku występują następujące sytuacje:  
  
-   Typ zawiera dwie indeksowane właściwości, które mają taką samą nazwę, ale różne liczby parametrów. Aby usunąć niejednoznaczność, Użyj przeciążenia <xref:System.Type.GetProperty%2A> metody, która określa typy parametrów.  
  
-   Typ pochodny deklaruje właściwość, która ukrywa właściwość dziedziczoną o tej samej nazwie, używając `new` modyfikatora (`Shadows` w Visual Basic). Aby rozwiązać niejednoznaczność, należy użyć <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> przeciążenia metody i <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> dodać flagę w celu ograniczenia wyszukiwania do elementów członkowskich, które nie są dziedziczone.  
  
## <a name="indexers-and-default-properties"></a>Indeksatory i domyślne właściwości  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] i[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczoną składnię do uzyskiwania dostępu do indeksowanych właściwości i zezwalają jednej indeksowanej właściwości na wartość domyślną dla tego typu. Na `myList` przykład jeśli zmienna odwołuje się <xref:System.Collections.ArrayList>do, składnia `myList[3]` (`myList(3)` w Visual Basic) Pobiera element o indeksie 3. Można doprowadzić do przeciążenia właściwości.  
  
 W C#programie ta funkcja nosi nazwę indeksatora i nie można jej odwoływać do nazwy. Domyślnie C# indeksator jest wyświetlany w metadanych jako indeksowana właściwość o nazwie "Item". Jednak deweloper biblioteki klas może użyć atrybutu, <xref:System.Runtime.CompilerServices.IndexerNameAttribute> aby zmienić nazwę indeksatora w metadanych. Na przykład <xref:System.String> Klasa ma indeksator o nazwie <xref:System.String.Chars%2A>. Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.  
  
 Aby określić, czy typ ma właściwość domyślną, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metody do przetestowania <xref:System.Reflection.DefaultMemberAttribute> atrybutu. Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute> <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> , właściwość zwraca nazwę domyślnej właściwości.  
  
   
  
## Examples  
 Poniższy przykład pobiera `Type` obiekt klasy zdefiniowanej przez użytkownika, pobiera właściwość tej klasy i wyświetla nazwę właściwości.  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 Wewnętrznie, ta właściwość jest określana w metadanych według nazwy "Item". Każda próba uzyskania `PropertyInfo` użycia odbicia musi określać tę wewnętrzną nazwę, aby prawidłowo `PropertyInfo` zwrócić właściwość.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną właściwość o określonej nazwie.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości do pobrania.</param>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.  
  
—lub— 
<see cref="System.Reflection.BindingFlags.Default" />do zwrócenia <see langword="null" />.</param>
        <summary>Wyszukuje określoną właściwość przy użyciu określonych ograniczeń powiązania.</summary>
        <returns>Obiekt reprezentujący właściwość, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie właściwość jest uznawana za prywatną i <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> musisz użyć &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w Visual Basic, połączyć wartości `Or`przy użyciu), aby je pobrać.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania właściwości, które mają być uwzględnione w wyszukiwaniu:  
  
-   Musisz określić albo `BindingFlags.Instance` `BindingFlags.Static` , aby uzyskać zwracaną wartość.  
  
-   Określ `BindingFlags.Public` , aby uwzględnić w wyszukiwaniu właściwości publiczne.  
  
-   Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu właściwości niepubliczne (czyli prywatne, wewnętrzne i chronione).  
  
-   Określ `BindingFlags.FlattenHierarchy` , aby `public` uwzględnić `protected` i statyczne składowe w hierarchii; `private` statyczne składowe w klasach dziedziczonych nie są uwzględniane.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi modyfikatorów mogą służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase`ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly`Aby przeszukać tylko właściwości zadeklarowane <xref:System.Type>w, a nie właściwości, które były po prostu dziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.PropertyInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje właściwości ograniczenia klasy.  
  
 W <xref:System.Reflection.AmbiguousMatchException> takim przypadku występują następujące sytuacje:  
  
-   Typ zawiera dwie indeksowane właściwości, które mają taką samą nazwę, ale różne liczby parametrów. Aby usunąć niejednoznaczność, Użyj przeciążenia <xref:System.Type.GetProperty%2A> metody, która określa typy parametrów.  
  
-   Typ pochodny deklaruje właściwość, która ukrywa właściwość dziedziczoną o tej samej nazwie, używając `new` modyfikatora (`Shadows` w Visual Basic). Aby usunąć niejednoznaczność, Dołącz <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> , aby ograniczyć wyszukiwanie do elementów członkowskich, które nie są dziedziczone.  
  
## <a name="indexers-and-default-properties"></a>Indeksatory i domyślne właściwości  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] i[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczoną składnię do uzyskiwania dostępu do indeksowanych właściwości i zezwalają jednej indeksowanej właściwości na wartość domyślną dla tego typu. Na `myList` przykład jeśli zmienna odwołuje się <xref:System.Collections.ArrayList>do, składnia `myList[3]` (`myList(3)` w Visual Basic) Pobiera element o indeksie 3. Można doprowadzić do przeciążenia właściwości.  
  
 W C#programie ta funkcja nosi nazwę indeksatora i nie można jej odwoływać do nazwy. Domyślnie C# indeksator jest wyświetlany w metadanych jako indeksowana właściwość o nazwie "Item". Jednak deweloper biblioteki klas może użyć atrybutu, <xref:System.Runtime.CompilerServices.IndexerNameAttribute> aby zmienić nazwę indeksatora w metadanych. Na przykład <xref:System.String> Klasa ma indeksator o nazwie <xref:System.String.Chars%2A>. Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.  
  
 Aby określić, czy typ ma właściwość domyślną, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metody do przetestowania <xref:System.Reflection.DefaultMemberAttribute> atrybutu. Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute> <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> , właściwość zwraca nazwę domyślnej właściwości.  
  
   
  
## Examples  
 Poniższy przykład pobiera typ klasy zdefiniowanej przez użytkownika, pobiera właściwość tej klasy i wyświetla nazwę właściwości zgodnie z określonymi ograniczeniami powiązań.  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną właściwość o określonej nazwie i pasuje do określonych ograniczeń powiązania.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości publicznej do pobrania.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <summary>Wyszukuje Właściwość publiczną z określoną nazwą i zwracanym typem.</summary>
        <returns>Obiekt reprezentujący właściwość publiczną o podanej nazwie, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie właściwość jest uznawana za prywatną i <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> musisz użyć &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w Visual Basic, połączyć wartości `Or`przy użyciu), aby je pobrać.  
  
 W wyszukiwaniu `name` jest rozróżniana wielkość liter. Wyszukiwanie uwzględnia właściwości wystąpienia statycznego publicznego i publicznego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.PropertyInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje właściwości ograniczenia klasy.  
  
## <a name="indexers-and-default-properties"></a>Indeksatory i domyślne właściwości  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] i[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczoną składnię do uzyskiwania dostępu do indeksowanych właściwości i zezwalają jednej indeksowanej właściwości na wartość domyślną dla tego typu. Na `myList` przykład jeśli zmienna odwołuje się <xref:System.Collections.ArrayList>do, składnia `myList[3]` (`myList(3)` w Visual Basic) Pobiera element o indeksie 3. Można doprowadzić do przeciążenia właściwości.  
  
 W C#programie ta funkcja nosi nazwę indeksatora i nie można jej odwoływać do nazwy. Domyślnie C# indeksator jest wyświetlany w metadanych jako indeksowana właściwość o nazwie "Item". Jednak deweloper biblioteki klas może użyć atrybutu, <xref:System.Runtime.CompilerServices.IndexerNameAttribute> aby zmienić nazwę indeksatora w metadanych. Na przykład <xref:System.String> Klasa ma indeksator o nazwie <xref:System.String.Chars%2A>. Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.  
  
 Aby określić, czy typ ma właściwość domyślną, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metody do przetestowania <xref:System.Reflection.DefaultMemberAttribute> atrybutu. Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute> <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> , właściwość zwraca nazwę domyślnej właściwości.  
  
   
  
## Examples  
 Poniższy przykład definiuje klasę z jedną właściwością i pobiera nazwę i typ właściwości.  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną właściwość o określonej nazwie.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />is <see langword="null" />lub <paramref name="returnType" /> is .<see langword="null" /></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości publicznej do pobrania.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów właściwości indeksowanej do pobrania.  
  
—lub— 
Pustą tablicę typu <see cref="T:System.Type" /> (czyli typ [] typy = nowy typ [0]) do uzyskania właściwości, która nie jest indeksowana.</param>
        <summary>Wyszukuje określoną właściwość publiczną, której parametry pasują do określonych typów argumentów.</summary>
        <returns>Obiekt reprezentujący właściwość publiczną, której parametry są zgodne z określonymi typami argumentów, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie właściwość jest uznawana za prywatną i <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> musisz użyć &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w Visual Basic, połączyć wartości `Or`przy użyciu), aby je pobrać.  
  
 W wyszukiwaniu `name` jest rozróżniana wielkość liter. Wyszukiwanie uwzględnia właściwości wystąpienia statycznego publicznego i publicznego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.PropertyInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje właściwości ograniczenia klasy.  
  
## <a name="indexers-and-default-properties"></a>Indeksatory i domyślne właściwości  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] i[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczoną składnię do uzyskiwania dostępu do indeksowanych właściwości i zezwalają jednej indeksowanej właściwości na wartość domyślną dla tego typu. Na `myList` przykład jeśli zmienna odwołuje się <xref:System.Collections.ArrayList>do, składnia `myList[3]` (`myList(3)` w Visual Basic) Pobiera element o indeksie 3. Można doprowadzić do przeciążenia właściwości.  
  
 W C#programie ta funkcja nosi nazwę indeksatora i nie można jej odwoływać do nazwy. Domyślnie C# indeksator jest wyświetlany w metadanych jako indeksowana właściwość o nazwie "Item". Jednak deweloper biblioteki klas może użyć atrybutu, <xref:System.Runtime.CompilerServices.IndexerNameAttribute> aby zmienić nazwę indeksatora w metadanych. Na przykład <xref:System.String> Klasa ma indeksator o nazwie <xref:System.String.Chars%2A>. Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.  
  
 Aby określić, czy typ ma właściwość domyślną, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metody do przetestowania <xref:System.Reflection.DefaultMemberAttribute> atrybutu. Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute> <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> , właściwość zwraca nazwę domyślnej właściwości.  
  
   
  
## Examples  
 Poniższy przykład pobiera `Type` obiekt klasy zdefiniowanej przez użytkownika, pobiera właściwość tej klasy i wyświetla nazwę właściwości oraz typ właściwości, jak określono przez argumenty przekazane do `GetProperty`.  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną właściwość o określonej nazwie i pasuje do określonych typów argumentów.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="types" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />jest wielowymiarowych.</exception>
        <exception cref="T:System.NullReferenceException">Element <paramref name="types" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości publicznej do pobrania.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów właściwości indeksowanej do pobrania.  
  
—lub— 
Pustą tablicę typu <see cref="T:System.Type" /> (czyli typ [] typy = nowy typ [0]) do uzyskania właściwości, która nie jest indeksowana.</param>
        <summary>Wyszukuje określoną właściwość publiczną, której parametry pasują do określonych typów argumentów.</summary>
        <returns>Obiekt reprezentujący właściwość publiczną, której parametry są zgodne z określonymi typami argumentów, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie właściwość jest uznawana za prywatną i <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> musisz użyć &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w Visual Basic, połączyć wartości `Or`przy użyciu), aby je pobrać.  
  
 W wyszukiwaniu `name` jest rozróżniana wielkość liter. Wyszukiwanie uwzględnia właściwości wystąpienia statycznego publicznego i publicznego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.PropertyInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje właściwości ograniczenia klasy.  
  
## <a name="indexers-and-default-properties"></a>Indeksatory i domyślne właściwości  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] i[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczoną składnię do uzyskiwania dostępu do indeksowanych właściwości i zezwalają jednej indeksowanej właściwości na wartość domyślną dla tego typu. Na `myList` przykład jeśli zmienna odwołuje się <xref:System.Collections.ArrayList>do, składnia `myList[3]` (`myList(3)` w Visual Basic) Pobiera element o indeksie 3. Można doprowadzić do przeciążenia właściwości.  
  
 W C#programie ta funkcja nosi nazwę indeksatora i nie można jej odwoływać do nazwy. Domyślnie C# indeksator jest wyświetlany w metadanych jako indeksowana właściwość o nazwie "Item". Jednak deweloper biblioteki klas może użyć atrybutu, <xref:System.Runtime.CompilerServices.IndexerNameAttribute> aby zmienić nazwę indeksatora w metadanych. Na przykład <xref:System.String> Klasa ma indeksator o nazwie <xref:System.String.Chars%2A>. Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.  
  
 Aby określić, czy typ ma właściwość domyślną, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metody do przetestowania <xref:System.Reflection.DefaultMemberAttribute> atrybutu. Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute> <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> , właściwość zwraca nazwę domyślnej właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną właściwość o określonej nazwie i pasuje do określonych typów argumentów.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="types" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />jest wielowymiarowych.</exception>
        <exception cref="T:System.NullReferenceException">Element <paramref name="types" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości publicznej do pobrania.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów właściwości indeksowanej do pobrania.  
  
—lub— 
Pustą tablicę typu <see cref="T:System.Type" /> (czyli typ [] typy = nowy typ [0]) do uzyskania właściwości, która nie jest indeksowana.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentująca atrybuty skojarzone z odpowiednim elementem <paramref name="types" /> w tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Wyszukuje określoną właściwość publiczną, której parametry pasują do określonych typów argumentów i modyfikatorów.</summary>
        <returns>Obiekt reprezentujący właściwość publiczną, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie właściwość jest uznawana za prywatną i <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> musisz użyć &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w Visual Basic, połączyć wartości `Or`przy użyciu), aby je pobrać.  
  
 Chociaż <xref:System.Reflection.ParameterModifier> domyślny spinacz nie przetwarza `modifiers` (parametr), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> , aby napisać niestandardowy spinacz, który przetwarza `modifiers`. `ParameterModifier`jest używany tylko podczas wywoływania za pomocą międzyoperacyjności modelu COM i obsługiwane są tylko parametry, które są przesyłane przez odwołanie.  
  
 W wyszukiwaniu `name` jest rozróżniana wielkość liter. Wyszukiwanie uwzględnia właściwości wystąpienia statycznego publicznego i publicznego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.PropertyInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje właściwości ograniczenia klasy.  
  
## <a name="indexers-and-default-properties"></a>Indeksatory i domyślne właściwości  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] i[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczoną składnię do uzyskiwania dostępu do indeksowanych właściwości i zezwalają jednej indeksowanej właściwości na wartość domyślną dla tego typu. Na `myList` przykład jeśli zmienna odwołuje się <xref:System.Collections.ArrayList>do, składnia `myList[3]` (`myList(3)` w Visual Basic) Pobiera element o indeksie 3. Można doprowadzić do przeciążenia właściwości.  
  
 W C#programie ta funkcja nosi nazwę indeksatora i nie można jej odwoływać do nazwy. Domyślnie C# indeksator jest wyświetlany w metadanych jako indeksowana właściwość o nazwie "Item". Jednak deweloper biblioteki klas może użyć atrybutu, <xref:System.Runtime.CompilerServices.IndexerNameAttribute> aby zmienić nazwę indeksatora w metadanych. Na przykład <xref:System.String> Klasa ma indeksator o nazwie <xref:System.String.Chars%2A>. Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.  
  
 Aby określić, czy typ ma właściwość domyślną, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metody do przetestowania <xref:System.Reflection.DefaultMemberAttribute> atrybutu. Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute> <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> , właściwość zwraca nazwę domyślnej właściwości.  
  
   
  
## Examples  
 Poniższy przykład uzyskuje `Type` obiekt `MyPropertyClass`odpowiadający, a indeksowana właściwość tej klasy jest pobierana przy użyciu argumentów przekazane do `GetProperty` metody.  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną właściwość o określonej nazwie i pasujące do określonych typów argumentów i modyfikatorów.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="types" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />jest wielowymiarowych.  
  
—lub— 
 <paramref name="modifiers" />jest wielowymiarowych.  
  
—lub— 
 <paramref name="types" />i <paramref name="modifiers" /> nie mają tej samej długości.</exception>
        <exception cref="T:System.NullReferenceException">Element <paramref name="types" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości do pobrania.</param>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.  
  
—lub— 
 <see cref="System.Reflection.BindingFlags.Default" />do zwrócenia <see langword="null" />.</param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
Odwołanie o wartości null<see langword="Nothing" /> (w Visual Basic), aby <see cref="P:System.Type.DefaultBinder" />użyć.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów właściwości indeksowanej do pobrania.  
  
—lub— 
Pustą tablicę typu <see cref="T:System.Type" /> (czyli typ [] typy = nowy typ [0]) do uzyskania właściwości, która nie jest indeksowana.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentująca atrybuty skojarzone z odpowiednim elementem <paramref name="types" /> w tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Wyszukuje określoną właściwość, której parametry pasują do określonych typów argumentów i modyfikatorów, przy użyciu określonych ograniczeń powiązania.</summary>
        <returns>Obiekt reprezentujący właściwość, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest uważana za publiczne odbicie, jeżeli ma co najmniej jeden publiczny akcesor. W przeciwnym razie właściwość jest uznawana za prywatną i <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> musisz użyć &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (w Visual Basic, połączyć wartości `Or`przy użyciu), aby je pobrać.  
  
 Chociaż <xref:System.Reflection.ParameterModifier> domyślny spinacz nie przetwarza `modifiers` (parametr), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> , aby napisać niestandardowy spinacz, który przetwarza `modifiers`. `ParameterModifier`jest używany tylko podczas wywoływania za pomocą międzyoperacyjności modelu COM i obsługiwane są tylko parametry, które są przesyłane przez odwołanie.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy bazowej są zwracane przez `Get` metody podczas odzwierciedlania typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania właściwości, które mają być uwzględnione w wyszukiwaniu:  
  
-   Musisz określić albo `BindingFlags.Instance` `BindingFlags.Static` , aby uzyskać zwracaną wartość.  
  
-   Określ `BindingFlags.Public` , aby uwzględnić w wyszukiwaniu właściwości publiczne.  
  
-   Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu właściwości niepubliczne (czyli prywatne, wewnętrzne i chronione).  
  
-   Określ `BindingFlags.FlattenHierarchy` , aby `public` uwzględnić `protected` i statyczne składowe w hierarchii; `private` statyczne składowe w klasach dziedziczonych nie są uwzględniane.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi modyfikatorów mogą służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase`ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly`Aby przeszukać tylko właściwości zadeklarowane <xref:System.Type>w, a nie właściwości, które były po prostu dziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, Metoda ta <xref:System.Reflection.PropertyInfo> zwraca parametry typu zastąpione przez odpowiednie argumenty typu.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda przeszukuje właściwości ograniczenia klasy.  
  
## <a name="indexers-and-default-properties"></a>Indeksatory i domyślne właściwości  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] i[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] mają uproszczoną składnię do uzyskiwania dostępu do indeksowanych właściwości i zezwalają jednej indeksowanej właściwości na wartość domyślną dla tego typu. Na `myList` przykład jeśli zmienna odwołuje się <xref:System.Collections.ArrayList>do, składnia `myList[3]` (`myList(3)` w Visual Basic) Pobiera element o indeksie 3. Można doprowadzić do przeciążenia właściwości.  
  
 W C#programie ta funkcja nosi nazwę indeksatora i nie można jej odwoływać do nazwy. Domyślnie C# indeksator jest wyświetlany w metadanych jako indeksowana właściwość o nazwie "Item". Jednak deweloper biblioteki klas może użyć atrybutu, <xref:System.Runtime.CompilerServices.IndexerNameAttribute> aby zmienić nazwę indeksatora w metadanych. Na przykład <xref:System.String> Klasa ma indeksator o nazwie <xref:System.String.Chars%2A>. Właściwości indeksowane utworzone za pomocą języków innych niż C# mogą mieć też nazwy inne niż Element.  
  
 Aby określić, czy typ ma właściwość domyślną, należy użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metody do przetestowania <xref:System.Reflection.DefaultMemberAttribute> atrybutu. Jeśli typ ma <xref:System.Reflection.DefaultMemberAttribute> <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> , właściwość zwraca nazwę domyślnej właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną właściwość o określonej nazwie i pasuje do określonych ograniczeń powiązania.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="types" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />jest wielowymiarowych.  
  
—lub— 
 <paramref name="modifiers" />jest wielowymiarowych.  
  
—lub— 
 <paramref name="types" />i <paramref name="modifiers" /> nie mają tej samej długości.</exception>
        <exception cref="T:System.NullReferenceException">Element <paramref name="types" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę właściwości do pobrania.</param>
        <param name="bindingAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania.  
  
—lub— 
 <see cref="System.Reflection.BindingFlags.Default" />do zwrócenia <see langword="null" />.</param>
        <param name="binder">Obiekt, który definiuje zestaw właściwości i umożliwia powiązanie, które może polegać na wyborze przeciążonego elementu członkowskiego, wymuszania typów argumentów i wywołaniu elementu członkowskiego za pomocą odbicia.  
  
—lub— 
Odwołanie o wartości null<see langword="Nothing" /> (w Visual Basic), aby <see cref="P:System.Type.DefaultBinder" />użyć.</param>
        <param name="returnType">Zwracany typ właściwości.</param>
        <param name="types">Tablica <see cref="T:System.Type" /> obiektów reprezentujących liczbę, kolejność i typ parametrów właściwości indeksowanej do pobrania.  
  
—lub— 
Pustą tablicę typu <see cref="T:System.Type" /> (czyli typ [] typy = nowy typ [0]) do uzyskania właściwości, która nie jest indeksowana.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentująca atrybuty skojarzone z odpowiednim elementem <paramref name="types" /> w tablicy. Domyślny konsolidator nie przetwarza tego parametru.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, wyszukuje określoną właściwość, której parametry pasują do określonych typów argumentów i modyfikatorów, przy użyciu określonych ograniczeń powiązania.</summary>
        <returns>Obiekt reprezentujący właściwość, która spełnia określone wymagania, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chociaż <xref:System.Reflection.ParameterModifier> domyślny spinacz nie przetwarza `modifiers` (parametr), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> , aby napisać niestandardowy spinacz, który przetwarza `modifiers`. `ParameterModifier`jest używany tylko podczas wywoływania za pomocą międzyoperacyjności modelu COM i obsługiwane są tylko parametry, które są przesyłane przez odwołanie.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania właściwości, które mają być uwzględnione w wyszukiwaniu:  
  
-   Musisz określić albo `BindingFlags.Instance` `BindingFlags.Static` , aby uzyskać zwracaną wartość.  
  
-   Określ `BindingFlags.Public` , aby uwzględnić w wyszukiwaniu właściwości publiczne.  
  
-   Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu właściwości niepubliczne (czyli prywatne, wewnętrzne i chronione).  
  
-   Określ `BindingFlags.FlattenHierarchy` , aby `public` uwzględnić `protected` i statyczne składowe w hierarchii; `private` statyczne składowe w klasach dziedziczonych nie są uwzględniane.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi modyfikatorów mogą służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase`ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly`Aby przeszukać tylko właściwości zadeklarowane <xref:System.Type>w, a nie właściwości, które były po prostu dziedziczone.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Znaleziono więcej niż jedną właściwość o określonej nazwie i pasuje do określonych ograniczeń powiązania.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="types" />jest <see langword="null" />.  
  
—lub— 
Jeden z elementów w programie <paramref name="types" /> ma <see langword="null" />wartość.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" />jest wielowymiarowych.  
  
—lub— 
 <paramref name="modifiers" />jest wielowymiarowych.  
  
—lub— 
 <paramref name="types" />i <paramref name="modifiers" /> nie mają tej samej długości.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący typ to <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" />, lub <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Type" /> Pobiera obiekt, który reprezentuje określony typ.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera bieżącą <see cref="T:System.Type" />wartość.</summary>
        <returns>Bieżący <see cref="T:System.Type" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Określanie w pełni kwalifikowanych nazw typów</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">Kwalifikowana dla zestawu nazwa typu do pobrania. Zobacz <see cref="P:System.Type.AssemblyQualifiedName" />. Jeśli typ znajduje się w aktualnie wykonywanym zestawie lub w bibliotece Mscorlib. dll, wystarczy podać nazwę typu kwalifikowana przez jego przestrzeń nazw.</param>
        <summary><see cref="T:System.Type" /> Pobiera o podanej nazwie, wykonując wyszukiwanie z uwzględnieniem wielkości liter.</summary>
        <returns>Typ o określonej nazwie, jeśli znaleziono; w przeciwnym razie. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć metody, <xref:System.Type.GetType%2A> aby <xref:System.Type> uzyskać obiekt dla typu w innym zestawie, jeśli znana jest jego kwalifikowana nazwa zestawu, którą można uzyskać z <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A>powoduje załadowanie zestawu określonego w `typeName`. Możesz również załadować zestaw przy <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> użyciu metody, a następnie <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> użyć metody lub <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> , aby pobrać <xref:System.Type> obiekty. Jeśli typ znajduje się w zestawie znanym dla programu w czasie kompilacji, jest bardziej wydajny do użycia `typeof` w programie C# lub `GetType` w operatorze w Visual Basic.
  
> [!NOTE]
>  Jeśli `typeName` nie można znaleźć, wywołanie <xref:System.Type.GetType%28System.String%29> metody zwróci wartość `null`. Nie zgłasza wyjątku. Aby określić, czy wyjątek jest zgłaszany, wywołaj Przeciążenie <xref:System.Type.GetType%2A> metody, która `throwOnError` ma parametr.  
  
 <xref:System.Type.GetType%2A>działa tylko na zestawach załadowanych z dysku. Jeśli wywołasz <xref:System.Type.GetType%2A> wyszukiwanie typu zdefiniowanego w zestawie dynamicznym zdefiniowanym <xref:System.Reflection.Emit> za pomocą usług, możesz uzyskać niespójne zachowanie. Zachowanie zależy od tego, czy zestaw dynamiczny jest trwały, który jest tworzony przy użyciu `RunAndSave` trybów <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> dostępu `Save` do programu lub. Jeśli dynamiczny zestaw jest trwały i został zapisany na dysku przed `GetType` wywołaniem, moduł ładujący odnajdzie zapisany zestaw na dysku, ładuje ten zestaw i pobiera typ z tego zestawu. Jeśli zestaw nie został zapisany na dysku, gdy `GetType` jest wywoływana, metoda zwraca. `null` `GetType`nie rozpoznaje przejściowych zestawów dynamicznych; w związku z `GetType` tym, wywołanie w celu pobrania typu w przejściowym `null`dynamicznym zestawie zwraca.  
  
 Aby skorzystać `GetType` z modułu dynamicznego, zasubskrybuj <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> zdarzenie i Wywołaj `GetType` przed zapisaniem. W przeciwnym razie otrzymasz dwie kopie zestawu w pamięci.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy bazowej są zwracane przez `Get` metody podczas odzwierciedlania typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Tablice lub typy COM nie są przeszukiwane, chyba że zostały już załadowane do tabeli dostępnych klas.  
  
 `typeName`może to być nazwa typu kwalifikowana przez jego przestrzeń nazw lub kwalifikowana dla zestawu nazwa zestawu. Zobacz <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Jeśli `typeName` zawiera przestrzeń nazw, ale nie nazwę zestawu, ta metoda przeszukuje tylko zestaw obiektów wywołujących i mscorlib. dll w tej kolejności. Jeśli właściwość typeName jest w pełni kwalifikowana z częściową lub kompletną nazwą zestawu, ta metoda wyszukuje w określonym zestawie. Jeśli zestaw ma silną nazwę, wymagana jest pełna nazwa zestawu.  
  
 <xref:System.Type.AssemblyQualifiedName%2A> Właściwość zwraca w pełni kwalifikowaną nazwę typu, w tym typy zagnieżdżone, nazwę zestawu i argumenty typu ogólnego. Wszystkie kompilatory, które obsługują aparat plików wykonywalnych języka wspólnego, w trakcie wykonania wyemitują prostą nazwę klasy zagnieżdżonej, a odbicie podczas kwerendy stworzy zniekształcone nazwy zgodnie z następującymi konwencjami.  
  
> [!NOTE]
>  W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw. Na przykład "ProcessorArchitecture = msil". Nie jest on jednak uwzględniony w ciągu zwracanym przez <xref:System.Type.AssemblyQualifiedName%2A> właściwość, ze względu na zgodność. Możesz również ładować typy przez utworzenie <xref:System.Reflection.AssemblyName> obiektu i przekazanie go do odpowiedniego przeciążenia <xref:System.Reflection.Assembly.Load%2A> metody. Następnie można użyć <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> metody do załadowania typów z zestawu. Zobacz też <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Ogranicznik|Znaczenie|  
|---------------|-------------|  
|Ukośnik odwrotny\\()|Znak ucieczki.|  
|Taktowanie (")|Poprzedza co najmniej jedną cyfrę reprezentującą liczbę parametrów typu, które znajdują się na końcu nazwy typu ogólnego.|  
|Nawiasy kwadratowe ([])|Ujmij listę argumentów typu ogólnego dla konstruowanego typu ogólnego; w obrębie listy argumentów typu należy ująć Typ kwalifikowana zestawu.|  
|Przecinek (,)|Poprzedza nazwę zestawu.|  
|Kropka (.)|Wskazuje przestrzeń nazw identyfikatorów.|  
|Znak plus (+)|Poprzedza klasę zagnieżdżoną.|  
  
 Na przykład w pełni kwalifikowana nazwa klasy może wyglądać następująco:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Jeśli przestrzeń nazw była TopNamespace. Sub +, a następnie ciąg musi poprzedzać znak plus (+) znakiem ucieczki (\\), aby zapobiec interpretowaniu go jako separatora zagnieżdżania. Odbicie emituje ten ciąg w następujący sposób:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 "+ +" Przyjmuje wartość "\\+\\\\+\\",a""zmienia\\się "".  
  
 Ta kwalifikowana nazwa może zostać utrwalona i później użyta do <xref:System.Type>załadowania. Aby wyszukać i załadować <xref:System.Type>obiekt, <xref:System.Type.GetType%2A> Użyj albo z nazwą typu lub z kwalifikowaną nazwą typu zestawu. <xref:System.Type.GetType%2A>Nazwa typu będzie wyglądała tylko <xref:System.Type> w odniesieniu do zestawu wywołującego, a następnie w zestawie systemowym. <xref:System.Type.GetType%2A>z nazwą typu kwalifikowanego zestawu będzie wyglądała <xref:System.Type> w dowolnym zestawie.  
  
 Nazwy typów mogą obejmować końcowe znaki, które wyznaczają dodatkowe informacje dotyczące typu, na przykład to, czy typ jest typem odwołania, typem wskaźnika lub typem tablicowym. Aby pobrać nazwę typu bez znaków końcowych, należy użyć `t.GetElementType().ToString()`, gdzie `t` jest typem.  
  
 Spacje są istotne we wszystkich składnikach nazwy z wyjątkiem nazwy zestawu. Spacje przed separatorem w nazwie zestawu ',' są istotne, ale spacje po separatorze ',' są ignorowane.  
  
 Nazwa typu ogólnego jest kończąca się znakiem kreski (\`), po którym następuje cyfra reprezentująca liczbę argumentów typu ogólnego. Celem tej nazwy dekorowanie jest umożliwienie kompilatorom obsługi typów ogólnych o tej samej nazwie, ale z różnymi liczbami parametrów typu, występujących w tym samym zakresie. Na `Tuple`przykład odbicie zwraca spójną` and ` `Tuple(Of T)` `2` zniekształcona nazw 1 z metod ogólnych i `Tuple(Of T0, T1)` w Visual Basic lub `Tuple<T>` i krotek`\<T0, T1>` w wizualizacji. C#  
  
 W przypadku typów ogólnych lista argumentów typu jest ujęta w nawiasy, a argumenty typu są rozdzielone przecinkami. Na przykład generyczne <xref:System.Collections.Generic.Dictionary%602> ma dwa parametry typu. Z z kluczami typu <xref:System.String> mogą być reprezentowane w następujący sposób: `MyType` <xref:System.Collections.Generic.Dictionary%602>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Aby określić typ kwalifikowana dla zestawu wewnątrz listy argumentów typu, należy ująć w nawiasy Typ kwalifikowana dla zestawu. W przeciwnym razie przecinki oddzielające części nazwy kwalifikowanej do zestawu są interpretowane jako ogranicznik dodatkowych argumentów typu. Na przykład <xref:System.Collections.Generic.Dictionary%602> `MyType` , z fromMyAssembly. dll, z kluczami typu <xref:System.String>, można określić w następujący sposób:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Typ kwalifikowany przez zestaw może być ujęty w nawiasy kwadratowe tylko wtedy, gdy pojawia się na liście parametrów typu. Reguły wyszukiwania zestawów dla kwalifikowanych i niekwalifikowanych typów na listach parametrów typu są takie same jak reguły dla typów kwalifikowanych i niekwalifikowanych.  
  
 Typy dopuszczające wartości null są szczególnym przypadkiem typów ogólnych. Na przykład wartość null <xref:System.Int32> jest reprezentowana przez ciąg "System. Nullable" 1 [System. Int32] ".  
  
> [!NOTE]
>  W C#, C++i Visual Basic można również uzyskać Typy dopuszczające wartości null przy użyciu operatorów typu. Na przykład typ dopuszczający <xref:System.Boolean> wartość null jest zwracany `typeof(Nullable<bool>)` przez C#w, `Nullable<Boolean>::typeid` C++w i `GetType(Nullable(Of Boolean))` w Visual Basic.  
  
 W poniższej tabeli przedstawiono składnię używaną `GetType` w przypadku różnych typów.  
  
|Aby uzyskać|Zastosowanie|  
|------------|---------|  
|Wartość null<xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Niezarządzany wskaźnik do`MyType`|`Type.GetType("MyType*")`|  
|Niezarządzany wskaźnik do wskaźnika do`MyType`|`Type.GetType("MyType**")`|  
|Zarządzany wskaźnik lub odwołanie do`MyType`|`Type.GetType("MyType&")`. Należy pamiętać, że w przeciwieństwie do wskaźników, odwołania są ograniczone do jednego poziomu.|  
|Klasa nadrzędna i Klasa zagnieżdżona|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Jednowymiarowa tablica z dolną granicą 0|`Type.GetType("MyType[]")`|  
|Tablica jednowymiarowa z nieznanym dolnym ograniczeniem|`Type.GetType("MyType[*]")`|  
|Tablica n-wymiarowa|Przecinek (,) wewnątrz nawiasów łącznie z n-1 razy. Na przykład `System.Object[,,]` reprezentuje `Object` tablicę trójwymiarową.|  
|Tablica tablic jednowymiarowych|`Type.GetType("MyType[][]")`|  
|Prostokątna Dwuwymiarowa tablica z nieznanymi dolnymi granicami|`Type.GetType("MyType[,]")`|  
|Typ ogólny z jednym argumentem typu|``Type.GetType("MyGenericType`1[MyType]")``|  
|Typ ogólny z dwoma argumentami typu|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|Typ ogólny z dwoma argumentami typu kwalifikowana dla zestawu|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|Typ ogólny kwalifikowana dla zestawu z argumentem typu kwalifikowana dla zestawu|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|Typ ogólny, którego argument typu jest typem ogólnym z dwoma argumentami typu|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 Poniższy przykład pobiera typ `System.Int32` i używa tego obiektu typu do <xref:System.Type.FullName%2A> wyświetlania właściwości `System.Int32`.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" />reprezentuje typ ogólny, który ma typ wskaźnika, <see langword="ByRef" /> typ lub <see cref="T:System.Void" /> jako jeden z argumentów typu.  
  
—lub— 
 <paramref name="typeName" />reprezentuje typ ogólny, który ma niepoprawną liczbę argumentów typu.  
  
—lub— 
 <paramref name="typeName" />reprezentuje typ ogólny, a jeden z jego argumentów typu nie spełnia ograniczeń dla odpowiadającego parametru typu.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" />reprezentuje tablicę <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 W programie <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET dla aplikacji ze sklepu Windows</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">przenośnej biblioteki klas</see>Przechwyć wyjątek <see cref="T:System.IO.IOException" />klasy bazowej, zamiast tego.  
  
</para>
          </block>  
  
 Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.  
  
 —lub—  
  
 Obecnie jest załadowana wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego, a zestaw został skompilowany przy użyciu nowszej wersji.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Określanie w pełni kwalifikowanych nazw typów</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Kwalifikowana dla zestawu nazwa typu do pobrania. Zobacz <see cref="P:System.Type.AssemblyQualifiedName" />. Jeśli typ znajduje się w aktualnie wykonywanym zestawie lub w bibliotece Mscorlib. dll, wystarczy podać nazwę typu kwalifikowana przez jego przestrzeń nazw.</param>
        <param name="throwOnError"><see langword="true" />Aby zgłosić wyjątek, jeśli nie można znaleźć typu; <see langword="false" /> do zwrócenia <see langword="null" />. Określenie <see langword="false" /> również pomija inne warunki wyjątków, ale nie wszystkie z nich. Zobacz sekcję Wyjątki.</param>
        <summary><see cref="T:System.Type" /> Pobiera o podanej nazwie, wykonując wyszukiwanie z uwzględnieniem wielkości liter i określając, czy zgłaszać wyjątek, jeśli typ nie zostanie znaleziony.</summary>
        <returns>Typ o określonej nazwie. Jeśli typ nie zostanie znaleziony, <paramref name="throwOnError" /> parametr określa, czy jest zwracany, czy <see langword="null" /> zgłaszany jest wyjątek. W niektórych przypadkach wyjątek jest zgłaszany niezależnie od wartości <paramref name="throwOnError" />. Zobacz sekcję Wyjątki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć metody, <xref:System.Type.GetType%2A> aby <xref:System.Type> uzyskać obiekt dla typu w innym zestawie, jeśli znana jest jego kwalifikowana nazwa zestawu, którą można uzyskać z <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A>powoduje załadowanie zestawu określonego w `typeName`. Możesz również załadować zestaw przy <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> użyciu metody, a następnie <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> użyć metody lub <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> , aby pobrać <xref:System.Type> obiekty. Jeśli typ znajduje się w zestawie znanym dla programu w czasie kompilacji, jest bardziej wydajny do użycia `typeof` w programie C# lub `GetType` w operatorze w Visual Basic.
  
 `GetType`działa tylko na zestawach załadowanych z dysku. Jeśli wywołasz `GetType` wyszukiwanie typu zdefiniowanego w zestawie dynamicznym zdefiniowanym <xref:System.Reflection.Emit> za pomocą usług, możesz uzyskać niespójne zachowanie. Zachowanie zależy od tego, czy zestaw dynamiczny jest trwały, który jest tworzony przy użyciu `RunAndSave` trybów <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> dostępu `Save` do programu lub. Jeśli dynamiczny zestaw jest trwały i został zapisany na dysku przed `GetType` wywołaniem, moduł ładujący odnajdzie zapisany zestaw na dysku, ładuje ten zestaw i pobiera typ z tego zestawu. Jeśli zestaw nie został zapisany na dysku, gdy `GetType` jest wywoływana, metoda zwraca. `null` `GetType`nie rozpoznaje przejściowych zestawów dynamicznych; w związku z `GetType` tym, wywołanie w celu pobrania typu w przejściowym `null`dynamicznym zestawie zwraca.  
  
 Aby skorzystać `GetType` z modułu dynamicznego, zasubskrybuj <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> zdarzenie i Wywołaj `GetType` przed zapisaniem. W przeciwnym razie otrzymasz dwie kopie zestawu w pamięci.  
  
 `throwOnError` Parametr określa, co się dzieje, gdy typ nie zostanie znaleziony, a także pomija pewne inne warunki wyjątków, zgodnie z opisem w sekcji wyjątki. Niektóre wyjątki są zgłaszane niezależnie od wartości `throwOnError`. Na przykład, jeśli typ jest znaleziony, ale nie można go załadować, <xref:System.TypeLoadException> jest zgłaszany nawet `throwOnError` wtedy `false`, gdy jest.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy bazowej są zwracane przez `Get` metody podczas odzwierciedlania typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Tablice lub typy COM nie są przeszukiwane, chyba że zostały już załadowane do tabeli dostępnych klas.  
  
 `typeName`może to być nazwa typu kwalifikowana przez jego przestrzeń nazw lub kwalifikowana dla zestawu nazwa zestawu. Zobacz <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Jeśli `typeName` zawiera przestrzeń nazw, ale nie nazwę zestawu, ta metoda przeszukuje tylko zestaw obiektów wywołujących i mscorlib. dll w tej kolejności. Jeśli właściwość typeName jest w pełni kwalifikowana z częściową lub kompletną nazwą zestawu, ta metoda wyszukuje w określonym zestawie. Jeśli zestaw ma silną nazwę, wymagana jest pełna nazwa zestawu.  
  
 <xref:System.Type.AssemblyQualifiedName%2A> Właściwość zwraca w pełni kwalifikowaną nazwę typu, w tym typy zagnieżdżone, nazwę zestawu i argumenty ogólne. Wszystkie kompilatory, które obsługują aparat plików wykonywalnych języka wspólnego, w trakcie wykonania wyemitują prostą nazwę klasy zagnieżdżonej, a odbicie podczas kwerendy stworzy zniekształcone nazwy zgodnie z następującymi konwencjami.  
  
> [!NOTE]
>  W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw. Na przykład "ProcessorArchitecture = msil". Nie jest on jednak uwzględniony w ciągu zwracanym przez <xref:System.Type.AssemblyQualifiedName%2A> właściwość, ze względu na zgodność. Możesz również ładować typy przez utworzenie <xref:System.Reflection.AssemblyName> obiektu i przekazanie go do odpowiedniego przeciążenia <xref:System.Reflection.Assembly.Load%2A> metody. Następnie można użyć <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> metody do załadowania typów z zestawu. Zobacz też <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Ogranicznik|Znaczenie|  
|---------------|-------------|  
|Ukośnik odwrotny\\()|Znak ucieczki.|  
|Taktowanie (")|Poprzedza co najmniej jedną cyfrę reprezentującą liczbę parametrów typu, które znajdują się na końcu nazwy typu ogólnego.|  
|Nawiasy kwadratowe ([])|Ujmij listę argumentów typu ogólnego dla konstruowanego typu ogólnego; w obrębie listy argumentów typu należy ująć Typ kwalifikowana zestawu.|  
|Przecinek (,)|Poprzedza nazwę zestawu.|  
|Kropka (.)|Wskazuje przestrzeń nazw identyfikatorów.|  
|Znak plus (+)|Poprzedza klasę zagnieżdżoną.|  
  
 Na przykład w pełni kwalifikowana nazwa klasy może wyglądać następująco:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Jeśli przestrzeń nazw była TopNamespace. Sub +, a następnie ciąg musi poprzedzać znak plus (+) znakiem ucieczki (\\), aby zapobiec interpretowaniu go jako separatora zagnieżdżania. Odbicie emituje ten ciąg w następujący sposób:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 "+ +" Przyjmuje wartość "\\+\\\\+\\",a""zmienia\\się "".  
  
 Ta kwalifikowana nazwa może zostać utrwalona i później użyta do <xref:System.Type>załadowania. Aby wyszukać i załadować <xref:System.Type>obiekt, <xref:System.Type.GetType%2A> Użyj albo z nazwą typu lub z kwalifikowaną nazwą typu zestawu. <xref:System.Type.GetType%2A>Nazwa typu będzie wyglądała tylko <xref:System.Type> w odniesieniu do zestawu wywołującego, a następnie w zestawie systemowym. <xref:System.Type.GetType%2A>z nazwą typu kwalifikowanego zestawu będzie wyglądała <xref:System.Type> w dowolnym zestawie.  
  
 Nazwy typów mogą obejmować końcowe znaki, które wyznaczają dodatkowe informacje dotyczące typu, na przykład to, czy typ jest typem odwołania, typem wskaźnika lub typem tablicowym. Aby pobrać nazwę typu bez znaków końcowych, należy użyć `t.GetElementType().ToString()`, gdzie `t` jest typem.  
  
 Spacje są istotne we wszystkich składnikach nazwy z wyjątkiem nazwy zestawu. Spacje przed separatorem w nazwie zestawu ',' są istotne, ale spacje po separatorze ',' są ignorowane.  
  
 Nazwa typu ogólnego jest kończąca się znakiem kreski (\`), po którym następuje cyfra reprezentująca liczbę argumentów typu ogólnego. Celem tej nazwy dekorowanie jest umożliwienie kompilatorom obsługi typów ogólnych o tej samej nazwie, ale z różnymi liczbami parametrów typu, występujących w tym samym zakresie. Na `Tuple`przykład odbicie zwraca spójną` and ` `Tuple(Of T)` `2` zniekształcona nazw 1 z metod ogólnych i `Tuple(Of T0, T1)` w Visual Basic lub `Tuple<T>` i krotek`\<T0, T1>` w wizualizacji. C#  
  
 W przypadku typów ogólnych lista argumentów typu jest ujęta w nawiasy, a argumenty typu są rozdzielone przecinkami. Na przykład generyczne <xref:System.Collections.Generic.Dictionary%602> ma dwa parametry typu. Z z kluczami typu <xref:System.String> mogą być reprezentowane w następujący sposób: `MyType` <xref:System.Collections.Generic.Dictionary%602>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Aby określić typ kwalifikowana dla zestawu wewnątrz listy argumentów typu, należy ująć w nawiasy Typ kwalifikowana dla zestawu. W przeciwnym razie przecinki oddzielające części nazwy kwalifikowanej do zestawu są interpretowane jako ogranicznik dodatkowych argumentów typu. Na przykład <xref:System.Collections.Generic.Dictionary%602> `MyType` , z z pliku z klasy. dll, z kluczami typu <xref:System.String>, można określić w następujący sposób:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Typ kwalifikowany przez zestaw może być ujęty w nawiasy kwadratowe tylko wtedy, gdy pojawia się na liście parametrów typu. Reguły wyszukiwania zestawów dla kwalifikowanych i niekwalifikowanych typów na listach parametrów typu są takie same jak reguły dla typów kwalifikowanych i niekwalifikowanych.  
  
 Typy dopuszczające wartości null są szczególnym przypadkiem typów ogólnych. Na przykład wartość null <xref:System.Int32> jest reprezentowana przez ciąg "System. Nullable" 1 [System. Int32] ".  
  
> [!NOTE]
>  W C#, C++i Visual Basic można również uzyskać Typy dopuszczające wartości null przy użyciu operatorów typu. Na przykład typ dopuszczający <xref:System.Boolean> wartość null jest zwracany `typeof(Nullable<bool>)` przez C#w, `Nullable<Boolean>::typeid` C++w i `GetType(Nullable(Of Boolean))` w Visual Basic.  
  
 W poniższej tabeli przedstawiono składnię używaną `GetType` w przypadku różnych typów.  
  
|Aby uzyskać|Zastosowanie|  
|------------|---------|  
|Wartość null<xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Niezarządzany wskaźnik do`MyType`|`Type.GetType("MyType*")`|  
|Niezarządzany wskaźnik do wskaźnika do`MyType`|`Type.GetType("MyType**")`|  
|Zarządzany wskaźnik lub odwołanie do`MyType`|`Type.GetType("MyType&")`. Należy pamiętać, że w przeciwieństwie do wskaźników, odwołania są ograniczone do jednego poziomu.|  
|Klasa nadrzędna i Klasa zagnieżdżona|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Jednowymiarowa tablica z dolną granicą 0|`Type.GetType("MyArray[]")`|  
|Tablica jednowymiarowa z nieznanym dolnym ograniczeniem|`Type.GetType("MyArray[*]")`|  
|Tablica n-wymiarowa|Przecinek (,) wewnątrz nawiasów łącznie z n-1 razy. Na przykład `System.Object[,,]` reprezentuje `Object` tablicę trójwymiarową.|  
|Tablica dwuwymiarowa macierzy|`Type.GetType("MyArray[][]")`|  
|Prostokątna Dwuwymiarowa tablica z nieznanymi dolnymi granicami|`Type.GetType("MyArray[,]")`|  
|Typ ogólny z jednym argumentem typu|``Type.GetType("MyGenericType`1[MyType]")``|  
|Typ ogólny z dwoma argumentami typu|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|Typ ogólny z dwoma argumentami typu kwalifikowana dla zestawu|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|Typ ogólny kwalifikowana dla zestawu z argumentem typu kwalifikowana dla zestawu|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|Typ ogólny, którego argument typu jest typem ogólnym z dwoma argumentami typu|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 Poniższy przykład pobiera typ `System.Int32` i używa tego obiektu typu do <xref:System.Type.FullName%2A> wyświetlania właściwości `System.Int32`. Jeśli obiekt typu odwołuje się do zestawu, który nie istnieje, w tym przykładzie zgłasza wyjątek.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" />jest <see langword="true" /> i nie znaleziono typu.  
  
—lub— 
 <paramref name="throwOnError" />ma <see langword="true" /> i<paramref name="typeName" /> zawiera nieprawidłowe znaki, takie jak karta osadzona. 
—lub— 
 <paramref name="throwOnError" />jest <see langword="true" /> i<paramref name="typeName" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="throwOnError" />is <see langword="true" /> i<paramref name="typeName" /> reprezentuje typ tablicy o nieprawidłowym rozmiarze.  
  
—lub— 
 <paramref name="typeName" />reprezentuje tablicę <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" />ma <see langword="true" /> i<paramref name="typeName" /> zawiera nieprawidłową składnię. Na przykład "MyType [, *,]".  
  
—lub— 
 <paramref name="typeName" />reprezentuje typ ogólny, który ma typ wskaźnika, <see langword="ByRef" /> typ lub <see cref="T:System.Void" /> jako jeden z argumentów typu.  
  
—lub— 
 <paramref name="typeName" />reprezentuje typ ogólny, który ma niepoprawną liczbę argumentów typu.  
  
—lub— 
 <paramref name="typeName" />reprezentuje typ ogólny, a jeden z jego argumentów typu nie spełnia ograniczeń dla odpowiadającego parametru typu.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" />jest <see langword="true" /> i nie znaleziono zestawu lub jednej z jego zależności.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 W programie <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET dla aplikacji ze sklepu Windows</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">przenośnej biblioteki klas</see>Przechwyć wyjątek <see cref="T:System.IO.IOException" />klasy bazowej, zamiast tego.  
  
</para>
          </block>  
  
 Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.  
  
 —lub—  
  
 Obecnie jest załadowana wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego, a zestaw został skompilowany przy użyciu nowszej wersji.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Określanie w pełni kwalifikowanych nazw typów</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typeName">Kwalifikowana dla zestawu nazwa typu do pobrania. Zobacz <see cref="P:System.Type.AssemblyQualifiedName" />. Jeśli typ znajduje się w aktualnie wykonywanym zestawie lub w bibliotece Mscorlib. dll, wystarczy podać nazwę typu kwalifikowana przez jego przestrzeń nazw.</param>
        <param name="throwOnError"><see langword="true" />Aby zgłosić wyjątek, jeśli nie można znaleźć typu; <see langword="false" /> do zwrócenia <see langword="null" />. Określenie <see langword="false" /> również pomija inne warunki wyjątków, ale nie wszystkie z nich. Zobacz sekcję Wyjątki.</param>
        <param name="ignoreCase"><see langword="true" />Aby wykonać wyszukiwanie w poszukiwaniu wielkości liter dla <paramref name="typeName" />, <see langword="false" /> należy wykonać wyszukiwanie <paramref name="typeName" />z uwzględnieniem wielkości liter.</param>
        <summary><see cref="T:System.Type" /> Pobiera o podanej nazwie, określając, czy zgłaszać wyjątek, jeśli typ nie zostanie znaleziony i czy ma być wykonywane wyszukiwanie z uwzględnieniem wielkości liter.</summary>
        <returns>Typ o określonej nazwie. Jeśli typ nie zostanie znaleziony, <paramref name="throwOnError" /> parametr określa, czy jest zwracany, czy <see langword="null" /> zgłaszany jest wyjątek. W niektórych przypadkach wyjątek jest zgłaszany niezależnie od wartości <paramref name="throwOnError" />. Zobacz sekcję Wyjątki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć metody, <xref:System.Type.GetType%2A> aby <xref:System.Type> uzyskać obiekt dla typu w innym zestawie, jeśli znana jest jego kwalifikowana nazwa zestawu, którą można uzyskać z <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A>powoduje załadowanie zestawu określonego w `typeName`. Możesz również załadować zestaw przy <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> użyciu metody, a następnie <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> użyć metody lub <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> , aby pobrać <xref:System.Type> obiekty. Jeśli typ znajduje się w zestawie znanym dla programu w czasie kompilacji, jest bardziej wydajny do użycia `typeof` w programie C# lub `GetType` w operatorze w Visual Basic.
  
 `GetType`działa tylko na zestawach załadowanych z dysku. Jeśli wywołasz `GetType` wyszukiwanie typu zdefiniowanego w zestawie dynamicznym zdefiniowanym <xref:System.Reflection.Emit> za pomocą usług, możesz uzyskać niespójne zachowanie. Zachowanie zależy od tego, czy zestaw dynamiczny jest trwały, który jest tworzony przy użyciu `RunAndSave` trybów <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> dostępu `Save` do programu lub. Jeśli dynamiczny zestaw jest trwały i został zapisany na dysku przed `GetType` wywołaniem, moduł ładujący odnajdzie zapisany zestaw na dysku, ładuje ten zestaw i pobiera typ z tego zestawu. Jeśli zestaw nie został zapisany na dysku, gdy `GetType` jest wywoływana, metoda zwraca. `null` `GetType`nie rozpoznaje przejściowych zestawów dynamicznych; w związku z `GetType` tym, wywołanie w celu pobrania typu w przejściowym `null`dynamicznym zestawie zwraca.  
  
 Aby skorzystać `GetType` z modułu dynamicznego, zasubskrybuj <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> zdarzenie i Wywołaj `GetType` przed zapisaniem. W przeciwnym razie otrzymasz dwie kopie zestawu w pamięci.  
  
 `throwOnError` Parametr określa, co się dzieje, gdy typ nie zostanie znaleziony, a także pomija pewne inne warunki wyjątków, zgodnie z opisem w sekcji wyjątki. Niektóre wyjątki są zgłaszane niezależnie od wartości `throwOnError`. Na przykład, jeśli typ jest znaleziony, ale nie można go załadować, <xref:System.TypeLoadException> jest zgłaszany nawet `throwOnError` wtedy `false`, gdy jest.  
  
 W poniższej tabeli przedstawiono, jakie elementy członkowskie klasy bazowej są zwracane przez `Get` metody podczas odzwierciedlania typu.  
  
|Typ elementu członkowskiego|Static|Niestatyczna|  
|-----------------|------------|-----------------|  
|Konstruktor|Nie|Nie|  
|Pole|Nie|Tak. Pole jest zawsze ukryte przez nazwę i podpis.|  
|Zdarzenie|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
|Metoda|Nie|Tak. Metodą (zarówno wirtualną, jak i niewirtualną) może być ukrycie przez nazwę lub przez nazwę i podpis.|  
|Typu zagnieżdżony|Nie|Nie|  
|Właściwość|Nie dotyczy|Zasadą systemu typu jest to, że dziedziczenie jest takie samo, jak w przypadku metod, które implementują właściwość. Odbicie traktuje właściwości jako ukryte przez nazwę i podpis. Patrz Uwaga 2 poniżej.|  
  
1.  Ukrycie przez nazwę i podpis dotyczy wszystkich części podpisu, w tym modyfikatorów niestandardowych, zwraca typy, typy parametrów, wartowników i niezarządzane konwencje wywoływania. To jest porównanie binarne.  
  
2.  W celu odbicia właściwości i zdarzenia są ukrywane przez nazwę i podpis. Jeśli istnieje właściwość z akcesorem pobierania i ustawiania w klasie bazowej, ale odziedziczona klasa ma tylko akcesor pobierania, właściwość klasy odziedziczonej ukrywa właściwości klasy bazowej, a nie można uzyskać dostępu do metody ustawiającej w klasie bazowej.  
  
3.  Atrybuty niestandardowe nie są częścią wspólnego typu systemowego.  
  
 Tablice lub typy COM nie są przeszukiwane, chyba że zostały już załadowane do tabeli dostępnych klas.  
  
 `typeName`może to być nazwa typu kwalifikowana przez jego przestrzeń nazw lub kwalifikowana dla zestawu nazwa zestawu. Zobacz <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Jeśli `typeName` zawiera przestrzeń nazw, ale nie nazwę zestawu, ta metoda przeszukuje tylko zestaw obiektów wywołujących i mscorlib. dll w tej kolejności. Jeśli właściwość typeName jest w pełni kwalifikowana z częściową lub kompletną nazwą zestawu, ta metoda wyszukuje w określonym zestawie. Jeśli zestaw ma silną nazwę, wymagana jest pełna nazwa zestawu.  
  
 <xref:System.Type.AssemblyQualifiedName%2A> Właściwość zwraca w pełni kwalifikowaną nazwę typu, w tym typy zagnieżdżone, nazwę zestawu i argumenty typu. Wszystkie kompilatory, które obsługują aparat plików wykonywalnych języka wspólnego, w trakcie wykonania wyemitują prostą nazwę klasy zagnieżdżonej, a odbicie podczas kwerendy stworzy zniekształcone nazwy zgodnie z następującymi konwencjami.  
  
> [!NOTE]
>  W wersji 2.0 środowiska .NET Framework architektura procesora jest dodawana do tożsamości zestawu i może być określona jako część zestawu ciągu nazw. Na przykład "ProcessorArchitecture = msil". Nie jest on jednak uwzględniony w ciągu zwracanym przez <xref:System.Type.AssemblyQualifiedName%2A> właściwość, ze względu na zgodność. Możesz również ładować typy przez utworzenie <xref:System.Reflection.AssemblyName> obiektu i przekazanie go do odpowiedniego przeciążenia <xref:System.Reflection.Assembly.Load%2A> metody. Następnie można użyć <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> metody do załadowania typów z zestawu. Zobacz też <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Ogranicznik|Znaczenie|  
|---------------|-------------|  
|Ukośnik odwrotny\\()|Znak ucieczki.|  
|Taktowanie (")|Poprzedza co najmniej jedną cyfrę reprezentującą liczbę parametrów typu, które znajdują się na końcu nazwy typu ogólnego.|  
|Nawiasy kwadratowe ([])|Ujmij listę argumentów typu ogólnego dla konstruowanego typu ogólnego; w obrębie listy argumentów typu należy ująć Typ kwalifikowana zestawu.|  
|Przecinek (,)|Poprzedza nazwę zestawu.|  
|Kropka (.)|Wskazuje przestrzeń nazw identyfikatorów.|  
|Znak plus (+)|Poprzedza klasę zagnieżdżoną.|  
  
 Na przykład w pełni kwalifikowana nazwa klasy może wyglądać następująco:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Jeśli przestrzeń nazw była TopNamespace. Sub +, a następnie ciąg musi poprzedzać znak plus (+) znakiem ucieczki (\\), aby zapobiec interpretowaniu go jako separatora zagnieżdżania. Odbicie emituje ten ciąg w następujący sposób:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 "+ +" Przyjmuje wartość "\\+\\\\+\\",a""zmienia\\się "".  
  
 Ta kwalifikowana nazwa może zostać utrwalona i później użyta do <xref:System.Type>załadowania. Aby wyszukać i załadować <xref:System.Type>obiekt, <xref:System.Type.GetType%2A> Użyj albo z nazwą typu lub z kwalifikowaną nazwą typu zestawu. <xref:System.Type.GetType%2A>Nazwa typu będzie wyglądała tylko <xref:System.Type> w odniesieniu do zestawu wywołującego, a następnie w zestawie systemowym. <xref:System.Type.GetType%2A>z nazwą typu kwalifikowanego zestawu będzie wyglądała <xref:System.Type> w dowolnym zestawie.  
  
 Nazwy typów mogą obejmować końcowe znaki, które wyznaczają dodatkowe informacje dotyczące typu, na przykład to, czy typ jest typem odwołania, typem wskaźnika lub typem tablicowym. Aby pobrać nazwę typu bez znaków końcowych, należy użyć `t.GetElementType().ToString()`, gdzie `t` jest typem.  
  
 Spacje są istotne we wszystkich składnikach nazwy z wyjątkiem nazwy zestawu. Spacje przed separatorem w nazwie zestawu ',' są istotne, ale spacje po separatorze ',' są ignorowane.  
  
 Nazwa typu ogólnego jest kończąca się znakiem kreski (\`), po którym następuje cyfra reprezentująca liczbę argumentów typu ogólnego. Celem tej nazwy dekorowanie jest umożliwienie kompilatorom obsługi typów ogólnych o tej samej nazwie, ale z różnymi liczbami parametrów typu, występujących w tym samym zakresie. Na `Tuple`przykład odbicie zwraca spójną` and ` `Tuple(Of T)` `2` zniekształcona nazw 1 z metod ogólnych i `Tuple(Of T0, T1)` w Visual Basic lub `Tuple<T>` i krotek`\<T0, T1>` w wizualizacji. C#  
  
 W przypadku typów ogólnych lista argumentów typu jest ujęta w nawiasy, a argumenty typu są rozdzielone przecinkami. Na przykład generyczne <xref:System.Collections.Generic.Dictionary%602> ma dwa parametry typu. Z z kluczami typu <xref:System.String> mogą być reprezentowane w następujący sposób: `MyType` <xref:System.Collections.Generic.Dictionary%602>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Aby określić typ kwalifikowana dla zestawu wewnątrz listy argumentów typu, należy ująć w nawiasy Typ kwalifikowana dla zestawu. W przeciwnym razie przecinki oddzielające części nazwy kwalifikowanej do zestawu są interpretowane jako ogranicznik dodatkowych argumentów typu. Na przykład <xref:System.Collections.Generic.Dictionary%602> `MyType` , z z pliku z klasy. dll, z kluczami typu <xref:System.String>, można określić w następujący sposób:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Typ kwalifikowany przez zestaw może być ujęty w nawiasy kwadratowe tylko wtedy, gdy pojawia się na liście parametrów typu. Reguły wyszukiwania zestawów dla kwalifikowanych i niekwalifikowanych typów na listach parametrów typu są takie same jak reguły dla typów kwalifikowanych i niekwalifikowanych.  
  
 Typy dopuszczające wartości null są szczególnym przypadkiem typów ogólnych. Na przykład wartość null <xref:System.Int32> jest reprezentowana przez ciąg "System. Nullable" 1 [System. Int32] ".  
  
> [!NOTE]
>  W C#, C++i Visual Basic można również uzyskać Typy dopuszczające wartości null przy użyciu operatorów typu. Na przykład typ dopuszczający <xref:System.Boolean> wartość null jest zwracany `typeof(Nullable<bool>)` przez C#w, `Nullable<Boolean>::typeid` C++w i `GetType(Nullable(Of Boolean))` w Visual Basic.  
  
 W poniższej tabeli przedstawiono składnię używaną `GetType` w przypadku różnych typów.  
  
|Aby uzyskać|Zastosowanie|  
|------------|---------|  
|Wartość null<xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Niezarządzany wskaźnik do`MyType`|`Type.GetType("MyType*")`|  
|Niezarządzany wskaźnik do wskaźnika do`MyType`|`Type.GetType("MyType**")`|  
|Zarządzany wskaźnik lub odwołanie do`MyType`|`Type.GetType("MyType&")`. Należy pamiętać, że w przeciwieństwie do wskaźników, odwołania są ograniczone do jednego poziomu.|  
|Klasa nadrzędna i Klasa zagnieżdżona|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Jednowymiarowa tablica z dolną granicą 0|`Type.GetType("MyArray[]")`|  
|Tablica jednowymiarowa z nieznanym dolnym ograniczeniem|`Type.GetType("MyArray[*]")`|  
|Tablica n-wymiarowa|Przecinek (,) wewnątrz nawiasów łącznie z n-1 razy. Na przykład `System.Object[,,]` reprezentuje `Object` tablicę trójwymiarową.|  
|Tablica dwuwymiarowa macierzy|`Type.GetType("MyArray[][]")`|  
|Prostokątna Dwuwymiarowa tablica z nieznanymi dolnymi granicami|`Type.GetType("MyArray[,]")`|  
|Typ ogólny z jednym argumentem typu|``Type.GetType("MyGenericType`1[MyType]")``|  
|Typ ogólny z dwoma argumentami typu|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|Typ ogólny z dwoma argumentami typu kwalifikowana dla zestawu|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|Typ ogólny kwalifikowana dla zestawu z argumentem typu kwalifikowana dla zestawu|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|Typ ogólny, którego argument typu jest typem ogólnym z dwoma argumentami typu|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" />jest <see langword="true" /> i nie znaleziono typu.  
  
—lub— 
 <paramref name="throwOnError" />ma <see langword="true" /> i<paramref name="typeName" /> zawiera nieprawidłowe znaki, takie jak karta osadzona. 
—lub— 
 <paramref name="throwOnError" />jest <see langword="true" /> i<paramref name="typeName" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="throwOnError" />is <see langword="true" /> i<paramref name="typeName" /> reprezentuje typ tablicy o nieprawidłowym rozmiarze.  
  
—lub— 
 <paramref name="typeName" />reprezentuje tablicę <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" />ma <see langword="true" /> i<paramref name="typeName" /> zawiera nieprawidłową składnię. Na przykład "MyType [, *,]".  
  
—lub— 
 <paramref name="typeName" />reprezentuje typ ogólny, który ma typ wskaźnika, <see langword="ByRef" /> typ lub <see cref="T:System.Void" /> jako jeden z argumentów typu.  
  
—lub— 
 <paramref name="typeName" />reprezentuje typ ogólny, który ma niepoprawną liczbę argumentów typu.  
  
—lub— 
 <paramref name="typeName" />reprezentuje typ ogólny, a jeden z jego argumentów typu nie spełnia ograniczeń dla odpowiadającego parametru typu.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" />jest <see langword="true" /> i nie znaleziono zestawu lub jednej z jego zależności.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.  
  
 —lub—  
  
 Obecnie jest załadowana wersja 2,0 lub nowsza środowiska uruchomieniowego języka wspólnego, a zestaw został skompilowany przy użyciu nowszej wersji.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Określanie w pełni kwalifikowanych nazw typów</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa typu, który ma zostać pobrany. Jeśli parametr jest podany, nazwa typu może być dowolnym ciągiem, który <paramref name="typeResolver" /> jest w stanie rozwiązać. <paramref name="typeResolver" /> Jeśli parametr jest podany lub w przypadku używania rozdzielczości typu standardowego, <paramref name="typeName" /> musi być kwalifikowana nazwa zestawu (patrz <see cref="P:System.Type.AssemblyQualifiedName" />), chyba że typ znajduje się w aktualnie wykonywanym zestawie lub w bibliotece Mscorlib. dll, w takim przypadku jest to wystarczające do <paramref name="assemblyResolver" /> Podaj nazwę typu kwalifikowana przez jego przestrzeń nazw.</param>
        <param name="assemblyResolver">Metoda, która lokalizuje i zwraca zestaw, który jest określony w <paramref name="typeName" />. Nazwa zestawu jest przenoszona do <paramref name="assemblyResolver" /> <see cref="T:System.Reflection.AssemblyName" /> obiektu jako obiekt. Jeśli <paramref name="typeName" /> nie zawiera nazwy zestawu, <paramref name="assemblyResolver" /> nie jest wywoływana. Jeśli <paramref name="assemblyResolver" /> nie zostanie podany, zostanie wykonane standardowe rozpoznawanie zestawu.  
  
Przestroga nie przekazuje metod z nieznanych lub niezaufanych wywołujących. Wykonanie tej operacji może spowodować podniesienie uprawnień dla złośliwego kodu. Użyj tylko określonych przez siebie metod lub tych, które znasz.</param>
        <param name="typeResolver">Metoda, która lokalizuje i zwraca typ, który jest określony przez <paramref name="typeName" /> z zestawu, który jest zwracany przez <paramref name="assemblyResolver" /> lub przez standardowe rozpoznanie zestawu. Jeśli nie podano żadnego zestawu, <paramref name="typeResolver" /> Metoda może ją podać. Metoda pobiera również parametr, który określa, czy należy wykonać wyszukiwanie bez uwzględniania wielkości liter; <see langword="false" /> jest przenoszona do tego parametru.  
  
Przestroga nie przekazuje metod z nieznanych lub niezaufanych wywołujących.</param>
        <summary>Pobiera typ o określonej nazwie, opcjonalnie dostarczając metody niestandardowe do rozpoznawania zestawu i typu.</summary>
        <returns>Typ z określoną nazwą lub <see langword="null" /> Jeśli nie można odnaleźć typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Scenariusze użycia tej metody i szczegółowe informacje o `assemblyResolver` parametrach i `typeResolver` <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> można znaleźć w przeciążeniu metody.  
  
> [!NOTE]
>  Jeśli `typeName` nie można znaleźć, wywołanie <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> metody zwróci wartość `null`. Nie zgłasza wyjątku. Aby określić, czy wyjątek jest zgłaszany, wywołaj Przeciążenie <xref:System.Type.GetType%2A> metody, która `throwOnError` ma parametr.  
  
 Wywołanie tego przeciążenia metody jest takie samo jak <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> wywołanie przeciążenia metody i określanie `false` `throwOnError` parametrów i `ignoreCase` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.ArgumentException">Błąd występuje, gdy <paramref name="typeName" /> jest analizowany do nazwy typu i nazwy zestawu (na przykład, gdy nazwa typu prostego zawiera niezmieniony znak specjalny).  
  
—lub— 
 <paramref name="typeName" />reprezentuje typ ogólny, który ma typ wskaźnika, <see langword="ByRef" /> typ lub <see cref="T:System.Void" /> jako jeden z argumentów typu.  
  
—lub— 
 <paramref name="typeName" />reprezentuje typ ogólny, który ma niepoprawną liczbę argumentów typu.  
  
—lub— 
 <paramref name="typeName" />reprezentuje typ ogólny, a jeden z jego argumentów typu nie spełnia ograniczeń dla odpowiadającego parametru typu.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" />reprezentuje tablicę <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.  
  
—lub— 
 <paramref name="typeName" />zawiera nieprawidłową nazwę zestawu.  
  
—lub— 
 <paramref name="typeName" />jest prawidłową nazwą zestawu bez nazwy typu.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.  
  
 —lub—  
  
 Zestaw został skompilowany przy użyciu nowszej wersji aparatu plików wykonywalnych języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa typu, który ma zostać pobrany. Jeśli parametr jest podany, nazwa typu może być dowolnym ciągiem, który <paramref name="typeResolver" /> jest w stanie rozwiązać. <paramref name="typeResolver" /> Jeśli parametr jest podany lub w przypadku używania rozdzielczości typu standardowego, <paramref name="typeName" /> musi być kwalifikowana nazwa zestawu (patrz <see cref="P:System.Type.AssemblyQualifiedName" />), chyba że typ znajduje się w aktualnie wykonywanym zestawie lub w bibliotece Mscorlib. dll, w takim przypadku jest to wystarczające do <paramref name="assemblyResolver" /> Podaj nazwę typu kwalifikowana przez jego przestrzeń nazw.</param>
        <param name="assemblyResolver">Metoda, która lokalizuje i zwraca zestaw, który jest określony w <paramref name="typeName" />. Nazwa zestawu jest przenoszona do <paramref name="assemblyResolver" /> <see cref="T:System.Reflection.AssemblyName" /> obiektu jako obiekt. Jeśli <paramref name="typeName" /> nie zawiera nazwy zestawu, <paramref name="assemblyResolver" /> nie jest wywoływana. Jeśli <paramref name="assemblyResolver" /> nie zostanie podany, zostanie wykonane standardowe rozpoznawanie zestawu.  
  
Przestroga nie przekazuje metod z nieznanych lub niezaufanych wywołujących. Wykonanie tej operacji może spowodować podniesienie uprawnień dla złośliwego kodu. Użyj tylko określonych przez siebie metod lub tych, które znasz.</param>
        <param name="typeResolver">Metoda, która lokalizuje i zwraca typ, który jest określony przez <paramref name="typeName" /> z zestawu, który jest zwracany przez <paramref name="assemblyResolver" /> lub przez standardowe rozpoznanie zestawu. Jeśli nie podano żadnego zestawu, Metoda może ją podać. Metoda pobiera również parametr, który określa, czy należy wykonać wyszukiwanie bez uwzględniania wielkości liter; <see langword="false" /> jest przenoszona do tego parametru.  
  
Przestroga nie przekazuje metod z nieznanych lub niezaufanych wywołujących.</param>
        <param name="throwOnError"><see langword="true" />Aby zgłosić wyjątek, jeśli nie można znaleźć typu; <see langword="false" /> do zwrócenia <see langword="null" />. Określenie <see langword="false" /> również pomija inne warunki wyjątków, ale nie wszystkie z nich. Zobacz sekcję Wyjątki.</param>
        <summary>Pobiera typ o określonej nazwie, określając, czy zgłaszać wyjątek, jeśli nie można odnaleźć typu, i opcjonalnie dostarczając metody niestandardowe, aby rozpoznać zestaw i typ.</summary>
        <returns>Typ o określonej nazwie. Jeśli typ nie zostanie znaleziony, <paramref name="throwOnError" /> parametr określa, czy jest zwracany, czy <see langword="null" /> zgłaszany jest wyjątek. W niektórych przypadkach wyjątek jest zgłaszany niezależnie od wartości <paramref name="throwOnError" />. Zobacz sekcję Wyjątki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Scenariusze użycia tej metody i szczegółowe informacje o `assemblyResolver` parametrach i `typeResolver` <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> można znaleźć w przeciążeniu metody.  
  
 Wywołanie tego przeciążenia metody jest takie samo jak wywołanie <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> przeciążenia metody i określanie `false` dla `ignoreCase` parametru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" />jest <see langword="true" /> i nie znaleziono typu.  
  
—lub— 
 <paramref name="throwOnError" />ma <see langword="true" /> i<paramref name="typeName" /> zawiera nieprawidłowe znaki, takie jak karta osadzona. 
—lub— 
 <paramref name="throwOnError" />jest <see langword="true" /> i<paramref name="typeName" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="throwOnError" />is <see langword="true" /> i<paramref name="typeName" /> reprezentuje typ tablicy o nieprawidłowym rozmiarze.  
  
—lub— 
 <paramref name="typeName" />reprezentuje tablicę <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">Błąd występuje, gdy <paramref name="typeName" /> jest analizowany do nazwy typu i nazwy zestawu (na przykład, gdy nazwa typu prostego zawiera niezmieniony znak specjalny).  
  
—lub— 
 <paramref name="throwOnError" />ma <see langword="true" /> i<paramref name="typeName" /> zawiera nieprawidłową składnię (na przykład "MyType [, *,]").  
  
—lub— 
 <paramref name="typeName" />reprezentuje typ ogólny, który ma typ wskaźnika, <see langword="ByRef" /> typ lub <see cref="T:System.Void" /> jako jeden z argumentów typu.  
  
—lub— 
 <paramref name="typeName" />reprezentuje typ ogólny, który ma niepoprawną liczbę argumentów typu.  
  
—lub— 
 <paramref name="typeName" />reprezentuje typ ogólny, a jeden z jego argumentów typu nie spełnia ograniczeń dla odpowiadającego parametru typu.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" />jest <see langword="true" /> i nie znaleziono zestawu lub jednej z jego zależności.  
  
—lub— 
 <paramref name="typeName" />zawiera nieprawidłową nazwę zestawu.  
  
—lub— 
 <paramref name="typeName" />jest prawidłową nazwą zestawu bez nazwy typu.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.  
  
 —lub—  
  
 Zestaw został skompilowany przy użyciu nowszej wersji aparatu plików wykonywalnych języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">Nazwa typu, który ma zostać pobrany. Jeśli parametr jest podany, nazwa typu może być dowolnym ciągiem, który <paramref name="typeResolver" /> jest w stanie rozwiązać. <paramref name="typeResolver" /> Jeśli parametr jest podany lub w przypadku używania rozdzielczości typu standardowego, <paramref name="typeName" /> musi być kwalifikowana nazwa zestawu (patrz <see cref="P:System.Type.AssemblyQualifiedName" />), chyba że typ znajduje się w aktualnie wykonywanym zestawie lub w bibliotece Mscorlib. dll, w takim przypadku jest to wystarczające do <paramref name="assemblyResolver" /> Podaj nazwę typu kwalifikowana przez jego przestrzeń nazw.</param>
        <param name="assemblyResolver">Metoda, która lokalizuje i zwraca zestaw, który jest określony w <paramref name="typeName" />. Nazwa zestawu jest przenoszona do <paramref name="assemblyResolver" /> <see cref="T:System.Reflection.AssemblyName" /> obiektu jako obiekt. Jeśli <paramref name="typeName" /> nie zawiera nazwy zestawu, <paramref name="assemblyResolver" /> nie jest wywoływana. Jeśli <paramref name="assemblyResolver" /> nie zostanie podany, zostanie wykonane standardowe rozpoznawanie zestawu.  
  
Przestroga nie przekazuje metod z nieznanych lub niezaufanych wywołujących. Wykonanie tej operacji może spowodować podniesienie uprawnień dla złośliwego kodu. Użyj tylko określonych przez siebie metod lub tych, które znasz.</param>
        <param name="typeResolver">Metoda, która lokalizuje i zwraca typ, który jest określony przez <paramref name="typeName" /> z zestawu, który jest zwracany przez <paramref name="assemblyResolver" /> lub przez standardowe rozpoznanie zestawu. Jeśli nie podano żadnego zestawu, Metoda może ją podać. Metoda pobiera również parametr, który określa, czy należy wykonać wyszukiwanie bez uwzględniania wielkości liter; wartość <paramref name="ignoreCase" /> jest przenoszona do tego parametru.  
  
Przestroga nie przekazuje metod z nieznanych lub niezaufanych wywołujących.</param>
        <param name="throwOnError"><see langword="true" />Aby zgłosić wyjątek, jeśli nie można znaleźć typu; <see langword="false" /> do zwrócenia <see langword="null" />. Określenie <see langword="false" /> również pomija inne warunki wyjątków, ale nie wszystkie z nich. Zobacz sekcję Wyjątki.</param>
        <param name="ignoreCase"><see langword="true" />Aby wykonać wyszukiwanie w poszukiwaniu wielkości liter dla <paramref name="typeName" />, <see langword="false" /> należy wykonać wyszukiwanie <paramref name="typeName" />z uwzględnieniem wielkości liter.</param>
        <summary>Pobiera typ o określonej nazwie, określając, czy należy wykonać wyszukiwanie z uwzględnieniem wielkości liter i czy zgłaszać wyjątek, jeśli typ nie zostanie odnaleziony, i opcjonalnie dostarczając metody niestandardowe do rozpoznawania zestawu i typu.</summary>
        <returns>Typ o określonej nazwie. Jeśli typ nie zostanie znaleziony, <paramref name="throwOnError" /> parametr określa, czy jest zwracany, czy <see langword="null" /> zgłaszany jest wyjątek. W niektórych przypadkach wyjątek jest zgłaszany niezależnie od wartości <paramref name="throwOnError" />. Zobacz sekcję Wyjątki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia metody i skojarzonych z nim przeciążeń (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> i <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>), aby zastąpić domyślną <xref:System.Type.GetType%2A> implementację metody bardziej elastycznymi implementacjami. Dostarczając własne metody, które rozwiązują nazwy typów i nazwy zestawów, które je zawierają, można wykonać następujące czynności:  
  
-   Kontrolowanie wersji zestawu, z którego jest ładowany typ.  
  
-   Podaj inne miejsce, aby wyszukać nazwę typu, który nie zawiera nazwy zestawu.  
  
-   Ładowanie zestawów przy użyciu częściowych nazw zestawów.  
  
-   Zwracaj podklasy <xref:System.Type?displayProperty=nameWithType> , które nie są tworzone przez środowisko uruchomieniowe języka wspólnego (CLR).  
  
 Na przykład w przypadku serializacji odpornej na wersje ta metoda umożliwia wyszukanie zestawu "Najlepsza dopasowane" przy użyciu nazwy częściowej. Inne przeciążenia <xref:System.Type.GetType%2A> metody wymagają nazwy typu kwalifikowanego przez zestaw, która zawiera numer wersji.  
  
 Alternatywne implementacje systemu typów mogą wymagać zwrócenia podklas <xref:System.Type?displayProperty=nameWithType> , które nie są tworzone przez środowisko CLR; wszystkie typy, które są zwracane przez inne przeciążenia <xref:System.Type.GetType%2A> metody, są typami środowiska uruchomieniowego.  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>Uwagi dotyczące użytkowania  
 Ta metoda jest przeciążona i skojarzone przeciążenia `typeName` analizujeją nazwę typu i nazwę zestawu, a następnie rozwiązują nazwy. Rozpoznanie nazwy zestawu występuje przed rozpoznaniem nazwy typu, ponieważ nazwa typu musi być rozwiązany w kontekście zestawu.  
  
> [!NOTE]
>  Jeśli nie znasz koncepcji nazw typów kwalifikowanych do zestawu, zapoznaj się z <xref:System.Type.AssemblyQualifiedName%2A> właściwością.  
  
 Jeśli `typeName` nie jest nazwą kwalifikowaną dla zestawu, rozpoznawanie zestawu jest pomijane. Niekwalifikowane nazwy typów mogą być rozpoznawane w kontekście biblioteki mscorlib. dll lub aktualnie wykonywanego zestawu lub opcjonalnie można podać zestaw w `typeResolver` parametrze. Efekty dołączania lub pomijania nazwy zestawu dla różnych rodzajów rozpoznawania nazw są wyświetlane jako tabela w sekcji [rozpoznawanie nazw mieszanych](#mixed_name_resolution) .  
  
 Ogólne uwagi dotyczące użycia:  
  
-   Nie przekazuj metod do `assemblyResolver` lub, `typeResolver` jeśli pochodzą z nieznanych lub niezaufanych wywołujących. Użyj tylko określonych przez siebie metod lub tych, które znasz.  
  
    > [!CAUTION]
    >  Użycie metod z nieznanych lub niezaufanych wywołujących może spowodować podniesienie uprawnień dla złośliwego kodu.  
  
-   W przypadku pominięcia `assemblyResolver` parametrów i `typeResolver` /lub wartość `throwOnError` parametru jest przenoszona do metod, które wykonują domyślne rozwiązanie.  
  
-   Jeśli `throwOnError` jest `typeResolver` ,ta<xref:System.TypeLoadException> Metoda zwraca wartośćwhen<xref:System.IO.FileNotFoundException> , a gdy`assemblyResolver` zwraca. `null` `null` `true`  
  
-   Ta metoda nie przechwytuje wyjątków zgłaszanych `typeResolver`przez `assemblyResolver` i. Użytkownik jest odpowiedzialny za wszelkie wyjątki, które są zgłaszane przez metody rozpoznawania nazw.  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>Rozpoznawanie zespołów  
 Metoda odbiera obiekt, który jest wytwarzany przez analizowanie nazwy zestawu String, która jest zawarta `typeName`w. `assemblyResolver` <xref:System.Reflection.AssemblyName> Jeśli `typeName` nie zawiera nazwy zestawu, `assemblyResolver` nie jest wywoływana i `null` jest przenoszona do `typeResolver`.  
  
 Jeśli `assemblyResolver` nie zostanie podany, Standardowa sonda zestawu jest używana do lokalizowania zestawu. Jeśli `assemblyResolver` jest podany <xref:System.Type.GetType%2A> , metoda nie wykonuje standardowej procedury sondowania. w takim przypadku należy upewnić się, że `assemblyResolver` można obsługiwać wszystkie zestawy, które są do niego przekazywane.  
  
 Metoda powinna zostać zwrócona `null` , jeśli nie można rozpoznać zestawu. `assemblyResolver` Jeśli `assemblyResolver` zwraca `null`, `throwOnError` niejest`true`wywoływana i nie<xref:System.IO.FileNotFoundException> występuje dalsze przetwarzanie; dodatkowo, jeśli jest, jest zgłaszany. `typeResolver`  
  
 Jeśli przekazanie do `assemblyResolver` jest częściową nazwą, co najmniej jedna z jej części `null`jest. <xref:System.Reflection.AssemblyName> Na przykład jeśli nie ma wersji, <xref:System.Reflection.AssemblyName.Version%2A> właściwość jest. `null` Jeśli właściwość, właściwość i <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> Metoda wszystkie zwracają `null`, podano tylko prostą nazwę zestawu. <xref:System.Reflection.AssemblyName.CultureInfo%2A> <xref:System.Reflection.AssemblyName.Version%2A> `assemblyResolver` Metoda może używać lub ignorować wszystkie części nazwy zestawu.  
  
 Efekty różnych opcji rozpoznawania zestawu są wyświetlane jako tabela w sekcji [rozpoznawanie nazw mieszanych](#mixed_name_resolution) dla nazw prostych i kwalifikowanych do zestawu.  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>Rozpoznawanie typów  
 Jeśli `typeName` nazwa zestawu nie zostanie określona, `typeResolver` jest zawsze wywoływana. Jeśli `typeName` określa nazwę zestawu, `typeResolver` jest wywoływana tylko w przypadku pomyślnego rozpoznania nazwy zestawu. Jeśli `assemblyResolver` lub `null` standardowa`typeResolver` funkcja sondowania zestawu standardowego nie jest wywoływana.  
  
 `typeResolver` Metoda otrzymuje trzy argumenty:  
  
-   Zestaw do wyszukania `null` lub `typeName` , jeśli nie zawiera nazwy zestawu.  
  
-   Prosta nazwa typu. W przypadku typu zagnieżdżonego jest to najbardziej zewnętrzny typ zawierający. W przypadku typu ogólnego jest to prosta nazwa typu ogólnego.  
  
-   Wartość logiczna, która jest `true` , jeśli wielkość liter w nazwach typów ma być ignorowana.  
  
 Implementacja określa sposób, w jaki te argumenty są używane. Metoda `typeResolver` powinna zostać zwrócona `null` , jeśli nie można rozpoznać typu. Jeśli `typeResolver` zwraca `null` i mawartość`true`, to Przeciążenie<xref:System.Type.GetType%2A> zwraca .<xref:System.TypeLoadException> `throwOnError`  
  
 Efekty różnych opcji rozpoznawania typów są wyświetlane jako tabela w sekcji [rozpoznawanie nazw mieszanych](#mixed_name_resolution) dla nazw prostych i kwalifikowanych do zestawu.  
  
#### <a name="resolving-nested-types"></a>Rozpoznawanie zagnieżdżonych typów  
 Jeśli `typeName` jest typu zagnieżdżonego, do `typeResolver`elementu jest przenoszona tylko nazwa zewnętrznego typu zawierającego. Gdy `typeResolver` zwraca ten typ <xref:System.Type.GetNestedType%2A> , metoda jest wywoływana rekursywnie do momentu, gdy wewnętrzny typ zagnieżdżony zostanie rozwiązany.  
  
#### <a name="resolving-generic-types"></a>Rozpoznawanie typów rodzajowych  
 <xref:System.Type.GetType%2A> Jest wywoływana rekursywnie w celu rozpoznania typów ogólnych: Najpierw w celu rozpoznania samego typu ogólnego, a następnie rozpoznania jego argumentów typu. Jeśli argument typu jest ogólny, <xref:System.Type.GetType%2A> jest wywoływana rekursywnie w celu rozpoznania argumentów typu i tak dalej.  
  
 Kombinacja `assemblyResolver` i`typeResolver` , którą zapewniasz, musi być w stanie rozwiązać wszystkie poziomy tej rekursji. Załóżmy na przykład, `assemblyResolver` że podajesz, że podasz kontrolkę, która steruje `MyAssembly`ładowaniem. Załóżmy, że chcesz rozpoznać typ `Dictionary<string, MyType>` ogólny (`Dictionary(Of String, MyType)` w Visual Basic). Można przekazać następującą nazwę typu ogólnego:  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 Zwróć uwagę `MyType` , że jest jedynym argumentem typu kwalifikowana dla zestawu. Nazwy <xref:System.Collections.Generic.Dictionary%602> klas i <xref:System.String> nie są kwalifikowana dla zestawu. `null` `null` <xref:System.String> <xref:System.Collections.Generic.Dictionary%602> Musi być w stanie obsłużyć zestaw lub, ponieważ będzie on otrzymywać dla i. `typeResolver` Może obsłużyć ten przypadek, wywołując Przeciążenie <xref:System.Type.GetType%2A> metody pobierającej ciąg, ponieważ obie niekwalifikowane nazwy typów znajdują się w bibliotece Mscorlib. dll:  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 `assemblyResolver` Metoda nie jest wywoływana dla typu słownika i typu String, ponieważ te nazwy typów nie są kwalifikowana dla zestawu.  
  
 Teraz Załóżmy, że zamiast `System.String`, pierwszy typ argumentu rodzajowego to `YourType`, z `YourAssembly`:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 Ponieważ ten zestaw nie jest ani mscorlib. dll ani aktualnie wykonywanym zestawem, nie `YourType` można rozpoznać bez nazwy kwalifikowanej do zestawu. `assemblyResolve` Ponieważ będzie ona wywoływana cyklicznie, musi być w stanie obsłużyć ten przypadek. Zamiast zwracać `null` zestawy inne niż `MyAssembly`, wykonuje teraz obciążenie zestawu przy użyciu podanego <xref:System.Reflection.AssemblyName> obiektu.  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 Wróć do [informacji o użyciu](#usage_notes).  
  
#### <a name="resolving-type-names-with-special-characters"></a>Rozpoznawanie nazw typów ze znakami specjalnymi  
 Niektóre znaki mają specjalne znaczenie w nazwach kwalifikowanych do zestawu. Jeśli nazwa typu prostego zawiera te znaki, znaki powodują błędy analizy, gdy prosta nazwa jest częścią nazwy kwalifikowanej do zestawu. Aby uniknąć błędów analizy, należy wypróbować znaki specjalne z ukośnikiem odwrotnym, zanim będzie można przekazać nazwę kwalifikowaną dla zestawu do <xref:System.Type.GetType%2A> metody. Na przykład, jeśli typ ma nazwę `Strange]Type`, znak ucieczki musi być dodany przed nawias kwadratowy w następujący sposób:. `Strange\]Type`  
  
> [!NOTE]
>  Nazwy zawierające takie znaki specjalne nie mogą być tworzone w Visual Basic C#lub, ale mogą być tworzone przy użyciu języka pośredniego firmy Microsoft (MSIL) lub przez emitowanie zestawów dynamicznych.  
  
 W poniższej tabeli przedstawiono znaki specjalne dla nazw typów.  
  
|Znak|Znaczenie|  
|---------------|-------------|  
|`,`pliku|Ogranicznik nazw kwalifikowanych do zestawu.|  
|`[]`(nawiasy kwadratowe)|Jako para sufiksów wskazuje typ tablicy; jako para ograniczników należy ująć listy argumentów ogólnych i nazwy kwalifikowane.|  
|`&`znaku|Jako sufiks, wskazuje, że typ jest typem referencyjnym.|  
|`*`znaku|Jako sufiks, wskazuje, że typ jest typem wskaźnika.|  
|`+`dłużon|Ogranicznik dla zagnieżdżonych typów.|  
|`\`ukośnika odwrotnego|Znak ucieczki.|  
  
 Właściwości, takie <xref:System.Type.AssemblyQualifiedName%2A> jak zwracają poprawne ciągi ucieczki. Do <xref:System.Type.GetType%2A> metody należy przekazać poprawnie wpisane ciągi ucieczki. Z kolei <xref:System.Type.GetType%2A> Metoda przekazuje poprawnie zmienione nazwy do `typeResolver` i do domyślnych metod rozpoznawania typów. Jeśli musisz porównać nazwę z niezmienionymi nazwami w `typeResolver`, musisz usunąć znaki ucieczki.  
  
 Wróć do [informacji o użyciu](#usage_notes).  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>Rozpoznawanie nazw mieszanych  
 Poniższa tabela zawiera podsumowanie interakcji między `assemblyResolver`programem, `typeResolver`i domyślnym rozpoznawaniem nazw dla wszystkich kombinacji nazw typu i nazwy zestawu w programie: `typeName`  
  
|Zawartość typu Name|Metoda rozpoznawania zestawu|Metoda rozpoznawania typów|Wynik|  
|---------------------------|------------------------------|--------------------------|------------|  
|typ, zestaw|wartość null|wartość null|Równoważne z wywołaniem <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> przeciążenia metody.|  
|typ, zestaw|podano|wartość null|`assemblyResolver`zwraca zestaw lub zwraca `null` , jeśli nie można rozpoznać zestawu. Jeśli zestaw zostanie rozwiązany, <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Przeciążenie metody jest używane do załadowania typu z zestawu; w przeciwnym razie nie jest podejmowana próba rozpoznania typu.|  
|typ, zestaw|wartość null|podano|Równoważne konwersji nazwy zestawu na <xref:System.Reflection.AssemblyName> obiekt i <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> wywołanie przeciążenia metody w celu pobrania zestawu. Jeśli zestaw jest rozpoznawany, jest przenoszona do `typeResolver`; `typeResolver` w przeciwnym razie nie jest wywoływana i nie ma dalszych prób rozpoznania typu.|  
|typ, zestaw|podano|podano|`assemblyResolver`zwraca zestaw lub zwraca `null` , jeśli nie można rozpoznać zestawu. Jeśli zestaw jest rozpoznawany, jest przenoszona do `typeResolver`; `typeResolver` w przeciwnym razie nie jest wywoływana i nie ma dalszych prób rozpoznania typu.|  
|— typ|wartość NULL, podana|wartość null|Równoważne z wywołaniem <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> przeciążenia metody. Ponieważ nie podano nazwy zestawu, przeszukiwane są tylko biblioteki mscorlib. dll i aktualnie wykonywane zestawy. Jeśli `assemblyResolver` jest podany, zostanie zignorowany.|  
|— typ|wartość NULL, podana|podano|`typeResolver`jest wywoływana i `null` jest przenoszona do zestawu. `typeResolver`można podać typ z dowolnego zestawu, w tym zestawy, które ładuje do tego celu. Jeśli `assemblyResolver` jest podany, zostanie zignorowany.|  
|zestaw|wartość NULL, podana|wartość NULL, podana|<xref:System.IO.FileLoadException> Jest zgłaszany, ponieważ nazwa zestawu jest analizowana tak, jakby była nazwą typu kwalifikowana dla zestawu. Powoduje to nieprawidłową nazwę zestawu.|  
  
 Powrót do: [Uwagi dotyczące użycia](#usage_notes), [Rozwiązywanie zestawów](#resolving_assemblies), [Rozwiązywanie typów](#resolving_types).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" />jest <see langword="true" /> i nie znaleziono typu.  
  
—lub— 
 <paramref name="throwOnError" />ma <see langword="true" /> i<paramref name="typeName" /> zawiera nieprawidłowe znaki, takie jak karta osadzona. 
—lub— 
 <paramref name="throwOnError" />jest <see langword="true" /> i<paramref name="typeName" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="throwOnError" />is <see langword="true" /> i<paramref name="typeName" /> reprezentuje typ tablicy o nieprawidłowym rozmiarze.  
  
—lub— 
 <paramref name="typeName" />reprezentuje tablicę <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">Błąd występuje, gdy <paramref name="typeName" /> jest analizowany do nazwy typu i nazwy zestawu (na przykład, gdy nazwa typu prostego zawiera niezmieniony znak specjalny).  
  
—lub— 
 <paramref name="throwOnError" />ma <see langword="true" /> i<paramref name="typeName" /> zawiera nieprawidłową składnię (na przykład "MyType [, *,]").  
  
—lub— 
 <paramref name="typeName" />reprezentuje typ ogólny, który ma typ wskaźnika, <see langword="ByRef" /> typ lub <see cref="T:System.Void" /> jako jeden z argumentów typu.  
  
—lub— 
 <paramref name="typeName" />reprezentuje typ ogólny, który ma niepoprawną liczbę argumentów typu.  
  
—lub— 
 <paramref name="typeName" />reprezentuje typ ogólny, a jeden z jego argumentów typu nie spełnia ograniczeń dla odpowiadającego parametru typu.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" />jest <see langword="true" /> i nie znaleziono zestawu lub jednej z jego zależności.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.  
  
—lub— 
 <paramref name="typeName" />zawiera nieprawidłową nazwę zestawu.  
  
—lub— 
 <paramref name="typeName" />jest prawidłową nazwą zestawu bez nazwy typu.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.  
  
 —lub—  
  
 Zestaw został skompilowany przy użyciu nowszej wersji aparatu plików wykonywalnych języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="args">Tablica obiektów, których typy należy określić.</param>
        <summary>Pobiera typy obiektów w określonej tablicy.</summary>
        <returns>Tablica <see cref="T:System.Type" /> obiektów reprezentujących typy odpowiadających elementów w <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Type.GetTypeArray%2A> metody do wyświetlania typów elementów tablicy.  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" />jest <see langword="null" />.  
  
—lub— 
Co najmniej jeden element w programie <paramref name="args" /> ma wartość. <see langword="null" /></exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjatory klas są wywoływane, a co najmniej jeden zgłasza wyjątek.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Typ, którego kod źródłowy ma zostać pobrany.</param>
        <summary>Pobiera źródłowy kod typu dla określonego <see cref="T:System.Type" />elementu.</summary>
        <returns>Kod typu bazowego lub <see cref="F:System.TypeCode.Empty" /> Jeśli <paramref name="type" /> jest <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku dziedziczenia <xref:System.Type>z, można zmienić zachowanie tej metody, <xref:System.Type.GetTypeCodeImpl%2A> zastępując metodę.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, <xref:System.TypeCode> jak można użyć wyliczenia. W bloku decyzyjnym wewnątrz `WriteObjectInfo` metody <xref:System.TypeCode> <xref:System.Object> jest sprawdzany parametr, a odpowiedni komunikat jest zapisywana w konsoli.  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod typu podstawowego tego <see cref="T:System.Type" /> wystąpienia.</summary>
        <returns>Kod typu dla typu podstawowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapewnia implementację `static` metody (in C#) lub `Shared` (w Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> . W przypadku dziedziczenia <xref:System.Type>z, można zastąpić tę metodę, aby zapewnić własną implementację <xref:System.Type.GetTypeCode%2A>programu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera typ skojarzony z określonym identyfikatorem klasy (CLSID).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">Identyfikator CLSID typu, który można pobrać.</param>
        <summary>Pobiera typ skojarzony z określonym identyfikatorem klasy (CLSID).</summary>
        <returns><see langword="System.__ComObject" />bez względu na to, czy identyfikator CLSID jest prawidłowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> Metoda obsługuje dostęp z późnym wiązaniem do niezarządzanych obiektów com z aplikacji .NET Framework, gdy znasz identyfikator klasy obiektu COM (CLSID).  Identyfikator klasy dla klas COM jest zdefiniowany w kluczu HKEY_CLASSES_ROOT\CLSID rejestru. Możesz pobrać wartość <xref:System.Type.IsCOMObject%2A> właściwości, aby określić, czy typ zwracany przez tę metodę jest obiektem com.  
  
> [!TIP]
>  Można wywołać <xref:System.Type.GetTypeFromProgID%2A> metodę w celu uzyskania opóźnionego dostępu do obiektów com, których znany jest identyfikator programowy (PROGID).  
  
 Tworzenie wystąpienia niezarządzanego obiektu COM z jego identyfikatora CLSID jest procesem dwuetapowym:  
  
1.  Pobierz obiekt, który`__ComObject` odpowiada identyfikatorowi CLSID, wywołując <xref:System.Type.GetTypeFromCLSID%2A> metodę. <xref:System.Type>  
  
2.  Wywołaj <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metodę, aby utworzyć wystąpienie obiektu com.  
  
 Zobacz przykład dla ilustracji.  
  
 Przeciążenie ignoruje wszelkie wyjątki, które mogą wystąpić podczas tworzenia wystąpienia <xref:System.Type> obiektu na podstawie `clsid` argumentu. <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> Należy zauważyć, że żaden wyjątek nie `clsid` jest zgłaszany, jeśli nie zostanie znaleziony w rejestrze.  
  
   
  
## Examples  
 Poniższy przykład używa identyfikatora CLSID [obiektu aplikacji](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) programu Microsoft Word do pobrania typu com, który reprezentuje aplikację Microsoft Word. Następnie tworzy wystąpienie typu przez wywołanie <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metody i zamyka ją przez wywołanie metody [Application. quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) .  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Ta metoda jest przeznaczona do użycia podczas pracy z obiektami COM, a nie z obiektami .NET Framework. Wszystkie obiekty zarządzane, w tym te, które są widoczne dla modelu COM (to <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> oznacza, <see langword="true" />że ich atrybut ma), mają identyfikator GUID <see cref="P:System.Type.GUID" /> , który jest zwracany przez właściwość. Chociaż metoda zwraca <see cref="T:System.Type" /> obiekt, który odpowiada identyfikatorowi GUID dla obiektów .NET Framework, nie można użyć tego <see cref="T:System.Type" /> obiektu do utworzenia wystąpienia <see cref="M:System.Activator.CreateInstance(System.Type)" /> typu przez wywołanie metody, jak pokazano w poniższym przykładzie.  
  
[! code-CSharp[System. Type. GetTypeFromCLSID # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! code — VB[System. Type. GetTypeFromCLSID # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Zamiast tego <see cref="T:System.Type" /> <see cref="M:System.Activator.CreateInstance(System.Type)" /> należy użyć tylko do pobrania identyfikatora GUID niezarządzanego obiektu com, a wynikowy obiekt, który jest przesyłany do metody musi reprezentować niezarządzany obiekt com. <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">Identyfikator CLSID typu, który można pobrać.</param>
        <param name="throwOnError"><see langword="true" />Aby zgłosić jakikolwiek wyjątek, który wystąpi.  
  
—lub— 
 <see langword="false" />do ignorowania dowolnego wyjątku, który wystąpi.</param>
        <summary>Pobiera typ skojarzony z określonym identyfikatorem klasy (CLSID), określając, czy zgłosić wyjątek, jeśli wystąpi błąd podczas ładowania typu.</summary>
        <returns><see langword="System.__ComObject" />bez względu na to, czy identyfikator CLSID jest prawidłowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> Metoda obsługuje dostęp z późnym wiązaniem do niezarządzanych obiektów com z aplikacji .NET Framework, gdy znasz identyfikator klasy obiektu COM (CLSID).  Identyfikator klasy dla klas COM jest zdefiniowany w kluczu HKEY_CLASSES_ROOT\CLSID rejestru. Możesz pobrać wartość <xref:System.Type.IsCOMObject%2A> właściwości, aby określić, czy typ zwracany przez tę metodę jest obiektem com.  
  
> [!TIP]
>  Można wywołać <xref:System.Type.GetTypeFromProgID%2A> metodę w celu uzyskania opóźnionego dostępu do obiektów com, których znany jest identyfikator programowy (PROGID).  
  
 Tworzenie wystąpienia niezarządzanego obiektu COM z jego identyfikatora CLSID jest procesem dwuetapowym:  
  
1.  Pobierz obiekt, który `__ComObject` odpowiada identyfikatorowi CLSID, wywołując <xref:System.Type.GetTypeFromCLSID%2A> metodę. <xref:System.Type>  
  
2.  Wywołaj <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metodę, aby utworzyć wystąpienie obiektu com.  
  
 Zobacz przykład dla ilustracji.  
  
 Wyjątki, takie <xref:System.OutOfMemoryException> jak zostaną zgłoszone podczas `true` określania `throwOnError`dla, ale nie powiodą się dla niezarejestrowanej klasy CLSID.  
  
   
  
## Examples  
 Poniższy przykład używa identyfikatora CLSID [obiektu aplikacji](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) programu Microsoft Word do pobrania typu com, który reprezentuje aplikację Microsoft Word. Następnie tworzy wystąpienie typu przez wywołanie <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metody i zamyka ją przez wywołanie metody [Application. quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) . Wyjątek jest generowany, jeśli wystąpi błąd podczas ładowania typu.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Ta metoda jest przeznaczona do użycia podczas pracy z obiektami COM, a nie z obiektami .NET Framework. Wszystkie obiekty zarządzane, w tym te, które są widoczne dla modelu COM (to <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> oznacza, <see langword="true" />że ich atrybut ma), mają identyfikator GUID <see cref="P:System.Type.GUID" /> , który jest zwracany przez właściwość. Chociaż metoda zwraca <see cref="T:System.Type" /> obiekt, który odpowiada identyfikatorowi GUID dla obiektów .NET Framework, nie można użyć tego <see cref="T:System.Type" /> obiektu do utworzenia wystąpienia <see cref="M:System.Activator.CreateInstance(System.Type)" /> typu przez wywołanie metody, jak pokazano w poniższym przykładzie.  
  
[! code-CSharp[System. Type. GetTypeFromCLSID # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! code — VB[System. Type. GetTypeFromCLSID # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Zamiast tego <see cref="T:System.Type" /> <see cref="M:System.Activator.CreateInstance(System.Type)" /> należy użyć tylko do pobrania identyfikatora GUID niezarządzanego obiektu com, a wynikowy obiekt, który jest przesyłany do metody musi reprezentować niezarządzany obiekt com. <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">Identyfikator CLSID typu, który można pobrać.</param>
        <param name="server">Serwer, z którego można załadować typ. Jeśli nazwa serwera to <see langword="null" />, ta metoda automatycznie wraca do komputera lokalnego.</param>
        <summary>Pobiera typ skojarzony z określonym identyfikatorem klasy (CLSID) z określonego serwera.</summary>
        <returns><see langword="System.__ComObject" />bez względu na to, czy identyfikator CLSID jest prawidłowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> Metoda obsługuje dostęp z późnym wiązaniem do niezarządzanych obiektów com z aplikacji .NET Framework, gdy znasz identyfikator klasy obiektu COM (CLSID).  Identyfikator klasy dla klas COM jest zdefiniowany w kluczu HKEY_CLASSES_ROOT\CLSID rejestru. Możesz pobrać wartość <xref:System.Type.IsCOMObject%2A> właściwości, aby określić, czy typ zwracany przez tę metodę jest obiektem com.  
  
> [!TIP]
>  Można wywołać <xref:System.Type.GetTypeFromProgID%2A> metodę w celu uzyskania opóźnionego dostępu do obiektów com, których znany jest identyfikator programowy (PROGID).  
  
 Tworzenie wystąpienia niezarządzanego obiektu COM z jego identyfikatora CLSID jest procesem dwuetapowym:  
  
1.  Pobierz obiekt, który `__ComObject` odpowiada identyfikatorowi CLSID, wywołując <xref:System.Type.GetTypeFromCLSID%2A> metodę. <xref:System.Type>  
  
2.  Wywołaj <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metodę, aby utworzyć wystąpienie obiektu com.  
  
   
  
## Examples  
 Poniższy przykład używa identyfikatora CLSID [obiektu aplikacji](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) programu Microsoft Word do pobrania typu com, który reprezentuje aplikację Microsoft Word z serwera o nazwie computer17.Central.contoso.com. Następnie tworzy wystąpienie typu przez wywołanie <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metody i zamyka ją przez wywołanie metody [Application. quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) .  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Ta metoda jest przeznaczona do użycia podczas pracy z obiektami COM, a nie z obiektami .NET Framework. Wszystkie obiekty zarządzane, w tym te, które są widoczne dla modelu COM (to <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> oznacza, <see langword="true" />że ich atrybut ma), mają identyfikator GUID <see cref="P:System.Type.GUID" /> , który jest zwracany przez właściwość. Chociaż metoda zwraca <see cref="T:System.Type" /> obiekt, który odpowiada identyfikatorowi GUID dla obiektów .NET Framework, nie można użyć tego <see cref="T:System.Type" /> obiektu do utworzenia wystąpienia <see cref="M:System.Activator.CreateInstance(System.Type)" /> typu przez wywołanie metody, jak pokazano w poniższym przykładzie.  
  
[! code-CSharp[System. Type. GetTypeFromCLSID # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! code — VB[System. Type. GetTypeFromCLSID # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Zamiast tego <see cref="T:System.Type" /> <see cref="M:System.Activator.CreateInstance(System.Type)" /> należy użyć tylko do pobrania identyfikatora GUID niezarządzanego obiektu com, a wynikowy obiekt, który jest przesyłany do metody musi reprezentować niezarządzany obiekt com. <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">Identyfikator CLSID typu, który można pobrać.</param>
        <param name="server">Serwer, z którego można załadować typ. Jeśli nazwa serwera to <see langword="null" />, ta metoda automatycznie wraca do komputera lokalnego.</param>
        <param name="throwOnError"><see langword="true" />Aby zgłosić jakikolwiek wyjątek, który wystąpi.  
  
—lub— 
 <see langword="false" />do ignorowania dowolnego wyjątku, który wystąpi.</param>
        <summary>Pobiera typ skojarzony z określonym identyfikatorem klasy (CLSID) z określonego serwera, określając, czy należy zgłosić wyjątek, jeśli wystąpi błąd podczas ładowania typu.</summary>
        <returns><see langword="System.__ComObject" />bez względu na to, czy identyfikator CLSID jest prawidłowy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> Metoda obsługuje dostęp z późnym wiązaniem do niezarządzanych obiektów com z aplikacji .NET Framework, gdy znasz identyfikator klasy obiektu COM (CLSID).  Identyfikator klasy dla klas COM jest zdefiniowany w kluczu HKEY_CLASSES_ROOT\CLSID rejestru. Możesz pobrać wartość <xref:System.Type.IsCOMObject%2A> właściwości, aby określić, czy typ zwracany przez tę metodę jest obiektem com.  
  
> [!TIP]
>  Można wywołać <xref:System.Type.GetTypeFromProgID%2A> metodę w celu uzyskania opóźnionego dostępu do obiektów com, których znany jest identyfikator programowy (PROGID).  
  
 Tworzenie wystąpienia niezarządzanego obiektu COM z jego identyfikatora CLSID jest procesem dwuetapowym:  
  
1.  Pobierz obiekt, który `__ComObject` odpowiada identyfikatorowi CLSID, wywołując <xref:System.Type.GetTypeFromCLSID%2A> metodę. <xref:System.Type>  
  
2.  Wywołaj <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metodę, aby utworzyć wystąpienie obiektu com.  
  
 Wyjątki, takie <xref:System.OutOfMemoryException> jak zostaną zgłoszone podczas `true` określania `throwOnError`dla, ale nie powiodą się dla niezarejestrowanej klasy CLSID.  
  
   
  
## Examples  
 Poniższy przykład używa identyfikatora CLSID [obiektu aplikacji](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) programu Microsoft Word do pobrania typu com, który reprezentuje aplikację Microsoft Word z serwera o nazwie computer17.Central.contoso.com. Następnie tworzy wystąpienie typu przez wywołanie <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metody i zamyka ją przez wywołanie metody [Application. quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) . Wyjątek jest generowany, jeśli wystąpi błąd podczas ładowania typu.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Ta metoda jest przeznaczona do użycia podczas pracy z obiektami COM, a nie z obiektami .NET Framework. Wszystkie obiekty zarządzane, w tym te, które są widoczne dla modelu COM (to <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> oznacza, <see langword="true" />że ich atrybut ma), mają identyfikator GUID <see cref="P:System.Type.GUID" /> , który jest zwracany przez właściwość. Chociaż metoda zwraca obiekt, który odpowiada identyfikatorowi GUID określonego obiektu zarządzanego, nie można użyć tego <see cref="T:System.Type" /> obiektu <see cref="M:System.Activator.CreateInstance(System.Type)" /> do utworzenia wystąpienia typu przez wywołanie metody, jak w poniższym przykładzie <see cref="T:System.Type" /> <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> pokazując.  
  
[! code-CSharp[System. Type. GetTypeFromCLSID # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! code — VB[System. Type. GetTypeFromCLSID # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Zamiast tego <see cref="T:System.Type" /> <see cref="M:System.Activator.CreateInstance(System.Type)" /> należy użyć tylko do pobrania identyfikatora GUID niezarządzanego obiektu com, a wynikowy obiekt, który jest przesyłany do metody musi reprezentować niezarządzany obiekt com. <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Obiekt, który odwołuje się do typu.</param>
        <summary>Pobiera typ, do którego odwołuje się określony uchwyt typu.</summary>
        <returns>Typ, do którego odwołuje <see cref="T:System.RuntimeTypeHandle" />się określony <see langword="null" /> , lub <see cref="P:System.RuntimeTypeHandle.Value" /> Jeśli właściwość <paramref name="handle" /> ma <see langword="null" />wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dojścia są prawidłowe tylko w domenie aplikacji, w której zostały uzyskane.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Type.GetTypeFromHandle%2A> metodę, aby <xref:System.Type> pobrać obiekt <xref:System.Type.GetTypeHandle%2A> z <xref:System.RuntimeTypeHandle> dostarczonej przez metodę.  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera typ skojarzony z określonym identyfikatorem programu (ProgID).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">Identyfikator ProgID typu do pobrania.</param>
        <summary>Pobiera typ skojarzony z określonym identyfikatorem programu (ProgID), zwracając wartość null, jeśli wystąpi błąd podczas ładowania <see cref="T:System.Type" />.</summary>
        <returns>Typ skojarzony z określonym identyfikatorem ProgID, jeśli <paramref name="progID" /> jest prawidłowym wpisem w rejestrze i jest z nim skojarzony. <see langword="null" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia obsługę COM. Identyfikatory ProgID nie są używane w strukturze Microsoft .NET, ponieważ zostały zastąpione przez koncepcję przestrzeni nazw.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">Identyfikator ProgID typu do pobrania.</param>
        <param name="throwOnError"><see langword="true" />Aby zgłosić jakikolwiek wyjątek, który wystąpi.  
  
—lub— 
 <see langword="false" />do ignorowania dowolnego wyjątku, który wystąpi.</param>
        <summary>Pobiera typ skojarzony z określonym identyfikatorem programu (ProgID), określając, czy zgłosić wyjątek, jeśli wystąpi błąd podczas ładowania typu.</summary>
        <returns>Typ skojarzony z określonym identyfikatorem programu (PROGID), jeśli <paramref name="progID" /> jest prawidłowym wpisem w rejestrze i jest z nim skojarzony. w przeciwnym razie,. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia obsługę COM. Identyfikatory programów nie są używane w programie Microsoft .NET Framework, ponieważ zostały zastąpione przez koncepcję przestrzeni nazw.  
  
   
  
## Examples  
 Poniższy przykład pobiera typ przez przekazanie identyfikatora ProgID, określając, czy zgłosić wyjątek, jeśli identyfikator ProgID jest nieprawidłowy. W tym przykładzie zostanie wyświetlony Identyfikator ClassID związany z identyfikatorem ProgID wraz z dowolnym odpowiednim komunikatem o wyjątku.  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Określony identyfikator ProgID nie jest zarejestrowany.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">Identyfikator progID typu do pobrania.</param>
        <param name="server">Serwer, z którego można załadować typ. Jeśli nazwa serwera to <see langword="null" />, ta metoda automatycznie wraca do komputera lokalnego.</param>
        <summary>Pobiera typ skojarzony z określonym identyfikatorem programu (progID) z określonego serwera, zwracając wartość null, jeśli wystąpi błąd podczas ładowania typu.</summary>
        <returns>Typ skojarzony z określonym identyfikatorem programu (PROGID), jeśli <paramref name="progID" /> jest prawidłowym wpisem w rejestrze i jest z nim skojarzony. w przeciwnym razie,. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia obsługę COM. Identyfikatory programów nie są używane w programie Microsoft .NET Framework, ponieważ zostały zastąpione przez koncepcję przestrzeni nazw.  
  
   
  
## Examples  
 Poniższy przykład pobiera typ przez przekazanie identyfikatora ProgID i nazwy serwera. W tym przykładzie zostanie wyświetlony Identyfikator ClassID związany z identyfikatorem ProgID lub zgłasza wyjątek, jeśli identyfikator ProgID lub nazwa serwera jest nieprawidłowa.  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="prodID" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">Identyfikator ProgID elementu <see cref="T:System.Type" /> do pobrania.</param>
        <param name="server">Serwer, z którego można załadować typ. Jeśli nazwa serwera to <see langword="null" />, ta metoda automatycznie wraca do komputera lokalnego.</param>
        <param name="throwOnError"><see langword="true" />Aby zgłosić jakikolwiek wyjątek, który wystąpi.  
  
—lub— 
 <see langword="false" />do ignorowania dowolnego wyjątku, który wystąpi.</param>
        <summary>Pobiera typ skojarzony z określonym identyfikatorem programu (progID) z określonego serwera, określając, czy należy zgłosić wyjątek, jeśli wystąpi błąd podczas ładowania typu.</summary>
        <returns>Typ skojarzony z określonym identyfikatorem programu (PROGID), jeśli <paramref name="progID" /> jest prawidłowym wpisem w rejestrze i jest z nim skojarzony. w przeciwnym razie,. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia obsługę COM. Identyfikatory programów nie są używane w programie Microsoft .NET Framework, ponieważ zostały zastąpione przez koncepcję przestrzeni nazw.  
  
   
  
## Examples  
 Poniższy przykład pobiera typ przez przekazanie identyfikatora ProgID i nazwy serwera. W tym przykładzie zostanie wyświetlony Identyfikator ClassID związany z identyfikatorem ProgID, określający, czy zgłosić wyjątek, jeśli identyfikator ProgID lub nazwa serwera jest nieprawidłowa.  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Określony identyfikator progID nie jest zarejestrowany.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt, dla którego ma zostać pobrany uchwyt typu.</param>
        <summary>Pobiera dojście dla <see cref="T:System.Type" /> określonego obiektu.</summary>
        <returns>Dojście dla <see cref="T:System.Type" /> określonego <see cref="T:System.Object" />elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dojścia są prawidłowe tylko w domenie aplikacji, w której zostały uzyskane.  
  
   
  
## Examples  
 Poniższy przykład definiuje klasę `MyClass1`, pobiera jej wystąpienie i pobiera uchwyt środowiska uruchomieniowego obiektu.  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="o" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator GUID skojarzony z <see cref="T:System.Type" />.</summary>
        <value>Identyfikator GUID skojarzony z <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator GUID jest skojarzony z typem przy użyciu <xref:System.Runtime.InteropServices.GuidAttribute> atrybutu.  
  
   
  
## Examples  
 `MyClass1` Poniższy przykład tworzy klasę przy użyciu metody publicznej, `Type` tworzy obiekt odpowiadający `MyClass1`i `Type` pobiera <xref:System.Guid> strukturę przy użyciu `GUID` właściwości klasy.  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący <see cref="T:System.Type" /> obiekt obejmuje lub odwołuje się do innego typu, czyli czy bieżąca <see cref="T:System.Type" /> jest tablicą, wskaźnikiem, czy jest przenoszona przez odwołanie.</summary>
        <value><see langword="true" />Jeśli jest tablicą, wskaźnikiem lub jest przekazaniem przez odwołanie; w przeciwnym <see langword="false" />razie,. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład wpisz. GetType ("Int32 []"). HasElementType zwraca `true`, ale Type. GetType ("Int32"). HasElementType zwraca `false`. HasElementType również zwraca `true` wartość "Int32 *" i "Int32 &".  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny lub parametr typu w definicji typu ogólnego lub metody generycznej, ta właściwość zawsze zwraca wartość `false`.  
  
   
  
## Examples  
 Poniższy przykład zwraca `true` lub `false` w zależności od tego, czy obiekt jest tablicą, typem referencyjnym czy wskaźnikiem.  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, implementuje <see cref="P:System.Type.HasElementType" /> Właściwość i określa, czy bieżąca <see cref="T:System.Type" /> dotyczy lub odwołuje się do innego typu, czyli czy bieżąca <see cref="T:System.Type" /> jest tablicą, wskaźnikiem, czy jest przenoszona przez odwołanie.</summary>
        <returns><see langword="true" />Jeśli jest tablicą, wskaźnikiem lub jest przekazaniem przez odwołanie; w przeciwnym <see langword="false" />razie,. <see cref="T:System.Type" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład wpisz. GetType ("Int32 []"). HasElementTypeImpl zwraca `true`, ale Type. GetType ("Int32"). HasElementTypeImpl zwraca `false`. HasElementTypeImpl również zwraca `true` wartość "Int32 *" i "Int32 &".  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano klasę `MyTypeDelegator`, która `HasElementTypeImpl` zastępuje metodę. Klasa główna sprawdza `HasElementType` Właściwość i wyświetla typ elementu.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wywołuje określonego członka bieżącego <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę konstruktora, metody, właściwości lub elementu członkowskiego pola do wywołania.  
  
—lub— 
Pusty ciąg ("") do wywołania domyślnego elementu członkowskiego.  
  
—lub— 
W <see langword="IDispatch" /> przypadku elementów członkowskich ciąg reprezentujący identyfikator DISPID, na przykład "[DISPID = 3]".</param>
        <param name="invokeAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania. Dostęp może być <see langword="BindingFlags" /> jednym z <see langword="Public" />takich <see langword="NonPublic" /> <see langword="Private" />, ,,,,itakdalej.<see langword="InvokeMethod" /> <see langword="GetField" /> Nie trzeba określać typu wyszukiwania. <see langword="BindingFlags.Public" /> W przypadku pominięcia <see langword="BindingFlags.Instance" />  | typuwyszukiwaniasąużywane  | . <see langword="BindingFlags.Static" /></param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
Odwołanie o wartości null<see langword="Nothing" /> (w Visual Basic), aby <see cref="P:System.Type.DefaultBinder" />użyć. Należy zauważyć, że jawne <see cref="T:System.Reflection.Binder" /> zdefiniowanie obiektu może być wymagane do pomyślnego wywołania przeciążenia metody z argumentami zmiennych.</param>
        <param name="target">Obiekt, na którym ma zostać wywołany określony element członkowski.</param>
        <param name="args">Tablica zawierająca argumenty do przekazania do elementu członkowskiego, który ma zostać wywołany.</param>
        <summary>Wywołuje określony element członkowski przy użyciu określonych ograniczeń powiązania i zgodnych z określoną listą argumentów.</summary>
        <returns>Obiekt reprezentujący wartość zwracaną wywoływanego elementu członkowskiego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Nie można użyć <xref:System.Type.InvokeMember%2A> do wywołania metody ogólnej.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania, które elementy członkowskie mają być uwzględnione w wyszukiwaniu:  
  
-   Określ `BindingFlags.Public` , aby uwzględnić publiczne składowe w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu niepubliczne składowe (czyli członków prywatnych i chronionych).  
  
-   Określ `BindingFlags.FlattenHierarchy` , aby uwzględnić statyczne składowe w hierarchii.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi modyfikatorów mogą służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase`ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly`Aby przeszukać tylko członków zadeklarowanych <xref:System.Type>w, a nie na elementach, które były po prostu dziedziczone.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi wywołania mogą służyć do określenia, jakie działanie ma wykonać element członkowski:  
  
-   `CreateInstance`do wywołania konstruktora. `name`jest ignorowany. Nieprawidłowe z innymi flagami wywołania.  
  
-   `InvokeMethod`Aby wywołać metodę, ale nie konstruktora ani inicjatora typu. Nieprawidłowe z `SetField` lub `SetProperty`. Jeśli `InvokeMethod` jest określony przez siebie, `BindingFlags.Public`, `BindingFlags.Instance`, i `BindingFlags.Static` są automatycznie dołączane.  
  
-   `GetField`Aby uzyskać wartość pola. Nieprawidłowe z `SetField`.  
  
-   `SetField`Aby ustawić wartość pola. Nieprawidłowe z `GetField`.  
  
-   `GetProperty`Aby pobrać właściwość. Nieprawidłowe z `SetProperty`.  
  
-   `SetProperty`Aby ustawić właściwość. Nieprawidłowe z `GetProperty`.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Metoda zostanie wywołana w przypadku spełnienia obu następujących warunków:  
  
-   Liczba parametrów w deklaracji metody jest równa liczbie argumentów w `args` tablicy (chyba że argumenty domyślne są zdefiniowane w elemencie członkowskim i `BindingFlags.OptionalParamBinding` są określone).  
  
-   Typ każdego argumentu może być konwertowany przez spinacz do typu parametru.  
  
 W spinaczu znajdą się wszystkie zgodne metody. Te metody są dostępne na podstawie typu żądanego powiązania (<xref:System.Reflection.BindingFlags> wartości `InvokeMethod`, `GetProperty`itd.). Zestaw metod jest filtrowany według nazwy, liczby argumentów i zestawu modyfikatorów wyszukiwania zdefiniowanego w spinaczu.  
  
 Po wybraniu metody jest wywoływana. Dostępność jest sprawdzana w tym momencie. Wyszukiwanie może kontrolować, który zestaw metod jest przeszukiwany w oparciu o atrybut dostępności skojarzony z tą metodą. <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Metoda<xref:System.Reflection.Binder> klasy jest odpowiedzialna za wybranie metody do wywołania. Domyślny spinacz wybiera najbardziej konkretne dopasowanie.  
  
 Ograniczenia dostępu są ignorowane dla w pełni zaufanego kodu; oznacza to, że prywatne konstruktory, metody, pola i właściwości są dostępne i wywoływane za <xref:System.Reflection> każdym razem, gdy kod jest w pełni zaufany.  
  
 Można użyć `Type.InvokeMember` , aby ustawić pole na określoną wartość przez określenie <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Na przykład jeśli chcesz ustawić pole wystąpienia publicznego o nazwie f w klasie C, a F to a `String`, możesz użyć kodu takiego jak:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 Jeśli F to a `String[]`, można użyć kodu takiego jak:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 co spowoduje zainicjowanie pola F do tej nowej tablicy. Można również użyć `Type.InvokeMember` , aby ustawić pozycję w tablicy, dostarczając indeks wartości, a następnie kolejną wartość przy użyciu kodu, takiego jak:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 Spowoduje to zmianę ciągu "z" w tablicy, którą F przechowuje ciąg "b".  
  
 Podczas wywoływania `IDispatch` elementu członkowskiego można określić identyfikator DISPID zamiast nazwy elementu członkowskiego przy użyciu formatu ciągu "[DISPID = # #]". Na przykład jeśli identyfikator DispID MyComMethod ma wartość 3, można określić ciąg "[DispID = 3]" zamiast "MyComMethod". Wywoływanie elementu członkowskiego przez DispID jest szybsze niż wyszukiwanie elementu członkowskiego według nazwy. W złożonych scenariuszach agregacji identyfikator DispID jest czasami jedynym sposobem wywołania żądanego elementu członkowskiego.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do niepublicznych elementów członkowskich, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw uprawnień niepublicznych składowych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
   
  
## Examples  
 Poniższy przykład używa `InvokeMember` do uzyskiwania dostępu do elementów członkowskich typu.  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" />nie zawiera <see langword="CreateInstance" /> i <paramref name="name" /> is. <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" />nie jest prawidłowym <see cref="T:System.Reflection.BindingFlags" /> atrybutem.  
  
—lub— 
 <paramref name="invokeAttr" />nie zawiera jednej z następujących flag powiązań: <see langword="InvokeMethod" />, <see langword="GetField" /> <see langword="SetField" /> <see langword="CreateInstance" />, <see langword="GetProperty" />,, lub <see langword="SetProperty" />.  
  
—lub— 
 <paramref name="invokeAttr" />zawiera <see langword="CreateInstance" /> połączenie z <see langword="InvokeMethod" />, <see langword="GetField" />, ,<see langword="SetField" /> lub<see langword="SetProperty" />. <see langword="GetProperty" />  
  
—lub— 
 <paramref name="invokeAttr" />zawiera zarówno <see langword="GetField" /> i <see langword="SetField" />.  
  
—lub— 
 <paramref name="invokeAttr" />zawiera zarówno <see langword="GetProperty" /> i <see langword="SetProperty" />.  
  
—lub— 
 <paramref name="invokeAttr" />zawiera <see langword="InvokeMethod" /> połączenie z <see langword="SetField" /> lub <see langword="SetProperty" />.  
  
—lub— 
 <paramref name="invokeAttr" />zawiera <see langword="SetField" /> i<paramref name="args" /> ma więcej niż jeden element.  
  
—lub— 
Ta metoda jest wywoływana w obiekcie com i jedna z następujących flag powiązań nie została <see langword="BindingFlags.InvokeMethod" />przeniesiona w:, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" /> <see langword="BindingFlags.PutDispProperty" />,, lub <see langword="BindingFlags.PutRefDispProperty" />.  
  
—lub— 
Jedna z nazwanych tablic parametrów zawiera ciąg <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">Określony element członkowski jest inicjatorem klasy.</exception>
        <exception cref="T:System.MissingFieldException">Nie można znaleźć pola lub właściwości.</exception>
        <exception cref="T:System.MissingMethodException">Nie można znaleźć metody pasującej do argumentów w <paramref name="args" />.  
  
—lub— 
Bieżący <see cref="T:System.Type" /> obiekt reprezentuje typ, który zawiera parametry typu otwartego, czyli <see cref="P:System.Type.ContainsGenericParameters" /> zwraca wartość <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">Nie można wywołać określonego elementu członkowskiego <paramref name="target" />w elemencie.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Więcej niż jedna metoda pasuje do kryteriów powiązania.</exception>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework obecnie nie obsługuje tej metody.</exception>
        <exception cref="T:System.InvalidOperationException">Metoda reprezentowana przez <paramref name="name" /> ma jeden lub więcej nieokreślonych parametrów typu ogólnego. Oznacza to, że <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> Właściwość metody zwraca. <see langword="true" /></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">W celu uzyskiwania dostępu do elementów członkowskich niepublicznych, niezależnie od ich zestawu uprawnień. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby wywoływać kod niezarządzany. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę konstruktora, metody, właściwości lub elementu członkowskiego pola do wywołania.  
  
—lub— 
Pusty ciąg ("") do wywołania domyślnego elementu członkowskiego.  
  
—lub— 
W <see langword="IDispatch" /> przypadku elementów członkowskich ciąg reprezentujący identyfikator DISPID, na przykład "[DISPID = 3]".</param>
        <param name="invokeAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania. Dostęp może być <see langword="BindingFlags" /> jednym z <see langword="Public" />takich <see langword="NonPublic" /> <see langword="Private" />, ,,,,itakdalej.<see langword="InvokeMethod" /> <see langword="GetField" /> Nie trzeba określać typu wyszukiwania. <see langword="BindingFlags.Public" /> W przypadku pominięcia <see langword="BindingFlags.Instance" />  | typuwyszukiwaniasąużywane  | . <see langword="BindingFlags.Static" /></param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
Odwołanie o wartości null<see langword="Nothing" /> (w Visual Basic), aby <see cref="P:System.Type.DefaultBinder" />użyć. Należy zauważyć, że jawne <see cref="T:System.Reflection.Binder" /> zdefiniowanie obiektu może być wymagane do pomyślnego wywołania przeciążenia metody z argumentami zmiennych.</param>
        <param name="target">Obiekt, na którym ma zostać wywołany określony element członkowski.</param>
        <param name="args">Tablica zawierająca argumenty do przekazania do elementu członkowskiego, który ma zostać wywołany.</param>
        <param name="culture">Obiekt reprezentujący ustawienia regionalne globalizacji, które mogą być niezbędne dla konwersji specyficznych dla ustawień regionalnych, takich jak konwertowanie wartości numerycznej <see cref="T:System.String" /> <see cref="T:System.Double" />na.  
  
—lub— 
Odwołanie o wartości null<see langword="Nothing" /> (w Visual Basic) do użycia bieżącego <see cref="T:System.Globalization.CultureInfo" />wątku.</param>
        <summary>Wywołuje określony element członkowski przy użyciu określonych ograniczeń powiązania i pasujących do wskazanej listy argumentów i kultury.</summary>
        <returns>Obiekt reprezentujący wartość zwracaną wywoływanego elementu członkowskiego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chociaż <xref:System.Globalization.CultureInfo> domyślny spinacz nie przetwarza `culture` (parametr), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> , aby napisać niestandardowy spinacz, który przetwarza `culture`.  
  
> [!NOTE]
>  Nie można użyć <xref:System.Type.InvokeMember%2A> do wywołania metody ogólnej.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania, które elementy członkowskie mają być uwzględnione w wyszukiwaniu:  
  
-   Określ `BindingFlags.Public` , aby uwzględnić publiczne składowe w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu niepubliczne składowe (czyli prywatne, wewnętrzne i chronione).  
  
-   Określ `BindingFlags.FlattenHierarchy` , aby uwzględnić statyczne składowe w hierarchii.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi modyfikatorów mogą służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase`ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly`Aby przeszukać tylko członków zadeklarowanych <xref:System.Type>w, a nie na elementach, które były po prostu dziedziczone.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi wywołania mogą służyć do określenia, jakie działanie ma wykonać element członkowski:  
  
-   `CreateInstance`do wywołania konstruktora. `name`jest ignorowany. Nieprawidłowe z innymi flagami wywołania.  
  
-   `InvokeMethod`Aby wywołać metodę, ale nie konstruktora ani inicjatora typu. Nieprawidłowe z `SetField` lub `SetProperty`. Jeśli `InvokeMethod` jest określony przez siebie, `BindingFlags.Public`, `BindingFlags.Instance`, i `BindingFlags.Static` są automatycznie dołączane.  
  
-   `GetField`Aby uzyskać wartość pola. Nieprawidłowe z `SetField`.  
  
-   `SetField`Aby ustawić wartość pola. Nieprawidłowe z `GetField`.  
  
-   `GetProperty`Aby pobrać właściwość. Nieprawidłowe z `SetProperty`.  
  
-   `SetProperty`Aby ustawić właściwość. Nieprawidłowe z `GetProperty`.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Metoda zostanie wywołana w przypadku spełnienia obu następujących warunków:  
  
-   Liczba parametrów w deklaracji metody jest równa liczbie argumentów w `args` tablicy (chyba że argumenty domyślne są zdefiniowane w elemencie członkowskim i `BindingFlags.OptionalParamBinding` są określone).  
  
-   Typ każdego argumentu może być konwertowany przez spinacz do typu parametru.  
  
 W spinaczu znajdą się wszystkie zgodne metody. Te metody są dostępne na podstawie typu żądanego powiązania (<xref:System.Reflection.BindingFlags> wartości `InvokeMethod`, `GetProperty`itd.). Zestaw metod jest filtrowany według nazwy, liczby argumentów i zestawu modyfikatorów wyszukiwania zdefiniowanego w spinaczu.  
  
 Po wybraniu metody jest wywoływana. Dostępność jest sprawdzana w tym momencie. Wyszukiwanie może kontrolować, który zestaw metod jest przeszukiwany w oparciu o atrybut dostępności skojarzony z tą metodą. <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Metoda<xref:System.Reflection.Binder> klasy jest odpowiedzialna za wybranie metody do wywołania. Domyślny spinacz wybiera najbardziej konkretne dopasowanie.  
  
 Ograniczenia dostępu są ignorowane dla w pełni zaufanego kodu; oznacza to, że prywatne konstruktory, metody, pola i właściwości są dostępne i wywoływane przez odbicie za każdym razem, gdy kod jest w pełni zaufany.  
  
 Można użyć `Type.InvokeMember` , aby ustawić pole na określoną wartość przez określenie <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Na przykład, jeśli chcesz ustawić pole wystąpienia publicznego o nazwie F w klasie C, a F to `String` można użyć kodu takiego jak:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 Jeśli F to a `String[]`, można użyć kodu takiego jak:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 co spowoduje zainicjowanie pola F do tej nowej tablicy. Można również użyć `Type.InvokeMember` , aby ustawić pozycję w tablicy, dostarczając indeks wartości, a następnie kolejną wartość przy użyciu kodu, takiego jak:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 Spowoduje to zmianę ciągu "z" w tablicy, którą F przechowuje ciąg "b".  
  
 Podczas wywoływania `IDispatch` elementu członkowskiego można określić identyfikator DISPID zamiast nazwy elementu członkowskiego przy użyciu formatu ciągu "[DISPID = # #]". Na przykład jeśli identyfikator DispID MyComMethod ma wartość 3, można określić ciąg "[DispID = 3]" zamiast "MyComMethod". Wywoływanie elementu członkowskiego przez DispID jest szybsze niż wyszukiwanie elementu członkowskiego według nazwy. W złożonych scenariuszach agregacji identyfikator DispID jest czasami jedynym sposobem wywołania żądanego elementu członkowskiego.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do niepublicznych elementów członkowskich, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw uprawnień niepublicznych składowych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" />nie zawiera <see langword="CreateInstance" /> i <paramref name="name" /> is. <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" />nie jest prawidłowym <see cref="T:System.Reflection.BindingFlags" /> atrybutem.  
  
—lub— 
 <paramref name="invokeAttr" />nie zawiera jednej z następujących flag powiązań: <see langword="InvokeMethod" />, <see langword="GetField" /> <see langword="SetField" /> <see langword="CreateInstance" />, <see langword="GetProperty" />,, lub <see langword="SetProperty" />.  
  
—lub— 
 <paramref name="invokeAttr" />zawiera <see langword="CreateInstance" /> połączenie z <see langword="InvokeMethod" />, <see langword="GetField" />, ,<see langword="SetField" /> lub<see langword="SetProperty" />. <see langword="GetProperty" />  
  
—lub— 
 <paramref name="invokeAttr" />zawiera zarówno <see langword="GetField" /> i <see langword="SetField" />.  
  
—lub— 
 <paramref name="invokeAttr" />zawiera zarówno <see langword="GetProperty" /> i <see langword="SetProperty" />.  
  
—lub— 
 <paramref name="invokeAttr" />zawiera <see langword="InvokeMethod" /> połączenie z <see langword="SetField" /> lub <see langword="SetProperty" />.  
  
—lub— 
 <paramref name="invokeAttr" />zawiera <see langword="SetField" /> i<paramref name="args" /> ma więcej niż jeden element.  
  
—lub— 
Ta metoda jest wywoływana w obiekcie com i jedna z następujących flag powiązań nie została <see langword="BindingFlags.InvokeMethod" />przeniesiona w:, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" /> <see langword="BindingFlags.PutDispProperty" />,, lub <see langword="BindingFlags.PutRefDispProperty" />.  
  
—lub— 
Jedna z nazwanych tablic parametrów zawiera ciąg <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">Określony element członkowski jest inicjatorem klasy.</exception>
        <exception cref="T:System.MissingFieldException">Nie można znaleźć pola lub właściwości.</exception>
        <exception cref="T:System.MissingMethodException">Nie można znaleźć metody pasującej do argumentów w <paramref name="args" />.  
  
—lub— 
Bieżący <see cref="T:System.Type" /> obiekt reprezentuje typ, który zawiera parametry typu otwartego, czyli <see cref="P:System.Type.ContainsGenericParameters" /> zwraca wartość <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">Nie można wywołać określonego elementu członkowskiego <paramref name="target" />w elemencie.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Więcej niż jedna metoda pasuje do kryteriów powiązania.</exception>
        <exception cref="T:System.InvalidOperationException">Metoda reprezentowana przez <paramref name="name" /> ma jeden lub więcej nieokreślonych parametrów typu ogólnego. Oznacza to, że <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> Właściwość metody zwraca. <see langword="true" /></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">W celu uzyskiwania dostępu do elementów członkowskich niepublicznych, niezależnie od ich zestawu uprawnień. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby wywoływać kod niezarządzany. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="namedParameters" Type="System.String[]" Index="7" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Ciąg zawierający nazwę konstruktora, metody, właściwości lub elementu członkowskiego pola do wywołania.  
  
—lub— 
Pusty ciąg ("") do wywołania domyślnego elementu członkowskiego.  
  
—lub— 
W <see langword="IDispatch" /> przypadku elementów członkowskich ciąg reprezentujący identyfikator DISPID, na przykład "[DISPID = 3]".</param>
        <param name="invokeAttr">Bitowa kombinacja wartości wyliczenia, które określają sposób przeszukiwania. Dostęp może być <see langword="BindingFlags" /> jednym z <see langword="Public" />takich <see langword="NonPublic" /> <see langword="Private" />, ,,,,itakdalej.<see langword="InvokeMethod" /> <see langword="GetField" /> Nie trzeba określać typu wyszukiwania. <see langword="BindingFlags.Public" /> W przypadku pominięcia <see langword="BindingFlags.Instance" />  | typuwyszukiwaniasąużywane  | . <see langword="BindingFlags.Static" /></param>
        <param name="binder">Obiekt, który określa zestaw właściwości i umożliwia powiązanie, które może obejmować wybór metody przeciążonej, wymuszanie typów argumentu i wywołanie elementu członkowskiego przez odbicie.  
  
—lub— 
Odwołanie o wartości null (Nothing w Visual Basic), aby użyć <see cref="P:System.Type.DefaultBinder" />. Należy zauważyć, że jawne <see cref="T:System.Reflection.Binder" /> zdefiniowanie obiektu może być wymagane do pomyślnego wywołania przeciążenia metody z argumentami zmiennych.</param>
        <param name="target">Obiekt, na którym ma zostać wywołany określony element członkowski.</param>
        <param name="args">Tablica zawierająca argumenty do przekazania do elementu członkowskiego, który ma zostać wywołany.</param>
        <param name="modifiers">Tablica <see cref="T:System.Reflection.ParameterModifier" /> obiektów reprezentująca atrybuty skojarzone z odpowiednim elementem <paramref name="args" /> w tablicy. Skojarzone atrybuty parametru są przechowywane w podpisie elementu członkowskiego.  
  
Domyślny spinacz przetwarza ten parametr tylko w przypadku wywoływania składnika COM.</param>
        <param name="culture"><see cref="T:System.Globalization.CultureInfo" /> Obiekt reprezentujący ustawienia regionalne globalizacji, które mogą być niezbędne dla konwersji specyficznych dla ustawień regionalnych, takich jak konwertowanie ciągu liczbowego na wartość typu Double.  
  
—lub— 
Odwołanie o wartości null<see langword="Nothing" /> (w Visual Basic) do użycia bieżącego <see cref="T:System.Globalization.CultureInfo" />wątku.</param>
        <param name="namedParameters">Tablica zawierająca nazwy parametrów, do których są przesyłane wartości z <paramref name="args" /> tablicy.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, wywołuje określony element członkowski przy użyciu określonych ograniczeń powiązania i dopasowuje określoną listę argumentów, modyfikatory i kulturę.</summary>
        <returns>Obiekt reprezentujący wartość zwracaną wywoływanego elementu członkowskiego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember`wywołuje element członkowski konstruktora lub element członkowski metody, Pobiera lub ustawia element członkowski właściwości, Pobiera lub ustawia element członkowski pola danych albo Pobiera lub ustawia elementy elementu członkowskiego tablicy.  
  
> [!NOTE]
>  Nie można użyć <xref:System.Type.InvokeMember%2A> do wywołania metody ogólnej.  
  
 Podczas wywoływania `IDispatch` elementu członkowskiego można określić identyfikator DISPID zamiast nazwy elementu członkowskiego przy użyciu formatu ciągu "[DISPID = # #]". Na przykład jeśli identyfikator DispID MyComMethod ma wartość 3, można określić ciąg "[DispID = 3]" zamiast "MyComMethod". Wywoływanie elementu członkowskiego przez DispID jest szybsze niż wyszukiwanie elementu członkowskiego według nazwy. W złożonych scenariuszach agregacji identyfikator DispID jest czasami jedynym sposobem wywołania żądanego elementu członkowskiego.  
  
 Chociaż domyślny spinacz nie przetwarza <xref:System.Reflection.ParameterModifier> lub <xref:System.Globalization.CultureInfo> ( `modifiers` parametry i `culture` ), można użyć klasy abstrakcyjnej <xref:System.Reflection.Binder?displayProperty=nameWithType> , aby napisać niestandardowy spinacz, który przetwarza `modifiers` i `culture`. `ParameterModifier`jest używany tylko podczas wywoływania za pomocą międzyoperacyjności modelu COM i obsługiwane są tylko parametry, które są przesyłane przez odwołanie.  
  
 Każdy parametr w `namedParameters` tablicy Pobiera wartość w odpowiednim elemencie `args` tablicy. Jeśli długość `args` jest większa niż `namedParameters`długość, pozostałe wartości argumentu są przesyłane w kolejności.  
  
 `namedParameters` Tablica może służyć do zmiany kolejności argumentów w tablicy wejściowej. Na przykład uwzględniając metodę `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` w Visual Basic) i tablicę `{ 42, "x" }`wejściową, Tablica wejściowa może być przekazywana bez zmian do `args` , jeśli tablica `{ "b", "a" }` jest dostarczana dla `namedParameters`.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi filtru mogą służyć do definiowania, które elementy członkowskie mają być uwzględnione w wyszukiwaniu:  
  
-   Określ `BindingFlags.Public` , aby uwzględnić publiczne składowe w wyszukiwaniu.  
  
-   Określ `BindingFlags.NonPublic` , aby uwzględnić w wyszukiwaniu niepubliczne składowe (czyli prywatne, wewnętrzne i chronione).  
  
-   Określ `BindingFlags.FlattenHierarchy` , aby uwzględnić statyczne składowe w hierarchii.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi modyfikatorów mogą służyć do zmiany sposobu działania wyszukiwania:  
  
-   `BindingFlags.IgnoreCase`ignorowanie wielkości liter `name`.  
  
-   `BindingFlags.DeclaredOnly`Aby przeszukać tylko członków zadeklarowanych <xref:System.Type>w, a nie na elementach, które były po prostu dziedziczone.  
  
 Poniższe <xref:System.Reflection.BindingFlags> flagi wywołania mogą służyć do określenia, jakie działanie ma wykonać element członkowski:  
  
-   `CreateInstance`do wywołania konstruktora. `name`jest ignorowany. Nieprawidłowe z innymi flagami wywołania.  
  
-   `InvokeMethod`Aby wywołać metodę, ale nie konstruktora ani inicjatora typu. Nieprawidłowe z `SetField` lub `SetProperty`. Jeśli `InvokeMethod` jest określony przez siebie, `BindingFlags.Public`, `BindingFlags.Instance`, i `BindingFlags.Static` są automatycznie dołączane.  
  
-   `GetField`Aby uzyskać wartość pola. Nieprawidłowe z `SetField`.  
  
-   `SetField`Aby ustawić wartość pola. Nieprawidłowe z `GetField`.  
  
-   `GetProperty`Aby pobrać właściwość. Nieprawidłowe z `SetProperty`.  
  
-   `SetProperty`Aby ustawić właściwość. Nieprawidłowe z `GetProperty`.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Metoda zostanie wywołana w przypadku spełnienia obu następujących warunków:  
  
-   Liczba parametrów w deklaracji metody jest równa liczbie argumentów w `args` tablicy (chyba że argumenty domyślne są zdefiniowane w elemencie członkowskim i `BindingFlags.OptionalParamBinding` są określone).  
  
-   Typ każdego argumentu może być konwertowany przez spinacz do typu parametru.  
  
 W spinaczu znajdą się wszystkie zgodne metody. Te metody są dostępne na podstawie typu żądanego powiązania (<xref:System.Reflection.BindingFlags> wartości `InvokeMethod`, `GetProperty`itd.). Zestaw metod jest filtrowany według nazwy, liczby argumentów i zestawu modyfikatorów wyszukiwania zdefiniowanego w spinaczu.  
  
 Po wybraniu metody jest wywoływana. Dostępność jest sprawdzana w tym momencie. Wyszukiwanie może kontrolować, który zestaw metod jest przeszukiwany w oparciu o atrybut dostępności skojarzony z tą metodą. <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Metoda<xref:System.Reflection.Binder> klasy jest odpowiedzialna za wybranie metody do wywołania. Domyślny spinacz wybiera najbardziej konkretne dopasowanie.  
  
 `InvokeMember`może służyć do wywoływania metod z parametrami, które mają wartości domyślne. Aby można było powiązać te metody, należy <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> określić odbicie. Dla parametru, który ma wartość domyślną, można podać inną wartość lub <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> określić, aby użyć wartości domyślnej.  
  
 Rozważmy na przykład metodę, taką jak Metoda (int x, float y = 2,0). Aby wywołać tę metodę tylko jako pierwszy argument jako Metoda (4), Przekaż jedną z powyższych flag powiązań i przekaż dwa argumenty, mianowicie, 4 jako pierwszy argument i `Missing.Value` dla drugiego argumentu. O ile nie używasz `Invoke` ,niemożnapominąćparametrówopcjonalnychzapomocąmetody.`Missing.Value` Jeśli to konieczne, użyj `InvokeMember` zamiast tego.  
  
 Ograniczenia dostępu są ignorowane dla w pełni zaufanego kodu; oznacza to, że prywatne konstruktory, metody, pola i właściwości są dostępne i wywoływane za <xref:System.Reflection> każdym razem, gdy kod jest w pełni zaufany.  
  
 Można użyć `Type.InvokeMember` , aby ustawić pole na określoną wartość przez określenie <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Na przykład jeśli chcesz ustawić pole wystąpienia publicznego o nazwie f w klasie C, a F to a `String`, możesz użyć kodu takiego jak:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 Jeśli F to a `String[]`, można użyć kodu takiego jak:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 co spowoduje zainicjowanie pola F do tej nowej tablicy. Można również użyć `Type.InvokeMember` , aby ustawić pozycję w tablicy, dostarczając indeks wartości, a następnie kolejną wartość przy użyciu kodu, takiego jak:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 Spowoduje to zmianę ciągu "z" w tablicy, którą F przechowuje ciąg "b".  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana w celu uzyskania dostępu do niepublicznych elementów członkowskich, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw uprawnień niepublicznych składowych jest ograniczony do zestawu uprawnień obiektu wywołującego lub podzestawu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Komisję. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" />nie zawiera <see langword="CreateInstance" /> i <paramref name="name" /> is. <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="args" />i <paramref name="modifiers" /> nie mają tej samej długości.  
  
—lub— 
 <paramref name="invokeAttr" />nie jest prawidłowym <see cref="T:System.Reflection.BindingFlags" /> atrybutem.  
  
—lub— 
 <paramref name="invokeAttr" />nie zawiera jednej z następujących flag powiązań: <see langword="InvokeMethod" />, <see langword="GetField" /> <see langword="SetField" /> <see langword="CreateInstance" />, <see langword="GetProperty" />,, lub <see langword="SetProperty" />.  
  
—lub— 
 <paramref name="invokeAttr" />zawiera <see langword="CreateInstance" /> połączenie z <see langword="InvokeMethod" />, <see langword="GetField" />, ,<see langword="SetField" /> lub<see langword="SetProperty" />. <see langword="GetProperty" />  
  
—lub— 
 <paramref name="invokeAttr" />zawiera zarówno <see langword="GetField" /> i <see langword="SetField" />.  
  
—lub— 
 <paramref name="invokeAttr" />zawiera zarówno <see langword="GetProperty" /> i <see langword="SetProperty" />.  
  
—lub— 
 <paramref name="invokeAttr" />zawiera <see langword="InvokeMethod" /> połączenie z <see langword="SetField" /> lub <see langword="SetProperty" />.  
  
—lub— 
 <paramref name="invokeAttr" />zawiera <see langword="SetField" /> i<paramref name="args" /> ma więcej niż jeden element.  
  
—lub— 
Tablica parametrów nazwanych jest większa niż tablica argumentów.  
  
—lub— 
Ta metoda jest wywoływana w obiekcie com i jedna z następujących flag powiązań nie została <see langword="BindingFlags.InvokeMethod" />przeniesiona w:, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" /> <see langword="BindingFlags.PutDispProperty" />,, lub <see langword="BindingFlags.PutRefDispProperty" />.  
  
—lub— 
Jedna z nazwanych tablic parametrów zawiera ciąg <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">Określony element członkowski jest inicjatorem klasy.</exception>
        <exception cref="T:System.MissingFieldException">Nie można znaleźć pola lub właściwości.</exception>
        <exception cref="T:System.MissingMethodException">Nie można znaleźć metody pasującej do argumentów w <paramref name="args" />.  
  
—lub— 
Nie można znaleźć żadnego elementu członkowskiego, który ma nazwy argumentów <paramref name="namedParameters" />podane w.  
  
—lub— 
Bieżący <see cref="T:System.Type" /> obiekt reprezentuje typ, który zawiera parametry typu otwartego, czyli <see cref="P:System.Type.ContainsGenericParameters" /> zwraca wartość <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">Nie można wywołać określonego elementu członkowskiego <paramref name="target" />w elemencie.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Więcej niż jedna metoda pasuje do kryteriów powiązania.</exception>
        <exception cref="T:System.InvalidOperationException">Metoda reprezentowana przez <paramref name="name" /> ma jeden lub więcej nieokreślonych parametrów typu ogólnego. Oznacza to, że <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> Właściwość metody zwraca. <see langword="true" /></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">W celu uzyskiwania dostępu do elementów członkowskich niepublicznych, niezależnie od ich zestawu uprawnień. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby wywoływać kod niezarządzany. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Type" /> element jest abstrakcyjny i musi zostać zastąpiony.</summary>
        <value><see langword="true" />Jeśli jest abstrakcyjny; w przeciwnym <see langword="false" />razie,. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAbstract%2A> Właściwość zwraca`true` w następujących przypadkach:  
  
-   Bieżący typ jest abstrakcyjny; oznacza to, że nie można utworzyć wystąpienia, ale może służyć tylko jako klasa bazowa dla klas pochodnych. W C#systemie klasy abstrakcyjne są oznaczane za pomocą słowa kluczowego [abstract](~/docs/csharp/language-reference/keywords/abstract.md) ; w Visual Basic są one oznaczone za pomocą słowa kluczowego [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) .  
  
-   Bieżący typ jest interfejsem.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta właściwość zawsze zwraca wartość `false`.  
  
   
  
## Examples  
 Poniższy <xref:System.Type> przykład tworzy tablicę obiektów, które reprezentują następujące typy: zawiera typ zwraca `true` , jeśli określony obiekt jest `abstract`; w przeciwnym razie zwraca `false`.  
  
-   `AbstractClass`, Klasa abstrakcyjna (Klasa oznaczona jako `abstract` in C# i `MustInherit` w Visual Basic).  
  
-   `DerivedClass`, Klasa, która dziedziczy z `AbstractClass`.  
  
-   `SingleClass`, Klasa niedziedziczna. Jest on definiowany jako `sealed` w C# i `NotInheritable` w Visual Basic.  
  
-   `ITypeInfo`, interfejs.  
  
-   `ImplementingClass`, Klasa, która implementuje `ITypeInfo` interfejs.  
  
 Metoda zwraca `true` tylko dla `AbstractClass`, klasy abstrakcyjnej i `ITypeInfo`interfejsu.  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy atrybut <see langword="AnsiClass" /> formatu ciągu jest wybrany <see cref="T:System.Type" />dla.</summary>
        <value><see langword="true" />w przypadku wybrania atrybutu <see langword="AnsiClass" /> format ciągu <see cref="T:System.Type" />dla; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> Wybiera atrybuty formatu ciągu. Atrybuty formatu ciągu zwiększają współdziałanie przez definiowanie sposobu interpretacji ciągów.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny, ta właściwość odnosi się do definicji typu ogólnego, z której został skonstruowany typ. Na przykład, jeśli <xref:System.Type> bieżący reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zawsze zwraca wartość `false`.  
  
   
  
## Examples  
 Poniższy przykład pobiera informacje o polach i sprawdza dla `AnsiClass` atrybutu.  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy typ jest tablicą.</summary>
        <value><see langword="true" />Jeśli bieżący typ jest tablicą; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zwraca `false` dla<xref:System.Array> klasy. <xref:System.Type.IsArray%2A> Zwraca `false` również wtedy, gdy bieżące wystąpienie <xref:System.Type> jest obiektem, który reprezentuje typ kolekcji lub interfejs przeznaczony do pracy z kolekcjami, takimi <xref:System.Collections.IEnumerable> jak <xref:System.Collections.Generic.IEnumerable%601>lub.  
  
 Aby sprawdzić tablicę, należy użyć kodu takiego jak:  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 Jeśli bieżący typ reprezentuje typ ogólny lub parametr typu w definicji typu ogólnego lub metody generycznej, ta właściwość zawsze zwraca wartość `false`.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Type.IsArray%2A> właściwości.  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy <see cref="T:System.Type" /> jest zastępowany w klasie pochodnej, implementuje <see cref="P:System.Type.IsArray" /> Właściwość i określa, czy jest tablicą.</summary>
        <returns><see langword="true" />Jeśli jest tablicą; w przeciwnym razie <see langword="false" />,. <see cref="T:System.Type" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie <xref:System.Array> klasy musi zwracać `false` , ponieważ jest obiektem, a nie tablicą.  
  
   
  
## Examples  
 Poniższy przykład zastępuje `IsArrayImpl` metodę `MyTypeDelegator` w klasie, sprawdza, czy zmienna jest tablicą i wyświetla wynik.  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c">Typ do porównania z bieżącym typem.</param>
        <summary>Określa, czy wystąpienie określonego typu można przypisać do zmiennej bieżącego typu.</summary>
        <returns><see langword="true" />Jeśli spełniony jest dowolny z następujących warunków: 
-   <paramref name="c" />a bieżące wystąpienie reprezentuje ten sam typ.  
  
-   <paramref name="c" />jest wyprowadzany bezpośrednio lub pośrednio z bieżącego wystąpienia. <paramref name="c" />jest wyprowadzany bezpośrednio z bieżącego wystąpienia, jeśli dziedziczy z bieżącego wystąpienia; <paramref name="c" /> jest wyprowadzany pośrednio z bieżącego wystąpienia, jeśli dziedziczy po powodzeniu jednej lub więcej klas, które dziedziczą z bieżącego wystąpienia.  
  
-Bieżące wystąpienie jest interfejsem, który <paramref name="c" /> implementuje.  
  
-   <paramref name="c" />jest parametrem typu ogólnego, a bieżące wystąpienie reprezentuje jedno z ograniczeń <paramref name="c" />.  
  
W poniższym przykładzie bieżące wystąpienie jest <see cref="T:System.Type" /> obiektem, który <see cref="T:System.IO.Stream" /> reprezentuje klasę. <c>GenericWithConstraint</c> jest typem ogólnym, którego parametr typu generycznego musi być <see cref="T:System.IO.Stream" />typem. Przekazanie parametru typu ogólnego do <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> wskazuje, że wystąpienie parametru typu ogólnego można przypisać <see cref="T:System.IO.Stream" /> do obiektu.  
  
[! code-CSharp[System. Type. IsAssignableFrom # 2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [! code — VB[System. Type. IsAssignableFrom # 2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)] 
-   <paramref name="c" />reprezentuje typ wartości, a bieżące wystąpienie reprezentuje wartość <c>null&lt;c&gt; </c> (<c>wartość null (w języku c)</c> w Visual Basic).  
  
 <see langword="false" />Jeśli żaden z tych warunków nie jest spełniony lub jeśli <paramref name="c" /> jest <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda może służyć do określenia, czy `c` wystąpienie może być przypisane do wystąpienia bieżącego typu, metoda jest najbardziej przydatna podczas obsługi obiektów, których typy nie są znane w czasie projektowania i umożliwiają warunkowo <xref:System.Type.IsAssignableFrom%2A> przypisanie, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 Ta metoda zapewnia, że wiersz kodu, podobny do poniższego, zostanie wykonany w czasie wykonywania bez <xref:System.InvalidCastException> zgłaszania wyjątku lub podobnego wyjątku:  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
> [!NOTE]
>  Nie można przypisać definicji typu ogólnego z zamkniętego typu skonstruowanego. Oznacza to, że nie można przypisać zamkniętego typu `MyGenericList<int>` skonstruowanego (`MyGenericList(Of Integer)` w Visual Basic) do zmiennej typu `MyGenericList<T>`.  
  
 Jeśli parametr jest typu <xref:System.Reflection.Emit.TypeBuilder>, wynik jest oparty na typie, który ma zostać skompilowany. `c` Poniższy przykład kodu demonstruje przy użyciu skompilowanego typu o nazwie `B`.  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład demonstruje `IsAssignableFrom` metodę przy użyciu zdefiniowanych klas, tablic całkowitych i typów ogólnych.  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy atrybut <see langword="AutoClass" /> formatu ciągu jest wybrany <see cref="T:System.Type" />dla.</summary>
        <value><see langword="true" />w przypadku wybrania atrybutu <see langword="AutoClass" /> format ciągu <see cref="T:System.Type" />dla; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> Wybiera atrybuty formatu ciągu. Atrybuty formatu ciągu zwiększają współdziałanie przez definiowanie sposobu interpretacji ciągów.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, ta właściwość ma zastosowanie do definicji typu ogólnego, z której został skonstruowany typ. Na przykład, jeśli <xref:System.Type> bieżący reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zawsze zwraca wartość `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy pola bieżącego typu są ustawiane automatycznie przez środowisko uruchomieniowe języka wspólnego.</summary>
        <value><see langword="true" />Jeśli właściwość bieżącego typu zawiera <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; w przeciwnym razie, <see langword="false" />. <see cref="P:System.Type.Attributes" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest zapewniana jako wygoda. Alternatywnie można użyć <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> wartości wyliczenia, aby wybrać atrybuty układu typu, a następnie sprawdzić, czy <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> jest ustawiony. Wartości wyliczenia<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, i <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> wskazują sposób, w jaki pola typu są określone w pamięci. <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>  
  
 W przypadku typów dynamicznych można określić <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> , kiedy tworzysz typ. W kodzie należy zastosować <xref:System.Runtime.InteropServices.StructLayoutAttribute> atrybut <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> z wartością wyliczenia do typu, aby umożliwić środowisko uruchomieniowe określić odpowiedni sposób układania klasy.  
  
> [!NOTE]
>  Nie można użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metody, aby określić, <xref:System.Runtime.InteropServices.StructLayoutAttribute> czy został on zastosowany do typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, ta właściwość ma zastosowanie do definicji typu ogólnego, z której został skonstruowany typ. Na przykład, jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w Visual Basic), wartość tej właściwości jest określana przez`MyGenericType<T>.`  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta właściwość zawsze zwraca wartość `false`.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie typu i wyświetla <xref:System.Type.IsAutoLayout%2A> właściwość.  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">Składniki samoopisujące się i metadane</related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, <see cref="T:System.Type" /> czy jest ona przenoszona przez odwołanie.</summary>
        <value><see langword="true" />Jeśli jest przenoszona przez odwołanie; <see langword="false" />w przeciwnym razie. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać dostęp do rzeczywistego typu, wycofaj odwołanie do typu, który został przesłany przez odwołanie <xref:System.Type.GetElementType%2A> , a następnie Wywołaj dla tego typu.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `IsByRef` właściwości, aby sprawdzić, czy określony typ jest przekazaniem przez odwołanie. W przykładzie zdefiniowano klasę `MyTypeDelegator`, która `HasElementTypeImpl` zastępuje metodę. Klasa główna sprawdza `HasElementType` Właściwość i wyświetla typ elementu.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy <see cref="T:System.Type" /> jest zastępowany w klasie pochodnej, implementuje <see cref="P:System.Type.IsByRef" /> Właściwość i określa, czy jest ona przenoszona przez odwołanie.</summary>
        <returns><see langword="true" />Jeśli jest przenoszona przez odwołanie; <see langword="false" />w przeciwnym razie. <see cref="T:System.Type" /></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Type" /> jest klasą, czy delegatem; to nie jest typ wartości lub interfejs.</summary>
        <value><see langword="true" />Jeśli jest klasą; w przeciwnym razie <see langword="false" />,. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca `true` dla klas oraz delegatów. Zwraca `false` dla typów wartości (dla struktur i wyliczeń), nawet jeśli są one opakowane.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta właściwość zawsze zwraca wartość `true`. Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, ta właściwość zwraca `true` , jeśli definicja typu ogólnego jest definicją klasy, czyli nie definiuje interfejsu ani typu wartości.  
  
> [!NOTE]
>  Ta właściwość zwraca `true` dla `Type` wystąpień, które reprezentują <xref:System.Enum> klasy <xref:System.ValueType> i. Te dwie klasy są typami podstawowymi dla wyliczeń i typów wartości, ale nie są to wyliczenia ani same typy wartości. Aby uzyskać więcej informacji, zobacz <xref:System.Type.IsValueType%2A> właściwości <xref:System.Type.IsEnum%2A> i.  
  
 Wartość <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> wyliczenia odróżnia deklarację typu jako klasę lub interfejs. Jednak zarówno klasy, jak i typy wartości są oznaczone <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> atrybutem. Jeśli pobierasz wartość właściwości atrybuty typu i użyjesz <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> wartości, aby określić, czy typ jest klasą, a nie typem wartości, należy również <xref:System.Type.IsValueType%2A> wywołać właściwość. Przykład <xref:System.Reflection.TypeAttributes> wyliczenia zawiera dodatkowe informacje, a także anexample.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie typu i wskazuje, czy typ jest klasą.  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, <see cref="T:System.Type" /> czy jest obiektem com.</summary>
        <value><see langword="true" />Jeśli jest obiektem com; w przeciwnym razie <see langword="false" />,. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca `false` dla interfejsów COM, ponieważ nie są obiektami. Interfejsy COM mogą być implementowane przez obiekty Microsoft .NET Framework.  
  
 Można również załadować klasę com i uzyskać `Type` obiekt dla tej klasy com za pomocą narzędzia [Tlbimp. exe (Importer biblioteki typów)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) .  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, ta właściwość ma zastosowanie do definicji typu ogólnego, z której został skonstruowany typ. Na przykład, jeśli <xref:System.Type> bieżący reprezentuje `MyGenericType<int`> (`MyGenericType(Of Integer)` w Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta właściwość zawsze zwraca wartość `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy <see cref="T:System.Type" /> jest zastępowany w klasie pochodnej, implementuje <see cref="P:System.Type.IsCOMObject" /> Właściwość i określa, czy jest to obiekt com.</summary>
        <returns><see langword="true" />Jeśli jest obiektem com; w przeciwnym razie <see langword="false" />,. <see cref="T:System.Type" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca `false` dla interfejsów COM, ponieważ nie są obiektami. Interfejsy COM mogą być implementowane przez obiekty Microsoft .NET Framework.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten obiekt reprezentuje skonstruowany typ ogólny. Można tworzyć wystąpienia konstruowanego typu ogólnego.</summary>
        <value><see langword="true" />Jeśli ten obiekt reprezentuje skonstruowany typ ogólny; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skonstruowany typ ogólny ma jawne typy dostarczone dla wszystkich parametrów typu ogólnego. Jest on również nazywany zamkniętym typem ogólnym.  
  
 Gdy ta właściwość ma `true`wartość, można utworzyć wystąpienia bieżącego typu; w przypadku, gdy nie `false`jest to możliwe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, <see cref="T:System.Type" /> czy może być hostowana w kontekście.</summary>
        <value><see langword="true" />Jeśli może być hostowana w kontekście; <see langword="false" />w przeciwnym razie. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontekst przechwytuje wywołania do członków klasy i wymusza zasady stosowane do klasy, takie jak synchronizacja. Aby uzyskać bardziej szczegółowe informacje na temat kontekstów komunikacji <xref:System.Runtime.Remoting.Contexts.Context>zdalnej, zobacz.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta właściwość zawsze zwraca wartość `false`.  
  
   
  
## Examples  
 Poniższy przykład demonstruje `IsContextful`właściwości <xref:System.Type.IsMarshalByRef%2A> <xref:System.Type.IsPrimitive%2A>,i klasy.<xref:System.Type> Sprawdza, czy dany typ może być hostowany w kontekście, czy może być zorganizowany przez odwołanie oraz czy typ jest typem danych pierwotnych.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementuje właściwość i określa, <see cref="T:System.Type" /> czy może być hostowana w kontekście. <see cref="P:System.Type.IsContextful" /></summary>
        <returns><see langword="true" />Jeśli może być hostowana w kontekście; <see langword="false" />w przeciwnym razie. <see cref="T:System.Type" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
 Kontekst przechwytuje wywołania do członków klasy i wymuszania zasad, które są stosowane do klasy, takie jak synchronizacja.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `IsContextfulImpl` metody.  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący <see cref="T:System.Type" /> reprezentuje Wyliczenie.</summary>
        <value><see langword="true" />Jeśli bieżąca <see cref="T:System.Type" /> reprezentuje Wyliczenie; <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca `true` dla wyliczenia, ale nie <xref:System.Enum> dla samego typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, ta właściwość ma zastosowanie do definicji typu ogólnego, z której został skonstruowany typ. Na przykład, jeśli <xref:System.Type> bieżący reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta właściwość zawsze zwraca wartość `false`.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia `IsEnum` właściwości.  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Wartość, która ma zostać przetestowana.</param>
        <summary>Zwraca wartość wskazującą, czy określona wartość istnieje w bieżącym typie wyliczeniowy.</summary>
        <returns><see langword="true" />Jeśli określona wartość jest elementem członkowskim bieżącego typu wyliczenia; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Bieżący typ nie jest wyliczeniem.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" />jest typu, który nie może być podstawowym typem wyliczenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="other">Typ COM, który jest testowany pod kątem równoważności z bieżącym typem.</param>
        <summary>Określa, czy dwa typy COM mają tę samą tożsamość i kwalifikują się do równoważności typów.</summary>
        <returns><see langword="true" />Jeśli typy COM są równoważne; w przeciwnym razie. <see langword="false" /> Ta metoda zwraca <see langword="false" /> również wtedy, gdy jeden typ znajduje się w zestawie, który jest ładowany do wykonania, a drugi znajduje się w zestawie, który jest ładowany do kontekstu przeznaczonego tylko do odbicia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od programu [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], środowisko uruchomieniowe języka wspólnego obsługuje osadzanie informacji o typie dla typów com bezpośrednio w zarządzanych zestawach, a nie wymaga, aby zarządzane zestawy uzyskały informacje o typie dla typów com z międzyoperacyjności. zestawów. Ponieważ informacje o typie osadzonym zawierają tylko typy i elementy członkowskie, które są faktycznie używane przez zarządzany zestaw, dwa zarządzane zestawy mogą mieć bardzo różne widoki tego samego typu COM. Każdy zarządzany zestaw ma inny <xref:System.Type> obiekt reprezentujący jego widok typu com. Środowisko uruchomieniowe języka wspólnego obsługuje równoważność typu między tymi różnymi widokami dla interfejsów, struktur, wyliczeń i delegatów.  
  
 Równoważność typu oznacza, że obiekt COM, który jest przesyłany z jednego zarządzanego zestawu do innego, może być rzutowany na odpowiedni typ zarządzany w zestawie do odbioru. <xref:System.Type.IsEquivalentTo%2A> Metoda umożliwia zestawowi określenie, że obiekt com uzyskany z innego zestawu ma taką samą tożsamość com jak jeden z wbudowanych typów międzyoperacyjnych zestawu, i w ten sposób może być rzutowany na ten typ.  
  
 Aby uzyskać więcej informacji, zobacz [równoważność typów i osadzone typy](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)międzyoperacyjnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy pola bieżącego typu są ustawiane w jawnie określonych przesunięciach.</summary>
        <value><see langword="true" />Jeśli właściwość bieżącego typu zawiera <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; w przeciwnym razie, <see langword="false" />. <see cref="P:System.Type.Attributes" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest zapewniana jako wygoda. Alternatywnie można użyć <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> wartości wyliczenia, aby wybrać atrybuty układu typu, a następnie sprawdzić, czy <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> jest ustawiony. Wartości wyliczenia <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, i <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> wskazują sposób, w jaki pola typu są określone w pamięci. <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>  
  
 W przypadku typów dynamicznych można określić <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> , kiedy tworzysz typ. W kodzie, należy zastosować <xref:System.Runtime.InteropServices.StructLayoutAttribute> atrybut <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> z wartością wyliczenia do typu, aby określić, że przesunięcia, w których początkowe pola są określane jawnie.  
  
> [!NOTE]
>  Nie można użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metody, aby określić, <xref:System.Runtime.InteropServices.StructLayoutAttribute> czy został on zastosowany do typu.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, ta właściwość ma zastosowanie do definicji typu ogólnego, z której został skonstruowany typ. Na przykład, jeśli <xref:System.Type> bieżący reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta właściwość zawsze zwraca wartość `false`.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie typu i wyświetla wartość jego <xref:System.Type.IsExplicitLayout%2A> właściwości. Używa `MySystemTime` klasy, która również jest w przykładzie kodu dla <xref:System.Runtime.InteropServices.StructLayoutAttribute>.  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">Składniki samoopisujące się i metadane</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący <see cref="T:System.Type" /> reprezentuje parametr typu w definicji typu ogólnego lub metody.</summary>
        <value><see langword="true" />Jeśli obiekt reprezentuje parametr typu w definicji typu ogólnego lub definicji metody generycznej; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type>obiekty reprezentujące parametry typu ogólnego można uzyskać, <xref:System.Type.GetGenericArguments%2A> wywołując metodę <xref:System.Type> obiektu, który reprezentuje definicję <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> typu ogólnego, <xref:System.Reflection.MethodInfo> lub metodę obiektu, który reprezentuje metodę rodzajową definicji.  
  
-   Dla typu ogólnego lub definicji metody, <xref:System.Type.IsGenericParameter%2A> Właściwość zwraca `true` dla każdego elementu tablicy wynikowej.  
  
-   Dla zamkniętego typu konstruowanego lub metody, <xref:System.Type.IsGenericParameter%2A> Właściwość zwraca `false` dla każdego elementu tablicy zwracanej przez <xref:System.Type.GetGenericArguments%2A> metodę.  
  
-   W przypadku otwartego typu konstruowanego lub metody niektóre elementy tablicy mogą być określone typy, a inne mogą być parametrami typu. <xref:System.Type.IsGenericParameter%2A>zwraca `false` dla typów i `true` parametrów typu. Przykład kodu dla <xref:System.Type.ContainsGenericParameters%2A> właściwości pokazuje klasę generyczną z mieszaniną typów i parametrów typu.  
  
 Aby zapoznać się z listą warunków niewariantów dla terminów używanych w odbiciu ogólnym <xref:System.Type.IsGenericType%2A> , zobacz uwagi dotyczące właściwości.  
  
   
  
## Examples  
 W poniższym przykładzie użyta <xref:System.Type.IsGenericParameter%2A> jest właściwość do testowania parametrów typu ogólnego w typie ogólnym.  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący typ jest typem ogólnym.</summary>
        <value><see langword="true" />Jeśli bieżący typ jest typem ogólnym; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj właściwości <xref:System.Type.IsGenericType%2A> , aby określić, <xref:System.Type> czy obiekt reprezentuje typ ogólny. Użyj właściwości <xref:System.Type.ContainsGenericParameters%2A> , aby określić, <xref:System.Type> czy obiekt reprezentuje otwarty typ skonstruowany, czy zamknięty typ skonstruowany.  
  
> [!NOTE]
>  <xref:System.Type.IsGenericType%2A> Właściwość zwraca`false` , jeśli typ bezpośredni nie jest ogólny. Na przykład tablica, której elementy są typu `A<int>` (`A(Of Integer)` w Visual Basic) nie należy do typu ogólnego.  
  
 Poniższa tabela podsumowuje niezmienne warunki dla typowych terminów używanych w odbiciu ogólnym.  
  
|Termin|Niezmiennej|  
|----------|---------------|  
|Definicja typu ogólnego|<xref:System.Type.IsGenericTypeDefinition%2A> Właściwość jest`true`.<br /><br /> Definiuje typ ogólny. Skonstruowany typ jest tworzony przez wywołanie <xref:System.Type.MakeGenericType%2A> metody <xref:System.Type> w obiekcie, który reprezentuje definicję typu ogólnego i określa tablicę argumentów typu.<br /><br /> <xref:System.Type.MakeGenericType%2A>można wywołać tylko dla definicji typu ogólnego.<br /><br /> Każda definicja typu ogólnego jest typem ogólnym ( <xref:System.Type.IsGenericType%2A> właściwość jest `true`), ale nie jest spełniony.|  
|typ ogólny|<xref:System.Type.IsGenericType%2A> Właściwość jest`true`.<br /><br /> Może być definicją typu ogólnego, otwartym typem skonstruowanym lub zamkniętym typem skonstruowanym.<br /><br /> Należy zauważyć, że typ tablicy, której typem elementu jest generyczny, nie jest własnym typem ogólnym. To samo jest prawdziwe <xref:System.Type> względem obiektu reprezentującego wskaźnik do typu ogólnego.|  
|Otwórz typ skonstruowany|<xref:System.Type.ContainsGenericParameters%2A> Właściwość jest`true`.<br /><br /> Przykłady to typ ogólny, który ma nieprzypisane parametry typu, typ, który jest zagnieżdżony w definicji typu ogólnego lub w otwartym typie skonstruowanym lub typ ogólny, który ma argument typu, dla którego <xref:System.Type.ContainsGenericParameters%2A> właściwość jest. `true`<br /><br /> Nie można utworzyć wystąpienia typu otwartego konstruowania.<br /><br /> Należy pamiętać, że nie wszystkie otwarte typy skonstruowane są ogólne. Na przykład tablica, której typem elementu jest definicja typu ogólnego nie jest ogólna, a wskaźnik do otwartego typu skonstruowanego nie jest ogólny.|  
|zamknięty typ skonstruowany|<xref:System.Type.ContainsGenericParameters%2A> Właściwość jest`false`.<br /><br /> Gdy badane cyklicznie, typ nie ma żadnych nieprzypisanych parametrów ogólnych.|  
|parametr typu ogólnego|<xref:System.Type.IsGenericParameter%2A> Właściwość jest`true`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> Właściwość jest`true`.<br /><br /> W definicji typu ogólnego, symbol zastępczy dla typu, który zostanie przypisany później.|  
|argument typu ogólnego|Może być dowolnego typu, w tym parametru typu ogólnego.<br /><br /> Argumenty typu są określane jako tablica <xref:System.Type> obiektów przekazane <xref:System.Type.MakeGenericType%2A> do metody podczas tworzenia konstruowanego typu ogólnego. Jeśli wystąpienia typu wyników mają być tworzone, <xref:System.Type.ContainsGenericParameters%2A> właściwość musi być `false` dla wszystkich argumentów typu.|  
  
 Poniższy przykład kodu i tabela przedstawiają niektóre z tych terminów i niewariantów. `Derived` Klasa jest szczególnie interesująca, ponieważ jej typ podstawowy jest skonstruowanym typem, który ma kombinację typów i parametrów typu z listy argumentów typu.  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 W poniższej tabeli przedstawiono przykłady używające i kompilowania klas `Base`, `Derived`, i `G`. Gdy C++ i C# kod jest taki sam, zostanie wyświetlony tylko jeden wpis.  
  
|Przykład|Nieposiadające wariantów|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|Dla tego typu:<br /><br /> <xref:System.Type.IsGenericType%2A>jest `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A>jest `true`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>jest `true`.|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|Dla tego typu:<br /><br /> <xref:System.Type.IsGenericType%2A>jest `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A>jest `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>jest `true`.|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|Dla typu zmiennej `d`:<br /><br /> <xref:System.Type.IsGenericType%2A>jest `false` , `d` ponieważ jest tablicą.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A>jest `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>jest `false`.|  
|`T`, `U` i`V` (wszędzie, gdzie są wyświetlane)|<xref:System.Type.IsGenericParameter%2A>jest `true`.<br /><br /> <xref:System.Type.IsGenericType%2A>wynika `false` z faktu, że nie ma możliwości ograniczenia parametru typu do typów ogólnych.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A>jest `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>jest `true` , `T`ponieważ ,`U` i`V` są same parametrami typu ogólnego. Nie oznacza to niczego informacji o argumentach typu, które są przypisane do nich później.|  
|Typ pola`F`|<xref:System.Type.IsGenericType%2A>jest `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A>jest `false` , ponieważ typ został przypisany do `G`parametru typu. Należy zauważyć, że jest to równoważne wywołaniu <xref:System.Type.MakeGenericType%2A> metody.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>jest `true` ze względu na to `F` , że typ pola ma argument typu, który jest otwartym typem skonstruowanym. Skonstruowany typ jest otwarty, ponieważ jego argument Type (is, `Base`) jest definicją typu ogólnego. Ilustruje to cykliczny charakter <xref:System.Type.IsGenericType%2A> właściwości.|  
|Klasa zagnieżdżona`Nested`|<xref:System.Type.IsGenericType%2A>jest `true`, mimo `Nested` że Klasa nie ma własnych parametrów typu, ponieważ jest zagnieżdżona w typie ogólnym.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A>jest `true`. Oznacza to, że można wywołać <xref:System.Type.MakeGenericType%2A> metodę i podać parametr typu otaczającego `Derived`typu.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>jest `true` ze względu na to, `Derived`że typ otaczający, ma parametry typu ogólnego. Ilustruje to cykliczny charakter <xref:System.Type.ContainsGenericParameters%2A> właściwości.|  
  
   
  
## Examples  
 Poniższy przykład kodu <xref:System.Type.IsGenericType%2A>wyświetla wartość właściwości <xref:System.Type.IsGenericParameter%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, i <xref:System.Type.ContainsGenericParameters%2A> dla typów opisanych w sekcji uwagi. Aby poznać wyjaśnienie wartości właściwości, zobacz towarzyszącą tabelę w obszarze uwagi.  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący <see cref="T:System.Type" /> reprezentuje definicję typu ogólnego, z której można utworzyć inne typy ogólne.</summary>
        <value><see langword="true" />Jeśli obiekt reprezentuje definicję typu ogólnego; <see langword="false" />w przeciwnym razie. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definicja typu ogólnego to szablon, na podstawie którego można utworzyć inne typy. Na przykład, z definicji `G<T>` typu ogólnego (wyrażona w C# składni; `G(Of Integer)` <xref:System.Type.MakeGenericType%2A> `G<int>` w Visual Basic lub `generic <typename T> ref class G` in C++) można utworzyć i utworzyć wystąpienie typu (w Visual Basic), wywołując metodę z listą argumentów ogólnych zawierającą `G(Of T)` <xref:System.Int32>typ. Obiekt reprezentujący ten skonstruowany typ <xref:System.Type.GetGenericTypeDefinition%2A> Metoda pobiera ponownie definicję typu ogólnego. <xref:System.Type>  
  
 Użyj właściwości <xref:System.Type.IsGenericTypeDefinition%2A> , aby określić, czy można tworzyć nowe typy z bieżącego typu. Jeśli właściwość zwraca `true`, można wywołać metodę,abyutworzyćnowetypyogólne.<xref:System.Type.MakeGenericType%2A> <xref:System.Type.IsGenericTypeDefinition%2A>  
  
 Aby zapoznać się z listą warunków niewariantów dla terminów używanych w odbiciu ogólnym <xref:System.Type.IsGenericType%2A> , zobacz uwagi dotyczące właściwości.  
  
   
  
## Examples  
 Poniższy przykład wyświetla informacje o typie, w tym to, czy jest to definicja typu ogólnego. Informacje są wyświetlane dla konstruowanego typu, dla jego definicji typu ogólnego i dla zwykłego typu.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Type" /> <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> atrybut ma zastosowany, wskazujący, że został zaimportowany z biblioteki typów modelu com.</summary>
        <value><see langword="true" /><see cref="T:System.Type" /> Jeśli <see langword="false" />ma ;wprzeciwnymrazie,.<see cref="T:System.Runtime.InteropServices.ComImportAttribute" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, ta właściwość ma zastosowanie do definicji typu ogólnego, z której został skonstruowany typ. Na przykład, jeśli bieżący <xref:System.Type> reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w Visual Basic), wartość tej właściwości jest określana przez`MyGenericType<T>.`  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta właściwość zawsze zwraca wartość `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt do porównania z bieżącym typem.</param>
        <summary>Określa, czy określony obiekt jest wystąpieniem bieżącej <see cref="T:System.Type" />.</summary>
        <returns><see langword="true" />Jeśli bieżąca <see langword="Type" /> znajduje się w hierarchii dziedziczenia obiektu reprezentowanego przez <paramref name="o" />, lub jeśli bieżąca <see langword="Type" /> jest interfejsem, który <paramref name="o" /> implementuje. <see langword="false" />Jeśli żaden z tych warunków nie jest w przypadku, <paramref name="o" /> Jeśli <see langword="null" />jest lub <see langword="Type" /> jest to otwarty typ ogólny (oznacza to, <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
> [!NOTE]
>  Skonstruowany typ nie jest wystąpieniem definicji typu ogólnego. Oznacza to, `MyGenericList<int>` że`MyGenericList(Of Integer)` (w Visual Basic) nie `MyGenericList<T>` jest wystąpieniem (`MyGenericList(Of T)` w Visual Basic).  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie `IsInstanceOfType` metody.  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Type" /> jest to interfejs, czyli nie jest klasą czy typem wartości.</summary>
        <value><see langword="true" />Jeśli jest interfejsem; w przeciwnym razie <see langword="false" />,. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> Odróżnia deklarację typu jako klasę, interfejs lub typ wartości.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta właściwość zawsze zwraca wartość `false`.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład tworzy interfejs, sprawdza typ interfejsu i wskazuje, czy Klasa ma `IsInterface` ustawioną właściwość.  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy pola bieżącego typu są ustawiane sekwencyjnie, w kolejności, w jakiej zostały zdefiniowane lub emitowane do metadanych.</summary>
        <value><see langword="true" />Jeśli właściwość bieżącego typu zawiera <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; w przeciwnym razie, <see langword="false" />. <see cref="P:System.Type.Attributes" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest zapewniana jako wygoda. Alternatywnie można użyć <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> wartości wyliczenia, aby wybrać atrybuty układu typu, a następnie sprawdzić, czy <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> jest ustawiony. Wartości wyliczenia <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, i <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> wskazują sposób, w jaki pola typu są określone w pamięci. <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>  
  
 W przypadku typów dynamicznych można określić <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> , kiedy tworzysz typ. W kodzie należy zastosować <xref:System.Runtime.InteropServices.StructLayoutAttribute> atrybut <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> z wartością wyliczenia do typu, aby określić, że układ jest sekwencyjny.  
  
> [!NOTE]
>  Nie można użyć <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metody, aby określić, <xref:System.Runtime.InteropServices.StructLayoutAttribute> czy został on zastosowany do typu.  
  
 Aby uzyskać więcej informacji, zobacz sekcję 9.1.2 specyfikacji dla dokumentacji Common Language Infrastructure (CLI), "Partition II: Definicja i semantyka metadanych ". Dokumentacja jest dostępna w trybie online; Zobacz [standardy C# ECMA i Common Language Infrastructure](https://go.microsoft.com/fwlink/?LinkID=99212) w MSDN i [Standard ECMA-335-Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) w międzynarodowej witrynie sieci Web ECMA.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, ta właściwość ma zastosowanie do definicji typu ogólnego, z której został skonstruowany typ. Na przykład, jeśli <xref:System.Type> bieżący reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta właściwość zawsze zwraca wartość `false`.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie klasy, dla której <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> <xref:System.Type.IsLayoutSequential%2A> ustawiono wartość wyliczenia <xref:System.Runtime.InteropServices.StructLayoutAttribute> w klasie, wyszukuje Właściwość i wyświetla wynik.  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">Składniki samoopisujące się i metadane</related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, <see cref="T:System.Type" /> czy jest organizowane przez odwołanie.</summary>
        <value><see langword="true" />Jeśli jest zorganizowany przez odwołanie; <see langword="false" />w przeciwnym razie. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład demonstruje `IsContextful`właściwości <xref:System.Type.IsMarshalByRef%2A> <xref:System.Type.IsPrimitive%2A>,i klasy.<xref:System.Type> Sprawdza, czy dany typ może być hostowany w kontekście, czy może być zorganizowany przez odwołanie oraz czy typ jest typem danych pierwotnych.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementuje właściwość i określa, <see cref="T:System.Type" /> czy jest zorganizowany przez odwołanie. <see cref="P:System.Type.IsMarshalByRef" /></summary>
        <returns><see langword="true" />Jeśli jest zorganizowany przez odwołanie; <see langword="false" />w przeciwnym razie. <see cref="T:System.Type" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
   
  
## Examples  
 Poniższy przykład określa, czy dany typ jest zorganizowany przez odwołanie i wyświetla wynik.  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący <see cref="T:System.Type" /> obiekt reprezentuje typ, którego definicja jest zagnieżdżona w definicji innego typu.</summary>
        <value><see langword="true" />Jeśli jest zagnieżdżona wewnątrz innego typu; w przeciwnym <see langword="false" />razie,. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsNested%2A> Właściwość zwraca`true` dla wszystkich zagnieżdżonych typów, niezależnie od widoczności. Aby przetestować na potrzeby zagnieżdżania i widoczności w tym samym czasie, użyj powiązanych właściwości <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A> <xref:System.Type.IsNestedFamORAssem%2A> <xref:System.Type.IsNestedPrivate%2A>,, lub <xref:System.Type.IsNestedPublic%2A>.  
  
> [!NOTE]
>  Element <xref:System.Reflection.TypeAttributes.VisibilityMask> członkowski wyliczenia wybiera atrybuty widoczności dla danego typu.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę zewnętrzną z liczbą zagnieżdżonych klas, które mają różne typy widoczności. Następnie pobiera wartość wielu właściwości związanych <xref:System.Type> z widocznością dla typu nadrzędnego i każdego z jego typów zagnieżdżonych.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Type" /> element jest zagnieżdżony i widoczny tylko w obrębie własnego zestawu.</summary>
        <value><see langword="true" />Jeśli jest zagnieżdżona i widoczna tylko w ramach własnego zestawu; <see langword="false" />w przeciwnym razie. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zawsze zwraca wartość `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>Wybiera atrybuty widoczności.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę zewnętrzną z liczbą zagnieżdżonych klas, które mają różne typy widoczności. Następnie pobiera wartość wielu właściwości związanych <xref:System.Type> z widocznością dla typu nadrzędnego i każdego z jego typów zagnieżdżonych.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Type" /> jest zagnieżdżona i widoczna tylko dla klas, które należą zarówno do własnej rodziny, jak i do własnego zestawu.</summary>
        <value><see langword="true" />Jeśli jest zagnieżdżona i widoczna tylko dla klas, które należą do własnej rodziny i własnego zestawu; <see langword="false" />w przeciwnym razie. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zawsze zwraca wartość `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>Wybiera atrybuty widoczności.  
  
> [!NOTE]
>  Języki C# i Visual Basic nie zawierają semantyki, która pozwala zdefiniować zagnieżdżony typ, który jest widoczny tylko dla typów chronionych w osobnym zestawie. `protected internal`widoczność C# i `Protected Friend` widoczność w Visual Basic definiują zagnieżdżony typ, który jest widoczny zarówno dla typów chronionych, jak i do typów w tym samym zestawie.  
  
 Rodzina obiektów jest definiowana jako wszystkie obiekty tego samego <xref:System.Type> i jego podtypów. <xref:System.Type>  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę zewnętrzną z liczbą zagnieżdżonych klas, które mają różne typy widoczności. Następnie pobiera wartość wielu właściwości związanych <xref:System.Type> z widocznością dla typu nadrzędnego i każdego z jego typów zagnieżdżonych.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Type" /> element jest zagnieżdżony i widoczny tylko w obrębie własnej rodziny.</summary>
        <value><see langword="true" />Jeśli jest zagnieżdżona i widoczna tylko w obrębie własnej rodziny; <see langword="false" />w przeciwnym razie. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zawsze zwraca wartość `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>Wybiera atrybuty widoczności.  
  
 Rodzina obiektów jest definiowana jako wszystkie obiekty dokładnie takie same <xref:System.Type> i jego podtypów. <xref:System.Type>  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę zewnętrzną z liczbą zagnieżdżonych klas, które mają różne typy widoczności. Następnie pobiera wartość wielu właściwości związanych <xref:System.Type> z widocznością dla typu nadrzędnego i każdego z jego typów zagnieżdżonych.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Type" /> jest zagnieżdżona i widoczna tylko dla klas, które należą do własnej rodziny lub do własnego zestawu.</summary>
        <value><see langword="true" />Jeśli jest zagnieżdżona i widoczna tylko dla klas, które należą do własnej rodziny lub do własnego zestawu; <see langword="false" />w przeciwnym razie. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli widoczność typu jest `protected internal` w C# lub `Protected Friend` w Visual Basic, <xref:System.Type.IsNestedFamORAssem%2A> Właściwość zwraca `true`.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zawsze zwraca wartość `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>Wybiera atrybuty widoczności.  
  
 Rodzina obiektów jest definiowana jako wszystkie obiekty dokładnie takie same <xref:System.Type> i jego podtypów. <xref:System.Type>  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę zewnętrzną z liczbą zagnieżdżonych klas, które mają różne typy widoczności. Następnie pobiera wartość wielu właściwości związanych <xref:System.Type> z widocznością dla typu nadrzędnego i każdego z jego typów zagnieżdżonych.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Type" /> jest zagnieżdżona i zadeklarowana jako prywatna.</summary>
        <value><see langword="true" />Jeśli jest zagnieżdżona i zadeklarowana jako prywatna; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zawsze zwraca wartość `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>Wybiera atrybuty widoczności.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę zewnętrzną z liczbą zagnieżdżonych klas, które mają różne typy widoczności. Następnie pobiera wartość wielu właściwości związanych <xref:System.Type> z widocznością dla typu nadrzędnego i każdego z jego typów zagnieżdżonych.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy Klasa jest zagnieżdżona i zadeklarowana jako publiczna.</summary>
        <value><see langword="true" />Jeśli klasa jest zagnieżdżona i zadeklarowana publicznie; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zawsze zwraca wartość `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>Wybiera atrybuty widoczności.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę zewnętrzną z liczbą zagnieżdżonych klas, które mają różne typy widoczności. Następnie pobiera wartość wielu właściwości związanych <xref:System.Type> z widocznością dla typu nadrzędnego i każdego z jego typów zagnieżdżonych.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, <see cref="T:System.Type" /> czy nie jest zadeklarowany jako publiczny.</summary>
        <value><see langword="true" />Jeśli nie <see langword="false" />jest zadeklarowany jako publiczny i nie jest typem zagnieżdżonym; w przeciwnym razie,. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy używać tej właściwości z typami zagnieżdżonymi; Zamiast tego użyj właściwości. <xref:System.Type.IsNestedPublic%2A>  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zwraca `false`.  
  
   
  
## Examples  
 Ten przykład używa `IsNotPublic` właściwości, aby uzyskać widoczność typu.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 Poniższy przykład kodu demonstruje, dlaczego nie można używać `IsPublic` i `IsNotPublic` dla klas zagnieżdżonych.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 W przypadku `IsPublic` klas zagnieżdżonych zignoruj wyniki i `IsNotPublic` i zwróć uwagę `IsNestedPublic` tylko `IsNestedPrivate`na wyniki i. Dane wyjściowe odbicia dla tego fragmentu kodu byłyby następujące:  
  
|Class|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|ELEMENT|FAŁSZ|OZNACZA|FAŁSZ|FAŁSZ|  
|B|FAŁSZ|FAŁSZ|OZNACZA|FAŁSZ|  
|C|FAŁSZ|FAŁSZ|FAŁSZ|OZNACZA|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, <see cref="T:System.Type" /> czy jest wskaźnikiem.</summary>
        <value><see langword="true" />Jeśli jest wskaźnikiem; w przeciwnym razie <see langword="false" />,. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny lub parametr typu w definicji typu ogólnego lub metody generycznej, ta właściwość zawsze zwraca wartość `false`.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie `IsPointer` właściwości.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy <see cref="T:System.Type" /> jest zastępowany w klasie pochodnej, implementuje <see cref="P:System.Type.IsPointer" /> Właściwość i określa, czy jest wskaźnikiem.</summary>
        <returns><see langword="true" />Jeśli jest wskaźnikiem; w przeciwnym razie <see langword="false" />,. <see cref="T:System.Type" /></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Type" /> jest jednym z typów pierwotnych.</summary>
        <value><see langword="true" />Jeśli jest jednym z typów pierwotnych; w przeciwnym razie <see langword="false" />,. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typy pierwotne to <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte> <xref:System.Int16> ,<xref:System.UInt16>,, ,<xref:System.UInt32>, ,,<xref:System.Int64>,, ,<xref:System.Char> <xref:System.UInt64> <xref:System.Int32> <xref:System.IntPtr> <xref:System.UIntPtr> <xref:System.Double>i .<xref:System.Single>  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny lub parametr typu w definicji typu ogólnego lub metody generycznej, ta właściwość zawsze zwraca wartość `false`.  
  
   
  
## Examples  
 Poniższy przykład demonstruje `IsContextful`właściwości <xref:System.Type.IsMarshalByRef%2A> <xref:System.Type.IsPrimitive%2A>,i klasy.<xref:System.Type> Sprawdza, czy dany typ może być hostowany w kontekście, czy może być zorganizowany przez odwołanie oraz czy typ jest typem danych pierwotnych.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy <see cref="T:System.Type" /> jest zastępowany w klasie pochodnej, implementuje <see cref="P:System.Type.IsPrimitive" /> Właściwość i określa, czy jest jednym z typów pierwotnych.</summary>
        <returns><see langword="true" />Jeśli jest jednym z typów pierwotnych; w przeciwnym razie <see langword="false" />,. <see cref="T:System.Type" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typy pierwotne to <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte> <xref:System.Int16> ,<xref:System.UInt16>,, ,<xref:System.UInt32>, ,,<xref:System.Int64>, i<xref:System.Single>. <xref:System.Int32> <xref:System.UInt64> <xref:System.Char> <xref:System.Double>  
  
   
  
## Examples  
 Poniższy przykład określa, czy dany typ jest typem pierwotnym i wyświetla wynik.  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, <see cref="T:System.Type" /> czy jest zadeklarowana jako publiczna.</summary>
        <value><see langword="true" />Jeśli jest zadeklarowana jako Public i nie jest typem zagnieżdżonym; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy używać z typami zagnieżdżonymi; Użyj <xref:System.Type.IsNestedPublic%2A> zamiast tego.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zwraca `true`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>Wybiera atrybuty widoczności.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie `MyTestClass`, sprawdza `IsPublic` Właściwość i wyświetla wynik.  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 W przypadku `IsPublic` klas zagnieżdżonych zignoruj wyniki i `IsNotPublic` i zwróć uwagę <xref:System.Type.IsNestedPublic%2A> tylko <xref:System.Type.IsNestedPrivate%2A>na wyniki i.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, <see cref="T:System.Type" /> czy jest zadeklarowany jako zapieczętowany.</summary>
        <value><see langword="true" />Jeśli jest zadeklarowany jako zapieczętowany; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu ogólnego, ta właściwość zawsze zwraca wartość `true`.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie `sealed` klasy, sprawdza `IsSealed` Właściwość i wyświetla wynik.  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący typ jest krytyczny pod względem zabezpieczeń, czy bezpieczny-krytyczny na bieżącym poziomie zaufania, dlatego może wykonywać krytyczne operacje.</summary>
        <value><see langword="true" />Jeśli bieżący typ jest krytyczny dla zabezpieczeń lub bezpieczny-krytyczny na bieżącym poziomie zaufania; <see langword="false" /> jeśli jest przezroczysty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A> i<xref:System.Type.IsSecurityTransparent%2A> raportują poziom przezroczystości typu na bieżącym poziomie zaufania, zgodnie z opisem w środowisku uruchomieniowym języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Korzystanie z tych właściwości jest znacznie prostsze niż badanie adnotacji zabezpieczeń zestawu i jego typów, sprawdzanie bieżącego poziomu zaufania i próba duplikowania reguł środowiska uruchomieniowego.  
  
> [!IMPORTANT]
>  Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu. Jeżeli zestaw jest ładowany do domeny aplikacji częściowo zaufanej (na przykład w domenie aplikacji w trybie piaskownicy), środowisko wykonawcze ignoruje adnotacje zabezpieczeń zestawu. Zestaw i wszystkie jego typy są traktowane jako przezroczyste. Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu). Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany. Bieżące poziomy zaufania zestawów i domen aplikacji można określić przy użyciu <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości i. <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>  
  
 Aby uzyskać więcej informacji o odbiciu i przezroczystości, zobacz Zagadnienia dotyczące [zabezpieczeń dotyczące odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Aby uzyskać informacje na temat przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Zagadnienia dotyczące zabezpieczeń dla odbicia</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Zmiany zabezpieczeń w programie .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący typ jest bezpieczny dla bezpieczeństwa-krytyczny na bieżącym poziomie zaufania; oznacza to, czy może wykonywać krytyczne operacje i można uzyskać do nich dostęp za pomocą przezroczystego kodu.</summary>
        <value><see langword="true" />Jeśli bieżący typ jest bezpieczny dla bezpieczeństwa-krytyczny na bieżącym poziomie zaufania; <see langword="false" /> jeśli jest to zabezpieczenia krytyczne lub przezroczyste.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A> i<xref:System.Type.IsSecurityTransparent%2A> raportują poziom przezroczystości typu na bieżącym poziomie zaufania, zgodnie z opisem w środowisku uruchomieniowym języka wspólnego (CLR). W poniższej tabeli przedstawiono kombinacje tych właściwości:  
  
|Poziom zabezpieczeń|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Krytyczny|`true`|`false`|`false`|  
|Bezpieczne krytyczne|`true`|`true`|`false`|  
|Przezroczyste|`false`|`false`|`true`|  
  
 Korzystanie z tych właściwości jest znacznie prostsze niż badanie adnotacji zabezpieczeń zestawu i jego typów, sprawdzanie bieżącego poziomu zaufania i próba duplikowania reguł środowiska uruchomieniowego.  
  
> [!IMPORTANT]
>  Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu. Jeżeli zestaw jest ładowany do domeny aplikacji częściowo zaufanej (na przykład w domenie aplikacji w trybie piaskownicy), środowisko wykonawcze ignoruje adnotacje zabezpieczeń zestawu. Zestaw i wszystkie jego typy są traktowane jako przezroczyste. Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu). Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany. Bieżące poziomy zaufania zestawów i domen aplikacji można określić przy użyciu <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości i. <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>  
  
 Aby uzyskać więcej informacji o odbiciu i przezroczystości, zobacz Zagadnienia dotyczące [zabezpieczeń dotyczące odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Aby uzyskać informacje na temat przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Zagadnienia dotyczące zabezpieczeń dla odbicia</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Zmiany zabezpieczeń w programie .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący typ jest przezroczysty na bieżącym poziomie zaufania i w związku z tym nie może wykonywać krytycznych operacji.</summary>
        <value><see langword="true" />Jeśli typ jest przezroczysty dla zabezpieczeń na bieżącym poziomie zaufania; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość zwróci `true`wartość, <xref:System.Type.IsSecurityCritical%2A> zwracane <xref:System.Type.IsSecuritySafeCritical%2A> `false`są właściwości i.  
  
 Właściwości <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A> i<xref:System.Type.IsSecurityTransparent%2A> raportują poziom przezroczystości typu na bieżącym poziomie zaufania, zgodnie z opisem w środowisku uruchomieniowym języka wspólnego (CLR). Korzystanie z tych właściwości jest znacznie prostsze niż badanie adnotacji zabezpieczeń zestawu i jego typów, sprawdzanie bieżącego poziomu zaufania i próba duplikowania reguł środowiska uruchomieniowego.  
  
> [!IMPORTANT]
>  Dla zestawów częściowego zaufania wartość tej właściwości zależy od bieżącego poziomu zaufania dla zestawu. Jeżeli zestaw jest ładowany do domeny aplikacji częściowo zaufanej (na przykład w domenie aplikacji w trybie piaskownicy), środowisko wykonawcze ignoruje adnotacje zabezpieczeń zestawu. Zestaw i wszystkie jego typy są traktowane jako przezroczyste. Środowisko wykonawcze zwraca uwagę na adnotacje zabezpieczeń zestawu częściowego zaufania tylko wtedy, gdy zestaw ten jest ładowany do w pełni zaufanej domeny aplikacji (na przykład, do domyślnej domeny aplikacji z aplikacji pulpitu). Z drugiej strony zaufany zestaw (czyli zestaw z silną nazwą zainstalowaną w globalnej pamięci podręcznej zestawów) zawsze jest ładowany z pełnym zaufaniem, bez względu na poziom zaufania domeny aplikacji, więc jego bieżący poziom zaufania zawsze jest w pełni zaufany. Bieżące poziomy zaufania zestawów i domen aplikacji można określić przy użyciu <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> właściwości i. <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>  
  
 Aby uzyskać więcej informacji o odbiciu i przezroczystości, zobacz Zagadnienia dotyczące [zabezpieczeń dotyczące odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Aby uzyskać informacje na temat przejrzystości, zobacz [zmiany zabezpieczeń](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Zagadnienia dotyczące zabezpieczeń dla odbicia</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Zmiany zabezpieczeń w programie .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest <see cref="T:System.Type" /> możliwy do serializacji.</summary>
        <value><see langword="true" />Jeśli jest <see cref="T:System.Type" /> możliwy do serializacji; <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Typy, które są zdefiniowane w .NET Standard nie są oznaczone atrybutem <xref:System.SerializableAttribute>. Zamiast tego każda implementacja platformy .NET określa, czy typ jest możliwy do serializacji. W czasie wykonywania można użyć <xref:System.Type.IsSerializable%2A> właściwości, aby określić, czy ta implementacja obsługuje serializację wystąpienia typu. Aby uzyskać więcej informacji i zapoznać się z przykładem, zobacz [Jak ustalić, czy obiekt .NET Standard jest możliwy do serializacji](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, ta właściwość ma zastosowanie do definicji typu ogólnego, z której został skonstruowany typ. Na przykład, jeśli <xref:System.Type> bieżący reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta właściwość zawsze zwraca wartość `false`.  
  
   
  
## Examples  
 Poniższy `MyTestClass` przykład tworzy wystąpienie klasy, ustawia atrybut [Serializable] i `IsSerializable` sprawdza właściwość dla `true` lub `false`.  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy typ ma nazwę wymagającą specjalnej obsługi.</summary>
        <value><see langword="true" />Jeśli typ ma nazwę wymagającą specjalnej obsługi; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwy rozpoczynające się od znaku podkreślenia (_), metody dostępu do właściwości i metod przeciążania operatora są przykładami typów, które mogą wymagać specjalnego traktowania przez niektóre kompilatory.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, ta właściwość ma zastosowanie do definicji typu ogólnego, z której został skonstruowany typ. Na przykład, jeśli <xref:System.Type> bieżący reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta właściwość zawsze zwraca wartość `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c">Typ do porównania z bieżącym typem.</param>
        <summary>Określa, czy bieżący <see cref="T:System.Type" /> pochodzi od określonego. <see cref="T:System.Type" /></summary>
        <returns><see langword="true" />Jeśli bieżący <see langword="Type" /> pochodzi z <paramref name="c" />; w przeciwnym razie <see langword="false" />. Ta metoda zwraca również <see langword="false" /> wartość <paramref name="c" /> , jeśli bieżąca <see langword="Type" /> jest równa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz wywołać metodę, <xref:System.Type.IsSubclassOf%2A> aby określić dowolne z następujących elementów:  
  
-   Określa, czy jedna klasa pochodzi od innej.  
  
-   Określa, czy typ pochodzi <xref:System.ValueType>od. <xref:System.Type.IsValueType%2A> Jednak jest to bardziej wydajny sposób, aby określić, czy typ jest typem wartości.  
  
-   Określa, czy typ pochodzi <xref:System.Enum>od. <xref:System.Type.IsEnum%2A> Jednak metoda jest bardziej wydajnym sposobem określenia, czy typ jest wyliczeniem.  
  
-   Określa, czy typ jest delegatem, czyli czy pochodzi z albo <xref:System.Delegate> lub. <xref:System.MulticastDelegate>  
  
 <xref:System.Type.IsSubclassOf%2A> Metoda nie może służyć do określenia, czy interfejs pochodzi z innego interfejsu, czy Klasa implementuje interfejs. <xref:System.Type.IsAssignableFrom%2A> Użyj metody do tego celu, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 Jeśli bieżący <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, pochodzi on z ograniczenia klasy lub z <xref:System.Object?displayProperty=nameWithType> , jeśli nie ma ograniczenia klasy.  
  
> [!NOTE]
>  Z wyjątkiem sytuacji, gdy jest <xref:System.Type.IsSubclassOf%2A> używana z interfejsami, <xref:System.Type.IsAssignableFrom%2A>jest to odwrotność. Oznacza `t1.IsSubclassOf(t2)` to, `true` `true`że to jest również. `t2.IsAssignableFrom(t1)`  
  
 Metoda ta może być zastąpiona przez klasę pochodną.  
  
   
  
## Examples  
 Poniższy przykład tworzy klasę o nazwie `Class1` i klasy pochodnej o nazwie. `DerivedC1` Wywołuje <xref:System.Type.IsSubclassOf%2A> metodę, aby pokazać, że `DerivedC1` jest podklasą `Class1`.  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" />jest <see langword="null" />.</exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy atrybut <see langword="UnicodeClass" /> formatu ciągu jest wybrany <see cref="T:System.Type" />dla.</summary>
        <value><see langword="true" />w przypadku wybrania atrybutu <see langword="UnicodeClass" /> format ciągu <see cref="T:System.Type" />dla; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> Służy do wybierania atrybutów formatu ciągu. Atrybuty formatu ciągu zwiększają współdziałanie przez definiowanie sposobu interpretacji ciągów.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, ta właściwość ma zastosowanie do definicji typu ogólnego, z której został skonstruowany typ. Na przykład, jeśli <xref:System.Type> bieżący reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta właściwość zawsze zwraca wartość `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, <see cref="T:System.Type" /> czy jest to typ wartości.</summary>
        <value><see langword="true" />Jeśli jest typem wartości; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Type" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typy wartości są typami, które są reprezentowane jako sekwencje bitów. typy wartości nie są klasami ani interfejsami. Typy wartości są określane jako "struktury" w niektórych językach programowania. Wyliczenia są szczególnym przypadkiem typów wartości.  
  
 Ta właściwość zwraca `false` <xref:System.ValueType> dla klasy, ponieważ <xref:System.ValueType> nie jest to typ wartości. Jest klasą bazową dla wszystkich typów wartości, w związku z czym można do niej przypisać każdy typ wartości. Nie będzie to możliwe, jeśli <xref:System.ValueType> sama była typem wartości. Typy wartości są opakowane, gdy są przypisane do pola typu <xref:System.ValueType>.  
  
 Ta właściwość zwraca `true` dla wyliczeń, ale nie <xref:System.Enum> dla samego typu. Przykład demonstrujący Takie zachowanie znajduje się w temacie <xref:System.Type.IsEnum%2A>.  
  
 Ta właściwość jest tylko do odczytu.  
  
   
  
## Examples  
 Poniższy przykład tworzy zmienną typu `MyEnum`, sprawdza obecność `IsValueType` właściwości i wyświetla wynik.  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementuje właściwość i określa, <see cref="T:System.Type" /> czy jest to typ wartości, czyli nie jest klasą lub interfejsem. <see cref="P:System.Type.IsValueType" /></summary>
        <returns><see langword="true" />Jeśli jest typem wartości; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Type" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapewnia włączenie implementacji systemów alternatywnych typów. Nie jest on zazwyczaj używany w kodzie aplikacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dostęp <see cref="T:System.Type" /> do niego można uzyskać za pomocą kodu poza zestawem.</summary>
        <value><see langword="true" />Jeśli bieżąca <see cref="T:System.Type" /> jest typu publicznego lub publicznego typu zagnieżdżonego, tak że wszystkie typy otaczające są publiczne; w przeciwnym razie, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej właściwości, aby określić, czy typ jest częścią interfejsu publicznego zestawu składnika.  
  
   
  
## Examples  
 Poniższy przykład kodu testuje dwie klasy, tylko jeden z nich jest widoczny poza zestawem.  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Type" /> Zwraca obiekt, który reprezentuje tablicę bieżącego typu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Type" /> Zwraca obiekt reprezentujący tablicę jednowymiarową bieżącego typu z dolną granicą równą zero.</summary>
        <returns><see cref="T:System.Type" /> Obiekt reprezentujący tablicę jednowymiarową bieżącego typu z dolną granicą zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A> Metoda umożliwia generowanie typów tablicowych, których typy elementów są obliczane w czasie wykonywania.  
  
 **Uwaga** Środowisko uruchomieniowe języka wspólnego wykonuje rozróżnienie między wektorami (czyli tablicami jednowymiarowymi, które są zawsze zerem) i tablic wielowymiarowych. Wektor, który zawsze ma tylko jeden wymiar, nie jest taki sam jak tablica wielowymiarowa, która ma tylko jeden wymiar. Tego przeciążenia metody można używać tylko do tworzenia typów wektorów i jest jedynym sposobem utworzenia typu wektora. Użyj przeciążenia <xref:System.Type.MakeArrayType%28System.Int32%29> metody, aby utworzyć wielowymiarowe typy tablic.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tablicę `ref` (`ByRef` w Visual Basic) `Test` i typ wskaźnika dla klasy.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej. Klasy pochodne muszą dostarczać implementację.</exception>
        <exception cref="T:System.TypeLoadException">Bieżącym typem jest <see cref="T:System.TypedReference" />.  
  
—lub— 
Bieżący typ jest <see langword="ByRef" /> typem. Oznacza to, <see cref="P:System.Type.IsByRef" /> że <see langword="true" />zwraca.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rank">Liczba wymiarów tablicy. Ta wartość musi być mniejsza lub równa 32.</param>
        <summary><see cref="T:System.Type" /> Zwraca obiekt reprezentujący tablicę bieżącego typu o określonej liczbie wymiarów.</summary>
        <returns>Obiekt reprezentujący tablicę bieżącego typu o określonej liczbie wymiarów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A> Metoda umożliwia generowanie typów tablicowych, których typy elementów są obliczane w czasie wykonywania.  
  
> [!NOTE]
>  Środowisko uruchomieniowe języka wspólnego wykonuje rozróżnienie między wektorami (czyli tablicami jednowymiarowymi, które są zawsze zerem) i tablic wielowymiarowych. Wektor, który zawsze ma tylko jeden wymiar, nie jest taki sam jak tablica wielowymiarowa, która ma tylko jeden wymiar. Nie można użyć tego przeciążenia metody do utworzenia typu wektora; Jeśli `rank` jest 1, to Przeciążenie metody zwraca typ tablicy wielowymiarowej, która ma taki sam wymiar. Użyj przeciążenia <xref:System.Type.MakeArrayType> metody, aby utworzyć typy wektorów.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tablicę `ref` (`ByRef` w Visual Basic) `Test` i typ wskaźnika dla klasy.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="rank" /> jest nieprawidłowy. Na przykład 0 lub ujemny.</exception>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</exception>
        <exception cref="T:System.TypeLoadException">Bieżącym typem jest <see cref="T:System.TypedReference" />.  
  
—lub— 
Bieżący typ jest <see langword="ByRef" /> typem. Oznacza to, <see cref="P:System.Type.IsByRef" /> że <see langword="true" />zwraca.  
  
—lub— 
 <paramref name="rank" />jest większa niż 32.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca obiekt, który reprezentuje bieżący typ, gdy jest <see langword="ref" /> przenoszona jako parametr<see langword="ByRef" /> (parametr w Visual Basic). <see cref="T:System.Type" /></summary>
        <returns>Obiekt, który reprezentuje bieżący typ, gdy jest <see langword="ref" /> przenoszona jako parametr<see langword="ByRef" /> (parametr w Visual Basic). <see cref="T:System.Type" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda umożliwia generowanie `ref` typów (`ByRef` w Visual Basic) dla list parametrów. <xref:System.Type.MakeByRefType%2A>  
  
 Przy użyciu składni języka pośredniego firmy Microsoft (MSIL), jeśli <xref:System.Type> bieżący obiekt <xref:System.Int32>reprezentuje <xref:System.Type> , ta metoda zwraca obiekt reprezentujący `Int32&`.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tablicę `ref` (`ByRef` w Visual Basic) `Test` i typ wskaźnika dla klasy.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</exception>
        <exception cref="T:System.TypeLoadException">Bieżącym typem jest <see cref="T:System.TypedReference" />.  
  
—lub— 
Bieżący typ jest <see langword="ByRef" /> typem. Oznacza to, <see cref="P:System.Type.IsByRef" /> że <see langword="true" />zwraca.</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericSignatureType">
      <MemberSignature Language="C#" Value="public static Type MakeGenericSignatureType (Type genericTypeDefinition, params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericSignatureType(class System.Type genericTypeDefinition, class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericSignatureType(System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericSignatureType (genericTypeDefinition As Type, ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericSignatureType(Type ^ genericTypeDefinition, ... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="static member MakeGenericSignatureType : Type * Type[] -&gt; Type" Usage="System.Type.MakeGenericSignatureType (genericTypeDefinition, typeArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericTypeDefinition" Type="System.Type" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="typeArguments" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="genericTypeDefinition">Definicja typu ogólnego.</param>
        <param name="typeArguments">Tablica argumentów typu.</param>
        <summary>Tworzy typ podpisu ogólnego, który umożliwia osobom trzecim odtworzenie odbicia, aby w pełni obsługiwać użycie typów sygnatur w elementach członkowskich typu zapytania.</summary>
        <returns>Typ podpisu ogólnego.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Tablica typów, które mają zostać zastąpione dla parametrów typu bieżącego typu ogólnego.</param>
        <summary>Zastępuje elementy tablicy typów dla parametrów typu bieżącej definicji typu ogólnego i zwraca <see cref="T:System.Type" /> obiekt reprezentujący wynikowy typ skonstruowany.</summary>
        <returns>Reprezentujący skonstruowany typ utworzony przez podstawianie <paramref name="typeArguments" /> elementów dla parametrów typu bieżącego typu ogólnego. <see cref="T:System.Type" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda pozwala napisać kod, który przypisuje określone typy do parametrów typu definicji typu ogólnego, <xref:System.Type> tworząc w ten sposób obiekt reprezentujący konkretny typ skonstruowany. <xref:System.Type.MakeGenericType%2A> Można użyć tego <xref:System.Type> obiektu, aby utworzyć wystąpienia typu w czasie wykonywania.  
  
 Typy skonstruowane z <xref:System.Type.MakeGenericType%2A> mogą być otwarte, to oznacza, że niektóre z ich argumentów typu mogą być parametrami typu zawierającymi ogólne metody lub typy. Możesz użyć takich otwartych typów, gdy emitujesz zestawy dynamiczne. Rozważmy na przykład klasy `Base` i `Derived` w poniższym kodzie.  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 Aby wygenerować `Derived` w zestawie dynamicznym, konieczne jest skonstruowanie jego typu podstawowego. W tym celu wywołaj <xref:System.Type.MakeGenericType%2A> metodę <xref:System.Type> na obiekcie reprezentującym klasę `Base`, używając argumentów <xref:System.Int32> typu ogólnego i parametru `V` typu z `Derived`. Ponieważ typy i parametry typu ogólnego są reprezentowane przez <xref:System.Type> obiekty, tablica zawierająca oba mogą być przesyłane <xref:System.Type.MakeGenericType%2A> do metody.  
  
> [!NOTE]
>  Skonstruowany typ, taki `Base<int, V>` jak jest przydatny podczas emitowania kodu, ale nie można <xref:System.Type.MakeGenericType%2A> wywołać metody dla tego typu, ponieważ nie jest to definicja typu ogólnego. Aby utworzyć zamknięty skonstruowany typ, który może być skonkretyzowany, najpierw Wywołaj <xref:System.Type.GetGenericTypeDefinition%2A> metodę, aby <xref:System.Type> uzyskać obiekt reprezentujący definicję typu ogólnego, a następnie <xref:System.Type.MakeGenericType%2A> Wywołaj z żądanymi argumentami typu.  
  
 <xref:System.Type.MakeGenericType%2A> <xref:System.Object.GetType%2A> Obiekt zwrócony przez <xref:System.Object.GetType%2A> jest taki sam jak uzyskanyprzezwywołaniemetodywynikowegotypukonstruowanialubmetodydowolnegotypuzłożonego,któryzostałutworzonynapodstawietegosamegogenerycznego<xref:System.Type> <xref:System.Type> Definicja typu przy użyciu tych samych argumentów typu.  
  
> [!NOTE]
>  Tablica typów ogólnych nie należy do typu ogólnego. Nie można wywołać <xref:System.Type.MakeGenericType%2A> typu tablicy, takiego jak `C<T>[]` (`Dim ac() As C(Of T)` w Visual Basic). Aby skonstruować zamknięty typ ogólny z `C<T>[]`, należy wywołać <xref:System.Type.GetElementType%2A> metodę w celu uzyskania definicji `C<T>`typu ogólnego; <xref:System.Type.MakeGenericType%2A> Wywołaj w <xref:System.Type.MakeArrayType%2A> definicji typu ogólnego, aby utworzyć skonstruowany typ, i na koniec wywołać metody skonstruowany typ do utworzenia typu tablicy. To samo dotyczy typów wskaźnikowych i `ref` typów (`ByRef` w Visual Basic).  
  
 Aby zapoznać się z listą warunków niewariantów dla terminów używanych w odbiciu ogólnym <xref:System.Type.IsGenericType%2A> , zobacz uwagi dotyczące właściwości.  
  
## <a name="nested-types"></a>Zagnieżdżone typy  
 Jeśli typ ogólny jest zdefiniowany przy użyciu C#, C++, lub Visual Basic, wówczas jego typy zagnieżdżone są wszystkie rodzajowe. Jest to prawdziwe, nawet jeśli zagnieżdżone typy nie mają własnych parametrów typu, ponieważ wszystkie trzy języki zawierają parametry typu otaczających typów na listach parametrów typu zagnieżdżonych. Rozważ następujące klasy:  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 Lista parametrów typu klasy `Inner` zagnieżdżonej ma dwa parametry typu, `T` a `U`pierwszy z nich jest parametrem typu otaczającej klasy. Podobnie, lista parametrów `Innermost1` typu klasy zagnieżdżonej ma trzy parametry typu, `T`, `U`, i `V`, z `T` i `U` pochodzące z jej klas otaczających. Klasa `Innermost2` zagnieżdżona ma dwa `T` parametry typu i `U`, które pochodzą z otaczających ją klas.  
  
 Jeśli lista parametrów typu otaczającego ma więcej niż jeden parametr typu, wszystkie parametry typu w kolejności są zawarte na liście parametrów typu zagnieżdżonego typu.  
  
 Aby utworzyć typ ogólny z definicji typu ogólnego dla typu zagnieżdżonego, wywołaj <xref:System.Type.MakeGenericType%2A> metodę z tablicą utworzoną przez złączenie tablic argumentów typu wszystkich typów otaczających, zaczynając od najbardziej zewnętrznego typu ogólnego i kończąc na należy wpisać tablicę argumentów typu zagnieżdżonego, jeśli ma ona własne parametry typu. Aby utworzyć wystąpienie elementu `Innermost1`, należy <xref:System.Type.MakeGenericType%2A> wywołać metodę z tablicą zawierającą trzy typy, która ma zostać przypisana do T, U i V. Aby utworzyć wystąpienie elementu `Innermost2`, należy <xref:System.Type.MakeGenericType%2A> wywołać metodę z tablicą zawierającą dwa typy, która ma zostać przypisana do T i U.  
  
 Języki propagują parametry typu otaczających typów w ten sposób, aby można było użyć parametrów typu otaczającego typu, aby zdefiniować pola zagnieżdżonych typów. W przeciwnym razie parametry typu nie będą znajdować się w zakresie w obrębie treści typów zagnieżdżonych. Istnieje możliwość zdefiniowania zagnieżdżonych typów bez propagowania parametrów typu otaczających typy przez emitowanie kodu w zestawach dynamicznych lub przy użyciu [Ilasm. exe (ASEMBLER Il)](~/docs/framework/tools/ilasm-exe-il-assembler.md). Rozważmy następujący kod asemblera MSIL:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 W tym przykładzie nie można zdefiniować pola typu `T` lub `U` klasy `Innermost`, ponieważ te parametry typu nie znajdują się w zakresie. Poniższy kod asemblera definiuje zagnieżdżone klasy, które zachowują się w sposób, w jaki C++byłyby zdefiniowane w C#, Visual Basic i:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 Można użyć [Ildasm. exe (Il dezasembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) , aby sprawdzić zagnieżdżone klasy zdefiniowane w językach wysokiego poziomu i obserwować ten schemat nazewnictwa.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Type.MakeGenericType%2A> metody do tworzenia typu konstruowanego z definicji typu ogólnego <xref:System.Collections.Generic.Dictionary%602> dla typu. Typ skonstruowany reprezentuje <xref:System.Collections.Generic.Dictionary%602> `Test` obiekty z kluczami ciągu.  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący typ nie reprezentuje definicji typu ogólnego. Oznacza to, <see cref="P:System.Type.IsGenericTypeDefinition" /> że <see langword="false" />zwraca.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeArguments" />jest <see langword="null" />.  
  
—lub— 
Każdy element <paramref name="typeArguments" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w <paramref name="typeArguments" /> nie jest taka sama jak liczba parametrów typu w bieżącej definicji typu ogólnego.  
  
—lub— 
Każdy element elementu <paramref name="typeArguments" /> nie spełnia ograniczeń określonych dla odpowiedniego parametru typu bieżącego typu ogólnego.  
  
—lub— 
 <paramref name="typeArguments" />zawiera element, który jest typem wskaźnika (<see cref="P:System.Type.IsPointer" /> zwraca <see langword="true" />), typu przez odwołanie (<see cref="P:System.Type.IsByRef" /> zwraca <see langword="true" />) lub <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej. Klasy pochodne muszą dostarczać implementację.</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Odbicie i typy ogólne</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Instrukcje: Badanie i tworzenie wystąpień typów ogólnych za pomocą odbicia</related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Type" /> Zwraca obiekt, który reprezentuje wskaźnik do bieżącego typu.</summary>
        <returns><see cref="T:System.Type" /> Obiekt, który reprezentuje wskaźnik do bieżącego typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakePointerType%2A> Metoda umożliwia generowanie typów wskaźników dla list parametrów.  
  
 Przy użyciu składni języka pośredniego firmy Microsoft (MSIL), jeśli <xref:System.Type> bieżący obiekt <xref:System.Int32>reprezentuje <xref:System.Type> , ta metoda zwraca obiekt reprezentujący `Int32*`.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tablicę `ref` (`ByRef` w Visual Basic) `Test` i typ wskaźnika dla klasy.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</exception>
        <exception cref="T:System.TypeLoadException">Bieżącym typem jest <see cref="T:System.TypedReference" />.  
  
—lub— 
Bieżący typ jest <see langword="ByRef" /> typem. Oznacza to, <see cref="P:System.Type.IsByRef" /> że <see langword="true" />zwraca.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Reflection.MemberTypes" /> Pobiera wartość wskazującą, że ten element członkowski jest typem lub typem zagnieżdżonym.</summary>
        <value><see cref="T:System.Reflection.MemberTypes" /> Wartość wskazująca, że ten element członkowski jest typem lub typem zagnieżdżonym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość przesłania <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>. W związku z tym podczas badania <xref:System.Reflection.MemberInfo> zestawu obiektów — na przykład tablica zwracana przez <xref:System.Type.GetMembers%2A> - <xref:System.Reflection.MemberInfo.MemberType%2A> Właściwość zwraca <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> , gdy dany element członkowski jest typem zagnieżdżonym.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, ta właściwość ma zastosowanie do definicji typu ogólnego, z której został skonstruowany typ. Na przykład, jeśli <xref:System.Type> bieżący reprezentuje `MyGenericType<int>` (`MyGenericType(Of Integer)` w Visual Basic), wartość tej właściwości jest określana przez `MyGenericType<T>`.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta właściwość zawsze zwraca wartość <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu przedstawia `MemberType` pole jako parametr `GetMember` do metody:  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje brakującą wartość w <see cref="T:System.Type" /> informacjach. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Missing` Użyj pola do wywołania przez odbicie, aby uzyskać wartość domyślną parametru. Jeśli pole jest przesyłane do wartości parametru i nie ma wartości domyślnej dla tego parametru <xref:System.ArgumentException> , zostanie zgłoszony. `Missing`  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie `Missing` pola do wywołania metody z argumentami domyślnymi.  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 Ten kod generuje następujące dane wyjściowe:  
  
 a = 10 b = 55,3 c = 12  
  
 a = 10 b = 1,3 c = 1  
  
 a = 10 b = 1,2 c = 1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł (dll), w którym jest zdefiniowana bieżąca <see cref="T:System.Type" /> wartość.</summary>
        <value>Moduł, w którym jest zdefiniowany <see cref="T:System.Type" /> bieżący.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, ta właściwość zwraca moduł, w którym zdefiniowano definicję typu ogólnego. Na przykład jeśli utworzysz wystąpienie elementu `MyGenericStack<int>` <xref:System.Type.Module%2A> , właściwość dla złożonego typu zwraca moduł, w którym `MyGenericStack<T>` jest zdefiniowany.  
  
 Podobnie, jeśli bieżący <xref:System.Type> reprezentuje parametr `T`generyczny, ta właściwość zwraca zestaw, który zawiera typ ogólny, który definiuje `T`.  
  
   
  
## Examples  
 <xref:System.Type.Namespace%2A> Poniższy przykład ilustruje użycie `Module` właściwościi<xref:System.Type.ToString%2A> i metody. <xref:System.Type>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera nazwę bieżącego typu.</summary>
        <value>Nazwa bieżącego typu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera przestrzeń nazw <see cref="T:System.Type" />.</summary>
        <value>Przestrzeń nazw <see cref="T:System.Type" />; <see langword="null" /> Jeśli bieżące wystąpienie nie ma przestrzeni nazw lub reprezentuje parametr generyczny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przestrzeń nazw jest logiczną wygodą nazewnictwa w czasie projektowania, używany głównie do definiowania zakresu w aplikacji i organizowania klas i innych typów w jednej strukturze hierarchicznej. Z punktu widzenia środowiska uruchomieniowego nie ma obszarów nazw.  
  
 Jeśli bieżący <xref:System.Type> reprezentuje skonstruowany typ ogólny, ta właściwość zwraca przestrzeń nazw, która zawiera definicję typu ogólnego. Podobnie, jeśli bieżący <xref:System.Type> reprezentuje parametr `T`generyczny, ta właściwość zwraca przestrzeń nazw, która zawiera definicję typu ogólnego, która definiuje `T`.  
  
 Jeśli bieżący <xref:System.Type> obiekt reprezentuje parametr generyczny, ta właściwość zwraca `null`.  
  
   
  
## Examples  
 `Namespace` Poniższy przykład ilustruje użycie <xref:System.Type.Module%2A> właściwościi<xref:System.Type.ToString%2A> i metody. <xref:System.Type>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Określanie w pełni kwalifikowanych nazw typów</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="right">Drugi obiekt, który będzie porównywany.</param>
        <summary>Wskazuje, czy <see cref="T:System.Type" /> dwa obiekty są równe.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest <see langword="false" />równa; w przeciwnym razie,. <paramref name="right" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="right">Drugi obiekt, który będzie porównywany.</param>
        <summary>Wskazuje, czy <see cref="T:System.Type" /> dwa obiekty nie są równe.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> nie jest <paramref name="right" />równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt klasy, który został użyty w celu uzyskania tego elementu członkowskiego.</summary>
        <value>Obiekt <see langword="Type" /> , za pomocą którego <see cref="T:System.Type" /> uzyskano ten obiekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W <xref:System.Type> przypadku obiektów wartość tej właściwości jest zawsze taka sama jak wartość <xref:System.Type.DeclaringType%2A> właściwości.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono typ odbitej klasy zagnieżdżonej.  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">Kwalifikowana nazwa <see cref="T:System.Type" /> zestawu do pobrania.</param>
        <param name="throwIfNotFound"><see langword="true" />Aby zgłosić <see cref="T:System.TypeLoadException" /> , czy nie można znaleźć typu; <see langword="false" /> zwraca<see langword="null" /> , jeśli nie można odnaleźć typu. Określenie <see langword="false" /> również pomija inne warunki wyjątków, ale nie wszystkie z nich. Zobacz sekcję Wyjątki.</param>
        <param name="ignoreCase"><see langword="true" />Aby wykonać wyszukiwanie <paramref name="typeName" />z uwzględnieniem wielkości liter. Aby wykonać wyszukiwanie z uwzględnieniem wielkości liter <paramref name="typeName" /> <see langword="false" /> .</param>
        <summary><see cref="T:System.Type" /> Pobiera o podanej nazwie, określając, czy należy wykonać wyszukiwanie z uwzględnieniem wielkości liter i czy zgłaszać wyjątek, jeśli typ nie zostanie znaleziony. Typ jest ładowany tylko do odbicia, a nie do wykonania.</summary>
        <returns>Typ o określonej nazwie, jeśli znaleziono; w przeciwnym razie. <see langword="null" /> Jeśli typ nie zostanie znaleziony, <paramref name="throwIfNotFound" /> parametr określa, czy jest zwracany, czy <see langword="null" /> zgłaszany jest wyjątek. W niektórych przypadkach wyjątek jest zgłaszany niezależnie od wartości <paramref name="throwIfNotFound" />. Zobacz sekcję Wyjątki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zestaw zawierający typ nie jest już załadowany do kontekstu tylko odbicia, użycie <xref:System.Type.ReflectionOnlyGetType%2A> metody jest równoważne pierwszym załadowaniu zestawu tylko do odbicia, <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> przy użyciu metody, a następnie załadowania typu przez wywołanie <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> Metoda zestawu. Aby uzyskać informacje o nazwach kwalifikowanych do zestawu <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> , zobacz Właściwość. Aby uzyskać dodatkowe informacje na temat określania nazw typów, <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> Zobacz Przeciążenie metody.  
  
 Jeśli zestaw jest już załadowany do wykonania, inna kopia zostanie załadowana do kontekstu tylko odbicie.  
  
 `throwIfNotFound` Parametr określa, co się dzieje, gdy typ nie zostanie znaleziony, a także pomija pewne inne warunki wyjątków, zgodnie z opisem w sekcji wyjątki. Niektóre wyjątki są zgłaszane niezależnie od wartości `throwIfNotFound`. Na przykład jeśli zestaw jest nieprawidłowy, <xref:System.BadImageFormatException> jest zgłaszany, nawet jeśli `throwIfNotFound` jest `false`.  
  
 Aby uzyskać więcej informacji na temat korzystania z kontekstu tylko odbicie [, zobacz How to: Załaduj zestawy do kontekstu](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)tylko odbicie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Inicjator klasy jest wywoływany i zgłasza wyjątek.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwIfNotFound" />jest <see langword="true" /> i nie znaleziono typu.  
  
—lub— 
 <paramref name="throwIfNotFound" />ma <see langword="true" /> i<paramref name="typeName" /> zawiera nieprawidłowe znaki, takie jak karta osadzona. 
—lub— 
 <paramref name="throwIfNotFound" />jest <see langword="true" /> i<paramref name="typeName" /> jest ciągiem pustym.  
  
—lub— 
 <paramref name="throwIfNotFound" />is <see langword="true" /> i<paramref name="typeName" /> reprezentuje typ tablicy o nieprawidłowym rozmiarze.  
  
—lub— 
 <paramref name="typeName" />reprezentuje tablicę <see cref="T:System.TypedReference" /> obiektów.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" />nie zawiera nazwy zestawu.  
  
—lub— 
 <paramref name="throwIfNotFound" />ma <see langword="true" /> i<paramref name="typeName" /> zawiera nieprawidłową składnię, na przykład "MyType [, *,]".  
  
—lub— 
 <paramref name="typeName" />reprezentuje typ ogólny, który ma typ wskaźnika, <see langword="ByRef" /> typ lub <see cref="T:System.Void" /> jako jeden z argumentów typu.  
  
—lub— 
 <paramref name="typeName" />reprezentuje typ ogólny, który ma niepoprawną liczbę argumentów typu.  
  
—lub— 
 <paramref name="typeName" />reprezentuje typ ogólny, a jeden z jego argumentów typu nie spełnia ograniczeń dla odpowiadającego parametru typu.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwIfNotFound" />jest <see langword="true" /> i nie znaleziono zestawu lub jednej z jego zależności.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub jeden z jego elementów zależnych został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException">Zestaw lub jeden z jego elementów zależnych nie są prawidłowe.  
  
 —lub—  
  
 Zestaw został skompilowany przy użyciu nowszej wersji aparatu plików wykonywalnych języka wspólnego niż wersja, która jest aktualnie załadowana.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Określanie w pełni kwalifikowanych nazw typów</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md">Instrukcje: Ładowanie zestawów do kontekstu Reflection-Only</related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> Pobiera, który opisuje układ bieżącego typu.</summary>
        <value><see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> Pobiera, który opisuje funkcje układu brutto bieżącego typu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute>nie jest zwracany przez <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metodę. Zamiast tego użyj tej właściwości, aby ją pobrać.  
  
   
  
## Examples  
 Poniższy przykład kodu najpierw definiuje klasę, strukturę i strukturę z specjalnymi atrybutami układu (struktury są zagnieżdżone w obrębie klasy). W przykładzie zostanie użyta <xref:System.Type.StructLayoutAttribute%2A> właściwość w celu <xref:System.Runtime.InteropServices.StructLayoutAttribute> uzyskania dla każdego typu i wyświetlenia właściwości atrybutów.  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wywoływana metoda nie jest obsługiwana w klasie bazowej.</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="rgszNames">Przekazana tablica nazw ma być mapowana.</param>
        <param name="cNames">Liczba nazw, które mają być mapowane.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</param>
        <param name="rgDispId">Tablica przydzielana przez obiekt wywołujący, który otrzymuje numery identyfikacyjne odpowiadających nazw.</param>
        <summary>Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Więcej informacji o `IDispatch::GetIDsOfNames`programie znajduje się w bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informacje o typie, który będzie zwracany.</param>
        <param name="lcid">Identyfikator regionalny dla informacji o typie.</param>
        <param name="ppTInfo">Wskaźnik do żądanego obiektu informacji o typie.</param>
        <summary>Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Więcej informacji o `IDispatch::GetTypeInfo`programie znajduje się w bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Wskazuje lokalizację, która odbiera informację o liczbie typów dostarczanych przez obiekt.</param>
        <summary>Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Więcej informacji o `IDispatch::GetTypeInfoCount`programie znajduje się w bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Określa element członkowski.</param>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</param>
        <param name="wFlags">Flagi opisujące kontekst wywołania.</param>
        <param name="pDispParams">Wskaźnik do struktury zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</param>
        <param name="pVarResult">Wskaźnik miejsca, gdzie ma być przechowywany wynik.</param>
        <param name="pExcepInfo">Wskaźnik do struktury, która zawiera informacje o wyjątku.</param>
        <param name="puArgErr">Indeks pierwszego argumentu, który zawiera błąd.</param>
        <summary>Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Więcej informacji o `IDispatch::Invoke`programie znajduje się w bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca reprezentującą nazwę bieżącego <see langword="Type" />elementu. <see langword="String" /></summary>
        <returns>Reprezentujący nazwę bieżącego <see cref="T:System.Type" />. <see cref="T:System.String" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca w pełni kwalifikowaną przestrzeń nazw środowiska uruchomieniowego języka wspólnego i nazwę dla wszystkich typów pierwotnych. Na przykład C# instrukcja `(long)0.Type().ToString()` zwraca "System. Int64" zamiast tylko "Int64".  
  
 Jeśli bieżący <xref:System.Type> reprezentuje typ ogólny, typ i jego argumenty typu są kwalifikowane według przestrzeni nazw i według typu zagnieżdżonego, ale nie według zestawu. Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta metoda zwraca niekwalifikowaną nazwę parametru typu.  
  
   
  
## Examples  
 <xref:System.Type.Namespace%2A> Poniższy przykład ilustruje użycie <xref:System.Type.Module%2A> właściwościi`ToString` i metody. <xref:System.Type>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 Poniższy przykład <xref:System.Type.ToString%2A> porównuje ciągi zwracane przez metodę `Name`oraz właściwości, <xref:System.Type.FullName%2A>i <xref:System.Type.AssemblyQualifiedName%2A> .  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dojście dla bieżącego <see cref="T:System.Type" />elementu.</summary>
        <value>Uchwyt dla bieżącego <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle`hermetyzuje wskaźnik do wewnętrznej struktury danych, która reprezentuje typ. To dojście jest unikatowe w okresie istnienia procesu. Dojście jest prawidłowe tylko w domenie aplikacji, w której został uzyskany.  
  
   
  
## Examples  
 Poniższy przykład zwraca dojście odpowiadającego typu i przekazuje uchwyt do metody, która pobiera typ z uchwytu i wyświetla go.  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework aktualnie nie obsługuje tej właściwości.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera inicjator dla tego typu.</summary>
        <value>Obiekt, który zawiera nazwę konstruktora klasy dla <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inicjatory klasy są również dostępne za pomocą <xref:System.Type.FindMembers%2A> metody lub przez przeciążenia <xref:System.Type.GetMember%2A>metod, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>i <xref:System.Type.GetConstructors%2A> , które przyjmują <xref:System.Reflection.BindingFlags> jako parametr.  
  
 Jeśli bieżąca <xref:System.Type> reprezentuje parametr typu w definicji typu ogólnego lub metody generycznej, ta właściwość zwraca `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje typ dostarczany przez środowisko uruchomieniowe języka wspólnego, który reprezentuje ten typ.</summary>
        <value>Podstawowy typ systemu dla <see cref="T:System.Type" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>
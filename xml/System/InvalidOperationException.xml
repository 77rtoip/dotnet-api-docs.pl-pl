<Type Name="InvalidOperationException" FullName="System.InvalidOperationException">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="786bf8369e78b00964b25a31729ceb9264c0d2f7" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48726319" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class InvalidOperationException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit InvalidOperationException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.InvalidOperationException" />
  <TypeSignature Language="VB.NET" Value="Public Class InvalidOperationException&#xA;Inherits SystemException" />
  <TypeSignature Language="C++ CLI" Value="public ref class InvalidOperationException : SystemException" />
  <TypeSignature Language="F#" Value="type InvalidOperationException = class&#xA;    inherit SystemException" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Wyjątek, który jest zgłaszany, gdy wywołanie metody jest nieprawidłowa dla bieżącego stanu obiektu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.InvalidOperationException> jest używana w przypadkach, po awarii, aby wywołać metodę jest spowodowany przez powodów innych niż nieprawidłowe argumenty. Typowo jest zgłaszany, gdy stan obiektu nie może obsłużyć wywołania metody. Na przykład <xref:System.InvalidOperationException> wyjątek jest generowany przez metody takie jak:  
  
-   <xref:System.Collections.IEnumerator.MoveNext%2A?displayProperty=nameWithType> Jeśli obiekty kolekcji są modyfikowane po utworzeniu modułu wyliczającego. Aby uzyskać więcej informacji, zobacz [zmiany kolekcji podczas jej iteracja](#Iterating).  
  
-   <xref:System.Resources.ResourceSet.GetString%2A?displayProperty=nameWithType> Jeśli zestaw zasobów jest zamknięty przed wywołaniem metody wykonano.  
  
-   <xref:System.Xml.Linq.XContainer.Add%2A?displayProperty=nameWithType>, jeśli obiekty, które mają zostać dodane w rezultacie niepoprawnie ze strukturą dokumentu XML.  
  
-   Metoda, która podejmuje próbę manipulowania interfejsu użytkownika z wątku, który jest głównym lub wątku interfejsu użytkownika.  
  
> [!IMPORTANT]
>  Ponieważ <xref:System.InvalidOperationException> zgłoszony wyjątek w wielu sytuacjach należy koniecznie przeczytaj komunikat o wyjątku, zwracany przez <xref:System.Exception.Message%2A> właściwości.  
  
 W tej sekcji:  
  
 [Niektóre typowe przyczyny InvalidOperationException wyjątków](#Causes)   
 [Aktualizowanie wątku interfejsu użytkownika z wątku innego niż interfejsu użytkownika](#UI)  
 [Zmiana kolekcji podczas jej iteracja](#Iterating)  
 [Sortowanie tablicy lub kolekcji obiektów, których nie można porównać.](#Sorting)  
 [Rzutowanie Nullable&lt;T&gt; mający wartość null na jej typ podstawowy](#Nullable)   
 [Wywołanie metody System.Linq.Enumerable na pustej kolekcji.](#Empty)  
 [Wywoływanie Enumerable.Single lub Enumerable.SingleOrDefault w sekwencji bez jeden element](#Single)  
 [Dostęp do pola dynamiczne domenie międzyaplikacyjnej](#Emit)  
[Zostanie zgłoszony wyjątek InvalidOperationException](#Throwing)  
[Dodatkowe informacje](#Misc)  
  
<a name="Causes"></a>   
## <a name="some-common-causes-of-invalidoperationexception-exceptions"></a>Niektóre typowe przyczyny InvalidOperationException wyjątków  
 W poniższych sekcjach opisano, jak niektóre typowe przypadki, w którym w <xref:System.InvalidOperationException> wyjątek jest zgłaszany w aplikacji. Jak obsługiwać ten problem, zależy od konkretnej sytuacji. Najczęściej, jednak powoduje wyjątek błędu dla deweloperów i <xref:System.InvalidOperationException> wyjątek może oczekiwać i unikać.  
  
<a name="UI"></a>   
### <a name="updating-a-ui-thread-from-a-non-ui-thread"></a>Aktualizowanie wątku interfejsu użytkownika z wątku innego niż interfejsu użytkownika  
 Wątki robocze są często używane w celu wykonania pewnej pracy tła, który obejmuje zbieranie danych, które mają być wyświetlane w interfejsie użytkownika aplikacji. Jednak. Większość struktur aplikacji graficznego interfejsu użytkownika (graficzny interfejs użytkownika) dla programu .NET Framework, takich jak formularze Windows i Windows Presentation Foundation (WPF), umożliwiają uzyskiwanie dostępu do obiektów graficznego interfejsu użytkownika, tylko z wątku, który tworzy i którymi zarządza interfejsu użytkownika (wątek główny lub interfejsu użytkownika). <xref:System.InvalidOperationException> Jest zgłaszany, gdy użytkownik próbuje uzyskać dostęp do elementu interfejsu użytkownika z wątku innego niż wątek interfejsu użytkownika.  Tekst komunikatu wyjątku przedstawiono w poniższej tabeli.  
  
|Typ aplikacji|Komunikat|  
|----------------------|-------------|  
|Aplikacja WPF|**Wątek wywołujący nie może uzyskać dostępu tego obiektu, ponieważ inny wątek jest jego właścicielem.**|  
|Aplikacja platformy uniwersalnej systemu Windows|**Aplikacja wywołuje interfejs, który został skierowany na inny wątek.**|  
|Aplikacja programu Windows Forms|**Nieprawidłowa operacja międzywątkowe: kontrola "TextBox1" dostępne z wątku innego niż wątek został utworzony na.**|  
  
 Implementowanie platform tworzenia interfejsu użytkownika dla programu .NET Framework *dyspozytora* wzorzec, który zawiera metodę sprawdzania, czy wywołanie do elementu członkowskiego elementu interfejsu użytkownika jest wykonywana przez wątek interfejsu użytkownika i innych metod, aby zaplanować wywołanie przez wątek interfejsu użytkownika:  
  
-   W aplikacjach WPF, należy wywołać <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A?displayProperty=nameWithType> metodę pozwala ustalić, czy metoda jest uruchomiona w wątku bez interfejsu użytkownika. Zwraca `true` Jeśli metoda jest uruchomiona w wątku interfejsu użytkownika i `false` inaczej. Wywoływanie jednego z przeciążeń <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=nameWithType> metodę, aby zaplanować wywołanie przez wątek interfejsu użytkownika.  
  
-   W aplikacjach platformy uniwersalnej systemu Windows, należy wywołać [CoreDispatcher.HasThreadAccess](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.hasthreadaccess.aspx) metodę pozwala ustalić, czy metoda jest uruchomiona w wątku bez interfejsu użytkownika. Wywołaj [CoreDispatcher.RunAsync](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.runasync.aspx) metodę, aby wykonać delegata, która aktualizuje wątku interfejsu użytkownika. Użyj  
  
-   W aplikacji Windows Forms za pomocą <xref:System.Windows.Forms.Control.InvokeRequired%2A?displayProperty=nameWithType> właściwości w celu określenia, czy metoda jest uruchomiona w wątku bez interfejsu użytkownika. Wywoływanie jednego z przeciążeń <xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=nameWithType> metodę, aby wykonać delegata, która aktualizuje wątku interfejsu użytkownika.  
  
 Poniższe przykłady ilustrują <xref:System.InvalidOperationException> wyjątek, który jest zgłaszany, gdy próba aktualizacji elementu interfejsu użytkownika z wątku innego niż wątek, który go utworzył.  Każdy przykład niezbędne jest utworzenie dwóch kontrolek:  
  
-   Formant pola tekstowego o nazwie `textBox1`.  W aplikacji Windows Forms, należy ustawić jego <xref:System.Windows.Forms.TextBox.Multiline%2A> właściwość `true`.  
  
-   Formant przycisku o nazwie `threadExampleBtn`. W przykładzie przedstawiono program obsługi, `ThreadsExampleBtn_Click`, dla tego przycisku `Click` zdarzeń.  
  
 W każdym przypadku `threadExampleBtn_Click` wywołań obsługi zdarzeń `DoSomeWork` metodę dwa razy. Pierwsze wywołanie jest uruchamiana synchronicznie i zakończy się pomyślnie. Ale drugie wywołanie, ponieważ jest ono uruchamiane asynchronicznie wątku z puli wątków, próbuje zaktualizować interfejs użytkownika z wątku bez interfejsu użytkownika. Skutkuje to <xref:System.InvalidOperationException> wyjątku.  
  
 Aplikacje WPF i platformy uniwersalnej systemu Windows  
 [!code-csharp[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/cs/MainWindow.xaml.cs#1)]
 [!code-vb[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/vb/MainWindow.xaml.vb#1)]  
  
 Następująca wersja `DoSomeWork` metoda eliminuje wyjątków w aplikacji WPF.  
  
 [!code-csharp[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/cs/MainWindowDispatcher.xaml.cs#3)]
 [!code-vb[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/vb/MainWindowDispatcher.xaml.vb#3)]  
  
 Następująca wersja `DoSomeWork` metoda eliminuje wyjątków w aplikacji platformy uniwersalnej systemu Windows.  
  
 [!code-csharp[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/cs/MainPage.xaml.cs#4)]
 [!code-vb[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/vb/MainPage.xaml.vb#4)]  
  
 Windows Forms aplikacji  
 [!code-csharp[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/cs/Form1.cs#2)]
 [!code-vb[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/vb/Form1.vb#2)]  
  
 Następująca wersja `DoSomeWork` metoda eliminuje wyjątków w aplikacji Windows Forms.  
  
 [!code-csharp[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/cs/Form1.cs#5)]
 [!code-vb[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/vb/Form1.vb#5)]  
  
<a name="Iterating"></a>   
### <a name="changing-a-collection-while-iterating-it"></a>Zmiana kolekcji podczas jej iteracja  
 `foreach` Instrukcji w języku C# lub `For Each` instrukcji w języku Visual Basic jest używana do iteracji elementów członkowskich kolekcji i aby odczytać lub zmodyfikować poszczególne elementy. Jednak nie można używać do dodawania lub usuwania elementów z kolekcji. Spowoduje to zgłasza <xref:System.InvalidOperationException> wyjątek z komunikatem, które są podobne, "**Kolekcja została zmodyfikowana; Nie można wykonać operacji wyliczenia. **"  
  
 Poniższy przykład wykonuje iterację prób zbioru liczb całkowitych do dodawania kwadratowy Każda liczba całkowita do kolekcji. Przykład generuje <xref:System.InvalidOperationException> przy pierwszym wywołaniu <xref:System.Collections.Generic.List%601.Add%2A?displayProperty=nameWithType> metody.  
  
 [!code-csharp[System.InvalidOperationException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating1.cs#1)]
 [!code-vb[System.InvalidOperationException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating1.vb#1)]  
  
 W zależności od logiki aplikacji, można wyeliminować wyjątku w jednej z dwóch sposobów:  
  
-   Jeśli elementy musi zostać dodany do kolekcji podczas jej iteracja, można wykonać iterację go przy użyciu indeksu `for` instrukcji zamiast `foreach` lub `For Each`. W poniższym przykładzie użyto instrukcji do dodawania kwadratowy liczb znajdujących się w kolekcji do kolekcji.  
  
     [!code-csharp[System.InvalidOperationException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating2.cs#2)]
     [!code-vb[System.InvalidOperationException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating2.vb#2)]  
  
     Należy pamiętać, musisz ustanowić liczby iteracji przed iteracja kolekcji za pomocą licznika wewnątrz pętli, która zostanie zakończona appropraitely pętli, iteracja Wstecz, z `Count` — 1 na 0 lub, podobnie jak przykładu, przypisując numer elementy w tablicy do zmiennej i używanie ich do ustanowienia górną granicę pętli. W przeciwnym razie jeśli element zostanie dodany do kolekcji w każdej iteracji, powoduje nieskończoną pętlę.  
  
-   Jeśli nie jest konieczne dodanie elementów do kolekcji podczas jej iteracja, można przechowywać elementy, które mają zostać dodane w kolekcji tymczasowej, możesz dodać po zakończeniu iteracja kolekcji.  W poniższym przykładzie użyto tego podejścia do dodawania kwadratowy liczb znajdujących się w kolekcji do kolekcji tymczasowej, a następnie połączyć kolekcji do obiektu pojedynczą tablicę.  
  
     [!code-csharp[System.InvalidOperationException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating3.cs#3)]
     [!code-vb[System.InvalidOperationException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating3.vb#3)]  
  
<a name="Sorting"></a>   
### <a name="sorting-an-array-or-collection-whose-objects-cannot-be-compared"></a>Sortowanie tablicy lub kolekcji obiektów, których nie można porównać.  
 Ogólnego przeznaczenia, sortowanie metod, takich jak <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> metody lub <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> metody, zwykle wymagają tego co najmniej jeden z obiektów, które ma zostać posortowana zaimplementować <xref:System.IComparable%601> lub <xref:System.IComparable> interfejsu. Jeśli nie, kolekcji lub tablicy nie można sortować, metoda zgłasza <xref:System.InvalidOperationException> wyjątku. W poniższym przykładzie zdefiniowano `Person` klasy magazynów dwa `Person` obiektów w ogólnej metodzie <xref:System.Collections.Generic.List%601> obiektu i próbuje posortować je. Jak wynika z w przykładzie pokazano wywołanie metody <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> metoda zgłasza wyjątek <xref:System.InvalidOperationException>.  
  
 [!code-csharp[System.InvalidOperationException#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort1.cs#12)]
 [!code-vb[System.InvalidOperationException#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort1.vb#12)]  
  
 Możesz wyeliminować wyjątek w jednym z trzech sposobów:  
  
-   Jeśli masz typ, który próbujesz sortowania (to znaczy, jeśli możesz kontrolować jego kod źródłowy), możesz ją zmodyfikować, aby zaimplementować <xref:System.IComparable%601> lub <xref:System.IComparable> interfejsu. Wymaga to wykonania albo <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> lub <xref:System.IComparable.CompareTo%2A> metody. Dodanie implementacji interfejsu do istniejącego typu nie jest zmianą przerywającą.  
  
     W poniższym przykładzie użyto tego podejścia w celu zapewnienia <xref:System.IComparable%601> implementację `Person` klasy. Może wciąż wywołać kolekcji lub tablicy ogólne metody sortowania i dane wyjściowe z przykładu pokazują, Kolekcja sortuje pomyślnie.  
  
     [!code-csharp[System.InvalidOperationException#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort2.cs#13)]
     [!code-vb[System.InvalidOperationException#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort2.vb#13)]  
  
-   Jeśli nie można zmodyfikować kod źródłowy dla typu, o których chcesz posortować, można zdefiniować klasę sortowania specjalnego przeznaczenia, która implementuje <xref:System.Collections.Generic.IComparer%601> interfejsu.  Można wywoływać przeciążenia `Sort` metodę, która obejmuje <xref:System.Collections.Generic.IComparer%601> parametru. To podejście jest szczególnie przydatne, jeśli chcą tworzyć klas wyspecjalizowanych sortowania, które można sortować obiektów na podstawie wielu kryteriów.  
  
     W poniższym przykładzie użyto podejście, opracowując własne `PersonComparer` klasę, która jest używana do sortowania `Person` kolekcji.  Następnie przekazuje wystąpienie tej klasy, aby <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29?displayProperty=nameWithType> metody.  
  
     [!code-csharp[System.InvalidOperationException#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort3.cs#14)]
     [!code-vb[System.InvalidOperationException#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort3.vb#14)]  
  
-   Jeśli nie można zmodyfikować kod źródłowy typ chcesz posortować, możesz utworzyć <xref:System.Comparison%601> delegata do wykonania sortowania. Podpis delegata  
  
    ```vb  
    Function Comparison(Of T)(x As T, y As T) As Integer  
    ```  
  
    ```csharp  
    int Comparison<T>(T x, T y)  
    ```  
  
     W poniższym przykładzie użyto podejście, definiując `PersonComparison` metodę, która spełnia <xref:System.Comparison%601> podpis delegata.  Następnie przekazuje ten delegat do <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29?displayProperty=nameWithType> metody.  
  
     [!code-csharp[System.InvalidOperationException#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort4.cs#15)]
     [!code-vb[System.InvalidOperationException#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort4.vb#15)]  
  
<a name="Nullable"></a>   
### <a name="casting-a-nullablet-that-is-null-to-its-underlying-type"></a>Rzutowanie Nullable\<T > jest wartość null, aby jej typ podstawowy  
 Podjęto próbę rzutowania <xref:System.Nullable%601> wartość, która jest `null` na jej typ podstawowy zgłasza <xref:System.InvalidOperationException> wyjątek i wyświetla komunikat o błędzie "**dopuszczającego wartość null, obiekt musi mieć wartość.**  
  
 Poniższy przykład generuje <xref:System.InvalidOperationException> wyjątek podczas próby jego iteracji tablicy, która zawiera `Nullable(Of Integer)` wartość.  
  
 [!code-csharp[System.InvalidOperationException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable1.cs#4)]
 [!code-vb[System.InvalidOperationException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable1.vb#4)]  
  
 Aby uniknąć wyjątek:  
  
-   Użyj <xref:System.Nullable%601.HasValue%2A?displayProperty=nameWithType> właściwość, aby wybrać tylko te elementy, które nie są `null`.  
  
-   Wywołanie jednej z <xref:System.Nullable%601.GetValueOrDefault%2A?displayProperty=nameWithType> przeciążeń do dostarczenia wartość domyślną dla `null` wartość.  
  
 Poniższy przykład robi, zarówno w celu uniknięcia <xref:System.InvalidOperationException> wyjątku.  
  
 [!code-csharp[System.InvalidOperationException#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable2.cs#5)]
 [!code-vb[System.InvalidOperationException#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable2.vb#5)]  
  
<a name="Empty"></a>   
### <a name="calling-a-systemlinqenumerable-method-on-an-empty-collection"></a>Wywołanie metody System.Linq.Enumerable na pustej kolekcji.  
 <xref:System.Linq.Enumerable.Aggregate%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Max%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Min%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>, I <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> metody wykonywania operacji w sekwencji i zwrócenia pojedynczego wyniku.   Niektóre przeciążenia metody te throw <xref:System.InvalidOperationException> wyjątek podczas sekwencji jest pusta, podczas gdy inne przeciążenia zwraca `null`. <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> Metoda generuje również <xref:System.InvalidOperationException> wyjątek, jeśli sekwencja zawiera więcej niż jeden element.  
  
> [!NOTE]
>  Większość metod, które generują <xref:System.InvalidOperationException> wyjątku są przeciążenia. Pamiętaj, że rozumiesz zachowanie przeciążenia, które wybierzesz.  
  
 W poniższej tabeli przedstawiono komunikaty o wyjątkach z <xref:System.InvalidOperationException> obiektów wyjątek zgłoszony przez wywołania do niektórych <xref:System.Linq.Enumerable?displayProperty=nameWithType> metody.  
  
|Metoda|Komunikat|  
|------------|-------------|  
|`Aggregate` <br /> `Average` <br /> `Last` <br /> `Max` <br /> `Min`|**Sekwencja nie zawiera żadnych elementów**|  
|`First`|**Sekwencja nie zawiera żadnych pasujący element**|  
|`Single` <br /> `SingleOrDefault`|**Sekwencja zawiera więcej niż jeden pasujący element**|  
  
 Jak wyeliminuj lub obsłużyć wyjątek zależy od aplikacji założenia i określoną metodę, którą wywołujesz.  
  
-   Podczas celowo wywoływania jednej z następujących metod bez sprawdzania pod kątem pustej sekwencji, są przy założeniu sekwencja nie jest pusty i że pustą sekwencją jest nieoczekiwane zdarzenie. W tym przypadku Przechwytywanie lub ponowne generowanie wyjątków jest odpowiednia.  
  
-   Jeśli przypadkowego błąd usługi pod kątem pustej sekwencji, można też wywołać jedną z przeciążeń <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> przeciążenia, aby ustalić, czy sekwencja zawiera żadnych elementów.  
  
    > [!TIP]
    >  Wywoływanie <xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> metoda przed wygenerowaniem sekwencji może poprawić wydajność, jeśli dane mają być przetwarzane mogą obejmować dużą liczbę elementów lub jeśli operacja, która generuje sekwencji jest kosztowne.  
  
-   Jeśli już wywołania metody takie jak <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>, lub <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>, można zastąpić alternatywna metoda, takich jak <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.LastOrDefault%2A?displayProperty=nameWithType>, lub <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>, zwracającego wartość domyślną, zamiast należących do sekwencji.  
  
 Przykłady zawierają dodatkowe informacje.  
  
 W poniższym przykładzie użyto <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType> metodę w celu obliczenia średniej sekwencji, których wartości są większe niż 4. Ponieważ żadne wartości z tablicy, oryginalnym przekracza 4, żadne wartości nie są uwzględnione w sekwencji, metoda zgłasza <xref:System.InvalidOperationException> wyjątku.  
  
 [!code-csharp[System.InvalidOperationException#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable1.cs#6)]
 [!code-vb[System.InvalidOperationException#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable1.vb#6)]  
  
 Wyjątki mogą zostać usunięte przez wywołanie metody <xref:System.Linq.Enumerable.Any%2A> metodę pozwala ustalić, czy sekwencja zawiera wszystkie elementy przed wywołaniem metody, która przetwarza sekwencji, co ilustruje poniższy przykład.  
  
 [!code-csharp[System.InvalidOperationException#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable2.cs#7)]
 [!code-vb[System.InvalidOperationException#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable2.vb#7)]  
  
 <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> Metoda zwraca pierwszy element w sekwencji lub do pierwszego elementu w sekwencji, który spełnia określony warunek. Jeśli sekwencja jest pusty, dlatego nie jest objęta pierwszego elementu wyniku weryfikacji zgłasza wyjątek <xref:System.InvalidOperationException> wyjątku.  
  
 W poniższym przykładzie <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> metoda zgłasza wyjątek <xref:System.InvalidOperationException> wyjątków ponieważ tablicy dbQueryResults nie zawiera elementu jest większy niż 4.  
  
 [!code-csharp[System.InvalidOperationException#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable3.cs#8)]
 [!code-vb[System.InvalidOperationException#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable3.vb#8)]  
  
 Możesz wywołać <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> zamiast metody <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> aby zwracać określoną lub wartość domyślna. Jeśli metoda nie może znaleźć pierwszego elementu w sekwencji, zwraca wartość domyślna dla tego typu danych.  Wartość domyślna to `null` dla typu odwołania zero dla typu liczbowego i <xref:System.DateTime.MinValue?displayProperty=nameWithType> dla <xref:System.DateTime> typu.  
  
> [!NOTE]
>  Interpretowanie wartość zwrócona przez obiekt <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> metoda jest często skomplikowana faktem, że wartość domyślna tego typu może być nieprawidłowa wartość w sekwencji. W takim przypadku wywołanie <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> metodę, aby określić, czy sekwencja ważnych elementów członkowskich przed wywołaniem <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> metody.  
  
 Poniższy przykład wywołuje <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> metodę, aby zapobiec <xref:System.InvalidOperationException> wyjątek zgłoszony w poprzednim przykładzie.  
  
 [!code-csharp[System.InvalidOperationException#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable4.cs#9)]
 [!code-vb[System.InvalidOperationException#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable4.vb#9)]  
  
<a name="Single"></a>   
### <a name="calling-enumerablesingle-or-enumerablesingleordefault-on-a-sequence-without-one-element"></a>Wywoływanie Enumerable.Single lub Enumerable.SingleOrDefault w sekwencji bez jeden element  
 <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> Metoda zwraca jedynym elementem sekwencji lub jedynym elementem sekwencji, który spełnia określony warunek.    Jeśli nie ma elementów w sekwencji, lub jeśli istnieje więcej niż jeden element, metoda zgłasza <xref:System.InvalidOperationException> wyjątku.  
  
 Możesz użyć <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> metodę, aby zwrócić wartość domyślną, zamiast zgłaszać wyjątek, gdy sekwencja nie zawiera żadnych elementów. Jednak <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> metoda nadal zgłasza <xref:System.InvalidOperationException> wyjątek, jeśli sekwencja zawiera więcej niż jeden element.  
  
 W poniższej tabeli przedstawiono komunikaty o wyjątkach z <xref:System.InvalidOperationException> obiektów wyjątek zgłoszony przez wywołania <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> i <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> metody.  
  
|Metoda|Komunikat|  
|------------|-------------|  
|`Single`|**Sekwencja nie zawiera żadnych pasujący element**|  
|`Single` <br /> `SingleOrDefault`|**Sekwencja zawiera więcej niż jeden pasujący element**|  
  
 W poniższym przykładzie wywołanie <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> metoda zgłasza wyjątek <xref:System.InvalidOperationException> wyjątków ponieważ kolejność nie ma elementu jest większy niż 4.  
  
 [!code-csharp[System.InvalidOperationException#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable5.cs#10)]
 [!code-vb[System.InvalidOperationException#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable5.vb#10)]  
  
 Poniższy przykład podejmie próbę zapobiec <xref:System.InvalidOperationException> wyjątek zgłaszany, gdy sekwencja jest pusta, wywołując zamiast <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> metody. Jednakże, ponieważ ta sekwencja zwraca wiele elementów, których wartość jest większa niż 2, zgłasza również <xref:System.InvalidOperationException> wyjątku.  
  
 [!code-csharp[System.InvalidOperationException#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable6.cs#11)]
 [!code-vb[System.InvalidOperationException#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable6.vb#11)]  
  
 Wywoływanie <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> metoda zakłada, że sekwencja lub sekwencji, która spełnia określone kryteria zawiera tylko jeden element.  <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> przyjęto założenie, Sekwencja zero lub jeden wynik, ale nie więcej. Jeśli ta zakłada się zamierzonego jeden ze strony użytkownika, a te warunki nie są spełnione, ponowne generowanie lub przechwytywanie wynikowy <xref:System.InvalidOperationException> jest odpowiednia. W przeciwnym razie lub Jeśli spodziewasz się, że nieprawidłowe warunki nastąpi z częstotliwością niektóre, należy rozważyć użycie innej <xref:System.Linq.Enumerable> metody, takie jak <xref:System.Linq.Enumerable.FirstOrDefault%2A> lub <xref:System.Linq.Enumerable.Where%2A>.  
  
<a name="Emit"></a>   
### <a name="dynamic-cross-application-domain-field-access"></a>Dostęp do pola dynamiczne domenie międzyaplikacyjnej  
 <xref:System.Reflection.Emit.OpCodes.Ldflda?displayProperty=nameWithType> Zgłasza instrukcji języka intermediate language (MSIL) firmy Microsoft <xref:System.InvalidOperationException> wyjątek, jeśli obiekt zawierający pole, którego adres próby pobrania nie mieści się w domenie aplikacji, w której kod jest wykonywany. Adresu pola mogą zostać oceniony jedynie z domeny aplikacji, w której znajduje się.  
  
<a name="Throwing"></a>   
## <a name="throwing-an-invalidoperationexception-exception"></a>Zostanie zgłoszony wyjątek InvalidOperationException  
 Należy zgłaszać <xref:System.InvalidOperationException> wyjątek tylko wtedy, gdy stan obiektu jakiegoś powodu nie obsługuje wywołaniu określonej metody. Oznacza to wywołanie metody jest prawidłowy w niektórych sytuacjach lub kontekstów, ale jest nieprawidłowy w innych.  
  
 W przypadku błędu wywołania metody ze względu na nieprawidłowe argumenty. następnie <xref:System.ArgumentException> lub jedna z jej klas pochodnych <xref:System.ArgumentNullException> lub <xref:System.ArgumentOutOfRangeException>, powinny być generowane zamiast tego.  
  
<a name="Misc"></a>   
## <a name="miscellaneous-information"></a>Dodatkowe informacje  
 <xref:System.InvalidOperationException> używa COR_E_INVALIDOPERATION HRESULT, która ma wartość 0x80131509.  
  
 Aby uzyskać listę początkowe wartości właściwości wystąpienia <xref:System.InvalidOperationException>, zobacz <xref:System.InvalidOperationException.%23ctor%2A> konstruktorów.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
    <altmember cref="T:System.Collections.IEnumerator" />
    <altmember cref="T:System.Resources.ResourceSet" />
    <related type="Article" href="~/docs/standard/exceptions/index.md">Obsługa i zgłaszanie wyjątków</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.InvalidOperationException" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.InvalidOperationException" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.Exception.Message%2A> właściwości nowego wystąpienia dostarczane przez system komunikatu, który opisuje błąd, takie jak "nie można wykonać żądanej operacji." Ten komunikat uwzględnia bieżącą kulturę systemu.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.InvalidOperationException>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Odwołanie o wartości null (`Nothing` w języku Visual Basic).|  
|<xref:System.Exception.Message%2A>|Zlokalizowany ciąg komunikatu o błędzie.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string -&gt; InvalidOperationException" Usage="new System.InvalidOperationException message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat, który opisuje błąd.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.InvalidOperationException" /> klasy przy użyciu określonego komunikatu o błędzie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.Exception.Message%2A?displayProperty=nameWithType> właściwości nowego wyjątku za pomocą `message` parametru. Zawartość `message` ma być zrozumiała dla ludzi. Obiekt wywołujący tego konstruktora jest wymagany w celu zagwarantowania, że ten ciąg został zlokalizowany w bieżącej kulturze systemu.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.InvalidOperationException>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Odwołanie o wartości null (`Nothing` w języku Visual Basic).|  
|<xref:System.Exception.Message%2A>|Ciąg komunikatu o błędzie.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InvalidOperationException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InvalidOperationException(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Obiekt zawierający dane serializowanego obiektu.</param>
        <param name="context">Informacje kontekstowe o źródłowego lub miejscu docelowym.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.InvalidOperationException" /> klasy z serializowanych danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływana podczas deserializacji do odtworzenia obiektu wyjątku przesyłanego za pomocą strumienia. Aby uzyskać więcej informacji, zobacz [XML oraz serializacji protokołu SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Serializacja XML i SOAP</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string * Exception -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat o błędzie wyjaśniający przyczynę wyjątku.</param>
        <param name="innerException">Wyjątek, który jest przyczyną bieżącego wyjątku. Jeśli <c>innerException</c> parametr nie jest odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), bieżący wyjątek jest zgłaszany w <see langword="catch" /> blok, który obsługuje wyjątek wewnętrzny.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.InvalidOperationException" /> klasy przy użyciu określonego komunikatu o błędzie i odwołania do wewnętrznego wyjątku, który jest przyczyną tego wyjątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyjątek generowany jako bezpośredni wynik poprzedniego wyjątku powinien zawierać odwołanie do poprzedniego wyjątku we <xref:System.Exception.InnerException%2A> właściwości. <xref:System.Exception.InnerException%2A> Właściwość zwraca taką samą wartość, która jest przekazywana do konstruktora, lub odwołanie o wartości null (`Nothing` w języku Visual Basic) jeżeli <xref:System.Exception.InnerException%2A> nie dostarcza wartości wewnętrznego wyjątku do konstruktora.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.InvalidOperationException>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Odwołanie do wewnętrznego wyjątku.|  
|<xref:System.Exception.Message%2A>|Ciąg komunikatu o błędzie.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
        <related type="Article" href="~/docs/standard/exceptions/index.md">Obsługa i zgłaszanie wyjątków</related>
      </Docs>
    </Member>
  </Members>
</Type>
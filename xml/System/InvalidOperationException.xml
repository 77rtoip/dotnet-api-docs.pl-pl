<Type Name="InvalidOperationException" FullName="System.InvalidOperationException">
  <Metadata><Meta Name="ms.openlocfilehash" Value="25c71127275f7f66a38c66d4f44927c80f0dbfa9" /><Meta Name="ms.sourcegitcommit" Value="cb4d218ffd5a459a5f921fe1d945c682d1e09aca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/16/2019" /><Meta Name="ms.locfileid" Value="69541145" /></Metadata><TypeSignature Language="C#" Value="public class InvalidOperationException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit InvalidOperationException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.InvalidOperationException" />
  <TypeSignature Language="VB.NET" Value="Public Class InvalidOperationException&#xA;Inherits SystemException" />
  <TypeSignature Language="C++ CLI" Value="public ref class InvalidOperationException : SystemException" />
  <TypeSignature Language="F#" Value="type InvalidOperationException = class&#xA;    inherit SystemException" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Wyjątek, który jest generowany, gdy wywołanie metody jest nieprawidłowe dla bieżącego stanu obiektu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.InvalidOperationException>jest używany w przypadkach, gdy błąd wywołania metody jest spowodowany przyczynami innymi niż nieprawidłowe argumenty. Zwykle jest generowany, gdy stan obiektu nie może obsługiwać wywołania metody. Na przykład <xref:System.InvalidOperationException> wyjątek jest zgłaszany przez metody takie jak:  
  
-   <xref:System.Collections.IEnumerator.MoveNext%2A?displayProperty=nameWithType>Jeśli obiekty kolekcji są modyfikowane po utworzeniu modułu wyliczającego. Aby uzyskać więcej informacji, zobacz [Zmiana kolekcji podczas iteracji](#Iterating).  
  
-   <xref:System.Resources.ResourceSet.GetString%2A?displayProperty=nameWithType>Jeśli zestaw zasobów jest zamknięty przed wywołaniem metody.  
  
-   <xref:System.Xml.Linq.XContainer.Add%2A?displayProperty=nameWithType>, jeśli obiekt lub obiekty, które mają zostać dodane, spowodują niewłaściwy strukturalny dokument XML.  
  
-   Metoda próbująca manipulować interfejsem użytkownika z wątku, który nie jest interfejsem głównym lub wątkiem interfejsu użytkownika.  
  
> [!IMPORTANT]
>  Ponieważ wyjątek może być zgłaszany w wielu sytuacjach, ważne jest, aby odczytać komunikat o wyjątku zwrócony <xref:System.Exception.Message%2A> przez właściwość. <xref:System.InvalidOperationException>  
  
 W tej sekcji:  
  
 [Niektóre typowe przyczyny wyjątków InvalidOperationException](#Causes)   
 [Aktualizowanie wątku interfejsu użytkownika z wątku innego niż interfejs użytkownika](#UI)  
 [Zmiana kolekcji podczas iteracji](#Iterating)  
 [Sortowanie tablicy lub kolekcji, której nie można porównać obiektów](#Sorting)  
 [Rzutowanie wartości&lt;typu&gt; nullable T, która ma wartość null, do jego typu podstawowego](#Nullable)   
 [Wywoływanie metody System. LINQ. wyliczalnej w pustej kolekcji](#Empty)  
 [Wywoływanie wyliczalnego elementu. Single lub wyliczalny. SingleOrDefault na sekwencji bez jednego elementu](#Single)  
 [Dynamiczny dostęp do pola domeny wielu aplikacji](#Emit)  
[Zgłaszanie wyjątku InvalidOperationException](#Throwing)  
[Różne informacje](#Misc)  
  
<a name="Causes"></a>   
## <a name="some-common-causes-of-invalidoperationexception-exceptions"></a>Niektóre typowe przyczyny wyjątków InvalidOperationException  
 W poniższych sekcjach pokazano, jak niektóre typowe przypadki, <xref:System.InvalidOperationException> w których wyjątek jest zgłaszany w aplikacji. Sposób obsługi problemu zależy od konkretnej sytuacji. Zazwyczaj jednak wyjątek jest wynikiem błędu dewelopera, a <xref:System.InvalidOperationException> wyjątek może być przewidywany i unikany.  
  
<a name="UI"></a>   
### <a name="updating-a-ui-thread-from-a-non-ui-thread"></a>Aktualizowanie wątku interfejsu użytkownika z wątku innego niż interfejs użytkownika  
 Często wątki robocze są używane do wykonywania niektórych zadań w tle, które obejmują gromadzenie danych do wyświetlania w interfejsie użytkownika aplikacji. Ale. Najpopularniejsze struktury aplikacji (graficznego interfejsu użytkownika) dla .NET Framework, takie jak Windows Forms i Windows Presentation Foundation (WPF), umożliwiają dostęp do obiektów GUI tylko z wątku, który tworzy i zarządza interfejsem użytkownika (główny lub wątek interfejsu użytkownika). <xref:System.InvalidOperationException> Jest zgłaszany podczas próby dostępu do elementu interfejsu użytkownika z wątku innego niż wątek interfejsu użytkownika.  W poniższej tabeli przedstawiono tekst komunikatu o wyjątku.  
  
|Typ aplikacji|Message|  
|----------------------|-------------|  
|Aplikacja WPF|**Wątek wywołujący nie może uzyskać dostępu do tego obiektu, ponieważ należy on do innego wątku.**|  
|Aplikacja platformy UWP|**Aplikacja nazywana interfejsem, który został zorganizowany dla innego wątku.**|  
|Aplikacja Windows Forms|**Nieprawidłowa operacja między wątkami: Kontrolka "TextBox1" uzyskuje dostęp z wątku innego niż wątek, w którym został utworzony.**|  
  
 Struktury interfejsu użytkownika dla .NET Framework implementują wzorzec *dyspozytora* , który zawiera metodę do sprawdzenia, czy wywołanie elementu CZŁONKOWSKIEgo interfejsu użytkownika jest wykonywane w wątku interfejsu użytkownika, oraz inne metody zaplanowania wywołania w wątku interfejsu użytkownika:  
  
-   W aplikacjach WPF, wywołaj <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A?displayProperty=nameWithType> metodę, aby określić, czy metoda jest uruchomiona w wątku nie będącym interfejsem użytkownika. Zwraca `true` , jeśli metoda jest uruchomiona w wątku interfejsu użytkownika i `false` w przeciwnym razie. Wywołaj jedno z przeciążeń <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=nameWithType> metody w celu zaplanowania wywołania w wątku interfejsu użytkownika.  
  
-   W aplikacjach platformy UWP Sprawdź <xref:Windows.UI.Core.CoreDispatcher.HasThreadAccess?displayProperty=nameWithType> właściwość, aby określić, czy metoda jest uruchomiona w wątku nie będącym interfejsem użytkownika. Wywołaj <xref:Windows.UI.Core.CoreDispatcher.RunAsync%2A?displayProperty=nameWithType> metodę, aby wykonać delegata, który zaktualizuje wątek interfejsu użytkownika. 
  
-   W aplikacjach Windows Forms Użyj <xref:System.Windows.Forms.Control.InvokeRequired%2A?displayProperty=nameWithType> właściwości, aby określić, czy metoda jest uruchomiona w wątku nie będącym interfejsem użytkownika. Wywołaj jedno z przeciążeń <xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=nameWithType> metody, aby wykonać delegata, który zaktualizuje wątek interfejsu użytkownika.  
  
 W poniższych przykładach przedstawiono <xref:System.InvalidOperationException> wyjątek, który jest zgłaszany podczas próby zaktualizowania elementu interfejsu użytkownika z wątku innego niż wątek, który go utworzył.  Każdy przykład wymaga utworzenia dwóch kontrolek:  
  
-   Kontrolka pola tekstowego o `textBox1`nazwie.  W aplikacji Windows Forms należy ustawić jej <xref:System.Windows.Forms.TextBox.Multiline%2A> właściwość na. `true`  
  
-   Kontrolka przycisku o `threadExampleBtn`nazwie. W przykładzie przedstawiono procedurę obsługi `ThreadsExampleBtn_Click`dla `Click` zdarzenia przycisku.  
  
 W każdym przypadku `threadExampleBtn_Click` program obsługi zdarzeń `DoSomeWork` wywołuje metodę dwa razy. Pierwsze wywołanie przebiega synchronicznie i kończy się powodzeniem. Ale drugie wywołanie, ponieważ działa asynchronicznie w wątku puli wątków, próbuje zaktualizować interfejs użytkownika z wątku innego niż interfejs użytkownika. Powoduje <xref:System.InvalidOperationException> to wyjątek.  
  
 Aplikacje WPF i platformy UWP  
 [!code-csharp[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/cs/MainWindow.xaml.cs#1)]
 [!code-vb[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/vb/MainWindow.xaml.vb#1)]  
  
 Następująca wersja `DoSomeWork` metody eliminuje wyjątek w aplikacji WPF.  
  
 [!code-csharp[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/cs/MainWindowDispatcher.xaml.cs#3)]
 [!code-vb[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/vb/MainWindowDispatcher.xaml.vb#3)]  
  
 Następująca wersja `DoSomeWork` metody eliminuje wyjątek w aplikacji platformy UWP.  
  
 [!code-csharp[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/cs/MainPage.xaml.cs#4)]
 [!code-vb[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/vb/MainPage.xaml.vb#4)]  
  
 Aplikacje Windows Forms  
 [!code-csharp[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/cs/Form1.cs#2)]
 [!code-vb[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/vb/Form1.vb#2)]  
  
 Następująca wersja `DoSomeWork` metody eliminuje wyjątek w aplikacji Windows Forms.  
  
 [!code-csharp[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/cs/Form1.cs#5)]
 [!code-vb[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/vb/Form1.vb#5)]  
  
<a name="Iterating"></a>   
### <a name="changing-a-collection-while-iterating-it"></a>Zmiana kolekcji podczas iteracji  
 Instrukcja in C# lub`For Each` instrukcji w Visual Basic jest używana do iteracji elementów członkowskich kolekcji i odczytywania lub modyfikowania poszczególnych elementów. `foreach` Nie można go jednak użyć do dodania lub usunięcia elementów z kolekcji. W ten sposób zgłaszany <xref:System.InvalidOperationException> jest wyjątek z komunikatem podobnym do "**Kolekcja została zmodyfikowana; nie można wykonać operacji wyliczania ".**  
  
 Poniższy przykład wykonuje iterację kolekcji liczb całkowitych próbuje dodać kwadrat każdej liczby całkowitej do kolekcji. Przykład generuje <xref:System.InvalidOperationException> z pierwszym wywołaniem <xref:System.Collections.Generic.List%601.Add%2A?displayProperty=nameWithType> metody.  
  
 [!code-csharp[System.InvalidOperationException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating1.cs#1)]
 [!code-vb[System.InvalidOperationException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating1.vb#1)]  
  
 Wyjątek można wyeliminować na jeden z dwóch sposobów, w zależności od logiki aplikacji:  
  
-   Jeśli elementy należy dodać do kolekcji podczas iteracji, można wykonać iterację przy użyciu `for` instrukcji `foreach` zamiast lub `For Each`. Poniższy przykład używa instrukcji for, aby dodać do kolekcji kwadrat numerów z kolekcji.  
  
     [!code-csharp[System.InvalidOperationException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating2.cs#2)]
     [!code-vb[System.InvalidOperationException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating2.vb#2)]  
  
     Należy pamiętać, że przed iteracją kolekcji należy określić liczbę iteracji, przy użyciu licznika wewnątrz pętli, która odpowiednio zamyka pętlę, przez iterację do tyłu, od `Count` -1 do 0 lub, jak na przykład, przypisując liczbę elementów w tablicy do zmiennej i przy użyciu jej do określenia górnej granicy pętli. W przeciwnym razie, jeśli element zostanie dodany do kolekcji dla każdej iteracji, powstaje nieskończona pętla.  
  
-   Jeśli nie jest konieczne dodawanie elementów do kolekcji podczas iteracji, można zapisać elementy do dodania w tymczasowej kolekcji dodawanej podczas iteracji kolekcji.  Poniższy przykład używa tego podejścia do dodawania kwadratów liczb w kolekcji do tymczasowej kolekcji, a następnie do łączenia kolekcji w jeden obiekt Array.  
  
     [!code-csharp[System.InvalidOperationException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating3.cs#3)]
     [!code-vb[System.InvalidOperationException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating3.vb#3)]  
  
<a name="Sorting"></a>   
### <a name="sorting-an-array-or-collection-whose-objects-cannot-be-compared"></a>Sortowanie tablicy lub kolekcji, której nie można porównać obiektów  
 Metody sortowania ogólnego przeznaczenia, takie <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> jak Metoda <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> lub metoda, zwykle wymagają, aby co najmniej jeden z obiektów <xref:System.IComparable%601> do <xref:System.IComparable> posortowania implementuje interfejs lub. W przeciwnym razie kolekcja lub tablica nie może być posortowana, a metoda zgłasza <xref:System.InvalidOperationException> wyjątek. Poniższy przykład definiuje `Person` klasę, przechowuje dwa `Person` obiekty w obiekcie ogólnym <xref:System.Collections.Generic.List%601> i próbuje je posortować. Jako dane wyjściowe z przykładu pokazuje, wywołanie <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> metody <xref:System.InvalidOperationException>zgłasza.  
  
 [!code-csharp[System.InvalidOperationException#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort1.cs#12)]
 [!code-vb[System.InvalidOperationException#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort1.vb#12)]  
  
 Wyjątek można wyeliminować na jeden z trzech sposobów:  
  
-   Jeśli można określić typ, który ma zostać posortowany (oznacza to, że jeśli kontrolujesz swój kod źródłowy), można zmodyfikować go w celu zaimplementowania <xref:System.IComparable%601> <xref:System.IComparable> interfejsu lub. Wymaga to zaimplementowania <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> <xref:System.IComparable.CompareTo%2A> metody lub. Dodawanie implementacji interfejsu do istniejącego typu nie jest istotną zmianą.  
  
     Poniższy przykład używa tego podejścia, aby zapewnić <xref:System.IComparable%601> implementację `Person` dla klasy. Nadal można wywołać ogólną metodę sortowania kolekcji lub tablicy oraz, jak dane wyjściowe z przykładu pokazują, kolekcja zostanie posortowana pomyślnie.  
  
     [!code-csharp[System.InvalidOperationException#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort2.cs#13)]
     [!code-vb[System.InvalidOperationException#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort2.vb#13)]  
  
-   Jeśli nie można zmodyfikować kodu źródłowego dla typu, który próbujesz sortować, można zdefiniować klasę sortowania specjalnego przeznaczenia, która implementuje <xref:System.Collections.Generic.IComparer%601> interfejs.  Można wywołać Przeciążenie `Sort` metody, która <xref:System.Collections.Generic.IComparer%601> zawiera parametr. Takie podejście jest szczególnie przydatne, jeśli chcesz opracować wyspecjalizowaną klasę sortowania, która może sortować obiekty na podstawie wielu kryteriów.  
  
     W poniższym przykładzie użyto podejścia, tworząc klasę niestandardową `PersonComparer` , która jest używana do sortowania `Person` kolekcji.  Następnie przekazuje wystąpienie tej klasy do <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29?displayProperty=nameWithType> metody.  
  
     [!code-csharp[System.InvalidOperationException#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort3.cs#14)]
     [!code-vb[System.InvalidOperationException#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort3.vb#14)]  
  
-   Jeśli nie możesz zmodyfikować kodu źródłowego dla typu, który próbujesz sortować, możesz utworzyć <xref:System.Comparison%601> delegata, aby wykonać sortowanie. Podpis delegata to  
  
    ```vb  
    Function Comparison(Of T)(x As T, y As T) As Integer  
    ```  
  
    ```csharp  
    int Comparison<T>(T x, T y)  
    ```  
  
     Poniższy przykład używa podejścia przez zdefiniowanie `PersonComparison` metody zgodnej z <xref:System.Comparison%601> podpisem delegata.  Następnie przekazuje tego delegata do <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29?displayProperty=nameWithType> metody.  
  
     [!code-csharp[System.InvalidOperationException#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort4.cs#15)]
     [!code-vb[System.InvalidOperationException#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort4.vb#15)]  
  
<a name="Nullable"></a>   
### <a name="casting-a-nullablet-that-is-null-to-its-underlying-type"></a>Rzutowanie wartości\<null T >, która ma wartość null do jego typu podstawowego  
 Próba rzutowania <xref:System.Nullable%601> wartości `null` będącej <xref:System.InvalidOperationException> jej typem podstawowym zgłasza wyjątek i wyświetla komunikat o błędzie, "**obiekt nullable musi mieć wartość.**  
  
 Poniższy przykład zgłasza <xref:System.InvalidOperationException> wyjątek podczas próby wykonania iteracji tablicy, która `Nullable(Of Integer)` zawiera wartość.  
  
 [!code-csharp[System.InvalidOperationException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable1.cs#4)]
 [!code-vb[System.InvalidOperationException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable1.vb#4)]  
  
 Aby zapobiec wyjątku:  
  
-   Użyj właściwości, aby zaznaczyć tylko te elementy, które nie `null`są. <xref:System.Nullable%601.HasValue%2A?displayProperty=nameWithType>  
  
-   Wywołaj jedno z <xref:System.Nullable%601.GetValueOrDefault%2A?displayProperty=nameWithType> przeciążeń, aby podać wartość domyślną `null` dla wartości.  
  
 Poniższy przykład ma na celu uniknięcie <xref:System.InvalidOperationException> wyjątku.  
  
 [!code-csharp[System.InvalidOperationException#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable2.cs#5)]
 [!code-vb[System.InvalidOperationException#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable2.vb#5)]  
  
<a name="Empty"></a>   
### <a name="calling-a-systemlinqenumerable-method-on-an-empty-collection"></a>Wywoływanie metody System. LINQ. wyliczalnej w pustej kolekcji  
 <xref:System.Linq.Enumerable.Aggregate%2A?displayProperty=nameWithType>Metody, <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType> ,<xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>, ,,<xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>, i<xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> wykonują operacje na sekwencji i zwracają jeden wynik. <xref:System.Linq.Enumerable.Max%2A?displayProperty=nameWithType> <xref:System.Linq.Enumerable.Min%2A?displayProperty=nameWithType> <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>   Niektóre przeciążenia tych metod <xref:System.InvalidOperationException> zgłaszają wyjątek, gdy sekwencja jest pusta, podczas gdy inne przeciążenia zwracają. `null` Metoda zgłasza również wyjątek, <xref:System.InvalidOperationException> gdy sekwencja zawiera więcej niż jeden element. <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>  
  
> [!NOTE]
>  Większość metod, które generują <xref:System.InvalidOperationException> wyjątek, są przeciążeniami. Upewnij się, że rozumiesz zachowanie wybranego przeciążenia.  
  
 W poniższej tabeli wymieniono komunikaty o wyjątkach <xref:System.InvalidOperationException> z obiektów wyjątków zgłoszonych przez wywołania <xref:System.Linq.Enumerable?displayProperty=nameWithType> niektórych metod.  
  
|Metoda|Message|  
|------------|-------------|  
|`Aggregate` <br /> `Average` <br /> `Last` <br /> `Max` <br /> `Min`|**Sekwencja nie zawiera żadnych elementów**|  
|`First`|**Sekwencja nie zawiera pasującego elementu**|  
|`Single` <br /> `SingleOrDefault`|**Sekwencja zawiera więcej niż jeden pasujący element**|  
  
 Sposób eliminacji lub obsługi wyjątku zależy od założeń aplikacji oraz od konkretnej metody wywołania.  
  
-   W przypadku świadomego wywołania jednej z tych metod bez sprawdzania pustej sekwencji zakłada się, że sekwencja nie jest pusta i że pusta sekwencja jest nieoczekiwanym wystąpieniem. W takim przypadku należy przechwycić lub ponownie zgłosić wyjątek.  
  
-   Jeśli niepowodzenie sprawdzania pustej sekwencji zostało przypadkowo, można wywołać jedno z przeciążenia <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> przeciążenia, aby określić, czy sekwencja zawiera jakiekolwiek elementy.  
  
    > [!TIP]
    >  <xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> Wywołanie metody przed wygenerowaniem sekwencji może zwiększyć wydajność, jeśli dane, które mają być przetwarzane mogą zawierać dużą liczbę elementów lub jeśli operacja generująca sekwencję jest kosztowna.  
  
-   Jeśli wywołana została metoda, taka jak <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>, lub <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>, można zastąpić alternatywną metodę, taką jak <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.LastOrDefault%2A?displayProperty=nameWithType>, lub <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>, która zwraca wartość domyślną zamiast elementu członkowskiego sekwencji.  
  
 Przykłady zapewniają dodatkowe szczegóły.  
  
 W poniższym przykładzie zastosowano <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType> metodę, aby obliczyć średnią dla sekwencji, której wartości są większe niż 4. Ponieważ żadne wartości z oryginalnej tablicy nie przekraczają 4, żadne wartości nie są uwzględniane w sekwencji, a metoda zgłasza <xref:System.InvalidOperationException> wyjątek.  
  
 [!code-csharp[System.InvalidOperationException#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable1.cs#6)]
 [!code-vb[System.InvalidOperationException#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable1.vb#6)]  
  
 Wyjątek można wyeliminować, wywołując <xref:System.Linq.Enumerable.Any%2A> metodę, aby określić, czy sekwencja zawiera jakiekolwiek elementy przed wywołaniem metody, która przetwarza sekwencję, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.InvalidOperationException#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable2.cs#7)]
 [!code-vb[System.InvalidOperationException#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable2.vb#7)]  
  
 <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> Metoda zwraca pierwszy element w sekwencji lub pierwszy element w sekwencji, który spełnia określony warunek. Jeśli sekwencja jest pusta i w związku z tym nie ma pierwszego elementu, zgłasza <xref:System.InvalidOperationException> wyjątek.  
  
 W poniższym przykładzie <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> Metoda <xref:System.InvalidOperationException> zgłasza wyjątek, ponieważ tablica dbQueryResults nie zawiera elementu większego niż 4.  
  
 [!code-csharp[System.InvalidOperationException#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable3.cs#8)]
 [!code-vb[System.InvalidOperationException#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable3.vb#8)]  
  
 <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> Metodę można wywołać <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> zamiast zwraca wartość określoną lub domyślną. Jeśli metoda nie odnajdzie pierwszego elementu w sekwencji, zwraca wartość domyślną dla tego typu danych.  Wartość domyślna to `null` dla typu odwołania, zero dla typu danych liczbowych i <xref:System.DateTime.MinValue?displayProperty=nameWithType> dla <xref:System.DateTime> typu.  
  
> [!NOTE]
>  Interpretacja wartości zwracanej przez <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> metodę jest często skomplikowany przez fakt, że wartość domyślna typu może być prawidłową wartością w sekwencji. W tym przypadku należy wywołać <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> metodę, aby określić, czy sekwencja ma prawidłowych elementów członkowskich przed <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> wywołaniem metody.  
  
 Poniższy przykład wywołuje metodę, <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> aby <xref:System.InvalidOperationException> zapobiec występowaniu wyjątku w poprzednim przykładzie.  
  
 [!code-csharp[System.InvalidOperationException#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable4.cs#9)]
 [!code-vb[System.InvalidOperationException#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable4.vb#9)]  
  
<a name="Single"></a>   
### <a name="calling-enumerablesingle-or-enumerablesingleordefault-on-a-sequence-without-one-element"></a>Wywoływanie wyliczalnego elementu. Single lub wyliczalny. SingleOrDefault na sekwencji bez jednego elementu  
 <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> Metoda zwraca jedyny element sekwencji lub jedyny element sekwencji, która spełnia określony warunek.    Jeśli nie ma żadnych elementów w sekwencji lub jeśli występuje więcej niż jeden element, metoda zgłasza <xref:System.InvalidOperationException> wyjątek.  
  
 Można użyć <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> metody do zwrócenia wartości domyślnej zamiast zgłaszania wyjątku, gdy sekwencja nie zawiera żadnych elementów. Jednak metoda nadal <xref:System.InvalidOperationException> zgłasza wyjątek, gdy sekwencja zawiera więcej niż jeden element. <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>  
  
 W poniższej tabeli wymieniono komunikaty o wyjątkach <xref:System.InvalidOperationException> z obiektów wyjątków zgłoszonych przez wywołania <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> metod <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> i.  
  
|Metoda|Message|  
|------------|-------------|  
|`Single`|**Sekwencja nie zawiera pasującego elementu**|  
|`Single` <br /> `SingleOrDefault`|**Sekwencja zawiera więcej niż jeden pasujący element**|  
  
 W poniższym przykładzie wywołanie <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> metody zgłasza wyjątek, <xref:System.InvalidOperationException> ponieważ sekwencja nie ma elementu większego niż 4.  
  
 [!code-csharp[System.InvalidOperationException#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable5.cs#10)]
 [!code-vb[System.InvalidOperationException#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable5.vb#10)]  
  
 Poniższy przykład próbuje zapobiec występowaniu <xref:System.InvalidOperationException> wyjątku, gdy sekwencja jest pusta przez <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> wywołanie metody. Jednak ponieważ ta sekwencja zwraca wiele elementów, których wartość jest większa niż 2, zgłasza <xref:System.InvalidOperationException> również wyjątek.  
  
 [!code-csharp[System.InvalidOperationException#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable6.cs#11)]
 [!code-vb[System.InvalidOperationException#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable6.vb#11)]  
  
 <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> Wywołanie metody zakłada, że sekwencję lub sekwencję spełniającą określone kryteria zawierają tylko jeden element.  <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>przyjmuje sekwencję z zerem lub jednym wynikiem, ale nie więcej. Jeśli to założenie jest zamierzone w danej części, a te warunki nie są spełnione, ponowne zgłoszenie lub przechwycenie wyniku <xref:System.InvalidOperationException> jest odpowiednie. W przeciwnym razie, Jeśli spodziewasz się, że nieprawidłowe warunki wystąpią z pewnymi częstotliwościami, należy <xref:System.Linq.Enumerable> rozważyć użycie innej metody <xref:System.Linq.Enumerable.FirstOrDefault%2A> , <xref:System.Linq.Enumerable.Where%2A>takiej jak lub.  
  
<a name="Emit"></a>   
### <a name="dynamic-cross-application-domain-field-access"></a>Dynamiczny dostęp do pola domeny wielu aplikacji  
 Instrukcja języka pośredniego <xref:System.InvalidOperationException> firmyMicrosoft(MSIL)zgłaszawyjątek,jeśliobiektzawierającypole,któregoadrespróbujeszpobrać,nieznajdujesięwdomenieaplikacji,wktórej<xref:System.Reflection.Emit.OpCodes.Ldflda?displayProperty=nameWithType> wykonywany jest kod. Do adresu pola można uzyskać dostęp tylko z domeny aplikacji, w której znajduje się.  
  
<a name="Throwing"></a>   
## <a name="throwing-an-invalidoperationexception-exception"></a>Zgłaszanie wyjątku InvalidOperationException  
 <xref:System.InvalidOperationException> Wyjątek należy zgłosić tylko wtedy, gdy stan obiektu z jakiegoś powodu nie obsługuje określonego wywołania metody. Oznacza to, że wywołanie metody jest prawidłowe w pewnych okolicznościach lub kontekstach, ale jest nieprawidłowe w innych.  
  
 Jeśli błąd wywołania metody jest spowodowany nieprawidłowymi argumentami, <xref:System.ArgumentException> następnie lub jedną z jej <xref:System.ArgumentNullException> klas pochodnych lub <xref:System.ArgumentOutOfRangeException>, należy zamiast tego zgłaszać.  
  
<a name="Misc"></a>   
## <a name="miscellaneous-information"></a>Różne informacje  
 <xref:System.InvalidOperationException>używa HRESULT COR_E_INVALIDOPERATION o wartości 0x80131509.  
  
 Aby uzyskać listę początkowe wartości właściwości wystąpienia <xref:System.InvalidOperationException>, zobacz <xref:System.InvalidOperationException.%23ctor%2A> konstruktorów.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
    <altmember cref="T:System.Collections.IEnumerator" />
    <altmember cref="T:System.Resources.ResourceSet" />
    <related type="Article" href="~/docs/standard/exceptions/index.md">Obsługa i zgłaszanie wyjątków</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.InvalidOperationException" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.InvalidOperationException" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.Exception.Message%2A> właściwość nowego wystąpienia do komunikatu dostarczonego przez system, który opisuje błąd, na przykład "nie można wykonać żądanej operacji". Ten komunikat uwzględnia bieżącą kulturę systemu.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.InvalidOperationException>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Odwołanie o wartości null (`Nothing` w języku Visual Basic).|  
|<xref:System.Exception.Message%2A>|Zlokalizowany ciąg komunikatu o błędzie.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string -&gt; InvalidOperationException" Usage="new System.InvalidOperationException message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat, który opisuje błąd.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.InvalidOperationException" /> klasy przy użyciu określonego komunikatu o błędzie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.Exception.Message%2A?displayProperty=nameWithType> właściwość nowego wyjątku `message` przy użyciu parametru. Zawartość `message` ma być zrozumiała dla ludzi. Obiekt wywołujący tego konstruktora jest wymagany w celu zagwarantowania, że ten ciąg został zlokalizowany w bieżącej kulturze systemu.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.InvalidOperationException>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Odwołanie o wartości null (`Nothing` w języku Visual Basic).|  
|<xref:System.Exception.Message%2A>|Ciąg komunikatu o błędzie.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InvalidOperationException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InvalidOperationException(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">Obiekt zawierający dane serializowanego obiektu.</param>
        <param name="context">Informacje kontekstowe o źródłowego lub miejscu docelowym.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.InvalidOperationException" /> klasy z serializowanych danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływana podczas deserializacji do odtworzenia obiektu wyjątku przesyłanego za pomocą strumienia. Aby uzyskać więcej informacji, zobacz [XML oraz serializacji protokołu SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Serializacja XML i SOAP</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string * Exception -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat o błędzie wyjaśniający przyczynę wyjątku.</param>
        <param name="innerException">Wyjątek, który jest przyczyną bieżącego wyjątku. Jeśli parametr nie jest odwołaniem null (<see langword="Nothing" /> w Visual Basic), bieżący <see langword="catch" /> wyjątek jest wywoływany w bloku, który obsługuje wyjątek wewnętrzny. <paramref name="innerException" /></param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.InvalidOperationException" /> klasy przy użyciu określonego komunikatu o błędzie i odwołania do wewnętrznego wyjątku, który jest przyczyną tego wyjątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyjątek generowany jako bezpośredni wynik poprzedniego wyjątku powinien zawierać odwołanie do poprzedniego wyjątku we <xref:System.Exception.InnerException%2A> właściwości. Właściwość zwraca tę samą wartość, która jest przenoszona do konstruktora lub odwołanie o wartości null (`Nothing` <xref:System.Exception.InnerException%2A> w Visual Basic), jeśli właściwość nie poda wewnętrznej wartości wyjątku do konstruktora. <xref:System.Exception.InnerException%2A>  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.InvalidOperationException>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Odwołanie do wewnętrznego wyjątku.|  
|<xref:System.Exception.Message%2A>|Ciąg komunikatu o błędzie.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
        <related type="Article" href="~/docs/standard/exceptions/index.md">Obsługa i zgłaszanie wyjątków</related>
      </Docs>
    </Member>
  </Members>
</Type>

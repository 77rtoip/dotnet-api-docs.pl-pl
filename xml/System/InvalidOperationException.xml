<Type Name="InvalidOperationException" FullName="System.InvalidOperationException">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="310a76379e88bee1dcef1420b7010efdaf2c8a3d" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36429912" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class InvalidOperationException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit InvalidOperationException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.InvalidOperationException" />
  <TypeSignature Language="VB.NET" Value="Public Class InvalidOperationException&#xA;Inherits SystemException" />
  <TypeSignature Language="C++ CLI" Value="public ref class InvalidOperationException : SystemException" />
  <TypeSignature Language="F#" Value="type InvalidOperationException = class&#xA;    inherit SystemException" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Wyjątek zgłaszany, gdy wywołanie metody jest nieprawidłowa dla bieżącego stanu obiektu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.InvalidOperationException> jest używany w przypadku gdy nie można wywołać metody wynika z innego powodu niż nieprawidłowe argumenty. Zazwyczaj jest generowany, gdy stan obiektu nie może obsłużyć wywołania metody. Na przykład <xref:System.InvalidOperationException> wyjątku za pomocą metod takich jak:  
  
-   <xref:System.Collections.IEnumerator.MoveNext%2A?displayProperty=nameWithType> Jeśli obiekty z kolekcji zostaną zmodyfikowane po utworzeniu modułu wyliczającego. Aby uzyskać więcej informacji, zobacz [zmiana kolekcji podczas jej iteracja](#Iterating).  
  
-   <xref:System.Resources.ResourceSet.GetString%2A?displayProperty=nameWithType> Jeśli zestaw zasobów jest zamknięty przed wywołania metody, które jest tworzone.  
  
-   <xref:System.Xml.Linq.XContainer.Add%2A?displayProperty=nameWithType>, jeśli obiekty do dodania w rezultacie dokumentu XML o nieprawidłowej strukturze.  
  
-   Metoda, która podejmuje próbę manipulowania interfejsu użytkownika z wątku, który nie głównym lub wątku interfejsu użytkownika.  
  
> [!IMPORTANT]
>  Ponieważ <xref:System.InvalidOperationException> może zostać zgłoszony wyjątek w różnych sytuacjach należy odczytać zwrócony przez komunikat o wyjątku <xref:System.Exception.Message%2A> właściwości.  
  
 W tej sekcji:  
  
 [Niektóre typowe przyczyny InvalidOperationException wyjątków](#Causes)   
 [Aktualizowanie wątku interfejsu użytkownika z wątku bez interfejsu użytkownika](#UI)  
 [Zmiana kolekcji podczas jej iteracja](#Iterating)  
 [Sortowanie tablicy lub kolekcji obiektów, których nie można porównać.](#Sorting)  
 [Rzutowanie typu Nullable&lt;T&gt; to null do jego typem podstawowym](#Nullable)   
 [Wywołanie metody System.Linq.Enumerable pustej kolekcji.](#Empty)  
 [Wywoływanie Enumerable.Single lub Enumerable.SingleOrDefault sekwencji bez jeden element.](#Single)  
 [Dostępu do pola dynamicznej domenie międzyaplikacyjnej](#Emit)  
[Zgłaszanie wyjątku InvalidOperationException](#Throwing)  
[Dodatkowe informacje](#Misc)  
  
<a name="Causes"></a>   
## <a name="some-common-causes-of-invalidoperationexception-exceptions"></a>Niektóre typowe przyczyny InvalidOperationException wyjątków  
 Poniższe sekcje pokazują, jak niektóre typowe przypadki, w którym w <xref:System.InvalidOperationException> wyjątek w aplikacji. Sposób obsługi problemu zależy od konkretnej sytuacji. Najczęściej, jednak wyjątek powoduje błędu deweloperów i <xref:System.InvalidOperationException> wyjątek może być zakładano i unikać.  
  
<a name="UI"></a>   
### <a name="updating-a-ui-thread-from-a-non-ui-thread"></a>Aktualizowanie wątku interfejsu użytkownika z wątku bez interfejsu użytkownika  
 Wątki robocze są często używane do wykonywania niektórych Praca w tle, który obejmuje zbieranie danych będzie wyświetlana w interfejsie użytkownika aplikacji. Jednak. Większość struktur aplikacji graficznego interfejsu użytkownika (graficznego interfejsu użytkownika) dla programu .NET Framework, takich jak formularzy systemu Windows i Windows Presentation Foundation (WPF) umożliwiają dostęp do obiektów z graficznym interfejsem użytkownika, tylko z wątku, który tworzy i którymi zarządza interfejsu użytkownika (wątku głównego lub interfejsu użytkownika). <xref:System.InvalidOperationException> Jest generowany, gdy użytkownik próbuje uzyskać dostęp do elementu interfejsu użytkownika z wątku innego niż wątek interfejsu użytkownika.  Tekst komunikatu wyjątku przedstawiono w poniższej tabeli.  
  
|Typ aplikacji|Komunikat|  
|----------------------|-------------|  
|Aplikacja WPF|**Wątek wywołujący nie może uzyskać dostępu do tego obiektu, ponieważ inny wątek jest jego właścicielem.**|  
|Aplikacji platformy uniwersalnej systemu Windows|**Aplikacja o nazwie interfejs, który został skierowany do innego wątku.**|  
|Aplikacji formularzy systemu Windows|**Nieprawidłowa operacja między wątkami: kontrola "Poletekstowe1" dostęp z wątku innego niż wątek, w którym został utworzony.**|  
  
 Implementowanie interfejsu użytkownika platformy .NET Framework *dyspozytora* wzorca, który zawiera metodę sprawdzania, czy wywołanie do elementu członkowskiego elementu interfejsu użytkownika jest wykonywana w wątku interfejsu użytkownika i innych metod, aby zaplanować połączenie w wątku interfejsu użytkownika:  
  
-   W aplikacjach WPF wywołać <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A?displayProperty=nameWithType> metodę, aby określić, czy metoda jest uruchomiony w wątku bez interfejsu użytkownika. Zwraca `true` Jeśli metoda jest uruchomiona w wątku interfejsu użytkownika i `false` inaczej. Wywoływanie jednego z przeciążeń <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=nameWithType> metodę, aby zaplanować połączenie w wątku interfejsu użytkownika.  
  
-   W aplikacjach platformy uniwersalnej systemu Windows, należy wywołać [CoreDispatcher.HasThreadAccess](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.hasthreadaccess.aspx) metodę, aby określić, czy metoda jest uruchomiony w wątku bez interfejsu użytkownika. Wywołanie [CoreDispatcher.RunAsync](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.runasync.aspx) metodę, aby wykonać delegata, który aktualizuje wątku interfejsu użytkownika. Użyj  
  
-   W aplikacjach formularzy systemu Windows, należy użyć <xref:System.Windows.Forms.Control.InvokeRequired%2A?displayProperty=nameWithType> właściwości w celu określenia, czy metoda jest uruchomiony w wątku bez interfejsu użytkownika. Wywoływanie jednego z przeciążeń <xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=nameWithType> metodę, aby wykonać delegata, który aktualizuje wątku interfejsu użytkownika.  
  
 Poniższe przykłady przedstawiają <xref:System.InvalidOperationException> wyjątku zgłoszonego podczas próby zaktualizowania elementu interfejsu użytkownika z wątku innego niż wątek, który go utworzył.  Każdy przykład wymaga utworzenia dwóch formantów:  
  
-   Polu tekstowym o nazwie `textBox1`.  W aplikacji formularzy systemu Windows, należy ustawić jej <xref:System.Windows.Forms.TextBox.Multiline%2A> właściwości `true`.  
  
-   Formant przycisk o nazwie `threadExampleBtn`. W przykładzie przedstawiono obsługi, `ThreadsExampleBtn_Click`, dla przycisku `Click` zdarzeń.  
  
 W każdym przypadku `threadExampleBtn_Click` wywołań obsługi zdarzeń `DoSomeWork` metody dwa razy. Pierwsze wywołanie jest uruchamiana synchronicznie i zakończy się pomyślnie. Ale drugie wywołanie, ponieważ asynchronicznie uruchamia się w wątku puli wątków próbuje zaktualizować interfejsu użytkownika z wątku bez interfejsu użytkownika. Powoduje to <xref:System.InvalidOperationException> wyjątku.  
  
 Aplikacje WPF i platformy uniwersalnej systemu Windows  
 [!code-csharp[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/cs/MainWindow.xaml.cs#1)]
 [!code-vb[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/vb/MainWindow.xaml.vb#1)]  
  
 Następująca wersja `DoSomeWork` metody eliminuje wyjątek w aplikacji WPF.  
  
 [!code-csharp[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/cs/MainWindowDispatcher.xaml.cs#3)]
 [!code-vb[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/vb/MainWindowDispatcher.xaml.vb#3)]  
  
 Następująca wersja `DoSomeWork` metody eliminuje wyjątek w aplikacji platformy uniwersalnej systemu Windows.  
  
 [!code-csharp[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/cs/MainPage.xaml.cs#4)]
 [!code-vb[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/vb/MainPage.xaml.vb#4)]  
  
 Aplikacji formularzy systemu Windows  
 [!code-csharp[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/cs/Form1.cs#2)]
 [!code-vb[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/vb/Form1.vb#2)]  
  
 Następująca wersja `DoSomeWork` metody eliminuje wyjątek w aplikacji formularzy systemu Windows.  
  
 [!code-csharp[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/cs/Form1.cs#5)]
 [!code-vb[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/vb/Form1.vb#5)]  
  
<a name="Iterating"></a>   
### <a name="changing-a-collection-while-iterating-it"></a>Zmiana kolekcji podczas jej iteracja  
 `foreach` Instrukcji w języku C# lub `For Each` używana jest instrukcja w języku Visual Basic w celu wykonania iteracji elementów członkowskich kolekcji i do odczytywania lub modyfikowania jej poszczególne elementy. Jednak nie można użyć do dodawania lub usuwania elementów z kolekcji. Spowoduje to zgłasza <xref:System.InvalidOperationException> komunikat, która jest podobna do "**Zmodyfikowano kolekcję. Nie można wykonać operacji wyliczania. **"  
  
 Poniższy przykład iteruje po kolekcji liczb całkowitych prób do dodania do kolekcji kwadratowe każdej liczby całkowitej. Przykład zgłasza <xref:System.InvalidOperationException> przy pierwszym wywołaniu <xref:System.Collections.Generic.List%601.Add%2A?displayProperty=nameWithType> metody.  
  
 [!code-csharp[System.InvalidOperationException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating1.cs#1)]
 [!code-vb[System.InvalidOperationException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating1.vb#1)]  
  
 W zależności od aplikacji logiki można wyeliminować wyjątek w jeden z dwóch sposobów:  
  
-   Jeśli elementy muszą zostać dodane do kolekcji podczas jej iteracja, można wykonać iterację go przy użyciu indeksu `for` instrukcji zamiast `foreach` lub `For Each`. W poniższym przykładzie użyto dla instrukcji dodać kwadratu liczb znajdujących się w kolekcji do kolekcji.  
  
     [!code-csharp[System.InvalidOperationException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating2.cs#2)]
     [!code-vb[System.InvalidOperationException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating2.vb#2)]  
  
     Należy pamiętać, że liczba iteracji, należy ustanowić przed iteracja kolekcji za pomocą licznika wewnątrz pętli, które zostanie zakończona appropraitely pętli przez iteracja Wstecz, z `Count` - 1 na 0 lub jak przykładzie, przypisując numer elementów w tablicy, tak aby w zmiennej i użyciem jej do ustalenia górna granica pętli. W przeciwnym razie jeśli element zostanie dodany do kolekcji w każdej iteracji, powoduje nieskończonej pętli.  
  
-   Jeśli nie jest konieczne jest dodanie elementów do kolekcji podczas jej iteracja, można przechowywać elementy do dodania w zbiorze tymczasowego możesz dodać po zakończeniu iteracja kolekcji.  Poniższy przykład korzysta z tej metody można dodać kwadratu liczb znajdujących się w kolekcji do kolekcji tymczasowej, a następnie połączyć kolekcji do obiektu pojedynczą tablicę.  
  
     [!code-csharp[System.InvalidOperationException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating3.cs#3)]
     [!code-vb[System.InvalidOperationException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating3.vb#3)]  
  
<a name="Sorting"></a>   
### <a name="sorting-an-array-or-collection-whose-objects-cannot-be-compared"></a>Sortowanie tablicy lub kolekcji obiektów, których nie można porównać.  
 Ogólnego przeznaczenia, sortowanie metod, takich jak <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> — metoda lub <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> metody, zwykle wymagają tego co najmniej jeden z obiektów, które ma zostać posortowana zaimplementować <xref:System.IComparable%601> lub <xref:System.IComparable> interfejsu. Jeśli nie, nie można sortować kolekcji lub tablicy, a metoda zgłasza <xref:System.InvalidOperationException> wyjątku. W poniższym przykładzie zdefiniowano `Person` klasy magazynów dwa `Person` obiektów w ogólnej metodzie <xref:System.Collections.Generic.List%601> obiektu i próbuje je posortować. Jako dane wyjściowe w przykładzie, wywołanie <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> metoda zgłasza <xref:System.InvalidOperationException>.  
  
 [!code-csharp[System.InvalidOperationException#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort1.cs#12)]
 [!code-vb[System.InvalidOperationException#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort1.vb#12)]  
  
 Można wyeliminować wyjątek w jednym z trzech sposobów:  
  
-   Typ, który próbujesz posortować (Jeśli możesz kontrolować jego kod źródłowy) mogą być właścicielami, można zmodyfikować go, aby zaimplementować <xref:System.IComparable%601> lub <xref:System.IComparable> interfejsu. Wymaga to wykonania albo <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> lub <xref:System.IComparable.CompareTo%2A> metody. Dodanie implementacji interfejsu do istniejącego typu nie jest istotne zmiany.  
  
     W poniższym przykładzie użyto tej metody w celu zapewnienia <xref:System.IComparable%601> implementację `Person` klasy. Nadal można wywoływać kolekcji lub tablicy, ogólną metodę sortowania i jak dane wyjściowe w przykładzie pokazano, kolekcji sortuje pomyślnie.  
  
     [!code-csharp[System.InvalidOperationException#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort2.cs#13)]
     [!code-vb[System.InvalidOperationException#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort2.vb#13)]  
  
-   Jeśli nie można zmodyfikować kod źródłowy dla typu próbujesz sortowania, można zdefiniować klasy sortowania specjalnych, który implementuje <xref:System.Collections.Generic.IComparer%601> interfejsu.  Można wywoływać przeciążenia `Sort` metodę, która obejmuje <xref:System.Collections.Generic.IComparer%601> parametru. Ta metoda jest szczególnie przydatne, jeśli chcesz utworzyć klasę sortowania specjalne można sortować obiektów na podstawie wielu kryteriów.  
  
     W poniższym przykładzie użyto podejście przez tworzenie niestandardowego `PersonComparer` klasy, która jest używana do sortowania `Person` kolekcji.  Następnie przekazuje wystąpienie tej klasy do <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29?displayProperty=nameWithType> metody.  
  
     [!code-csharp[System.InvalidOperationException#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort3.cs#14)]
     [!code-vb[System.InvalidOperationException#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort3.vb#14)]  
  
-   Nie można zmodyfikować kod źródłowy dla typu próbujesz posortować, można utworzyć <xref:System.Comparison%601> pełnomocnika, aby wykonać sortowanie. Podpis delegata  
  
    ```vb  
    Function Comparison(Of T)(x As T, y As T) As Integer  
    ```  
  
    ```csharp  
    int Comparison<T>(T x, T y)  
    ```  
  
     W poniższym przykładzie użyto podejście, definiując `PersonComparison` metodę, która odpowiada <xref:System.Comparison%601> podpisu delegata.  Następnie przekazuje ten delegat do <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29?displayProperty=nameWithType> metody.  
  
     [!code-csharp[System.InvalidOperationException#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort4.cs#15)]
     [!code-vb[System.InvalidOperationException#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort4.vb#15)]  
  
<a name="Nullable"></a>   
### <a name="casting-a-nullablet-that-is-null-to-its-underlying-type"></a>Rzutowanie typu Nullable\<T > jest wartość null na jego typ podstawowy  
 Próba rzutowania <xref:System.Nullable%601> wartość, czyli `null` do jego typem podstawowym zgłasza <xref:System.InvalidOperationException> wyjątek i wyświetla komunikat o błędzie "**obiekt dopuszczający wartość pustą musi mieć wartość.**  
  
 Poniższy przykład zwraca <xref:System.InvalidOperationException> wyjątek podczas próby wykonania iteracji w tablicy, która zawiera `Nullable(Of Integer)` wartość.  
  
 [!code-csharp[System.InvalidOperationException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable1.cs#4)]
 [!code-vb[System.InvalidOperationException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable1.vb#4)]  
  
 Aby uniknąć wyjątek:  
  
-   Użyj <xref:System.Nullable%601.HasValue%2A?displayProperty=nameWithType> właściwość, aby wybrać tylko te elementy, które nie są `null`.  
  
-   Wywoływanie jednego z <xref:System.Nullable%601.GetValueOrDefault%2A?displayProperty=nameWithType> przeciążenia można podać wartości domyślnej dla `null` wartość.  
  
 Poniższy przykład jest zarówno w celu uniknięcia <xref:System.InvalidOperationException> wyjątku.  
  
 [!code-csharp[System.InvalidOperationException#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable2.cs#5)]
 [!code-vb[System.InvalidOperationException#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable2.vb#5)]  
  
<a name="Empty"></a>   
### <a name="calling-a-systemlinqenumerable-method-on-an-empty-collection"></a>Wywołanie metody System.Linq.Enumerable pustej kolekcji.  
 <xref:System.Linq.Enumerable.Aggregate%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Max%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Min%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>, I <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> metody wykonują operacje na sekwencji i zwracają pojedynczego wyniku.   Throw przeciążenia niektóre z tych metod <xref:System.InvalidOperationException> wyjątku, gdy sekwencja jest pusta, podczas gdy inne przeciążenia zwracać `null`. <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> Metoda również zwraca <xref:System.InvalidOperationException> wyjątku, gdy sekwencja zawiera więcej niż jeden element.  
  
> [!NOTE]
>  Większość metod, które zgłaszają <xref:System.InvalidOperationException> wyjątków są przeciążenia. Pamiętaj, że rozumiesz zachowanie przeciążenia, które można wybrać.  
  
 W poniższej tabeli przedstawiono komunikaty wyjątku z <xref:System.InvalidOperationException> obiekty wyjątków zgłaszanych przez niektóre wywołania <xref:System.Linq.Enumerable?displayProperty=nameWithType> metody.  
  
|Metoda|Komunikat|  
|------------|-------------|  
|`Aggregate` <br /> `Average` <br /> `Last` <br /> `Max` <br /> `Min`|**Sekwencja nie zawiera elementów**|  
|`First`|**Sekwencja nie zawiera zgodnego elementu.**|  
|`Single` <br /> `SingleOrDefault`|**Sekwencja zawiera więcej niż jeden zgodny element.**|  
  
 Jak usunąć lub obsłużyć wyjątek zależy od założenia aplikacji oraz konkretnej metody, które należy wywołać.  
  
-   Podczas celowo wywoływania jednej z tych metod bez sprawdzania pod kątem pustej sekwencji, są przy założeniu sekwencji nie jest pusty i że pustą sekwencją jest nieoczekiwane zdarzenie. W takim przypadku Przechwytywanie lub ponowne generowanie wyjątek jest odpowiedni.  
  
-   Jeśli niewykonanie sprawdzaj pustej sekwencji niepotrzebnemu, należy wywołać jednego z przeciążeń <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> przeciążenia, aby określić, czy sekwencja zawiera żadnych elementów.  
  
    > [!TIP]
    >  Wywoływanie <xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> metoda przed wygenerowaniem sekwencję może poprawić wydajność, jeśli dane mają być przetwarzane mogą zawierać dużą liczbę elementów lub jeśli operacja, która generuje sekwencji jest kosztowna.  
  
-   Jeśli już wywołał metodę, takich jak <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>, lub <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>, można zastąpić to alternatywna metoda, takich jak <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.LastOrDefault%2A?displayProperty=nameWithType>, lub <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>, która zwraca wartość domyślną, zamiast elementu członkowskiego sekwencji.  
  
 Przykłady zawierają dodatkowe szczegóły.  
  
 W poniższym przykładzie użyto <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType> metodę w celu obliczenia średniej sekwencji, których wartości są większe niż 4. Ponieważ żadnej wartości nie z oryginalnego tablicy przekracza 4, wartości nie są uwzględniane w sekwencji, metoda wygeneruje <xref:System.InvalidOperationException> wyjątku.  
  
 [!code-csharp[System.InvalidOperationException#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable1.cs#6)]
 [!code-vb[System.InvalidOperationException#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable1.vb#6)]  
  
 Wyjątek mogą zostać usunięte przez wywołanie metody <xref:System.Linq.Enumerable.Any%2A> metodę, aby określić, czy sekwencja zawiera wszystkie elementy przed wywołaniem metody, która przetwarza sekwencji, jak przedstawiono na poniższym przykładzie.  
  
 [!code-csharp[System.InvalidOperationException#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable2.cs#7)]
 [!code-vb[System.InvalidOperationException#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable2.vb#7)]  
  
 <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> Metoda zwraca pierwszy element w sekwencji lub pierwszym elementem w kolejności, która spełnia określony warunek. Jeśli sekwencja jest pusta, w związku z tym nie ma pierwszy element zgłasza <xref:System.InvalidOperationException> wyjątku.  
  
 W poniższym przykładzie <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> metoda zgłasza <xref:System.InvalidOperationException> wyjątek ponieważ tablicy dbQueryResults nie zawiera elementu większe niż 4.  
  
 [!code-csharp[System.InvalidOperationException#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable3.cs#8)]
 [!code-vb[System.InvalidOperationException#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable3.vb#8)]  
  
 Możesz wywołać <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> zamiast metody <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> aby zwracać określoną lub wartość domyślna. Jeśli metoda nie może znaleźć pierwszego elementu w sekwencji, zwraca wartość domyślną dla tego typu danych.  Wartość domyślna to `null` dla typu odwołania zero dla typu liczbowego i <xref:System.DateTime.MinValue?displayProperty=nameWithType> dla <xref:System.DateTime> typu.  
  
> [!NOTE]
>  Interpretowanie wartość zwrócona przez <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> metoda jest często skomplikowany fakt, że wartość domyślna typu może być prawidłową wartością w sekwencji. W takim przypadku należy wywołanie <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> metodę, aby ustalić, czy sekwencja ma prawidłowe elementy Członkowskie przed wywołaniem <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> metody.  
  
 Następujące przykładowe wywołania <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> metodę, aby zapobiec <xref:System.InvalidOperationException> wyjątek w poprzednim przykładzie.  
  
 [!code-csharp[System.InvalidOperationException#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable4.cs#9)]
 [!code-vb[System.InvalidOperationException#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable4.vb#9)]  
  
<a name="Single"></a>   
### <a name="calling-enumerablesingle-or-enumerablesingleordefault-on-a-sequence-without-one-element"></a>Wywoływanie Enumerable.Single lub Enumerable.SingleOrDefault sekwencji bez jeden element.  
 <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> Metoda zwraca jedynym elementem sekwencji lub jedynym elementem sekwencję, która spełnia określony warunek.    Jeżeli nie ma elementów w sekwencji, lub jeśli istnieje więcej niż jeden element, metoda wygeneruje <xref:System.InvalidOperationException> wyjątku.  
  
 Można użyć <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> metody, aby przywrócić wartość domyślną, zamiast generowania wyjątku, gdy sekwencja nie zawiera żadnych elementów. Jednak <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> metoda nadal zgłasza <xref:System.InvalidOperationException> wyjątku, gdy sekwencja zawiera więcej niż jeden element.  
  
 W poniższej tabeli przedstawiono komunikaty wyjątku z <xref:System.InvalidOperationException> obiekty wyjątków zgłaszanych przez wywołania <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> i <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> metody.  
  
|Metoda|Komunikat|  
|------------|-------------|  
|`Single`|**Sekwencja nie zawiera zgodnego elementu.**|  
|`Single` <br /> `SingleOrDefault`|**Sekwencja zawiera więcej niż jeden zgodny element.**|  
  
 W poniższym przykładzie, wywołanie <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> metoda zgłasza <xref:System.InvalidOperationException> wyjątek ponieważ sekwencja nie ma elementu większe niż 4.  
  
 [!code-csharp[System.InvalidOperationException#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable5.cs#10)]
 [!code-vb[System.InvalidOperationException#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable5.vb#10)]  
  
 Poniższy przykład próbuje zapobiec <xref:System.InvalidOperationException> wyjątek podczas sekwencji jest pusta, wywołując zamiast <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> metody. Jednakże, ponieważ ta sekwencja zwraca wiele elementów, którego wartość jest większa niż 2, również zgłasza <xref:System.InvalidOperationException> wyjątku.  
  
 [!code-csharp[System.InvalidOperationException#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable6.cs#11)]
 [!code-vb[System.InvalidOperationException#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable6.vb#11)]  
  
 Wywoływanie <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> metody zakłada, że sekwencja lub sekwencji, który spełnia określone kryteria zawiera tylko jeden element.  <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> Założono sekwencję z zero lub jeden wynik, ale nie więcej. Jeśli to założenie jest zamierzone jednym ze strony użytkownika, a te warunki nie są spełnione, ponowne generowanie lub przechwytywanie powstałe w ten sposób <xref:System.InvalidOperationException> jest odpowiedni. W przeciwnym razie lub Jeśli przypuszczasz, że niektóre częstotliwość nastąpi nieprawidłowe warunki, należy rozważyć użycie innymi <xref:System.Linq.Enumerable> metody, takie jak <xref:System.Linq.Enumerable.FirstOrDefault%2A> lub <xref:System.Linq.Enumerable.Where%2A>.  
  
<a name="Emit"></a>   
### <a name="dynamic-cross-application-domain-field-access"></a>Dostępu do pola dynamicznej domenie międzyaplikacyjnej  
 <xref:System.Reflection.Emit.OpCodes.Ldflda?displayProperty=nameWithType> Microsoft zgłasza instrukcji języka pośredniego (MSIL) <xref:System.InvalidOperationException> wyjątek, jeśli obiekt zawierający pola, którego próbujesz pobrać adres nie jest w domenie aplikacji, w którym jest wykonywany kodu. Adresu pola można uzyskać tylko z domeny aplikacji, w której znajduje się.  
  
<a name="Throwing"></a>   
## <a name="throwing-an-invalidoperationexception-exception"></a>Zgłaszanie wyjątku InvalidOperationException  
 Powinien zgłosić <xref:System.InvalidOperationException> wyjątek tylko wtedy, gdy stan obiektu z jakiegoś powodu nie obsługuje wywołania określonej metody. Oznacza to, że wywołanie metody jest prawidłowa w niektórych sytuacjach lub kontekstów, ale jest nieprawidłowy w innych.  
  
 W przypadku błędu wywołania metody ze względu na nieprawidłowe argumenty, następnie <xref:System.ArgumentException> lub jednej z jej klas pochodnych <xref:System.ArgumentNullException> lub <xref:System.ArgumentOutOfRangeException>, powinien zostać zgłoszony, zamiast tego.  
  
<a name="Misc"></a>   
## <a name="miscellaneous-information"></a>Dodatkowe informacje  
 <xref:System.InvalidOperationException> używa COR_E_INVALIDOPERATION HRESULT, która ma wartość 0x80131509.  
  
 Aby uzyskać listę początkowe wartości właściwości dla wystąpienia <xref:System.InvalidOperationException>, zobacz <xref:System.InvalidOperationException.%23ctor%2A> konstruktorów.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
    <altmember cref="T:System.Collections.IEnumerator" />
    <altmember cref="T:System.Resources.ResourceSet" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.InvalidOperationException" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.InvalidOperationException" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.Exception.Message%2A> właściwość nowego wystąpienia dostarczony przez system komunikatu, opisem błędu, takie jak "nie można wykonać żądanej operacji." Ten komunikat uwzględnia bieżącą kulturę systemu.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.InvalidOperationException>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Odwołanie o wartości null (`Nothing` w języku Visual Basic).|  
|<xref:System.Exception.Message%2A>|Zlokalizowany ciąg komunikatu o błędzie.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string -&gt; InvalidOperationException" Usage="new System.InvalidOperationException message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat, który opisuje błąd.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.InvalidOperationException" /> klasy z powodu określonego błędu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.Exception.Message%2A?displayProperty=nameWithType> właściwość nowego przy użyciu wyjątek `message` parametru. Zawartość `message` ma na celu rozumiane przez człowieka. Obiekt wywołujący tego konstruktora jest wymagany w celu zagwarantowania, że ten ciąg został zlokalizowany w bieżącej kulturze systemu.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.InvalidOperationException>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Odwołanie o wartości null (`Nothing` w języku Visual Basic).|  
|<xref:System.Exception.Message%2A>|Ciąg komunikatu o błędzie.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InvalidOperationException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InvalidOperationException(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Obiekt zawierający dane serializowanego obiektu.</param>
        <param name="context">Informacje kontekstowe o źródłowego lub miejscu docelowym.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.InvalidOperationException" /> z zserializowanymi danymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływana podczas deserializacji do odtworzenia obiektu wyjątku przesyłanego za pomocą strumienia. Aby uzyskać więcej informacji, zobacz [XML i serializacji SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string * Exception -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat o błędzie wyjaśniający przyczynę wyjątku.</param>
        <param name="innerException">Wyjątek, który jest przyczyną bieżącego wyjątku. Jeśli <c>innerException</c> parametr nie jest odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic), bieżący wyjątek jest zgłaszany w <see langword="catch" /> bloku, który obsługuje wyjątek wewnętrzny.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.InvalidOperationException" /> z określonego komunikatu o błędzie i odwołania do wyjątek wewnętrzny będący przyczyną tego wyjątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyjątek zgłaszany bezpośrednio w wyniku poprzedniego wyjątku powinien zawierać odwołanie do poprzedniego wyjątku we <xref:System.Exception.InnerException%2A> właściwości. <xref:System.Exception.InnerException%2A> Właściwość zwraca tę samą wartość, która została przekazana do konstruktora lub odwołanie o wartości null (`Nothing` w języku Visual Basic) Jeśli <xref:System.Exception.InnerException%2A> właściwości nie dostarcza do konstruktora wartości wyjątku wewnętrznego.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.InvalidOperationException>.  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Odwołanie do wewnętrznego wyjątku.|  
|<xref:System.Exception.Message%2A>|Ciąg komunikatu o błędzie.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="IDisposable" FullName="System.IDisposable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1e6b408b88af2e3e5027106be9c33751cc9e19c3" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34452203" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IDisposable" />
  <TypeSignature Language="VB.NET" Value="Public Interface IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia mechanizm służący do zwalniania niezarządzanych zasobów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podstawowym zastosowaniem tego interfejsu jest, aby zwolnić zasoby niezarządzane. Moduł zbierający elementy bezużyteczne automatycznie zwalnia pamięć przydzielona do zarządzanego obiektu, gdy obiekt jest już używany. Jednak nie jest możliwe do przewidzenia, gdy nastąpi wyrzucanie elementów bezużytecznych. Ponadto moduł garbage collector nie zna niezarządzane zasoby, takie jak dojścia do okna lub Otwórz pliki i strumienie.  
  
 Użyj <xref:System.IDisposable.Dispose%2A> metoda jawnie zwolnić niezarządzane zasoby w połączeniu z modułu zbierającego elementy bezużyteczne w tym interfejsie. Tę metodę można wywołać obiektu konsumenta, gdy obiekt jest już potrzebne.  
  
> [!WARNING]
>  Jest to istotne zmiany, aby dodać <xref:System.IDisposable> interfejs do istniejącej klasy. Ponieważ już istniejących konsumentów tego typu nie można wywołać <xref:System.IDisposable.Dispose%2A>, nie można mieć pewności, zostaną zwolnione niezarządzane zasoby zajmowane przez danego typu.  
  
 Ponieważ <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementacji jest wywoływana przez użytkownika typu zasobów należących do wystąpienia są już potrzebne, albo zawijania obiektu zarządzanego w <xref:System.Runtime.InteropServices.SafeHandle> (zalecaną alternatywą) lub powinny zastępować <xref:System.Object.Finalize%2A?displayProperty=nameWithType>do zwalniania niezarządzanych zasobów, w przypadku, gdy użytkownik zapomni do wywołania <xref:System.IDisposable.Dispose%2A>.  
  
> [!IMPORTANT]
>  W programie .NET Framework kompilatora C++ obsługuje deterministyczne usuwania zasobów i nie zezwala na bezpośrednie implementacja <xref:System.IDisposable.Dispose%2A> metody.  
  
 Szczegółowe omówienie o tym, jak ten interfejs i <xref:System.Object.Finalize%2A?displayProperty=nameWithType> są używane metody, zobacz [wyrzucanie elementów bezużytecznych](~/docs/standard/garbage-collection/index.md) i [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md) tematów.  
  
## <a name="using-an-object-that-implements-idisposable"></a>Przy użyciu obiektu implementującego interfejs IDisposable  
 Jeśli aplikacja korzysta z po prostu obiekt, który implementuje <xref:System.IDisposable> interfejsu, należy wywołać obiektu <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementacji po zakończeniu korzystania z niego. W zależności od języka programowania można to zrobić na dwa sposoby:  
  
-   Przy użyciu języka takich jak utworzyć `using` instrukcji w języku C# i Visual Basic.  
  
-   Zawijania wywołanie <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementacja `try` / `finally` bloku.  
  
> [!NOTE]
>  Dokumentację dla typów, które implementują <xref:System.IDisposable> należy pamiętać, że faktów i dołączyć przypomnienie wywołać jej <xref:System.IDisposable.Dispose%2A> implementacji.  
  
<a name="Using"></a>   
### <a name="the-c-and-visual-basic-using-statement"></a>C# i Visual Basic za pomocą instrukcji  
 Jeśli język obsługuje konstrukcję, takich jak [przy użyciu](~/docs/csharp/language-reference/keywords/using.md) instrukcji w języku C# i [Using](~/docs/visual-basic/language-reference/statements/using-statement.md) instrukcji w języku Visual Basic, służy zamiast jawnie podczas wywoływania <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> samodzielnie. Poniższy przykład korzysta z tej metody, definiując `WordCount` klasy, która zachowuje informacje o pliku i liczbę słów w nim.  
  
 [!code-csharp[System.IDisposable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling1.cs#1)]
 [!code-vb[System.IDisposable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling1.vb#1)]  
  
 `using` Instrukcja jest rzeczywiście udogodnienie składni. W czasie kompilacji, kompilator języka implementuje języku pośrednim (IL) dla `try` / `finally` bloku.  
  
 Aby uzyskać więcej informacji na temat `using` instrukcji, zobacz [instrukcji Using](~/docs/visual-basic/language-reference/statements/using-statement.md) lub [za pomocą instrukcji](~/docs/csharp/language-reference/keywords/using-statement.md) tematów.  
  
### <a name="the-tryfinally-block"></a>Blok Try/Finally  
 Jeśli język programowania nie obsługuje konstrukcji, takich jak `using` instrukcji w języku C# lub Visual Basic, lub jeśli nie chcesz jej użyć, należy wywołać <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementację z `finally` zablokować z `try` / `finally` instrukcji. W poniższym przykładzie `using` blok w poprzednim przykładzie z `try` / `finally` bloku.  
  
 [!code-csharp[System.IDisposable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling2.cs#2)]
 [!code-vb[System.IDisposable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling2.vb#2)]  
  
 Aby uzyskać więcej informacji na temat `try` / `finally` wzorca, zobacz [spróbuj... CATCH... Instrukcji finally](~/docs/visual-basic/language-reference/statements/try-catch-finally-statement.md), [try-finally](~/docs/csharp/language-reference/keywords/try-finally.md), lub [try-finally — instrukcja](http://msdn.microsoft.com/library/514400c1-c322-4bf3-9e48-3047240b8a82).  
  
## <a name="implementing-idisposable"></a>Implementacja interfejsu IDisposable  
 Należy zaimplementować <xref:System.IDisposable> tylko wtedy, gdy bezpośrednio z danym typem używa zasoby niezarządzane. Konsumenci tego typu można wywołać z <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementacji, aby zwolnić zasoby, gdy wystąpienie jest już potrzebne. Do obsługi przypadków, w których się one zakończyć niepowodzeniem do wywołania <xref:System.IDisposable.Dispose%2A>, należy albo użyj klasą pochodną <xref:System.Runtime.InteropServices.SafeHandle> opakowywać niezarządzane zasoby, lub powinny zastępować <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metody dla typu odwołania. W obu przypadkach można użyć <xref:System.IDisposable.Dispose%2A> metodę w celu niezależnie od oczyszczania jest konieczne po użyciu niezarządzane zasoby, takie jak zwalnianie zwalnianiem lub resetowaniem zasobów niezarządzanych.  
  
> [!IMPORTANT]
>  Jeśli definiujesz klasę podstawową używającą zasoby niezarządzane i który ma, albo może mieć podklas, które powinny zostać usunięte, należy zaimplementować <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> — metoda i podaj drugi przeciążenia `Dispose`, zgodnie z opisem w następnej sekcja.  
  
<a name="BaseClasses"></a>   
## <a name="idisposable-and-the-inheritance-hierarchy"></a>Interfejs IDisposable i Hierarchia dziedziczenia  
 Klasa podstawowa z podklas, które powinny być usuwalne musi implementować <xref:System.IDisposable> w następujący sposób. Należy użyć tego wzorca przy każdym zaimplementowaniem <xref:System.IDisposable> na dowolnego typu, który nie jest `sealed` (`NotInheritable` w języku Visual Basic).  
  
-   Powinien zawierać jedno publiczne-virtual <xref:System.IDisposable.Dispose> — metoda i chronione wirtualnego `Dispose(Boolean disposing)` metody.  
  
-   <xref:System.IDisposable.Dispose> Należy wywołać metodę `Dispose(true)` i ma pomijać finalizacji wydajności.  
  
-   Typ podstawowy nie może zawierać żadnych finalizatory.  
  
 Poniższy fragment kodu odzwierciedla wzorzec dispose dla klas podstawowych. Przyjęto założenie, że typu nie przesłania <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metody.  
  
 [!code-csharp[System.IDisposable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
 [!code-vb[System.IDisposable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]  
  
 Jeśli zastąpienie <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metody, klasy należy zaimplementować następującego wzorca.  
  
 [!code-csharp[System.IDisposable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
 [!code-vb[System.IDisposable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]  
  
 Podklasy powinny implementować wzorzec rozporządzający w następujący sposób:  
  
-   Zastępują one musi `Dispose(Boolean)` i Wywołaj klasę bazową `Dispose(Boolean)` implementacji.  
  
-   W razie potrzeby, ich Podaj finalizator. Należy wywołać finalizatora `Dispose(false)`.  
  
 Należy pamiętać, że klas pochodnych się implementuje <xref:System.IDisposable> interfejsu i nie ma bezparametrowego <xref:System.IDisposable.Dispose%2A> metody. Zastępują one tylko klasę podstawową `Dispose(Boolean)` metody.  
  
 Poniższy fragment kodu odzwierciedla wzorzec dispose dla klas pochodnych. Przyjęto założenie, że typu nie przesłania <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metody.  
  
 [!code-csharp[System.IDisposable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
 [!code-vb[System.IDisposable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć klasę zasobu, który implementuje <xref:System.IDisposable> interfejsu.  
  
 [!code-cpp[System.IDisposable.Dispose Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CPP/idisposabledispose.cpp#1)]
 [!code-csharp[System.IDisposable.Dispose Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CS/idisposabledispose.cs#1)]
 [!code-vb[System.IDisposable.Dispose Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/VB/idisposabledispose.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" />
  </Docs>
  <Members>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IDisposable.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Dispose();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wykonuje zadania zdefiniowane przez aplikację skojarzone z uwalnianiem, zwalnianiem lub resetowaniem niezarządzanych zasobów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby zamknąć lub zwolnij niezarządzane zasoby, takie jak pliki, strumieni i uchwytów posiadanych przez wystąpienie klasy, który implementuje ten interfejs. Konwencja, ta metoda jest używana dla wszystkich zadań skojarzonych z zwalnianie zasoby zajmowane przez obiekt lub obiekt do ponownego użycia.  
  
> [!WARNING]
>  Jeśli używasz klasy, która implementuje <xref:System.IDisposable> interfejsu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> implementacji po zakończeniu przy użyciu klasy. Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu implementującego interfejs IDisposable" w <xref:System.IDisposable> tematu.  
  
 Po wdrożeniu tej metody, upewnij się, wszystkie przechowywane się, że zasoby są zwalniane przez propagowanie wywołania przez hierarchię zawierania. Na przykład, jeśli obiekt A przydziela obiektu B, a obiekt B przydziela obiektu C, A następnie <xref:System.IDisposable.Dispose%2A> implementacji należy wywołać <xref:System.IDisposable.Dispose%2A> na B, który z kolei wywołać <xref:System.IDisposable.Dispose%2A> na C.  
  
> [!IMPORTANT]
>  Kompilator języka C++ obsługuje deterministyczne usuwania zasobów i nie zezwala na bezpośrednie implementacja <xref:System.IDisposable.Dispose%2A> metody.  
  
 Obiekt musi także wywołać metodę <xref:System.IDisposable.Dispose%2A> metody swojej klasy podstawowej, jeśli implementuje klasy podstawowej <xref:System.IDisposable>. Aby uzyskać więcej informacji o implementacji <xref:System.IDisposable> klasy podstawowej oraz jego podklas, zobacz sekcję "IDisposable i hierarchii dziedziczenia" w <xref:System.IDisposable> tematu.  
  
 Jeśli obiekt <xref:System.IDisposable.Dispose%2A> metoda jest wywoływana więcej niż raz, obiekt należy zignorować wszystkie wywołania po pierwszym polem. Obiekt nie należy zgłosić wyjątek, jeśli jego <xref:System.IDisposable.Dispose%2A> metoda jest wywoływana wiele razy. Wystąpienie metody inne niż <xref:System.IDisposable.Dispose%2A> może zgłosić <xref:System.ObjectDisposedException> gdy zasoby są już usunięty.  
  
 Użytkownicy mogą wymagać typu zasobu na potrzeby określenia przydzielone stan i stan zwolnionych określonej Konwencji. Na przykład jest strumienia klasy, które są tradycyjnie traktować jako otwarty lub zamknięty. Realizator klasy, która ma takie Konwencję można zaimplementować publiczną metodę o nazwie niestandardowych, takich jak `Close`, że wywołania <xref:System.IDisposable.Dispose%2A> metody.  
  
 Ponieważ <xref:System.IDisposable.Dispose%2A> metoda musi zostać jawnie wywołana, jest zawsze zagrożenia, które nie będą niezarządzane zasoby zwolnione, ponieważ konsumenta obiektu nie powiodło się wywołanie jego <xref:System.IDisposable.Dispose%2A> metody. Istnieją dwa sposoby, aby zapobiec tej sytuacji:  
  
-   Zawijanie zarządzanego zasobu w obiekt pochodzący od <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>. Twoje <xref:System.IDisposable.Dispose%2A> następnie wykonanie wymaga <xref:System.IDisposable.Dispose%2A> metody <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> wystąpień. Aby uzyskać więcej informacji, zobacz sekcję "Alternatywnej SafeHandle" w <xref:System.Object.Finalize%2A?displayProperty=nameWithType> tematu.  
  
-   Implementuje finalizator w celu zwolnienia zasobów podczas <xref:System.IDisposable.Dispose%2A> nie jest wywoływany. Domyślnie moduł zbierający elementy bezużyteczne automatycznie wywołuje finalizatora obiektu przed odzyskiwanie pamięci. Jednak jeśli <xref:System.IDisposable.Dispose%2A> metoda została wywołana, nie jest zazwyczaj konieczne dla modułu zbierającego elementy bezużyteczne wywołać finalizatora usuniętego obiektu. Aby uniknąć automatycznego finalizacji <xref:System.IDisposable.Dispose%2A> implementacje można wywołać <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> metody.  
  
 Jeśli używasz obiektu, który uzyskuje dostęp do zasobów niezarządzanych, takich jak <xref:System.IO.StreamWriter>, dobrym rozwiązaniem jest utworzenie wystąpienia o `using` instrukcji. `using` Instrukcji jest automatycznie zamykany strumienia i wywołania <xref:System.IDisposable.Dispose%2A> obiektu po ukończeniu kod, który jest używany. Na przykład zobacz <xref:System.IO.StreamWriter> klasy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak można zaimplementować <xref:System.IDisposable.Dispose%2A> metody.  
  
 [!code-cpp[System.IDisposable.Dispose Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CPP/idisposabledispose.cpp#1)]
 [!code-csharp[System.IDisposable.Dispose Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CS/idisposabledispose.cs#1)]
 [!code-vb[System.IDisposable.Dispose Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/VB/idisposabledispose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Uri" FullName="System.Uri">
  <Metadata><Meta Name="ms.openlocfilehash" Value="221cff9960f4aa8ce26194360235919ed49bcb9a" /><Meta Name="ms.sourcegitcommit" Value="b0551d7828f015124aca601dbb64bd913cc5067d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="12/13/2018" /><Meta Name="ms.locfileid" Value="53332549" /></Metadata><TypeSignature Language="C#" Value="public class Uri : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Uri extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Uri" />
  <TypeSignature Language="VB.NET" Value="Public Class Uri&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Uri : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Uri = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.UriTypeConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Umożliwia reprezentowanie obiektów za pomocą jednolitych identyfikatorów zasobów (URI) oraz łatwy dostęp do elementów identyfikatorów URI.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator URI jest compact reprezentacja tych zasobów, które są dostępne dla aplikacji w intranecie lub Internecie. <xref:System.Uri> Klasy definiuje właściwości i metody obsługi identyfikatory URI, w tym analizowania, porównywania i łączenia. <xref:System.Uri> Właściwości klas, które są przeznaczone tylko do odczytu; Aby utworzyć obiekt można modyfikować, należy użyć <xref:System.UriBuilder> klasy.  
  
 Względne identyfikatory URI (na przykład, "/ new/index.htm") musi być rozwinięty względem podstawowy identyfikator URI, aby były one bezwzględne. <xref:System.Uri.MakeRelative%2A> Metoda znajduje się przekonwertować bezwzględne identyfikatorów URI względne identyfikatory URI, gdy jest to konieczne.  
  
 <xref:System.Uri> Konstruktory wyprowadza parametry identyfikatora URI, jeśli ciąg jest poprawnie sformułowanym identyfikatorem URI, łącznie z identyfikatorem schematu.  
  
 <xref:System.Uri> Właściwości zwracają reprezentacji danych canonical kodowanie o zmienionym znaczeniu, za pomocą wszystkie znaki z wartości Unicode większych niż 127 zastąpione ich szesnastkowych. Aby wprowadzić identyfikator URI w formie kanonicznej <xref:System.Uri> Konstruktor wykonuje następujące czynności:  
  
-   Konwertuje schemat identyfikatora URI na małe litery.  
  
-   Konwertuje nazwę hosta na małe litery.  
  
-   Jeśli nazwa hosta jest adres IPv6, Kanoniczny adres IPv6 jest używany. Właściwości ScopeId i inne opcjonalne dane IPv6 są usuwane.  
  
-   Usuwa domyślne i numery portów puste.
  
-   Konwertuje ścieżki plików jawne ze schematem file:// ścieżki plików niejawne bez ze schematem file:// (na przykład "C:\my\file").
  
-   Znaki ucieczki przestają być (znany także jako procent, kodowane w oktetach), które nie mają zastrzeżone przeznaczenia są dekodowane (znany także jako trwa o niezmienionym znaczeniu). Obejmuje niezastrzeżone znaki wielkich i łącznik cyfry dziesiętne (30-% 39), małe litery (% 41-% 5A i % 7A 61%) (% 2D), kropki (% 2E), znaku podkreślenia (% 5F), a tylda (% 7E).

-   Canonicalizes ścieżki hierarchicznej identyfikatory URI przez sekwencje kompaktowania takich jak /. /, /... /, a / / (czy sekwencji jest poprzedzone znakiem zmiany znaczenia). Należy pamiętać, że istnieją niektóre schematy, dla których nie skompaktowany jest tych sekwencji.
  
-   Identyfikatory URI hierarchiczne Jeśli host nie ma znacznika kończącego ukośnikiem (/), dodaniu.  
  
-   Domyślnie wszystkie zastrzeżone znaki w identyfikatorze URI są poprzedzone znakiem zmiany znaczenia zgodnie z RFC 2396. Tej zmiany zachowania po włączeniu analizy międzynarodowych identyfikatorach zasobów lub międzynarodową nazwę domeny w których wielkość zastrzeżone znaki w identyfikatorze URI są poprzedzone znakiem zmiany znaczenia zgodnie ze standardem RFC 3986 i RFC 3987.

 Jako część canonicalization w Konstruktorze niektóre schematy, kropka segmenty i pustych segmentów (/. /, /... /, a / /) jest kompaktowana (innymi słowy, zostaną usunięte). Schematy, dla których identyfikator URI kompaktuje tych sekwencji obejmują http, https, tcp, net.pipe i net.tcp. Niektóre systemy nie skompaktowany się tych sekwencji. Oto, jak to kompaktowania wygląda w praktyce.
  
```  
var uri = new Uri("http://myUrl/../.."); // http scheme, unescaped
OR
var uri = new Uri("http://myUrl/%2E%2E/%2E%2E"); // http scheme, escaped
OR
var uri = new Uri("ftp://myUrl/../.."); // ftp scheme, unescaped
OR
var uri = new Uri("ftp://myUrl/%2E%2E/%2E%2E"); // ftp scheme, escaped

Console.WriteLine(uri.AbsoluteUri);  
Console.WriteLine(uri.PathAndQuery);  
```  
  
 Kiedy ten kod jest wykonywany, zwraca następujące dane wyjściowe z sekwencjami ucieczki, o niezmienionym znaczeniu, jeśli to konieczne, a następnie kompaktowana.

```  
http://myUrl/  
/  
```  
  
 Zawartość można przekształcać <xref:System.Uri> klasy z ucieczki zakodowany identyfikator URI odwołania do odczytu odwołanie do identyfikatora URI za pomocą <xref:System.Uri.ToString%2A> metody. Należy zauważyć, że niektóre zastrzeżone znaki mogą nadal być poprzedzone znakiem zmiany znaczenia w danych wyjściowych <xref:System.Uri.ToString%2A> metody. Jest to do obsługi jednoznaczną odbudowy identyfikatora URI z wartością zwróconą przez <xref:System.Uri.ToString%2A>.  
  
 Niektóre identyfikatory URI obejmują identyfikator fragmentu zapytania i/lub. Identyfikator fragmentu jest dowolny tekst, który następuje po znaku numeru (#), nie wliczając znak numeru; tekst fragmentów jest przechowywany w <xref:System.Uri.Fragment%2A> właściwości. Informacje o kwerendzie jest dowolny tekst, który następuje znak zapytania (?) w identyfikatorze URI; Tekst zapytania są przechowywane w <xref:System.Uri.Query%2A> właściwości.  
  
 W .NET Framework w wersji 1.1, jeśli ciąg określony do konstruktora zawiera nieznany schemat i "c:\\", wstawia klasy Uri "/ /" po dwukropku. Na przykład identyfikator URI `xyz:c:\abc` jest konwertowana na `xyz://c:/abc`. W .NET Framework w wersji 2.0, to zachowanie został usunięty, a przykładowy ciąg jest konwertowany na `xyz:c:/abc`.  
  
> [!NOTE]
>  Klasy URI obsługuje adresów IP w notacji zarówno cztery dla protokołu IPv4 i szesnastkowa dwukropkiem dla protokołu IPv6. Pamiętaj, aby ująć adres IPv6 w nawiasach kwadratowych, jak http://[::1].  
  
## <a name="international-resource-identifier-support"></a>Obsługa identyfikatorów zasobów międzynarodowych  
 Adresy sieci Web zwykle są wyrażone za pomocą identyfikatorów URI, które składają się z bardzo ograniczony zestaw znaków:  
  
-   Wielkich i małych liter ASCII litery z alfabetu angielskiego.  
  
-   Cyfry od 0 do 9.  
  
-   Niewielka liczba innych symboli ASCII.  
  
 Specyfikacje dotyczące identyfikatorów URI są opisane w dokumencie RFC 2396, specyfikacji RFC 2732, ze standardem RFC 3986 i 3987 RFC opublikowane przez Internet Engineering Task Force (IETF).  
  
 Rozwój Internetu jest rosnąca potrzeba identyfikacji zasobów, w językach innych niż angielski. Identyfikatory, które ułatwiają te potrzeby i Zezwalaj na znaki spoza zestawu ASCII (liczba znaków w zestawie znaków Unicode/ISO 10646) są znane jako międzynarodowych identyfikatorach zasobów (IRIs). Specyfikacje dotyczące IRIs są opisane w specyfikacji RFC 3987 opublikowane przez grupę IETF. Za pomocą IRIs umożliwia adresu URL zawierała znaki Unicode.  
  
 Istniejące <xref:System.Uri> klasy został rozszerzony w .NET Framework 3.5, 3.0 z dodatkiem SP1 i 2.0 z dodatkiem SP1 w celu zapewnienia obsługi IRI oparte na specyfikacji RFC 3987. Użytkownicy wersji programu .NET Framework w wersji 4.5 starszej niż nie będą widzieć wszelkie zmiany w zachowaniu .NET Framework 2.0, chyba że jawnie włączyć IRI. Dzięki temu zgodność aplikacji z wcześniejszych wersji programu .NET Framework.  
  
 Aby włączyć obsługę IRI, konieczne jest następujące zmiany:  
  
-   Określić, czy analizy Zinternacjonalizowanych nazw domen (IDN) stosowane do nazwy domeny i czy powinny być stosowane IRI podczas analizowania reguły. Można to zrobić *machine.config* lub *app.config* pliku. Na przykład dodaj następujący kod:  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 .NET Framework 4.5 i nowsze przeznaczenie IRI włączone. Podczas analizowania IRI nie można zmienić za pomocą *.config* pliku.  
  
 Włączanie IDN, spowoduje przekonwertowanie wszystkich etykiet Unicode w nazwie domeny na ich odpowiedniki Punycode. Nazwy Punycode zawierać tylko znaki ASCII i zawsze rozpoczynają się prefiksem xn —. Przyczyną tego jest do obsługi istniejących serwerów DNS w Internecie, ponieważ większość serwery DNS obsługują tylko znaki ASCII (zobacz RFC 3940).  
  
 Włączanie IRI i IDN ma wpływ na wartość <xref:System.Uri.DnsSafeHost%2A?displayProperty=nameWithType> właściwości. Włączanie IRI i IDN można również zmienić zachowanie <xref:System.Uri.Equals%2A>, <xref:System.Uri.OriginalString%2A>, <xref:System.Uri.GetComponents%2A>, i <xref:System.Uri.IsWellFormedOriginalString%2A> metody.  
  
 Istnieją trzy możliwe wartości IDN w zależności od serwerów DNS, które są używane:  
  
-   IDN, włączone = All  
  
     Ta wartość spowoduje przekonwertowanie wszystkie nazwy domen, Unicode na ich odpowiedniki Punycode (nazwy IDN).  
  
-   IDN, włączone = AllExceptIntranet  
  
     Ta wartość będzie przekonwertować wszystkie nazwy domeny Unicode nie w lokalnej sieci Intranet w celu użyj odpowiedników Punycode (nazwy IDN). W tym przypadku do obsługi międzynarodowe nazwy w lokalnym intranecie, serwerów DNS, które są używane dla dostępu z intranetu powinien obsługiwać rozpoznawanie nazw Unicode.  
  
-   IDN, włączone = None  
  
     Ta wartość nie zostanie przekonwertować wszystkie nazwy domen Unicode, aby użyć Punycode. Jest to wartość domyślna, która jest zgodna z zachowaniem .NET Framework 2.0.  
  
 Po włączeniu analizy IRI (iriParsing włączone = `true`) normalizacji i sprawdzanie znaków, które są wykonywane zgodnie z najnowsze reguły IRI w dokumencie RFC 3986 i RFC 3987. Po wyłączeniu analizowania IRI normalizacji i sprawdzanie znaków są wykonywane zgodnie z RFC 2396 i specyfikacji RFC 2732 (literały IPv6).  W wersjach programu .NET Framework przed w wersji 4.5, wartość domyślna to `false`. W .NET Framework w wersji 4.5 lub nowszej, wartość domyślna to `true`, i stan włączenia analizy IRI nie można zmodyfikować przez ustawienia w *.config* pliku.  
  
 IRI i IDN, przetwarzanie w <xref:System.Uri> klasy można również sterować przy użyciu <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType>, <xref:System.Configuration.IdnElement?displayProperty=nameWithType>, i <xref:System.Configuration.UriSection?displayProperty=nameWithType> klasy ustawień konfiguracji. <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> Ustawienie włącza lub wyłącza IRI przetwarzanie w <xref:System.Uri> klasy. <xref:System.Configuration.IdnElement?displayProperty=nameWithType> Ustawienie włącza lub wyłącza IDN, przetwarzanie w <xref:System.Uri> klasy. <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> Ustawienie pośrednio kontroluje IDN. Przetwarzanie IRI musi być włączona dla IDN, przetwarzania, aby zawsze jest możliwe. Jeśli przetwarzanie IRI jest wyłączone, ustawienie domyślne, których zachowanie środowiska .NET Framework 2.0 jest używany do zapewnienia zgodności i nazwy IDN nie są używane ustawiony jest IDN przetwarzania.  
  
 Ustawienie konfiguracji dotyczące <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> i <xref:System.Configuration.IdnElement?displayProperty=nameWithType> zostanie odczytany raz podczas pierwszej <xref:System.Uri?displayProperty=nameWithType> klasy. Zmiany ustawień konfiguracji po tym czasie są ignorowane.  
  
 <xref:System.GenericUriParser?displayProperty=nameWithType> Klasy ma również rozszerzone możliwości tworzenia dostosowywalne analizatora składni, która obsługuje IRI i IDN. Zachowanie <xref:System.GenericUriParser?displayProperty=nameWithType> obiektu jest określony przez przekazanie bitowa kombinacja wartości, które są dostępne w <xref:System.GenericUriParserOptions?displayProperty=nameWithType> wyliczeniu, aby <xref:System.GenericUriParser?displayProperty=nameWithType> konstruktora. <xref:System.GenericUriParserOptions.IriParsing?displayProperty=nameWithType> Typ wskazuje parser obsługuje reguły analizy składni określony w RFC 3987 dla międzynarodowych identyfikatorów zasobów (IRI). Czy ma być używana IRI jest zależna od wartości konfiguracji omówionych wcześniej.  
  
 <xref:System.GenericUriParserOptions.Idn?displayProperty=nameWithType> Typ wskazuje parser obsługuje międzynarodowych nazw domen (IDN) podczas analizowania (IDN) nazw hostów. Czy ma być używana IDN jest zależna od wartości konfiguracji omówionych wcześniej.  
  
## <a name="implicit-file-path-support"></a>Obsługa ścieżki plików niejawne
 <xref:System.Uri> również może służyć do reprezentowania ścieżki systemu plików lokalnych. Te ścieżki mogą być reprezentowane *jawnie* identyfikatorów URI, który zaczyna się schematem file:// i *niejawnie* identyfikatorów URI, które nie mają ze schematem file://. W konkretnym przykładzie następujące dwa identyfikatory URI są obie prawidłowe i reprezentują tej samej ścieżki pliku:
```csharp
Uri uri1 = new Uri("C:/test/path/file.txt") // Implicit file path.
Uri uri2 = new Uri("file:///C:/test/path/file.txt") // Explicit file path.
```
 Te ścieżki plików niejawne nie są zgodne ze specyfikacją identyfikatora URI i dlatego należy unikać gdy jest to możliwe. Przy użyciu platformy .NET Core w systemach opartych na systemie Unix, ścieżki plików niejawne może być szczególnie kłopotliwe w sytuacji, ponieważ jest ścieżka bezwzględna do pliku niejawne *nierozróżnialne* ze ścieżką względną. Jeśli występuje takie niejednoznaczności <xref:System.Uri> domyślnie interpretowanie ścieżkę jako bezwzględny identyfikator URI.
  
## <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 Jeśli używasz *Web.config * plik, który zawiera identyfikatory URI w celu zainicjowania czasu aplikacji, dodatkowe wymagane do przetwarzania identyfikatory URI, jeśli ich identyfikatorów schematu są niestandardowe. W takim przypadku zainicjować częściami aplikacji, gdy identyfikatory URI są wymagane, nie o godzinie rozpoczęcia.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Uri> klasy i używa jej do utworzenia <xref:System.Net.WebRequest> wystąpienia.  
  
 [!code-cpp[Classic Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage"><para>Ze względów bezpieczeństwa aplikacji należy zachować ostrożność podczas akceptowania <see cref="T:System.Uri" /> wystąpień ze źródeł niezaufanych i za pomocą <paramref name="dontEscape" /> równa <see langword="true" />. Ciąg identyfikatora URI poprawność można sprawdzić przez wywołanie metody <see cref="M:System.Uri.IsWellFormedOriginalString" /> metody.</para></block>
    <altmember cref="T:System.Configuration.IdnElement" />
    <altmember cref="T:System.Configuration.IriParsingElement" />
    <altmember cref="T:System.Configuration.UriSection" />
    <altmember cref="P:System.Uri.DnsSafeHost" />
    <altmember cref="M:System.Uri.MakeRelative(System.Uri)" />
    <altmember cref="M:System.Uri.IsWellFormedOriginalString" />
    <altmember cref="T:System.UriBuilder" />
    <related type="Article" href="https://msdn.microsoft.com/library/35883fe9-2d09-4d8b-80ca-cf23a941e459">Zmiany w przestrzeni nazw System.Uri w wersji 2.0</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b5e994c3-3535-4aff-8e1b-b69be22e9a22">Obsługa identyfikatorów zasobów międzynarodowych w System.UriSystem.Uri</related>
    <related type="Article" href="~/docs/framework/network-programming/index.md">Programowanie dla sieci w .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Uri" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString);" />
      <MemberSignature Language="F#" Value="new Uri : string -&gt; Uri" Usage="new System.Uri uriString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriString">Ciąg, który identyfikuje zasób może być reprezentowana przez <see cref="T:System.Uri" /> wystąpienia. Należy pamiętać, że adres IPv6 w postaci ciągu muszą być ujęte w nawiasy kwadratowe. Na przykład "http://[2607:f8b0:400d:c06::69]".</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Uri" /> klasy przy użyciu określonego identyfikatora URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy <xref:System.Uri> wystąpienia ciągu identyfikatora URI. Jej analizuje identyfikator URI, umieszcza go w formacie kanonicznym i sprawia, że wszystkie wymagane ucieczki kodowania.  
  
 Ten konstruktor nie upewnij się, że <xref:System.Uri> odwołuje się do zasobem.  
  
 Ten konstruktor założono, że `string` parametr odwołuje się do bezwzględny identyfikator URI i jest równoważne z wywoływaniem <xref:System.Uri.%23ctor%2A> konstruktora z <xref:System.UriKind> równa <xref:System.UriKind.Absolute>. Jeśli `string` parametr przekazany do konstruktora jest względny identyfikator URI, spowoduje zgłoszenie tego konstruktora <xref:System.UriFormatException>.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia o identyfikatorze URI "http://www.contoso.com/".  
  
 [!code-cpp[Classic Uri.Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriString" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.FormatException" />, a zamiast tego.</para>
          </block>
          <paramref name="uriString" /> jest pusty.  
  
—lub— 
Określonym w schemacie <paramref name="uriString" /> nie jest poprawnie sformułowany. Zobacz <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
—lub— 
 <paramref name="uriString" /> zawiera zbyt wiele ukośników.  
  
—lub— 
Hasło określone w <paramref name="uriString" /> jest nieprawidłowy.  
  
—lub— 
Nazwa hosta określona w <paramref name="uriString" /> jest nieprawidłowy.  
  
—lub— 
Nazwa pliku określona w <paramref name="uriString" /> jest nieprawidłowy.  
  
—lub— 
Nazwa użytkownika określona w <paramref name="uriString" /> jest nieprawidłowy.  
  
—lub— 
Nazwa hosta lub urząd, określona w <paramref name="uriString" /> nie może zostać zakończone przez ukośników odwrotnych.  
  
—lub— 
Podany numer portu <paramref name="uriString" /> jest nieprawidłowa lub nie można przeanalizować.  
  
—lub— 
Długość <paramref name="uriString" /> przekracza 65519 znaków.  
  
—lub— 
Długość określonym w schemacie <paramref name="uriString" /> dłuższa niż 1023 znaków.  
  
—lub— 
Ma nieprawidłową sekwencję znaków w <paramref name="uriString" />.  
  
—lub— 
Ścieżka systemu MS-DOS, określona w <paramref name="uriString" /> musi rozpoczynać się od c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Uri (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Uri(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new Uri : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Uri" Usage="new System.Uri (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Wystąpienie <see cref="T:System.Runtime.Serialization.SerializationInfo" /> klasa zawierająca informacje wymagane do serializacji nowej <see cref="T:System.Uri" /> wystąpienia.</param>
        <param name="streamingContext">Wystąpienie <see cref="T:System.Runtime.Serialization.StreamingContext" /> klasa zawierająca źródła strumienia serializacji, skojarzone z nowym <see cref="T:System.Uri" /> wystąpienia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Uri" /> klasy z określonego wystąpienia <see cref="T:System.Runtime.Serialization.SerializationInfo" /> i <see cref="T:System.Runtime.Serialization.StreamingContext" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor implementuje <xref:System.Runtime.Serialization.ISerializable> interfejs na potrzeby <xref:System.Uri> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serializationInfo" /> Parametr zawiera <see langword="null" /> identyfikatora URI.</exception>
        <exception cref="T:System.UriFormatException"><paramref name="serializationInfo" /> Parametr zawiera identyfikator URI, który jest pusty.  
  
—lub— 
Schemat określony jest nieprawidłowo sformułowany. Zobacz <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
—lub— 
Identyfikator URI zawiera zbyt wiele ukośników.  
  
—lub— 
Hasło określone w identyfikatorze URI nie jest prawidłowy.  
  
—lub— 
Nazwa hosta określona w identyfikatorze URI nie jest prawidłowy.  
  
—lub— 
Nazwa pliku określona w identyfikatorze URI nie jest prawidłowy.  
  
—lub— 
Nazwa użytkownika określona w identyfikatorze URI nie jest prawidłowy.  
  
—lub— 
Nazwa hosta lub urząd określona w identyfikatorze URI nie może zostać zakończone przez ukośników odwrotnych.  
  
—lub— 
Numer portu, określona w identyfikatorze URI jest nieprawidłowy lub nie można przeanalizować.  
  
—lub— 
Długość identyfikatora URI przekracza 65519 znaków.  
  
—lub— 
Długość schemat określony w identyfikatorze URI przekracza 1023 znaków.  
  
—lub— 
Ma nieprawidłową sekwencję znaków w identyfikatorze URI.  
  
—lub— 
Ścieżka systemu MS-DOS, określona w identyfikatorze URI musi zaczynać się od c:\\\\.</exception>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Serializacja XML i SOAP</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : string * bool -&gt; Uri" Usage="new System.Uri (uriString, dontEscape)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="uriString">Ciąg, który identyfikuje zasób może być reprezentowana przez <see cref="T:System.Uri" /> wystąpienia. Należy pamiętać, że adres IPv6 w postaci ciągu muszą być ujęte w nawiasy kwadratowe. Na przykład "http://[2607:f8b0:400d:c06::69]".</param>
        <param name="dontEscape"><see langword="true" /> Jeśli <paramref name="uriString" /> jest całkowicie zmienione; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Uri" /> klasy przy użyciu określonego identyfikatora URI z jawną kontrolę znak ucieczki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy <xref:System.Uri> wystąpienia ciągu identyfikatora URI. Ona analizuje identyfikator URI i umieszcza go w formacie kanonicznym.  
  
 `dontEscape` Parametr określa czy zastrzeżone znaki są tłumaczone na sekwencje unikowe. Ten parametr powinien być ustawiony na `true` tylko jeśli masz pewność, że wszystkie zastrzeżone znaki w identyfikatorze URI została zmieniona. Ustawienie wartości `true` dla identyfikatora URI, który nie został całkowicie ucieczki może spowodować nieoczekiwane zachowanie. Zalecane jest zawsze Ustaw ten parametr na `false`.  
  
 Jeśli `dontEscape` ustawiono `false`, konstruktora specjalne znaków zarezerwowanych, sprawdzając wszystkie wystąpienia procentu (%) następuje sekwencja ucieczki prawidłowe. Jeśli sekwencja znaków, po procent nie jest prawidłowy, procent zastępuje % 25.  
  
 Ten konstruktor nie upewnij się, że <xref:System.Uri> odwołuje się do zasobem.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia identyfikatora URI http://www.contoso.com/Hello%20World.htm. Ponieważ zawarte identyfikatora URI jest całkowicie poprzedzone znakiem zmiany znaczenia i są w formie kanonicznej `dontEscape` można ustawić parametru `true`.  
  
 [!code-cpp[Classic Uri.Uri1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriString" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><paramref name="uriString" /> jest pusta lub zawiera tylko spacje.  
  
—lub— 
Określonym w schemacie <paramref name="uriString" /> jest nieprawidłowy.  
  
—lub— 
 <paramref name="uriString" /> zawiera zbyt wiele ukośników.  
  
—lub— 
Hasło określone w <paramref name="uriString" /> jest nieprawidłowy.  
  
—lub— 
Nazwa hosta określona w <paramref name="uriString" /> jest nieprawidłowy.  
  
—lub— 
Nazwa pliku określona w <paramref name="uriString" /> jest nieprawidłowy.  
  
—lub— 
Nazwa użytkownika określona w <paramref name="uriString" /> jest nieprawidłowy.  
  
—lub— 
Nazwa hosta lub urząd, określona w <paramref name="uriString" /> nie może zostać zakończone przez ukośników odwrotnych.  
  
—lub— 
Podany numer portu <paramref name="uriString" /> jest nieprawidłowa lub nie można przeanalizować.  
  
—lub— 
Długość <paramref name="uriString" /> przekracza 65519 znaków.  
  
—lub— 
Długość określonym w schemacie <paramref name="uriString" /> dłuższa niż 1023 znaków.  
  
—lub— 
Ma nieprawidłową sekwencję znaków w <paramref name="uriString" />.  
  
—lub— 
Ścieżka systemu MS-DOS, określona w <paramref name="uriString" /> musi rozpoczynać się od c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="new Uri : string * UriKind -&gt; Uri" Usage="new System.Uri (uriString, uriKind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">Ciąg, który identyfikuje zasób może być reprezentowana przez <see cref="T:System.Uri" /> wystąpienia. Należy pamiętać, że adres IPv6 w postaci ciągu muszą być ujęte w nawiasy kwadratowe. Na przykład "http://[2607:f8b0:400d:c06::69]".</param>
        <param name="uriKind">Określa, czy ciąg identyfikatora URI jest względny identyfikator URI bezwzględnym identyfikatorem URI jest nieokreślony.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Uri" /> klasy przy użyciu określonego identyfikatora URI. Ten konstruktor pozwala określić ciąg identyfikatora URI jest względny identyfikator URI bezwzględny identyfikator URI, czy jest nieokreślony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory URI względnych i bezwzględnych mieć różnych ograniczeń na ich format. Na przykład względnym identyfikatorem URI nie wymaga schematu lub urzędu. Wartość określona w `uriKind` musi odpowiadać typowi URI przekazanej `uriString`. Jednak jeśli <xref:System.UriKind.RelativeOrAbsolute> określono ciąg identyfikatora URI może być względna lub bezwzględna.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="uriKind" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="uriString" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.FormatException" />, a zamiast tego.</para>
          </block>
          <paramref name="uriString" /> zawiera względny identyfikator URI i <paramref name="uriKind" /> jest <see cref="F:System.UriKind.Absolute" />.  
  
lub 
 <paramref name="uriString" /> zawiera bezwzględny identyfikator URI i <paramref name="uriKind" /> jest <see cref="F:System.UriKind.Relative" />.  
  
lub 
 <paramref name="uriString" /> jest pusty.  
  
—lub— 
Określonym w schemacie <paramref name="uriString" /> nie jest poprawnie sformułowany. Zobacz <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
—lub— 
 <paramref name="uriString" /> zawiera zbyt wiele ukośników.  
  
—lub— 
Hasło określone w <paramref name="uriString" /> jest nieprawidłowy.  
  
—lub— 
Nazwa hosta określona w <paramref name="uriString" /> jest nieprawidłowy.  
  
—lub— 
Nazwa pliku określona w <paramref name="uriString" /> jest nieprawidłowy.  
  
—lub— 
Nazwa użytkownika określona w <paramref name="uriString" /> jest nieprawidłowy.  
  
—lub— 
Nazwa hosta lub urząd, określona w <paramref name="uriString" /> nie może zostać zakończone przez ukośników odwrotnych.  
  
—lub— 
Podany numer portu <paramref name="uriString" /> jest nieprawidłowa lub nie można przeanalizować.  
  
—lub— 
Długość <paramref name="uriString" /> przekracza 65519 znaków.  
  
—lub— 
Długość określonym w schemacie <paramref name="uriString" /> dłuższa niż 1023 znaków.  
  
—lub— 
Ma nieprawidłową sekwencję znaków w <paramref name="uriString" />.  
  
—lub— 
Ścieżka systemu MS-DOS, określona w <paramref name="uriString" /> musi rozpoczynać się od c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseUri">Podstawowy identyfikator URI.</param>
        <param name="relativeUri">Względny identyfikator URI do dodania do podstawowego identyfikatora URI.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Uri" /> klasy na podstawie określonej podstawowy identyfikator URI i ciągu względną identyfikatora URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy <xref:System.Uri> wystąpienia, łącząc `baseUri` i `relativeUri`. Jeśli `relativeUri` jest bezwzględny identyfikator URI (zawierający schemat, nazwę hosta i, opcjonalnie, numer portu), <xref:System.Uri> tworzone jest wystąpienie przy użyciu tylko `relativeUri`.  
 
 Jeśli `baseUri` składa się z części względnych (takich jak `/api`), względna muszą być zakończone znakiem ukośnika, a następnie (takich jak `/api/`), jeśli względna `baseUri` mają być zachowane w stworzonego elementu <xref:System.Uri>. 

 Ponadto jeśli `relativeUri` rozpoczyna się od ukośnika, a następnie zastąpić dowolną względną część `baseUri`

 Ten konstruktor nie upewnij się, że <xref:System.Uri> odwołuje się do zasobem.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowe wystąpienie klasy <xref:System.Uri> klasy, łącząc względne identyfikatory URI http://www.contoso.com i catalog/shownew.htm w celu utworzenia bezwzględnym identyfikatorem URI http://www.contoso.com/catalog/shownew.htm.  
  
 [!code-cpp[Classic Uri.Uri3 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri3 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseUri" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="baseUri" /> nie jest ścieżką bezwzględną <see cref="T:System.Uri" /> wystąpienia.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.FormatException" />, a zamiast tego.</para>
          </block>
Identyfikator URI utworzony przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest pusta lub zawiera tylko spacje.  
  
—lub— 
Schemat określony w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  
  
—lub— 
Identyfikator URI utworzony przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> zawiera zbyt wiele ukośników.  
  
—lub— 
Hasło określone w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  
  
—lub— 
Nazwa hosta określona w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  
  
—lub— 
Nazwa pliku określona w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  
  
—lub— 
Nazwa użytkownika określona w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  
  
—lub— 
Nazwa hosta lub urząd określona w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> nie może zostać zakończone przez ukośników odwrotnych.  
  
—lub— 
Numer portu, określona w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowa lub nie można przeanalizować.  
  
—lub— 
Długość identyfikatora URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> przekracza 65519 znaków.  
  
—lub— 
Długość schemat określony w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> dłuższa niż 1023 znaków.  
  
—lub— 
Ma nieprawidłową sekwencję znaków w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" />.  
  
—lub— 
Ścieżka systemu MS-DOS, określona w <paramref name="uriString" /> musi rozpoczynać się od c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, Uri relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, class System.Uri relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, Uri ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * Uri -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="baseUri">Bezwzględna <see cref="T:System.Uri" /> czyli podstawa nowego <see cref="T:System.Uri" /> wystąpienia.</param>
        <param name="relativeUri">Względna <see cref="T:System.Uri" /> wystąpienia, który jest połączony z <paramref name="baseUri" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Uri" /> klasy oparte na kombinacji określonej podstawie <see cref="T:System.Uri" /> wystąpienie i względna <see cref="T:System.Uri" /> wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nową <xref:System.Uri> wystąpienia, łącząc bezwzględnym <xref:System.Uri> wypadku `baseUri`, za pomocą względna <xref:System.Uri> wystąpienia `relativeUri`. Jeśli `relativeUri` jest ścieżką bezwzględną <xref:System.Uri> wystąpienia (zawierający schemat, nazwę hosta i, opcjonalnie, numer portu), <xref:System.Uri> tworzone jest wystąpienie przy użyciu tylko `relativeUri`.  
 
 Jeśli `baseUri` składa się z części względnych (takich jak `/api`), względna muszą być zakończone znakiem ukośnika, a następnie (takich jak `/api/`), jeśli względna `baseUri` mają być zachowane w stworzonego elementu <xref:System.Uri>. 

 Ponadto jeśli `relativeUri` rozpoczyna się od ukośnika, a następnie zastąpić dowolną względną część `baseUri`
 
 Ten konstruktor nie upewnij się, że <xref:System.Uri> odwołuje się do zasobem.  
  
   
  
## Examples  
 W tym przykładzie tworzy bezwzględnym <xref:System.Uri> wypadku `absoluteUri`i względna <xref:System.Uri> wypadku `relativeUri`. Nowy <xref:System.Uri> wypadku `combinedUri`, zostanie utworzony z tych dwóch wystąpień.  
  
 [!code-cpp[NCLUriEnhancements#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#2)]
 [!code-csharp[NCLUriEnhancements#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#2)]
 [!code-vb[NCLUriEnhancements#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="baseUri" /> nie jest ścieżką bezwzględną <see cref="T:System.Uri" /> wystąpienia.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseUri" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="baseUri" /> nie jest ścieżką bezwzględną <see cref="T:System.Uri" /> wystąpienia.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.FormatException" />, a zamiast tego.</para>
          </block>
Identyfikator URI utworzony przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest pusta lub zawiera tylko spacje.  
  
—lub— 
Schemat określony w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  
  
—lub— 
Identyfikator URI utworzony przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> zawiera zbyt wiele ukośników.  
  
—lub— 
Hasło określone w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  
  
—lub— 
Nazwa hosta określona w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  
  
—lub— 
Nazwa pliku określona w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  
  
—lub— 
Nazwa użytkownika określona w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  
  
—lub— 
Nazwa hosta lub urząd określona w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> nie może zostać zakończone przez ukośników odwrotnych.  
  
—lub— 
Numer portu, określona w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowa lub nie można przeanalizować.  
  
—lub— 
Długość identyfikatora URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> przekracza 65519 znaków.  
  
—lub— 
Długość schemat określony w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> dłuższa niż 1023 znaków.  
  
—lub— 
Ma nieprawidłową sekwencję znaków w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" />.  
  
—lub— 
Ścieżka systemu MS-DOS, określona w <paramref name="uriString" /> musi rozpoczynać się od c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string * bool -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri, dontEscape)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="baseUri">Podstawowy identyfikator URI.</param>
        <param name="relativeUri">Względny identyfikator URI do dodania do podstawowego identyfikatora URI.</param>
        <param name="dontEscape"><see langword="true" /> Jeśli <paramref name="uriString" /> jest całkowicie zmienione; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Uri" /> klasy oparte na określony podstawowy i względne identyfikatory URI, z jawną kontrolę znak ucieczki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy <xref:System.Uri> wystąpienia, łącząc `baseUri` i `relativeUri`. Jeśli identyfikator URI przekazywany w `relativeUri` jest bezwzględny identyfikator URI (zawierający schemat, nazwę hosta i, opcjonalnie, numer portu), <xref:System.Uri> tworzone jest wystąpienie przy użyciu tylko `relativeUri`.  
  
 `dontEscape` Parametr określa czy zastrzeżone znaki są tłumaczone na sekwencje unikowe. Ten parametr powinien być ustawiony na `true` tylko jeśli masz pewność, że wszystkie zastrzeżone znaki w identyfikatorze URI została zmieniona. Ustawienie wartości `true` dla identyfikatora URI, który nie został całkowicie ucieczki może spowodować nieoczekiwane zachowanie. Zalecane jest zawsze Ustaw ten parametr na `false`. Jeśli `dontEscape` ustawiono `false`, konstruktora specjalne znaków zarezerwowanych, sprawdzając wszystkie wystąpienia procentu (%) następuje sekwencja ucieczki prawidłowe. Jeśli sekwencja znaków, po procent nie jest prawidłowy, procent zastępuje % 25.  
  
 Ten konstruktor nie upewnij się, że <xref:System.Uri> odwołuje się do zasobem.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowe wystąpienie klasy <xref:System.Uri> klasy, łącząc względne identyfikatory URI http://www.contoso.com i Hello%20World.htm w celu utworzenia bezwzględnym identyfikatorem URI.  
  
 [!code-cpp[Classic Uri.Uri4 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri4 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseUri" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="baseUri" /> nie jest ścieżką bezwzględną <see cref="T:System.Uri" /> wystąpienia.</exception>
        <exception cref="T:System.UriFormatException">Identyfikator URI utworzony przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest pusta lub zawiera tylko spacje.  
  
—lub— 
Schemat określony w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  
  
—lub— 
Identyfikator URI utworzony przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> zawiera zbyt wiele ukośników.  
  
—lub— 
Hasło określone w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  
  
—lub— 
Nazwa hosta określona w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  
  
—lub— 
Nazwa pliku określona w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  
  
—lub— 
Nazwa użytkownika określona w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  
  
—lub— 
Nazwa hosta lub urząd określona w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> nie może zostać zakończone przez ukośników odwrotnych.  
  
—lub— 
Numer portu, określona w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowa lub nie można przeanalizować.  
  
—lub— 
Długość identyfikatora URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> przekracza 65519 znaków.  
  
—lub— 
Długość schemat określony w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" /> dłuższa niż 1023 znaków.  
  
—lub— 
Ma nieprawidłową sekwencję znaków w identyfikatorze URI sformułowany, łącząc <paramref name="baseUri" /> i <paramref name="relativeUri" />.  
  
—lub— 
Ścieżka systemu MS-DOS, określona w <paramref name="uriString" /> musi rozpoczynać się od c:\\\\.</exception>
        <block subset="none" type="usage"><para>Ze względów bezpieczeństwa aplikacji nie powinien wywoływać tego konstruktora z ciągami URI ze źródeł niezaufanych i za pomocą <paramref name="dontEscape" /> równa <see langword="true" />. Alternatywnie można sprawdzić ciąg identyfikatora URI dla ważności przez wywołanie metody <see cref="M:System.Uri.IsWellFormedOriginalString" /> metoda przed wywołaniem tego konstruktora.</para></block>
      </Docs>
    </Member>
    <Member MemberName="AbsolutePath">
      <MemberSignature Language="C#" Value="public string AbsolutePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsolutePath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsolutePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsolutePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsolutePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsolutePath : string" Usage="System.Uri.AbsolutePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę bezwzględny identyfikator URI.</summary>
        <value>Element <see cref="T:System.String" /> zawierający ścieżkę bezwzględną do zasobu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.AbsolutePath%2A> Właściwość zawiera informacje o ścieżce, używany do rozpoznawania żądań, aby uzyskać informacje na serwerze. Zazwyczaj jest to ścieżka do żądanego informacji w systemie plików serwera, mimo że jest on również określać aplikację lub skrypt, który na serwerze musi działać o podanie informacji.  
  
 Informacje o ścieżce nie zawiera schemat, nazwę hosta lub część zapytania identyfikatora URI.  
  
   
  
## Examples  
 Poniższy przykład zapisuje /catalog/shownew.htm ścieżki do konsoli.  
  
 [!code-cpp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsolutePath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="AbsoluteUri">
      <MemberSignature Language="C#" Value="public string AbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsoluteUri As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsoluteUri { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsoluteUri : string" Usage="System.Uri.AbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bezwzględnym identyfikatorem URI.</summary>
        <value>Element <see cref="T:System.String" /> zawierający całego identyfikatora URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.AbsoluteUri%2A> Właściwość zawiera całego identyfikatora URI, przechowywane w <xref:System.Uri> wystąpienia, w tym wszystkich fragmentów i ciągi zapytań.  
  
   
  
## Examples  
 Poniższy przykład zapisuje Pełna zawartość <xref:System.Uri> wystąpienia do konsoli. W przykładzie pokazano http://www.contoso.com/catalog/shownew.htm?date=today jest wyświetlony w konsoli.  
  
 [!code-cpp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Authority">
      <MemberSignature Language="C#" Value="public string Authority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Authority" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Authority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authority As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Authority { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Authority : string" Usage="System.Uri.Authority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę hosta systemu nazw domen (DNS, Domain Name System) lub adres IP i numer portu serwera.</summary>
        <value>Element <see cref="T:System.String" /> zawierający składnika wystawcy identyfikatora URI, reprezentowane przez to wystąpienie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Authority%2A> Właściwość jest zwykle nazwy hosta DNS serwera lub adres IP. Ta właściwość może zawierać numer portu usługi, jeśli jest inny niż domyślny port dla identyfikatora URI. Jeśli <xref:System.Uri.Authority%2A> składnik zawiera zastrzeżone znaki, te są poprzedzone znakiem zmiany znaczenia w wartości ciągu zwracane przez tę właściwość.  
  
   
  
## Examples  
 Poniższy przykład zapisuje nazwę hosta (www.contoso.com) i numer portu (8080) serwera do konsoli.  
  
 [!code-cpp[Classic Uri.Authority Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Authority Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Authority Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Authority Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Authority Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Authority Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Canonicalize">
      <MemberSignature Language="C#" Value="protected virtual void Canonicalize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Canonicalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Canonicalize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Canonicalize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Canonicalize();" />
      <MemberSignature Language="F#" Value="abstract member Canonicalize : unit -&gt; unit&#xA;override this.Canonicalize : unit -&gt; unit" Usage="uri.Canonicalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wewnętrznie przechowywany identyfikator URI w formie kanonicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Canonical wersję identyfikatora URI są przechowywane wewnętrznie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta metoda jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
        <exception cref="T:System.UriFormatException">Identyfikator URI jest niepoprawnie sformułowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="CheckHostName">
      <MemberSignature Language="C#" Value="public static UriHostNameType CheckHostName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UriHostNameType CheckHostName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckHostName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckHostName (name As String) As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UriHostNameType CheckHostName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member CheckHostName : string -&gt; UriHostNameType" Usage="System.Uri.CheckHostName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa hosta do sprawdzania poprawności. Może to być adres IPv4 lub IPv6 lub nazwy hosta w Internecie.</param>
        <summary>Określa, czy określona nazwa hosta jest prawidłową nazwą DNS.</summary>
        <returns>A <see cref="T:System.UriHostNameType" /> oznacza typ nazwy hosta. Jeśli nie można określić typu nazwy hosta lub nazwa hosta jest <see langword="null" /> lub ciągiem o zerowej długości, Metoda ta zwraca <see cref="F:System.UriHostNameType.Unknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.CheckHostName%2A> Metoda sprawdza, czy nazwa hosta podana spełnia wymagania dotyczące prawidłową nazwę hosta dla Internet. Nie, jednak są wykonywane jest wyszukiwanie nazwy hosta w celu sprawdzenia istnienia hosta.  
  
   
  
## Examples  
 Poniższy przykład sprawdza, czy nazwa hosta jest prawidłowa.  
  
 [!code-cpp[Classic Uri.CheckHostName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.CheckHostName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.CheckHostName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSchemeName">
      <MemberSignature Language="C#" Value="public static bool CheckSchemeName (string schemeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CheckSchemeName(string schemeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSchemeName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckSchemeName (schemeName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CheckSchemeName(System::String ^ schemeName);" />
      <MemberSignature Language="F#" Value="static member CheckSchemeName : string -&gt; bool" Usage="System.Uri.CheckSchemeName schemeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="schemeName">Nazwa schematu do sprawdzania poprawności.</param>
        <summary>Określa, czy nazwa określony schemat jest nieprawidłowy.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, która jest <see langword="true" /> Jeśli nazwa schematu jest prawidłowy; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza nazwę schematu dla ważności, zgodnie z RFC 2396 domyślnie. Jeśli międzynarodowych identyfikatorach zasobów (IRIs) lub analizy Zinternacjonalizowanych nazw domen (IDN) jest włączona, ta metoda sprawdza nazwę schematu dla ważności, zgodnie ze standardem RFC 3986. Nazwa schematu musi rozpoczynać się od litery i może zawierać tylko litery, cyfry i znaki ".", "+" lub "-".  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję Spostrzeżenia, aby <xref:System.Uri> klasy.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i sprawdza, czy nazwa schematu jest nieprawidłowa.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSecurity">
      <MemberSignature Language="C#" Value="protected virtual void CheckSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CheckSecurity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSecurity" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CheckSecurity ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CheckSecurity();" />
      <MemberSignature Language="F#" Value="abstract member CheckSecurity : unit -&gt; unit&#xA;override this.CheckSecurity : unit -&gt; unit" Usage="uri.CheckSecurity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywołanie tej metody nie ma znaczenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(class System.Uri uri1, class System.Uri uri2, valuetype System.UriComponents partsToCompare, valuetype System.UriFormat compareFormat, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Compare(System.Uri,System.Uri,System.UriComponents,System.UriFormat,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (uri1 As Uri, uri2 As Uri, partsToCompare As UriComponents, compareFormat As UriFormat, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(Uri ^ uri1, Uri ^ uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : Uri * Uri * UriComponents * UriFormat * StringComparison -&gt; int" Usage="System.Uri.Compare (uri1, uri2, partsToCompare, compareFormat, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
        <Parameter Name="partsToCompare" Type="System.UriComponents" />
        <Parameter Name="compareFormat" Type="System.UriFormat" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="uri1">Pierwszy <see cref="T:System.Uri" />.</param>
        <param name="uri2">Drugi <see cref="T:System.Uri" />.</param>
        <param name="partsToCompare">Bitowa kombinacja <see cref="T:System.UriComponents" /> wartości, które określa części <paramref name="uri1" /> i <paramref name="uri2" /> do porównania.</param>
        <param name="compareFormat">Jedną z <see cref="T:System.UriFormat" /> wartości, które określa znak ucieczki używany, gdy składniki identyfikatora URI są porównywane.</param>
        <param name="comparisonType">Jedną z <see cref="T:System.StringComparison" /> wartości.</param>
        <summary>Porównuje określonej części dwa identyfikatory URI, za pomocą reguł porównywania określonej.</summary>
        <returns><see cref="T:System.Int32" /> Wartość, która wskazuje relację między porównany z certyfikatami <see cref="T:System.Uri" /> składników.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Znaczenie 
 </description></listheader><item><term> Mniej niż zero 
 </term><description><paramref name="uri1" /> jest mniejsza niż <paramref name="uri2" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="uri1" /> równa się <paramref name="uri2" />.  
  
 </description></item><item><term> Większe od zera 
 </term><description><paramref name="uri1" /> jest większa niż <paramref name="uri2" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli oba `uri1` i `uri2` są `null`, ta metoda zwraca wartość 0. Podczas porównywania wartości identyfikatora URI, względny identyfikator URI jest zawsze mniejsza niż bezwzględny identyfikator URI i innych niż null identyfikatora URI jest zawsze większa niż wartość null identyfikatora URI. W przypadkach, gdzie oba `uri1` i `uri2` nie są `null` i oba są względne identyfikatory URI lub obu bezwzględne identyfikatorów URI <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> metoda wykonuje porównanie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> nie jest prawidłowym <see cref="T:System.StringComparison" /> wartość.</exception>
      </Docs>
    </Member>
    <Member MemberName="DnsSafeHost">
      <MemberSignature Language="C#" Value="public string DnsSafeHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DnsSafeHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.DnsSafeHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DnsSafeHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DnsSafeHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DnsSafeHost : string" Usage="System.Uri.DnsSafeHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę hosta na który, po trwa do o niezmienionym, jeśli to konieczne, znaczeniu bezpiecznym rozwiązaniem jest użycie dla rozpoznawania nazw DNS.</summary>
        <value>Element <see cref="T:System.String" /> zawierający hosta część identyfikatora URI w formacie odpowiednim do rozpoznawania nazw DNS; lub oryginalny ciąg hosta, jeśli jest odpowiednia dla rozwiązania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla adresów IPv6, nawiasy kwadratowe ([]) są usuwane i <xref:System.Net.IPAddress.ScopeId%2A> właściwość jest ustawiona, jeśli został on określony, jeśli został zbudowany tego wystąpienia.

Jeśli używano ciągiem o zmienionym znaczeniu w celu utworzenia tego wystąpienia (na przykład "http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), następnie DnsSafeHost zwraca ciąg o zmienionym znaczeniu. Unescape dowolny ciąg o zmienionym znaczeniu zwróciło `DnsSafeHost` przed rozpoczęciem korzystania z tego ciągu do rozpoznawania nazw DNS (Zobacz przykład). Jeśli używano nieprawidłowy ciąg o niezmienionym znaczeniu w celu utworzenia tego wystąpienia (na przykład "http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm"), następnie DnsSafeHost zwraca ciąg o niezmienionym znaczeniu.
  
 <xref:System.Uri.DnsSafeHost%2A> Właściwości jest zależne od ustawień konfiguracji, zgodnie z opisem w dalszej części tego tematu. Nie można zmienić ustawień konfiguracji przez aplikacje Windows Store, co może prowadzić do niespójnych wyników, korzystając z <xref:System.Uri.DnsSafeHost%2A>. <xref:System.Uri.IdnHost%2A> Właściwość została podana jako preferowana alternatywa dla przy użyciu <xref:System.Uri.DnsSafeHost%2A>, ponieważ <xref:System.Uri.IdnHost%2A> jest gwarantowane, zawsze można bezpieczne, niezależnie od tego, jakie bieżącego DNS *app.config* ustawienia mogą być.  
  
 <xref:System.Uri.DnsSafeHost%2A> Właściwość została rozszerzona w .NET Framework 3.5, 3.0 z dodatkiem SP1 i 2.0 z dodatkiem SP1, aby zapewnić międzynarodowych identyfikatorów zasobów (IRI) obsługuje na podstawie specyfikacji RFC 3987. Bieżąca liczba użytkowników nie będą widzieć wszelkie zmiany w zachowaniu .NET Framework 2.0, chyba że jawnie włączyć IRI. Dzięki temu zgodność aplikacji z wcześniejszych wersji programu .NET Framework.  
  
 Aby włączyć obsługę IRI, wymagane są następujące dwie zmiany:  
  
1.  Dodaj następujący wiersz do *machine.config* pliku w katalogu .NET Framework 2.0  
  
     \<section name="uri" type="System.Configuration.UriSection, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />  
  
2.  Określić, czy analizy Zinternacjonalizowanych nazw domen (IDN) stosowane do nazwy domeny i czy powinny być stosowane IRI podczas analizowania reguły. Można to zrobić *machine.config* lub *app.config* pliku. Na przykład dodaj następujący kod:  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 Włączanie IDN, spowoduje przekonwertowanie wszystkich etykiet Unicode w nazwie domeny na ich odpowiedniki Punycode. Nazwy Punycode zawierać tylko znaki ASCII i zawsze rozpoczynają się prefiksem xn —. Przyczyną tego jest do obsługi istniejących serwerów DNS w Internecie, ponieważ większość serwery DNS obsługują tylko znaki ASCII (zobacz RFC 3940).  
  
 Włączanie IDN ma wpływ tylko na wartość <xref:System.Uri.DnsSafeHost%2A> właściwości.  
  
 Istnieją trzy możliwe wartości IDN w zależności od serwerów DNS, które są używane:  
  
-   IDN, włączone = All  
  
     Ta wartość spowoduje przekonwertowanie wszystkie nazwy domen, Unicode na ich odpowiedniki Punycode (nazwy IDN).  
  
-   IDN, włączone = AllExceptIntranet  
  
     Ta wartość spowoduje przekonwertowanie wszystkich zewnętrznych Unicode nazw domen i użyj odpowiedników Punycode (nazwy IDN). W tym przypadku do obsługi międzynarodowe nazwy w lokalnym intranecie, serwerów DNS, które są używane dla dostępu z intranetu powinien obsługiwać nazwy Unicode.  
  
-   IDN, włączone = None  
  
     Ta wartość nie zostanie przekonwertować wszystkie nazwy domen Unicode, aby użyć Punycode. Jest to wartość domyślna, która jest zgodna z zachowaniem .NET Framework 2.0.  
  
 Włączanie analizy IRI (iriParsing włączone = `true`) będziesz robić normalizacji i znak sprawdzanie zgodnie z IRI najnowsze reguły w dokumencie RFC 3987. Wartość domyślna to `false` będzie czy normalizacji i znak sprawdzanie zgodnie z RFC 2396 i specyfikacji RFC 2732 (dla literałów IPv6).  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję Spostrzeżenia, aby <xref:System.Uri> klasy.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia ciągu. Przykład ilustruje różnicę między wartością zwróconą z <xref:System.Uri.Host%2A>, która zwraca nazwę hosta lub adres określony w identyfikatorze URI i wartość zwracana z <xref:System.Uri.DnsSafeHost%2A>, która zwraca adres który jest bezpiecznym rozwiązaniem jest użycie w rozpoznawania nazw DNS.  
  
 [!code-cpp[NCLUriEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#4)]
 [!code-csharp[NCLUriEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#4)]
 [!code-vb[NCLUriEnhancements#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#4)]  

 Jak wyjaśniono w uwagi, unescape nazwę hosta, przed jego rozwiązaniem. Możesz użyć <xref:System.Uri.UnescapeDataString%2A> metody unescape nazwę hosta, na które może rozwiązać ten problem, wywołanie <xref:System.Net.Dns.GetHostEntry%2A> metody.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uri.Equals comparand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand"><see cref="T:System.Uri" /> Wystąpienia lub identyfikator URI do porównania z bieżącym wystąpieniem.</param>
        <summary>Porównuje dwa <see cref="T:System.Uri" /> wystąpienia pod kątem równości.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, która jest <see langword="true" /> Jeśli dwa wystąpienia reprezentują tego samego identyfikatora URI; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Equals%2A> Metoda porównuje dwa wystąpienia, bez względu na informacje o użytkowniku (<xref:System.Uri.UserInfo%2A>) i fragment (<xref:System.Uri.Fragment%2A>) części, które mogą zawierać. Na przykład, biorąc pod uwagę identyfikatory URI http://www.contoso.com/index.htm#search i http://user:password@www.contoso.com/index.htm, <xref:System.Uri.Equals%2A> zwróci metoda `true`.  
  
 Jeśli taki <xref:System.Uri> wystąpienie jest tworzone z nazwą hosta Unicode i `comparand` parametr zawiera <xref:System.Uri> wystąpienie lub identyfikator, który został utworzony z nazwą hosta, następnie mającego nazwę hosta Punycode równoważne <xref:System.Uri.Equals%2A> zwraca `true` tylko wtedy, gdy obsługa międzynarodowych identyfikatorów zasobów (IRI) i międzynarodowych nazw domen (IDN) są włączone. Nazwy Punycode zawierać tylko znaki ASCII i zawsze rozpoczynają się prefiksem xn —.  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję Spostrzeżenia, aby <xref:System.Uri> klasy.  
  
> [!NOTE]
>  W .NET Framework w wersji 1.0 i 1.1 <xref:System.Uri.Query%2A> również jest ignorowana.  
  
> [!NOTE]
>  <xref:System.Uri.Equals%2A> Metoda może zostać przesłonięta w pochodnej klasie; zamierzających można modyfikować metody należy zachować ostrożność. Nie należy używać tej metody do sprawdzania zabezpieczeń, jeśli nie masz pewności, że to wystąpienie pochodzi z zaufanego źródła.  
  
   
  
## Examples  
 W tym przykładzie tworzy dwa <xref:System.Uri> wystąpień z ciągów i porównuje je, aby ustalić, czy stanowią one tę samą wartość. `address1` i `address2` są takie same, ponieważ <xref:System.Uri.Fragment%2A> część jest ignorowany dla tego porównania. Wynik jest zapisywany do konsoli.  
  
 [!code-cpp[NCLUriExamples#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#8)]
 [!code-csharp[NCLUriExamples#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#8)]
 [!code-vb[NCLUriExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#8)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby zapobiec wynikających z częściowo zaufanego kodu <see cref="T:System.Uri" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="protected virtual void Escape ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Escape() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Escape" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Escape ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Escape();" />
      <MemberSignature Language="F#" Value="abstract member Escape : unit -&gt; unit&#xA;override this.Escape : unit -&gt; unit" Usage="uri.Escape " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wszystkie znaki niebezpieczne lub zarezerwowany w składnik ścieżki do ich reprezentacji znaków szesnastkowych.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">Identyfikator URI przekazywany z konstruktora jest nieprawidłowy. Ten wyjątek może wystąpić, jeśli identyfikator URI ma zbyt wiele znaków lub identyfikator URI jest względny.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeDataString">
      <MemberSignature Language="C#" Value="public static string EscapeDataString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeDataString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeDataString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeDataString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeDataString : string -&gt; string" Usage="System.Uri.EscapeDataString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">Ciąg jako znak ucieczki.</param>
        <summary>Konwertuje ciąg na jego reprezentację o zmienionym znaczeniu.</summary>
        <returns>A <see cref="T:System.String" /> zawierający reprezentację o zmienionym znaczeniu <paramref name="stringToEscape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Uri.EscapeDataString%2A> metoda konwertuje wszystkie znaki z wyjątkiem niezarezerwowanych znaków RFC 2396 do ich reprezentacji szesnastkowej. Jeśli włączono międzynarodowych identyfikatorach zasobów (IRIs) lub analizy Zinternacjonalizowanych nazw domen (IDN) <xref:System.Uri.EscapeDataString%2A> metoda konwertuje wszystkie znaki z wyjątkiem RFC 3986 niezarezerwowanych znaków do ich reprezentacji szesnastkowej. Wszystkie znaki Unicode są konwertowane do formatu UTF-8 przed są poprzedzone znakiem zmiany znaczenia.  
  
 Ta metoda zakłada, że `stringToEscape` powoduje nie sekwencje ucieczki.  
  
 Domyślnie ten ciąg jest poprzedzone znakiem zmiany znaczenia zgodnie z RFC 2396. Jeśli międzynarodowych identyfikatorach zasobów (IRIs) lub analizy Zinternacjonalizowanych nazw domen (IDN) jest włączony, ten ciąg jest poprzedzone znakiem zmiany znaczenia zgodnie ze standardem RFC 3986 i RFC 3987. Zobacz następujące dokumenty RFC definicji znaków zastrzeżonych i niezastrzeżonych.  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję Spostrzeżenia, aby <xref:System.Uri> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stringToEscape" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.FormatException" />, a zamiast tego.</para>
          </block>  
  
 Długość <paramref name="stringToEscape" /> przekracza 32766 znaków.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeString">
      <MemberSignature Language="C#" Value="protected static string EscapeString (string str);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig string EscapeString(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function EscapeString (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::String ^ EscapeString(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member EscapeString : string -&gt; string" Usage="System.Uri.EscapeString str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Ciąg do przekształcenia na jego reprezentację o zmienionym znaczeniu.</param>
        <summary>Konwertuje ciąg na jego reprezentację o zmienionym znaczeniu.</summary>
        <returns>O zmienionym znaczeniu reprezentację ciągu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.EscapeString%2A> Metoda konwertuje znaki zarezerwowane w dokumencie RFC 2396 i wszystkie znaki z wartości znaków większej niż 127 reprezentacji szesnastkowej. Wszystkie znaki Unicode są konwertowane do formatu UTF-8 przed są poprzedzone znakiem zmiany znaczenia.  
  
 Domyślnie ten ciąg jest poprzedzone znakiem zmiany znaczenia zgodnie z RFC 2396. Jeśli międzynarodowych identyfikatorach zasobów (IRIs) lub analizy Zinternacjonalizowanych nazw domen (IDN) jest włączony, ten ciąg jest poprzedzone znakiem zmiany znaczenia zgodnie ze standardem RFC 3986 i RFC 3987.  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję Spostrzeżenia, aby <xref:System.Uri> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapeUriString">
      <MemberSignature Language="C#" Value="public static string EscapeUriString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeUriString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeUriString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeUriString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeUriString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeUriString : string -&gt; string" Usage="System.Uri.EscapeUriString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">Ciąg jako znak ucieczki.</param>
        <summary>Konwertuje ciąg identyfikatora URI na jego reprezentację o zmienionym znaczeniu.</summary>
        <returns>A <see cref="T:System.String" /> zawierający reprezentację o zmienionym znaczeniu <paramref name="stringToEscape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Uri.EscapeUriString%2A> metoda o niezmienionym znaczeniu ciągu identyfikatora URI jako parametru, aby przygotować <xref:System.Uri.%23ctor%2A> konstruktora.  
  
 Domyślnie <xref:System.Uri.EscapeUriString%2A> metoda konwertuje wszystkie znaki z wyjątkiem RFC 2396 niezarezerwowanych znaków, do ich reprezentacji szesnastkowej. Jeśli włączono międzynarodowych identyfikatorach zasobów (IRIs) lub analizy Zinternacjonalizowanych nazw domen (IDN) <xref:System.Uri.EscapeUriString%2A> metoda konwertuje wszystkie znaki z wyjątkiem RFC 3986 niezarezerwowanych znaków do ich reprezentacji szesnastkowej. Wszystkie znaki Unicode są konwertowane do formatu UTF-8 przed są poprzedzone znakiem zmiany znaczenia.  
  
 Ta metoda zakłada, że `stringToEscape` powoduje nie sekwencje ucieczki.  
  
 Domyślnie ten ciąg jest poprzedzone znakiem zmiany znaczenia zgodnie z RFC 2396. Jeśli międzynarodowych identyfikatorach zasobów (IRIs) lub analizy Zinternacjonalizowanych nazw domen (IDN) jest włączony, ten ciąg jest poprzedzone znakiem zmiany znaczenia zgodnie ze standardem RFC 3986 i RFC 3987. Zobacz następujące dokumenty RFC definicji znaków zastrzeżonych i niezastrzeżonych.  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję Spostrzeżenia, aby <xref:System.Uri> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stringToEscape" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.FormatException" />, a zamiast tego.</para>
          </block>  
  
 Długość <paramref name="stringToEscape" /> przekracza 32766 znaków.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fragment">
      <MemberSignature Language="C#" Value="public string Fragment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Fragment" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Fragment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Fragment As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Fragment { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Fragment : string" Usage="System.Uri.Fragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik fragment identyfikatora URI o zmienionym znaczeniu.</summary>
        <value>Element <see cref="T:System.String" /> zawierający wszystkie informacje fragmentu identyfikatora URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Fragment%2A> Właściwości pobiera dowolny tekst, następujące znacznik fragmentu (#) w identyfikatorze URI, w tym znacznik fragmentu, sam. Podany identyfikator URI http://www.contoso.com/index.htm#main, <xref:System.Uri.Fragment%2A> właściwości zwróci #main.  
  
 <xref:System.Uri.Fragment%2A> Właściwość nie jest traktowana jako we wszystkich <xref:System.Uri.Equals%2A> porównania.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i zapisuje informacje fragmentu do konsoli.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromHex">
      <MemberSignature Language="C#" Value="public static int FromHex (char digit);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FromHex(char digit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.FromHex(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHex (digit As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FromHex(char digit);" />
      <MemberSignature Language="F#" Value="static member FromHex : char -&gt; int" Usage="System.Uri.FromHex digit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="digit" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="digit">Cyfra szesnastkowa (0-9, a-f, A-F) do przekonwertowania.</param>
        <summary>Pobiera wartość dziesiętna cyfrą szesnastkową.</summary>
        <returns><see cref="T:System.Int32" /> Wartość, która zawiera liczbę z zakresu od 0 do 15, która odnosi się do określonej wartości szesnastkowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.FromHex%2A> Metoda konwertuje znak reprezentujący cyfrą szesnastkową (0-9, a-f, A-F) do wartości dziesiętnej (od 0 do 15). Jeśli `digit` nie jest prawidłową cyfrą szesnastkową <xref:System.ArgumentException> wyjątku.  
  
   
  
## Examples  
 Poniższy przykład określa, czy znak jest znaków szesnastkowych, a jeśli tak jest, zapisuje odpowiadająca wartość dziesiętna do konsoli.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="digit" /> nie jest prawidłową cyfrą szesnastkową (0-9, a-f, A-F).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetComponents">
      <MemberSignature Language="C#" Value="public string GetComponents (UriComponents components, UriFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetComponents(valuetype System.UriComponents components, valuetype System.UriFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetComponents(System.UriComponents,System.UriFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetComponents (components As UriComponents, format As UriFormat) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetComponents(UriComponents components, UriFormat format);" />
      <MemberSignature Language="F#" Value="member this.GetComponents : UriComponents * UriFormat -&gt; string" Usage="uri.GetComponents (components, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="components" Type="System.UriComponents" />
        <Parameter Name="format" Type="System.UriFormat" />
      </Parameters>
      <Docs>
        <param name="components">Bitowa kombinacja <see cref="T:System.UriComponents" /> wartości, które określa, które części bieżącego wystąpienia, aby powrócić do obiektu wywołującego.</param>
        <param name="format">Jedną z <see cref="T:System.UriFormat" /> wartości, które kontroluje sposób specjalne znaki będą miały zmienione znaczenie.</param>
        <summary>Pobiera określone składniki bieżącego wystąpienia przy użyciu określonego anulowania zapewnianego element dla znaków specjalnych.</summary>
        <returns>Element <see cref="T:System.String" /> zawierający składniki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UriComponents.Query>, <xref:System.UriComponents.Fragment>, <xref:System.UriComponents.Scheme>, <xref:System.UriComponents.UserInfo>, <xref:System.UriComponents.Host>, <xref:System.UriComponents.Port>, I <xref:System.UriComponents.Path> składniki nie zawierają ogranicznik. Można połączyć <xref:System.UriComponents.KeepDelimiter> flagi (przy użyciu bitowego operatora OR) przy użyciu dowolnego z tych wartości, które można pobrać wartości przy użyciu ogranicznika. Dla wszystkich innych <xref:System.UriComponents> wartości i kombinacje wartości, ograniczniki są uwzględnione w zwracanej wartości.  
  
 Składniki są zwracane w porządku, które pojawiają się w identyfikatorze URI. Na przykład jeśli <xref:System.UriComponents.Scheme> jest określona, pojawi się pierwszy.  
  
 Po włączeniu obsługi międzynarodowych identyfikatorów zasobów (IRI) i międzynarodowych nazw domen (IDN), liczbę znaków, które są zwracane w <xref:System.String> zwiększa się. Nazwy Punycode, używane do obsługi IRI zawierać tylko znaki ASCII i zawsze rozpoczynają się prefiksem xn —. Po włączeniu IRI i IDN znaków dwuskładnikowych Unicode są obsługiwane poprawnie przez <xref:System.Uri.GetComponents%2A> metody.  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję Spostrzeżenia, aby <xref:System.Uri> klasy.  
  
> [!NOTE]
>  Jeśli <xref:System.Uri.GetComponents%2A> metoda jest wywoływana z `format` równa <xref:System.UriFormat.Unescaped> , wartość zwracana nie można użyć jako argumentu do <xref:System.Uri.%23ctor%2A> konstruktora, aby utworzyć odpowiednik <xref:System.Uri>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="components" /> nie jest kombinacją prawidłowe <see cref="T:System.UriComponents" /> wartości.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżący <see cref="T:System.Uri" /> nie jest bezwzględny identyfikator URI. Względne identyfikatory URI nie można używać w przypadku tej metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uri.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość skrótu dla identyfikatora URI.</summary>
        <returns><see cref="T:System.Int32" /> Zawierający wartość skrótu, generowany dla tego identyfikatora URI.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i zapisuje wartość skrótu do konsoli.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLeftPart">
      <MemberSignature Language="C#" Value="public string GetLeftPart (UriPartial part);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetLeftPart(valuetype System.UriPartial part) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetLeftPart(System.UriPartial)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLeftPart (part As UriPartial) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetLeftPart(UriPartial part);" />
      <MemberSignature Language="F#" Value="member this.GetLeftPart : UriPartial -&gt; string" Usage="uri.GetLeftPart part" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="part" Type="System.UriPartial" />
      </Parameters>
      <Docs>
        <param name="part">Jedną z <see cref="T:System.UriPartial" /> wartości, które określa koniec fragment identyfikatora URI do zwrócenia.</param>
        <summary>Pobiera określoną część <see cref="T:System.Uri" /> wystąpienia.</summary>
        <returns>A <see cref="T:System.String" /> zawierający określoną część <see cref="T:System.Uri" /> wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.GetLeftPart%2A> Metoda zwraca ciąg zawierający skrajnej lewej części ciągu identyfikatora URI, kończąc część określony przez `part`.  
  
 <xref:System.Uri.GetLeftPart%2A> zawiera ograniczników w następujących przypadkach:  
  
-   <xref:System.UriPartial.Scheme> zawiera schemat ogranicznik.  
  
-   <xref:System.UriPartial.Authority> nie ma ogranicznika ścieżka.  
  
-   <xref:System.UriPartial.Path> dołącza ograniczniki oryginalnego identyfikatora URI do ogranicznik zapytania lub fragmentu.  
  
-   <xref:System.UriPartial.Query> obejmuje <xref:System.UriPartial.Path>, oraz zapytania, a jego ogranicznik.  
  
 W poniższych przykładach pokazano identyfikatora URI i wyniki wywołania <xref:System.Uri.GetLeftPart%2A> z <xref:System.UriPartial.Scheme>, <xref:System.UriPartial.Authority>, <xref:System.UriPartial.Path>, lub <xref:System.UriPartial.Query>.  
  
|Identyfikator URI|Schemat|Urząd|Ścieżka|Zapytanie|  
|---------|------------|---------------|----------|-----------|  
|http://www.contoso.com/index.htm?date=today|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm?date=today|  
|http://www.contoso.com/index.htm#main|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm|  
|mailto:user@contoso.com? podmiotu = identyfikator uri|mailto:|mailto:user@contoso.com|mailto:user@contoso.com? podmiotu = identyfikator uri|\<Brak >|  
|nntp://news.contoso.com/123456@contoso.com|nntp://|nntp://news.contoso.com|nntp://news.contoso.com/123456@contoso.com|nntp://news.contoso.com/123456@contoso.com|  
|news:123456@contoso.com|grupy dyskusyjne:|news:123456@contoso.com|news:123456@contoso.com|\<Brak >|  
|file://server/filename.ext|File://|File://Server|file://server/filename.ext|file://server/filename.ext|  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i zapisuje ścieżki do konsoli.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący <see cref="T:System.Uri" /> wystąpienia nie jest wystąpieniem bezwzględne.</exception>
        <exception cref="T:System.ArgumentException">Określony <paramref name="part" /> jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="member this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="uri.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiekt zawierający informacje wymagane do wykonywania serializacji <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> obiekt zawierający źródłowe i docelowe serializowanym strumieniu skojarzone z <see cref="T:System.Uri" />.</param>
        <summary>Zwraca dane potrzebne do serializacji bieżącego wystąpienia.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby użyć metody serializacji. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="HexEscape">
      <MemberSignature Language="C#" Value="public static string HexEscape (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string HexEscape(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexEscape(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexEscape (character As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ HexEscape(char character);" />
      <MemberSignature Language="F#" Value="static member HexEscape : char -&gt; string" Usage="System.Uri.HexEscape character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Znak do przekonwertowania na reprezentację w postaci szesnastkowej.</param>
        <summary>Konwertuje określony znak na jego kod szesnastkowy.</summary>
        <returns>Szesnastkowych reprezentujący określonego znaku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład konwertuje znak do jego kod szesnastkowy i zapisuje je w konsoli.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="character" /> jest większe niż 255.</exception>
      </Docs>
    </Member>
    <Member MemberName="HexUnescape">
      <MemberSignature Language="C#" Value="public static char HexUnescape (string pattern, ref int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char HexUnescape(string pattern, int32&amp; index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexUnescape(System.String,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexUnescape (pattern As String, ByRef index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char HexUnescape(System::String ^ pattern, int % index);" />
      <MemberSignature Language="F#" Value="static member HexUnescape : string *  -&gt; char" Usage="System.Uri.HexUnescape (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="pattern">Reprezentacji szesnastkowej znaku.</param>
        <param name="index">Lokalizacja w <paramref name="pattern" /> gdzie rozpoczyna się reprezentacji szesnastkowej znaku.</param>
        <summary>Konwertuje określoną reprezentację szesnastkową znak na znak.</summary>
        <returns>Znaku, reprezentowane przez kodowanie szesnastkowe w położeniu <paramref name="index" />. Jeśli znak na pozycji <paramref name="index" /> nie jest zakodowany szesnastkowo, znak na pozycji <paramref name="index" /> jest zwracana. Wartość <paramref name="index" /> rośnie, aby wskazywał znak ten, który został zwrócony następujący.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poniższy przykład kodu Określa, czy znak jest szesnastkową kodowane, a jeśli tak, zapisuje równoważne znak do konsoli.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza niż 0 lub większa niż lub równa liczbie znaków w <paramref name="pattern" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Host" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Host : string" Usage="System.Uri.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik hosta tego wystąpienia.</summary>
        <value>Element <see cref="T:System.String" /> zawierający nazwę hosta. Jest to zazwyczaj nazwy hosta DNS lub adres IP serwera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od <xref:System.Uri.Authority%2A> właściwości, wartość tej właściwości nie ma numeru portu.  
  
   
  
## Examples  
 Poniższy przykład zapisuje nazwę hosta (www.contoso.com) na serwerze do konsoli.  
  
 [!code-cpp[Classic Uri.Host Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Host Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Host Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Host Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Host Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Host Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="HostNameType">
      <MemberSignature Language="C#" Value="public UriHostNameType HostNameType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.UriHostNameType HostNameType" />
      <MemberSignature Language="DocId" Value="P:System.Uri.HostNameType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HostNameType As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property UriHostNameType HostNameType { UriHostNameType get(); };" />
      <MemberSignature Language="F#" Value="member this.HostNameType : UriHostNameType" Usage="System.Uri.HostNameType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ nazwa hosta określona w identyfikatorze URI.</summary>
        <value>Członek <see cref="T:System.UriHostNameType" /> wyliczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i zapisy <xref:System.Uri.HostNameType%2A> do konsoli.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="IdnHost">
      <MemberSignature Language="C#" Value="public string IdnHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string IdnHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IdnHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IdnHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ IdnHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IdnHost : string" Usage="System.Uri.IdnHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>RFC 3490 zgodne międzynarodową nazwę domeny hosta, za pomocą Punycode zgodnie z potrzebami. Ten ciąg jest do o niezmienionym, jeśli to konieczne, znaczeniu po bezpiecznie używać do rozpoznawania nazw DNS.</summary>
        <value>Zwraca nazwę hosta, sformatowany przy użyciu Punycode zgodnie ze standardem IDN. <see cref="T:System.String" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest udostępniana do użytku niższego poziomu protokołów sieciowych, które wymagają nazwy domeny w postaci Punycode. Jeśli Twój kod nie wymaga tego określonego formatu, użyj <xref:System.Uri.Host%2A> nazwy hosta.  
  
 Przestarzała <xref:System.Uri.DnsSafeHost%2A> właściwości jest zależne od *app.config* ustawienia, które nie mogą być zmieniane przez aplikacje Windows Store. IdnHost jest dostarczana jako preferowana alternatywa dla przy użyciu <xref:System.Uri.DnsSafeHost%2A>, ponieważ <xref:System.Uri.IdnHost%2A> jest gwarantowane, zawsze można bezpieczne, niezależnie od tego, jakie bieżącego DNS *app.config* ustawienia mogą być.  

 Jeśli używano ciągiem o zmienionym znaczeniu w celu utworzenia tego wystąpienia (na przykład "http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), następnie IdnHost zwraca ciąg o zmienionym znaczeniu. Należy unescape dowolny ciąg o zmienionym znaczeniu zwróciło IdnHost przed rozpoczęciem korzystania z tego ciągu do rozpoznawania nazw DNS. Należy pamiętać, że jeśli używasz nieprawidłowy ciąg o niezmienionym znaczeniu do utworzenia tego wystąpienia (na przykład "http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm"), a następnie IdnHost zwraca ciąg o niezmienionym znaczeniu.


 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAbsoluteUri">
      <MemberSignature Language="C#" Value="public bool IsAbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsAbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbsoluteUri As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbsoluteUri { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbsoluteUri : bool" Usage="System.Uri.IsAbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy <see cref="T:System.Uri" /> wystąpienia jest bezwzględna.</summary>
        <value>A <see cref="T:System.Boolean" /> wartość, która jest <see langword="true" /> Jeśli <see cref="T:System.Uri" /> wystąpienie jest bezwzględny; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest `true` Jeśli ciąg lub <xref:System.Uri> wystąpienia, który został przekazany do konstruktora, może być analizowana jako bezwzględnym <xref:System.Uri> wystąpienia, co zawiera schemat, Urząd i ścieżkę. W przeciwnym razie <xref:System.Uri> wystąpienie jest traktowany jako względną i może pominąć systemu lub inne składniki identyfikatora URI.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBadFileSystemCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsBadFileSystemCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsBadFileSystemCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBadFileSystemCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsBadFileSystemCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsBadFileSystemCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsBadFileSystemCharacter : char -&gt; bool&#xA;override this.IsBadFileSystemCharacter : char -&gt; bool" Usage="uri.IsBadFileSystemCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character"><see cref="T:System.Char" /> Do testowania.</param>
        <summary>Pobiera informacje, czy znak jest nieprawidłowy w nazwie pliku systemu.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, która jest <see langword="true" /> Jeśli określony znak jest nieprawidłowy; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znak są analizowane zgodnie z regułami systemu plików NTFS.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBaseOf">
      <MemberSignature Language="C#" Value="public bool IsBaseOf (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsBaseOf(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBaseOf(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsBaseOf(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.IsBaseOf : Uri -&gt; bool" Usage="uri.IsBaseOf uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">Określony <see cref="T:System.Uri" /> wystąpienia do testowania.</param>
        <summary>Określa, czy bieżący <see cref="T:System.Uri" /> wystąpienie jest podstawą określonego <see cref="T:System.Uri" /> wystąpienia.</summary>
        <returns><see langword="true" /> Jeśli bieżący <see cref="T:System.Uri" /> wystąpienie jest podstawą <paramref name="uri" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsBaseOf%2A> Służy do porównywania bieżącego <xref:System.Uri> wystąpienia określonego <xref:System.Uri> do ustalenia, czy ten identyfikator URI jest podstawowy dla określonego <xref:System.Uri>. Podczas porównywania dwóch <xref:System.Uri> obiektów, aby ustalić relacji podstawowej, informacje o użytkowniku (<xref:System.Uri.UserInfo%2A>) nie jest oceniany. Podczas porównywania dwóch identyfikatorów URI (identyfikator uri1 i uri2), identyfikator uri1 jest podstawą uri2 podczas Ignoruj wszystkich elementów w uri2 po ostatnim ukośnika (/) dwa identyfikatory URI są identyczne. Za pomocą http://host/path/path/file?query jako podstawowy identyfikator URI w poniższej tabeli przedstawiono, czy jest to podstawowy dla innych identyfikatorów URI.  
  
|Identyfikator URI|http://host/path/path/file?query to podstawa|  
|---------|------------------------------------------------------|  
|http://host/path/path/file/|tak|  
|http://host/path/path/#fragment|tak|  
|http://host/path/path/MoreDir/"|tak|  
|http://host/path/path/OtherFile?Query|tak|  
|http://host/path/path/|tak|  
|http://host/path/path/file|tak|  
|http://host/path/path|Brak|  
|http://host/path/path?query|Brak|  
|http://host/path/path#Fragment|Brak|  
|http://host/path/path2/|Brak|  
: //host/path/path2/MoreDir|Brak|  
|http://host/path/File|Brak|  
  
   
  
## Examples  
 Ten przykład tworzy <xref:System.Uri> wystąpienia, która reprezentuje podstawowej <xref:System.Uri> wystąpienia. Następnie tworzy drugi <xref:System.Uri> wystąpienia ciągu. Wywołuje <xref:System.Uri.IsBaseOf%2A> do ustalenia, czy wystąpienie podstawowego jest podstawą drugie wystąpienie. Wynik jest zapisywany do konsoli.  
  
 [!code-cpp[NCLUriEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#6)]
 [!code-csharp[NCLUriEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#6)]
 [!code-vb[NCLUriEnhancements#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uri" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefaultPort">
      <MemberSignature Language="C#" Value="public bool IsDefaultPort { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefaultPort" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsDefaultPort" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDefaultPort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDefaultPort { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefaultPort : bool" Usage="System.Uri.IsDefaultPort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje, czy wartość portu identyfikatora URI jest ustawieniem domyślnym dla tego schematu.</summary>
        <value>A <see cref="T:System.Boolean" /> wartość, która jest <see langword="true" /> Jeśli wartość w <see cref="P:System.Uri.Port" /> właściwość jest domyślny port dla tego schematu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i sprawdza, czy ma być używany port domyślny.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsExcludedCharacter">
      <MemberSignature Language="C#" Value="protected static bool IsExcludedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool IsExcludedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsExcludedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function IsExcludedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static bool IsExcludedCharacter(char character);" />
      <MemberSignature Language="F#" Value="static member IsExcludedCharacter : char -&gt; bool" Usage="System.Uri.IsExcludedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character"><see cref="T:System.Char" /> Do testowania.</param>
        <summary>Pobiera informacje, czy określony znak powinien być poprzedzone znakiem zmiany znaczenia.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, która jest <see langword="true" /> , jeśli określony znak powinien być zmienione; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFile">
      <MemberSignature Language="C#" Value="public bool IsFile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFile" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsFile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFile As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFile { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFile : bool" Usage="System.Uri.IsFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy określonego <see cref="T:System.Uri" /> jest plikiem identyfikatora URI.</summary>
        <value>A <see cref="T:System.Boolean" /> wartość, która jest <see langword="true" /> Jeśli <see cref="T:System.Uri" /> jest plikiem identyfikator URI; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsFile%2A> Właściwość `true` podczas <xref:System.Uri.Scheme%2A> właściwości jest równa <xref:System.Uri.UriSchemeFile>.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy jest to plik identyfikatora URI.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsHexDigit">
      <MemberSignature Language="C#" Value="public static bool IsHexDigit (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexDigit(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexDigit (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexDigit(char character);" />
      <MemberSignature Language="F#" Value="static member IsHexDigit : char -&gt; bool" Usage="System.Uri.IsHexDigit character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Znak do sprawdzania poprawności.</param>
        <summary>Określa, czy określony znak jest prawidłową cyfrą szesnastkową.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, która jest <see langword="true" /> Jeśli znak jest cyfrą szesnastkową prawidłowy; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cyfry szesnastkowe są cyfry od 0 do 9 i litery A-F lub a-f.  
  
   
  
## Examples  
 Poniższy przykład określa, czy znak jest znaków szesnastkowych, a jeśli tak jest, zapisuje odpowiadająca wartość dziesiętna do konsoli.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHexEncoding">
      <MemberSignature Language="C#" Value="public static bool IsHexEncoding (string pattern, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexEncoding(string pattern, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexEncoding(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexEncoding (pattern As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexEncoding(System::String ^ pattern, int index);" />
      <MemberSignature Language="F#" Value="static member IsHexEncoding : string * int -&gt; bool" Usage="System.Uri.IsHexEncoding (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pattern">Ciąg do sprawdzenia.</param>
        <param name="index">Lokalizacja w <paramref name="pattern" /> pod kątem kodowanie szesnastkowe.</param>
        <summary>Określa, czy znak w ciągu jest szesnastkowe zakodowany.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, która jest <see langword="true" /> Jeśli <paramref name="pattern" /> jest szesnastkowe zakodowane w określonej lokalizacji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsHexEncoding%2A> Metoda sprawdza szesnastkowe kodowania, który jest zgodny ze wzorcem "% hexhex" w ciągu, gdzie "hex" jest cyfrą z zakresu od 0 do 9 i litery od A-F (bez uwzględniania wielkości liter).  
  
   
  
## Examples  
 Poniższy przykład kodu Określa, czy znak jest szesnastkową kodowane, a jeśli tak, zapisuje równoważne znak do konsoli.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public bool IsLoopback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsLoopback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoopback { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoopback : bool" Usage="System.Uri.IsLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy określonego <see cref="T:System.Uri" /> odwołuje się do hosta lokalnego.</summary>
        <value>A <see cref="T:System.Boolean" /> wartość, która jest <see langword="true" /> Jeśli <see cref="T:System.Uri" /> odwołuje się do hosta lokalnego; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsLoopback%2A> Zwraca `true` Jeśli identyfikator URI określony podczas tworzenia tego wystąpienia 127.0.0.1, sprzężenia zwrotnego, lub localhost, lub jeśli nie określono identyfikatora URI hosta informacji (na przykład file:///c:Dir/file.txt). Inne return identyfikatorów URI `false`.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy odwołuje się do hosta lokalnego.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReservedCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsReservedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsReservedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsReservedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsReservedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsReservedCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsReservedCharacter : char -&gt; bool&#xA;override this.IsReservedCharacter : char -&gt; bool" Usage="uri.IsReservedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character"><see cref="T:System.Char" /> Do testowania.</param>
        <summary>Pobiera informacje, czy określony znak jest znakiem zastrzeżone.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, która jest <see langword="true" /> Jeśli określony znak jest zastrzeżonego znaku, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnc">
      <MemberSignature Language="C#" Value="public bool IsUnc { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnc" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsUnc" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnc As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnc { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnc : bool" Usage="System.Uri.IsUnc" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy określonego <see cref="T:System.Uri" /> jest ścieżka uniwersalną konwencją nazewnictwa (UNC).</summary>
        <value>A <see cref="T:System.Boolean" /> wartość, która jest <see langword="true" /> Jeśli <see cref="T:System.Uri" /> jest ścieżką UNC; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsUnc%2A> Właściwość `true` Jeśli określony <xref:System.Uri> wystąpienie jest ścieżką UNC (takie jak \\\server\folder lub file://server/folder). Właściwość ta zwraca zawsze `true` Jeśli identyfikator URI ma ze schematem file:// i określa składnik hosta.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy jest ścieżką UNC.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedOriginalString">
      <MemberSignature Language="C#" Value="public bool IsWellFormedOriginalString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsWellFormedOriginalString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedOriginalString" />
      <MemberSignature Language="VB.NET" Value="Public Function IsWellFormedOriginalString () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsWellFormedOriginalString();" />
      <MemberSignature Language="F#" Value="member this.IsWellFormedOriginalString : unit -&gt; bool" Usage="uri.IsWellFormedOriginalString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy ten ciąg jest używany do utworzenia tego <see cref="T:System.Uri" /> został poprawnie sformułowany i nie jest wymagane dalsze dodać znak ucieczki.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, która jest <see langword="true" /> Jeśli ten ciąg został poprawnie sformułowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten ciąg jest uważany za być poprawnie sformułowany, zgodnie z RFC 2396 i specyfikacji RFC 2732 domyślnie. Jeśli międzynarodowych identyfikatorach zasobów (IRIs) lub analizy Zinternacjonalizowanych nazw domen (IDN) jest włączony, ten ciąg jest uważany za poprawnie sformułowany, zgodnie ze standardem RFC 3986 i RFC 3987  
  
 Ten ciąg jest traktowany jako źle sformułowany, powodując metoda zwróci wartość false, jeśli wystąpi dowolne z następujących warunków.  
  
|Błąd|Przykład|  
|-----------|-------------|  
|Ciąg nie jest poprawnie wyjściowym.|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) Nazwa|  
|Ten ciąg jest ścieżką bezwzględną <xref:System.Uri> reprezentujący plik niejawne <xref:System.Uri>.|c:\\\directory\filename|  
|Ten ciąg jest bezwzględny identyfikator URI, który nie zawiera ukośnik przed ścieżką.|File://c:/Directory/filename|  
|Ciąg zawiera o niezmienionym znaczeniu ukośników odwrotnych, nawet wtedy, gdy są one traktowane jako ukośników.|http:\\\host/path/file|  
|Ciąg reprezentuje hierarchiczny bezwzględną <xref:System.Uri> i nie zawiera "://".|www.contoso.com/path/file|  
|Analizator dla <xref:System.Uri.Scheme%2A?displayProperty=nameWithType> wskazuje, że oryginalny ciąg nie jest poprawnie sformułowany.|Przykład zależy od schemat identyfikatora URI.|  
  
 Domyślnie ten ciąg jest używany do utworzenia tego <xref:System.Uri> są traktowane jako poprawnie sformułowany w zgodnie z RFC 2396 i RFC 2732.  
  
 Jeżeli są włączone międzynarodowych identyfikatorów zasobów (IRI) i obsługa międzynarodowych nazw domen (IDN), ciąg używany do budowy to <xref:System.Uri> są traktowane jako poprawnie sformułowany w zgodnie z RFC 3986 i RFC 3987. Nazwy Punycode, używane do obsługi IRI zawierać tylko znaki ASCII i zawsze rozpoczynają się prefiksem xn —.  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję Spostrzeżenia, aby <xref:System.Uri> klasy.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="http://www.ietf.org/">http://www.ietf.org</related>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedUriString">
      <MemberSignature Language="C#" Value="public static bool IsWellFormedUriString (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWellFormedUriString(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedUriString(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWellFormedUriString(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="static member IsWellFormedUriString : string * UriKind -&gt; bool" Usage="System.Uri.IsWellFormedUriString (uriString, uriKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">Ciąg używany do podjęto próbę stworzenia <see cref="T:System.Uri" />.</param>
        <param name="uriKind">Typ <see cref="T:System.Uri" /> w <paramref name="uriString" />.</param>
        <summary>Wskazuje, czy ten ciąg jest poprawnie sformułowany, próba utworzenia identyfikatora URI z ciągiem i gwarantuje, że ten ciąg nie wymaga dalszych anulowania zapewnianego element.</summary>
        <returns><see langword="true" /> Jeśli ten ciąg został poprawnie sformułowany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wersjach programu .NET przed w wersji 4.5 domyślnie ten ciąg jest uważany za poprawnie sformułowany w zgodnie z RFC 2396 i RFC 2732. Jeśli międzynarodowych identyfikatorach zasobów (IRIs) lub analizy Zinternacjonalizowanych nazw domen (IDN) są włączone, ten ciąg jest uważany za poprawnie sformułowany w zgodnie z RFC 3986 i RFC 3987.  
  
 Począwszy od .NET 4.5, ciągi są zawsze traktowane jako poprawnie sformułowany w zgodnie ze standardem RFC 3986 i RFC 3987, czy IRI lub IDN są włączone. Należy jednak pamiętać, że to jest tylko wartość true dla aplikacji przeznaczonych dla platformy .NET 4.5 lub nowszej. Aplikacje, których platformą docelową .NET 4.0 wywołania zgodność kodu i środowisko stare zachowanie (pre-4.5).  
  
 Ten ciąg jest uznawany za źle sformułowany, powodując metoda zwróci wartość false, jeśli wystąpi dowolne z następujących warunków  
  
|Błąd|Przykład|  
|-----------|-------------|  
|Ciąg nie jest poprawnie wyjściowym.|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) Nazwa|  
|Ten ciąg jest ścieżką bezwzględną <xref:System.Uri> reprezentujący plik niejawne <xref:System.Uri>.|c:\\\directory\filename|  
|Ten ciąg jest bezwzględny identyfikator URI, który nie zawiera ukośnik przed ścieżką.|File://c:/Directory/filename|  
|Ciąg zawiera o niezmienionym znaczeniu ukośników odwrotnych, nawet wtedy, gdy będą one traktowane jako ukośniki|http:\\\host/path/file|  
|Ciąg reprezentuje hierarchiczny bezwzględną <xref:System.Uri> i nie zawiera "://"|www.contoso.com/path/file|  
|Analizator dla <xref:System.Uri.Scheme%2A> wskazuje, że oryginalny ciąg nie jest poprawnie sformułowany.|Przykład zależy od schemat identyfikatora URI.|  
|Począwszy od platformy .NET 4.5, względne identyfikatory URI z dwukropkiem (': ') w ich pierwszy segment nie są uważane za poprawnie sformułowany.|2013.05.29_14:33:41|  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję Spostrzeżenia, aby <xref:System.Uri> klasy.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="http://www.ietf.org/">http://www.ietf.org</related>
      </Docs>
    </Member>
    <Member MemberName="LocalPath">
      <MemberSignature Language="C#" Value="public string LocalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalPath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.LocalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LocalPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalPath : string" Usage="System.Uri.LocalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera reprezentację lokalnego systemu operacyjnego nazwy pliku.</summary>
        <value>Element <see cref="T:System.String" /> zawierający lokalnego systemu operacyjnego reprezentacja nazwy pliku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana przez tę właściwość jest o niezmienionym znaczeniu. Jeśli ścieżka jest rozpoznawana jako ścieżkę do pliku Windows, wszystkie kreski ułamkowe (/) są zastępowane przez ukośniki z poprzednimi wersjami (\\).  
  
 Aby uzyskać identyfikator URI `file://computer/file.ext`, jest ścieżka bezwzględna `/file.ext` i ścieżka lokalna jest `\\computer\file.ext`.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i zapisuje ścieżkę lokalną do konsoli.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelative">
      <MemberSignature Language="C#" Value="public string MakeRelative (Uri toUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MakeRelative(class System.Uri toUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelative(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function MakeRelative (toUri As Uri) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MakeRelative(Uri ^ toUri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelative : Uri -&gt; string" Usage="uri.MakeRelative toUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use MakeRelativeUri(Uri uri). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="toUri">Identyfikator URI do porównania z bieżącym identyfikatorem URI.</param>
        <summary>Określa różnicę między dwoma <see cref="T:System.Uri" /> wystąpień.</summary>
        <returns>Jeśli nazwy hosta i schemat tego wystąpienia identyfikatora URI i <paramref name="toUri" /> są takie same, a następnie ta metoda zwraca <see cref="T:System.String" /> reprezentujący względny identyfikator URI, gdy dołączane do bieżącego wystąpienia identyfikatora URI, daje <paramref name="toUri" /> parametru.  
  
Jeśli nazwa hosta lub schemat jest inny, a następnie ta metoda zwraca <see cref="T:System.String" /> reprezentujący <paramref name="toUri" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono wystąpienia identyfikatora URI `toUri`, a wyniki wywołania <xref:System.Uri.MakeRelative%2A>.  
  
|Bieżące wystąpienie identyfikatora URI|`toUri`|Wartość zwracana|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|test/test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|.. /|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|test1/test1.txt|  
  
 Informacje o użytkowniku, jeśli jest obecny w identyfikatorze URI, jest ignorowany.  
  
   
  
## Examples  
 Poniższy przykład tworzy 2 <xref:System.Uri> wystąpień. Różnica w informacje o ścieżce są zapisywane do konsoli.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="toUri" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta metoda jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelativeUri">
      <MemberSignature Language="C#" Value="public Uri MakeRelativeUri (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Uri MakeRelativeUri(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelativeUri(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri ^ MakeRelativeUri(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelativeUri : Uri -&gt; Uri" Usage="uri.MakeRelativeUri uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">Identyfikator URI do porównania z bieżącym identyfikatorem URI.</param>
        <summary>Określa różnicę między dwoma <see cref="T:System.Uri" /> wystąpień.</summary>
        <returns>Jeśli nazwa hosta i schemat tego wystąpienia identyfikatora URI i <paramref name="uri" /> są takie same, a następnie ta metoda zwraca wartość względna <see cref="T:System.Uri" /> , gdy dołączane do bieżącego wystąpienia identyfikatora URI, daje <paramref name="uri" />.  
  
Jeśli nazwa hosta lub schemat jest inny, a następnie ta metoda zwraca <see cref="T:System.Uri" /> reprezentujący <paramref name="uri" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono wystąpienia identyfikatora URI `toUri`, a wyniki wywołania <xref:System.Uri.MakeRelativeUri%2A>.  
  
|Bieżące wystąpienie identyfikatora URI|`toUri`|Wartość zwracana|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|test/test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|.. /|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|test1/test1.txt|  
  
 Informacje o użytkowniku, jeśli jest obecny w identyfikatorze URI, jest ignorowany.  
  
   
  
## Examples  
 Poniższy przykład tworzy 2 <xref:System.Uri> wystąpień. Różnica w informacje o ścieżce są zapisywane do konsoli.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="uri" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Equality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Uri * Uri -&gt; bool" Usage="uri1 = uri2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">A <see cref="T:System.Uri" /> wystąpienie do porównania z <paramref name="uri2" />.</param>
        <param name="uri2">A <see cref="T:System.Uri" /> wystąpienie do porównania z <paramref name="uri1" />.</param>
        <summary>Określa, czy dwa <see cref="T:System.Uri" /> wystąpienia mają taką samą wartość.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, która jest <see langword="true" /> Jeśli <see cref="T:System.Uri" /> wystąpienia są równoważne; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używa tego przeciążenia <xref:System.Uri.Equals%2A> metodę, aby określić, czy dwa <xref:System.Uri> wystąpienia są równoważne. <xref:System.Uri.UserInfo%2A> i <xref:System.Uri.Fragment%2A> zawartości jest ignorowany podczas wprowadzania tego porównania.  
  
   
  
## Examples  
 W tym przykładzie tworzy trzy <xref:System.Uri> wystąpień z ciągów i porównuje je, aby ustalić, czy stanowią one tę samą wartość. `Address1` i `Address2` są takie same, ponieważ <xref:System.Uri.Fragment%2A> część jest ignorowany dla tego porównania. Wynik jest zapisywany do konsoli.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Inequality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Uri * Uri -&gt; bool" Usage="System.Uri.op_Inequality (uri1, uri2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">A <see cref="T:System.Uri" /> wystąpienie do porównania z <paramref name="uri2" />.</param>
        <param name="uri2">A <see cref="T:System.Uri" /> wystąpienie do porównania z <paramref name="uri1" />.</param>
        <summary>Określa, czy dwa <see cref="T:System.Uri" /> wystąpień nie mają taką samą wartość.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, która jest <see langword="true" /> Jeśli dwa <see cref="T:System.Uri" /> wystąpienia nie są równe; w przeciwnym razie <see langword="false" />. Jeśli jest albo parametr <see langword="null" />, Metoda ta zwraca <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używa tego przeciążenia <xref:System.Uri.Equals%2A> metodę, aby określić, czy dwa <xref:System.Uri> wystąpienia nie są równoważne. <xref:System.Uri.UserInfo%2A> i <xref:System.Uri.Fragment%2A> zawartości jest ignorowany podczas wprowadzania tego porównania.  
  
   
  
## Examples  
 W tym przykładzie tworzy trzy <xref:System.Uri> wystąpień z ciągów i porównuje je, aby ustalić, czy stanowią one tę samą wartość. `Address2` i `Address3` są takie same ponieważ `Address3` zawiera <xref:System.Uri.Query%2A> nie znaleziono w `Address2`. Wynik jest zapisywany do konsoli.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalString">
      <MemberSignature Language="C#" Value="public string OriginalString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OriginalString" />
      <MemberSignature Language="DocId" Value="P:System.Uri.OriginalString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OriginalString { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalString : string" Usage="System.Uri.OriginalString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera, oryginalnym ciągu identyfikatora URI, który został przekazany do <see cref="T:System.Uri" /> konstruktora.</summary>
        <value>A <see cref="T:System.String" /> zawierającym dokładny identyfikator URI określone, gdy to wystąpienie zostało stworzonego elementu; w przeciwnym razie <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli identyfikator URI określony do konstruktora zawiera początkowe lub końcowe spacje, zostaną zachowane te miejsca do magazynowania.  
  
 Wartość zwracana przez tę właściwość różni się od <xref:System.Uri.ToString%2A> i <xref:System.Uri.AbsoluteUri%2A>. <xref:System.Uri.ToString%2A> Zwraca canonically o niezmienionym znaczeniu formie identyfikatora URI. <xref:System.Uri.AbsoluteUri%2A> Zwraca canonically o zmienionym znaczeniu formie identyfikatora URI.  
  
 Po włączeniu obsługi międzynarodowych identyfikatorów zasobów (IRI) i międzynarodowych nazw domen (IDN) <xref:System.Uri.OriginalString%2A> zwraca oryginalny ciąg bez znormalizowane z nazwą hosta Punycode, jeśli zostało ono użyte do zainicjowania <xref:System.Uri> wystąpienia. Nazwy Punycode zawierać tylko znaki ASCII i zawsze rozpoczynają się prefiksem xn —.  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję Spostrzeżenia, aby <xref:System.Uri> klasy.  
  
 Gdy <xref:System.Uri> obiekt jest serializowany, <xref:System.Uri.OriginalString%2A> nie są zachowywane. Proces serializacji korzysta z w pełni o zmienionym znaczeniu i postaci kanonicznej <xref:System.Uri.AbsoluteUri%2A> właściwości podczas serializacji. Aby uzyskać <xref:System.Uri> zawierającą adres IPv6, adres IPv6 i identyfikator zakresu są uwzględniane w serializacji <xref:System.Uri> obiektu.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.Uri> wystąpienia ciągu. Przykład ilustruje różnicę między wartością zwróconą z <xref:System.Uri.OriginalString%2A>, która zwraca ciąg, który został przekazany do konstruktora, a po wywołaniu <xref:System.Uri.ToString%2A>, która zwraca forma kanoniczna ciągu.  
  
 [!code-cpp[NCLUriEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#3)]
 [!code-csharp[NCLUriEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#3)]
 [!code-vb[NCLUriEnhancements#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="protected virtual void Parse ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Parse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Parse" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Parse ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Parse();" />
      <MemberSignature Language="F#" Value="abstract member Parse : unit -&gt; unit&#xA;override this.Parse : unit -&gt; unit" Usage="uri.Parse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Analizuje identyfikatora URI bieżącego wystąpienia, aby upewnić się, że zawiera wszystkie elementy, które są wymagane do prawidłowego identyfikatora URI.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">Identyfikator Uri przekazywany z konstruktora jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="PathAndQuery">
      <MemberSignature Language="C#" Value="public string PathAndQuery { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathAndQuery" />
      <MemberSignature Language="DocId" Value="P:System.Uri.PathAndQuery" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathAndQuery As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathAndQuery { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathAndQuery : string" Usage="System.Uri.PathAndQuery" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="P:System.Uri.AbsolutePath" /> i <see cref="P:System.Uri.Query" /> właściwości oddzielonych znakiem zapytania (?).</summary>
        <value>A <see cref="T:System.String" /> zawierający <see cref="P:System.Uri.AbsolutePath" /> i <see cref="P:System.Uri.Query" /> właściwości oddzielonych znakiem zapytania (?).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.PathAndQuery%2A> Właściwość zawiera ścieżki bezwzględnej na serwerze i dane zapytania wysłane z żądaniem. Jest taka sama jak złączenie <xref:System.Uri.AbsolutePath%2A> i <xref:System.Uri.Query%2A> właściwości.  
  
 <xref:System.Uri.PathAndQuery%2A> Właściwości została zmieniona zgodnie z RFC 2396 domyślnie. Jeśli włączono międzynarodowych identyfikatorach zasobów (IRIs) lub analizy Zinternacjonalizowanych nazw domen (IDN) <xref:System.Uri.PathAndQuery%2A> właściwości została zmieniona zgodnie ze standardem RFC 3986 i RFC 3987.  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję Spostrzeżenia, aby <xref:System.Uri> klasy.  
  
   
  
## Examples  
 Poniższy przykład zapisuje składnik path identyfikatora URI (/ catalog/shownew.htm) i zapytania (Data = dzisiaj) informacji do konsoli.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.PathAndQuery Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Port">
      <MemberSignature Language="C#" Value="public int Port { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Port" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Port" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Port As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Port { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Port : int" Usage="System.Uri.Port" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera numer portu tego identyfikatora URI.</summary>
        <value><see cref="T:System.Int32" /> Wartość, która zawiera numer portu dla tego identyfikatora URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numer portu definiuje port protokół używany do nawiązywania kontaktu z serwerem, do których odwołuje się w identyfikatorze URI. Jeśli port nie jest określony jako część identyfikatora URI <xref:System.Uri.Port%2A> właściwość zwraca wartość domyślna dla protokołu. W przypadku nie domyślny numer portu, ta właściwość zwraca wartość -1.  
  
   
  
## Examples  
 Poniższy przykład zapisuje numer portu identyfikatora URI do konsoli. W tym przypadku wartość jest domyślny numer portu dla protokołu HTTP, port 80.  
  
 [!code-cpp[Classic Uri.Port Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Port Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Port Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Port Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Port Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Port Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Query">
      <MemberSignature Language="C#" Value="public string Query { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Query" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Query" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Query As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Query { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Query : string" Usage="System.Uri.Query" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje zapytań, wszystkie objęte określonego identyfikatora URI.</summary>
        <value>Element <see cref="T:System.String" /> zawierający informacje zapytań, wszystkie objęte określonego identyfikatora URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Query%2A> Właściwość zawiera informacje zapytania uwzględnione w identyfikatorze URI. Informacje o kwerendzie jest oddzielony od informacji o ścieżce przez znak zapytania (?) i kontynuuje do końca identyfikatora URI. Zwracane informacje dotyczą zapytania zawiera znak zapytania wiodących.  
  
 Informacje o kwerendzie jest poprzedzone znakiem zmiany znaczenia zgodnie z RFC 2396 domyślnie. Jeśli włączono międzynarodowych identyfikatorach zasobów (IRIs) lub analizy Zinternacjonalizowanych nazw domen (IDN), informacje o kwerendzie jest poprzedzone znakiem zmiany znaczenia zgodnie ze standardem RFC 3986 i RFC 3987.  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję Spostrzeżenia, aby <xref:System.Uri> klasy.  
  
   
  
## Examples  
 Poniższy przykład zapisuje zapytania? Data = dzisiaj w konsoli.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#2)]
 [!code-vb[Classic Uri.PathAndQuery Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheme : string" Usage="System.Uri.Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę schematu dla tego identyfikatora URI.</summary>
        <value>Element <see cref="T:System.String" /> zawierający schemat dla tego identyfikatora URI konwertowane na małe litery.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Scheme%2A> Właściwość zwraca schemat, używane do zainicjowania <xref:System.Uri> wystąpienia. Ta właściwość wskazuje, że schemat używany do inicjowania <xref:System.Uri> wystąpienie zostało rozpoznane.  
  
 W poniższej tabeli przedstawiono przykłady niektórych możliwych wartości zwracanych przez <xref:System.Uri.Scheme%2A> właściwości.  
  
|Schemat|Opis|  
|------------|-----------------|  
| — plik|Zasób jest plik na komputerze lokalnym.|  
|FTP|Zasób jest dostępny za pośrednictwem protokołu FTP.|  
|gopher|Zasób jest dostępny za pośrednictwem protokołu Gopher.|  
|http|Zasób jest dostępny za pośrednictwem protokołu HTTP.|  
|https|Zasób jest dostępny za pośrednictwem protokołu HTTP z protokołem szyfrowania SSL.|  
|LDAP|Zasób jest dostępny za pośrednictwem protokołu LDAP.|  
|mailto|Zasób jest adres e-mail i dostępne za pośrednictwem protokołu SMTP.|  
|net.pipe|Zasób jest dostępny za pośrednictwem nazwanych potoków.|  
|net.tcp|Zasób jest dostępny z punktu końcowego TCP.|  
|wiadomości|Zasób jest dostępny za pośrednictwem protokołu NNTP.|  
|NNTP|Zasób jest dostępny za pośrednictwem protokołu NNTP.|  
|telnet|Zasób jest dostępny za pośrednictwem protokołu TELNET.|  
|uuid|Zasób jest dostępny za pośrednictwem unikatową nazwę punktu końcowego UUID do komunikowania się z usługą.|  
  
   
  
## Examples  
 Poniższy przykład zapisuje nazwę schematu (http) do konsoli dla http://www.contoso.com/ identyfikatora URI.  
  
 [!code-cpp[Classic Uri.Scheme Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Scheme Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Scheme Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Scheme Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemeDelimiter">
      <MemberSignature Language="C#" Value="public static readonly string SchemeDelimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string SchemeDelimiter" />
      <MemberSignature Language="DocId" Value="F:System.Uri.SchemeDelimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SchemeDelimiter As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ SchemeDelimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable SchemeDelimiter : string" Usage="System.Uri.SchemeDelimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa znaki rozdzielające schemat protokołu komunikacji z część adresu URI. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy ciąg z <xref:System.Uri.UriSchemeHttp>, <xref:System.Uri.SchemeDelimiter>oraz adresu. A <xref:System.Uri> następnie tworzone jest wystąpienie z ciągu.  
  
 [!code-cpp[NCLUriExamples#17](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#17)]
 [!code-csharp[NCLUriExamples#17](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#17)]
 [!code-vb[NCLUriExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Segments">
      <MemberSignature Language="C#" Value="public string[] Segments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Segments" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Segments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Segments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Segments { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Segments : string[]" Usage="System.Uri.Segments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera tablicę zawierającą segmenty ścieżki, które tworzą określonego identyfikatora URI.</summary>
        <value>A <see cref="T:System.String" /> tablica, która zawiera ścieżkę segmenty wchodzących w skład określonego identyfikatora URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Segments%2A> Właściwość zwraca tablicę ciągów, które zawierają "segmenty" (podciągów), które tworzą ścieżki bezwzględnej identyfikatory URI. Pierwszy segment są uzyskiwane przez analizowanie ścieżki bezwzględnej od jego pierwszego znaku, aż ukośnika (/) lub na końcu ścieżki. Każdy z segmentów dodatkowe rozpoczyna się od pierwszego znaku po poprzedniego segmentu i kończy się ukośnikiem dalej lub końca ścieżki. (Ścieżka bezwzględny identyfikator URI zawiera wszystko, czego po hosta i portu, a przed query i fragment).  
  
 Poniższy przykład pokazuje ścieżki bezwzględnej i segmentów dwa identyfikatory URI. Drugi przykład przedstawia fragmentu i zapytania nie są częścią ścieżki bezwzględnej i dlatego nie są one segmentów.  
  
 Bezwzględny identyfikator URI:  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm  
  
 Ścieżka bezwzględna:  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Segmenty:  
 - /
 - Rozdziały /
 - Chapter1 /
 - Sekcje /
 - Section1.htm  
  
 Bezwzględny identyfikator URI:  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm#page1?answer=NO  
  
 Ścieżka bezwzględna:  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Segmenty:  
 - /
 - Rozdziały /
 - Chapter1 /
 - Sekcje /
 - Section1.htm  
  
 Należy pamiętać, że, ponieważ ścieżka bezwzględna rozpoczyna się od '/', pierwszy segment zawiera go i od niczego więcej.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienie z 3 segmenty i wyświetla segmenty na ekranie.  
  
 [!code-cpp[NCLUriExamples#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#5)]
 [!code-csharp[NCLUriExamples#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#5)]
 [!code-vb[NCLUriExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiekt zawierający informacje wymagane do wykonywania serializacji <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> obiekt zawierający źródłowe i docelowe serializowanym strumieniu skojarzone z <see cref="T:System.Uri" />.</param>
        <summary>Zwraca dane potrzebne do serializacji bieżącego wystąpienia.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby użyć metody serializacji. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="uri.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera reprezentację kanoniczna ciągu określonego <see cref="T:System.Uri" /> wystąpienia.</summary>
        <returns>A <see cref="T:System.String" /> wystąpienia, które zawiera o niezmienionym znaczeniu canonical reprezentacja <see cref="T:System.Uri" /> wystąpienia. O niezmienionym znaczeniu są wszystkie znaki z wyjątkiem #,? i %.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciąg zwracany przez tę metodę nie zawiera informacje o porcie, gdy port jest domyślnym portem dla schematu.  
  
> [!NOTE]
>  Ciąg zwracany przez <xref:System.Uri.ToString%2A> metoda może zawierać znaków kontrolnych, które mogą doprowadzić do uszkodzenia aplikacji konsoli. Możesz użyć <xref:System.Uri.GetComponents%2A> metody z <xref:System.UriFormat.SafeUnescaped?displayProperty=nameWithType> formatu, aby usunąć znaki kontrolne z zwracanego ciągu.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.Uri> wystąpienia ciągu. Przykład ilustruje różnicę między wartością zwróconą z <xref:System.Uri.OriginalString%2A>, która zwraca ciąg, który został przekazany do konstruktora, a po wywołaniu <xref:System.Uri.ToString%2A>, która zwraca forma kanoniczna ciągu.  
  
 [!code-cpp[NCLUriExamples#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#7)]
 [!code-csharp[NCLUriExamples#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#7)]
 [!code-vb[NCLUriExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#7)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby zapobiec wynikających z częściowo zaufanego kodu <see cref="T:System.Uri" />. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryCreate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Uri" />. Zgłasza wyjątek, jeśli <see cref="T:System.Uri" /> nie można utworzyć.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (string uriString, UriKind uriKind, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(string uriString, valuetype System.UriKind uriKind, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.String,System.UriKind,System.Uri@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(System::String ^ uriString, UriKind uriKind, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : string * UriKind *  -&gt; bool" Usage="System.Uri.TryCreate (uriString, uriKind, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
        <Parameter Name="result" Type="System.Uri" RefType="out" />
      </Parameters>
      <Docs>
        <param name="uriString"><see cref="T:System.String" /> Reprezentujący <see cref="T:System.Uri" />.</param>
        <param name="uriKind">Typ identyfikatora Uri.</param>
        <param name="result">Po powrocie z tej metody zawiera stworzonego elementu <see cref="T:System.Uri" />.</param>
        <summary>Tworzy nową <see cref="T:System.Uri" /> przy użyciu określonego <see cref="T:System.String" /> wystąpienia i <see cref="T:System.UriKind" />.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, która jest <see langword="true" /> Jeśli <see cref="T:System.Uri" /> został pomyślnie utworzony; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta metoda zwraca `true`, nowe <xref:System.Uri> znajduje się w `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, string relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, string relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.String,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As String, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, System::String ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * string *  -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="result" Type="System.Uri" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">Podstawa <see cref="T:System.Uri" />.</param>
        <param name="relativeUri">Względny <see cref="T:System.Uri" />, jest reprezentowana jako <see cref="T:System.String" />, aby dodać do podstawy <see cref="T:System.Uri" />.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.Uri" /> skonstruowany na podstawie <paramref name="baseUri" /> i <paramref name="relativeUri" />. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Tworzy nową <see cref="T:System.Uri" /> przy użyciu określonej podstawie i względna <see cref="T:System.String" /> wystąpień.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, która jest <see langword="true" /> Jeśli <see cref="T:System.Uri" /> został pomyślnie utworzony; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta metoda zwraca `true`, nowe <xref:System.Uri> znajduje się w `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, Uri relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, class System.Uri relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.Uri,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As Uri, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, Uri ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * Uri *  -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
        <Parameter Name="result" Type="System.Uri" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">Podstawa <see cref="T:System.Uri" />.</param>
        <param name="relativeUri">Względny <see cref="T:System.Uri" /> do dodania do podstawy <see cref="T:System.Uri" />.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.Uri" /> skonstruowany na podstawie <paramref name="baseUri" /> i <paramref name="relativeUri" />. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Tworzy nową <see cref="T:System.Uri" /> przy użyciu określonej podstawie i względna <see cref="T:System.Uri" /> wystąpień.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, która jest <see langword="true" /> Jeśli <see cref="T:System.Uri" /> został pomyślnie utworzony; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta metoda zwraca `true`, nowe <xref:System.Uri> znajduje się w `result`.  
  
 Ta metoda tworzy identyfikator URI, umieszcza go w formie kanonicznej i zweryfikuje go. Jeśli wystąpi nieobsługiwany wyjątek, ta metoda go przechwycił. Jeśli chcesz tworzyć <xref:System.Uri> a wyjątki get, użyj jednej z <xref:System.Uri.%23ctor%2A> konstruktorów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseUri" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="protected virtual string Unescape (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string Unescape(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Unescape (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ Unescape(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member Unescape : string -&gt; string&#xA;override this.Unescape : string -&gt; string" Usage="uri.Unescape path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><see cref="T:System.String" /> Do przekonwertowania.</param>
        <summary>Konwertuje określony ciąg, zastępując wszystkie sekwencje ucieczki ich reprezentacji o niezmienionym znaczeniu.</summary>
        <returns>A <see cref="T:System.String" /> zawierający wartości o niezmienionym znaczeniu <paramref name="path" /> parametru.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnescapeDataString">
      <MemberSignature Language="C#" Value="public static string UnescapeDataString (string stringToUnescape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UnescapeDataString(string stringToUnescape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.UnescapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnescapeDataString (stringToUnescape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UnescapeDataString(System::String ^ stringToUnescape);" />
      <MemberSignature Language="F#" Value="static member UnescapeDataString : string -&gt; string" Usage="System.Uri.UnescapeDataString stringToUnescape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToUnescape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToUnescape">Ciąg do unescape.</param>
        <summary>Konwertuje ciąg na jego reprezentację o niezmienionym znaczeniu.</summary>
        <returns>A <see cref="T:System.String" /> zawierający reprezentację o niezmienionym znaczeniu <paramref name="stringToUnescape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody należy używać ostrożnie. Ciąg, który został wcześniej o niezmienionym znaczeniu unescaping może prowadzić do niejednoznaczności i błędów.  
  
 Wiele przeglądarek sieci Web ucieczki spacje wewnątrz bloków URI w plus znaków ("+"). Jednak metoda UnescapeDataString nie przekonwertować i znaków do miejsca do magazynowania, ponieważ to zachowanie nie jest standardowy we wszystkich schematach identyfikatora URI.  
  
   
  
## Examples  
 Poniższy przykład kodu unescapes identyfikatora URI, a następnie konwertuje dowolnego i znaków ("+") do miejsca do magazynowania.  
  
 [!code-csharp[NCLUriExamples#19](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stringToUnescape" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Uri.EscapeDataString(System.String)" />
        <altmember cref="M:System.Uri.EscapeUriString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFile">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFile" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFile As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFile;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFile : string" Usage="System.Uri.UriSchemeFile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że identyfikator URI jest wskaźnikiem do pliku. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W programie .NET Framework w wersji 1.1 "`file:///path`"Identyfikator URI została przekonwertowana na"`file:/path`". Zostało to poprawione w wersji 2.0.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy jest to schemat <xref:System.Uri.UriSchemeFile>.  
  
 [!code-cpp[NCLUriExamples#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#10)]
 [!code-csharp[NCLUriExamples#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#10)]
 [!code-vb[NCLUriExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFtp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFtp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFtp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFtp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFtp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFtp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFtp : string" Usage="System.Uri.UriSchemeFtp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że identyfikator URI jest dostępny za pośrednictwem protokołu FTP (File Transfer). To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy jest to schemat <xref:System.Uri.UriSchemeFtp>.  
  
 [!code-cpp[NCLUriExamples#15](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#15)]
 [!code-csharp[NCLUriExamples#15](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#15)]
 [!code-vb[NCLUriExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeGopher">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeGopher;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeGopher" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeGopher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeGopher As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeGopher;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeGopher : string" Usage="System.Uri.UriSchemeGopher" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że identyfikator URI jest dostępny za pośrednictwem protokołu Gopher. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy jest to schemat <xref:System.Uri.UriSchemeGopher>.  
  
 [!code-cpp[NCLUriExamples#14](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#14)]
 [!code-csharp[NCLUriExamples#14](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#14)]
 [!code-vb[NCLUriExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttp : string" Usage="System.Uri.UriSchemeHttp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że identyfikator URI jest dostępny za pośrednictwem protokołu HTTP (Hypertext Transfer). To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy jest to schemat <xref:System.Uri.UriSchemeHttp>.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttps">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttps;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttps" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttps" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttps As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttps;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttps : string" Usage="System.Uri.UriSchemeHttps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że identyfikator URI jest dostępny za pośrednictwem Secure Hypertext Transfer Protocol (HTTPS). To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy jest to schemat <xref:System.Uri.UriSchemeHttps>.  
  
 [!code-cpp[NCLUriExamples#16](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#16)]
 [!code-csharp[NCLUriExamples#16](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#16)]
 [!code-vb[NCLUriExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeMailto">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeMailto;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeMailto" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeMailto" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeMailto As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeMailto;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeMailto : string" Usage="System.Uri.UriSchemeMailto" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że identyfikator URI jest adres e-mail i jest dostępny za pośrednictwem transportu protokołu SMTP (Simple Mail). To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy jest to schemat <xref:System.Uri.UriSchemeMailto>.  
  
 [!code-cpp[NCLUriExamples#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#11)]
 [!code-csharp[NCLUriExamples#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#11)]
 [!code-vb[NCLUriExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetPipe">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetPipe;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetPipe" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetPipe" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetPipe As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetPipe;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetPipe : string" Usage="System.Uri.UriSchemeNetPipe" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że identyfikator URI jest dostępny za pośrednictwem schematu NetPipe używane przez Windows Communication Foundation (WCF). To pole jest tylko do odczytu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetTcp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetTcp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetTcp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetTcp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetTcp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetTcp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetTcp : string" Usage="System.Uri.UriSchemeNetTcp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że identyfikator URI jest dostępny za pośrednictwem schematu NetTcp używane przez Windows Communication Foundation (WCF). To pole jest tylko do odczytu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNews">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNews;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNews" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNews" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNews As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNews;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNews : string" Usage="System.Uri.UriSchemeNews" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że identyfikator URI jest grupa wiadomości Internet, a następnie odbywa się za pomocą transportu protokołu NNTP (Network News). To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy jest to schemat <xref:System.Uri.UriSchemeNews>.  
  
 [!code-cpp[NCLUriExamples#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#12)]
 [!code-csharp[NCLUriExamples#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#12)]
 [!code-vb[NCLUriExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNntp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNntp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNntp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNntp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNntp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNntp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNntp : string" Usage="System.Uri.UriSchemeNntp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że identyfikator URI jest grupa wiadomości Internet, a następnie odbywa się za pomocą transportu protokołu NNTP (Network News). To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 NNTP <xref:System.Uri> analizy błędów w programie .NET Framework w wersji 1.1 zostały skorygowane.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy jest to schemat <xref:System.Uri.UriSchemeNntp>.  
  
 [!code-cpp[NCLUriExamples#13](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#13)]
 [!code-csharp[NCLUriExamples#13](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#13)]
 [!code-vb[NCLUriExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserEscaped">
      <MemberSignature Language="C#" Value="public bool UserEscaped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UserEscaped" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserEscaped" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserEscaped As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UserEscaped { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserEscaped : bool" Usage="System.Uri.UserEscaped" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, że ciąg identyfikatora URI został całkowicie poprzedzone znakiem zmiany znaczenia przed <see cref="T:System.Uri" /> wystąpienie zostało utworzone.</summary>
        <value>A <see cref="T:System.Boolean" /> wartość, która jest <see langword="true" /> Jeśli <paramref name="dontEscape" /> ustawiono parametr <see langword="true" /> podczas <see cref="T:System.Uri" /> wystąpienia został utworzony; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.UserEscaped%2A> Właściwość jest ustawiona na `true` do wskazania, że ten ciąg jest używany do tworzenia <xref:System.Uri> wystąpienie zostało całkowicie poprzedzone znakiem zmiany znaczenia zanim został przekazany do konstruktora; czyli, `dontEscape` ustawionoparametrwywołaniakonstruktora`true`.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy jego został w pełni poprzedzone znakiem zmiany znaczenia podczas jej tworzenia.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInfo">
      <MemberSignature Language="C#" Value="public string UserInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserInfo" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserInfo { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInfo : string" Usage="System.Uri.UserInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę użytkownika, hasła lub inne informacje specyficzne dla użytkownika skojarzonego z określonym identyfikatorem URI.</summary>
        <value>Element <see cref="T:System.String" /> zawierający informacje o użytkowniku, skojarzony z identyfikatora URI. Zwracana wartość nie obejmuje "\@" znaku zarezerwowanego rozdzielający część informacji użytkownika identyfikatora URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę właściwość jest zwykle w formacie "nazwa_użytkownika: hasło".  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i zapisuje informacje o użytkowniku do konsoli.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość jest prawidłowy tylko w przypadku bezwzględne identyfikatorów URI.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
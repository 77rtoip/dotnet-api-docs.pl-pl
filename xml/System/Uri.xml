<Type Name="Uri" FullName="System.Uri">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a7cda0f169fd0f3565aa706bd9a109f77f3a9d22" />
    <Meta Name="ms.sourcegitcommit" Value="e1a8d081ac69395d1e6c5d5b8f4176252dc2a495" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/26/2018" />
    <Meta Name="ms.locfileid" Value="36947831" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Uri : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Uri extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Uri" />
  <TypeSignature Language="VB.NET" Value="Public Class Uri&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Uri : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Uri = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.UriTypeConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Umożliwia reprezentowanie obiektów za pomocą jednolitych identyfikatorów zasobów (URI) oraz łatwy dostęp do elementów identyfikatorów URI.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator URI jest compact reprezentacja zasobu dostępne dla aplikacji w intranecie lub Internecie. <xref:System.Uri> Klasa definiuje właściwości i metody obsługi identyfikatorów URI, w tym analizy, porównanie i połączenie. <xref:System.Uri> Właściwości klasy są tylko do odczytu, aby utworzyć obiekt można modyfikować przy użyciu <xref:System.UriBuilder> klasy.  
  
 Względne identyfikatory URI (na przykład "/ new/index.htm") musi być rozwinięty w odniesieniu do podstawowego identyfikatora URI, dzięki czemu są one bezwzględną. <xref:System.Uri.MakeRelative%2A> Metody podano Aby przekonwertować bezwzględny identyfikator URI względne identyfikatory URI, gdy jest to konieczne.  
  
 <xref:System.Uri> Konstruktorów ucieczki nie parametry identyfikatora URI, jeśli ciąg jest poprawnie sformułowanym identyfikatorem URI, w tym identyfikator schematu.  
  
 <xref:System.Uri> Właściwości zwracają reprezentację danych canonical w kodowaniu zmienionym z wszystkich znaków Unicode wartości większej niż 127 zastąpione ich szesnastkowych. Aby put identyfikator URI w formie kanonicznej <xref:System.Uri> Konstruktor wykonuje następujące czynności:  
  
-   Konwertuje schemat identyfikatora URI na małe litery.  
  
-   Konwertuje nazwę hosta na małe litery.  
  
-   Jeśli nazwa hosta jest adres IPv6, kanonicznej adres IPv6 jest używany. Właściwości ScopeId i inne opcjonalne dane IPv6 zostały usunięte.  
  
-   Usuwa domyślne i numery portów puste.

-   Zmienionym znaków (znanej także jako procent, kodowane w oktetach), które nie mają zastrzeżone cel są dekodowane (znanej także jako trwa niezmienionym znaczeniu). Te znaki bezwarunkowe zawierać wielkie i łącznika cyfr dziesiętnych (30-% 39), małe litery (% 41-% 5A i % 7A 61%) (% 2D), okres (% 2E), podkreślenia (% 5F), a tylda (% 7E).

-   Canonicalizes Ścieżka hierarchiczna identyfikatory URI przez sekwencje kompaktowania takich jak /. /, /... /, a / / (określa, czy sekwencja została zmieniona). Należy pamiętać, że niektóre systemy, dla których nie są kompaktowanie tych sekwencji.
  
-   Hierarchiczna identyfikatory URI Jeśli host nie jest zakończony ukośnikiem (/), dodaniu.  
  
-   Domyślnie wszystkie zastrzeżone znaki w identyfikatorze URI są anulowane zgodnie z RFC 2396. Jeśli identyfikatory zasobów międzynarodowej lub międzynarodowe nazwy domeny podczas analizowania jest włączona w których wielkość znaków zastrzeżonych w identyfikatorze URI tej zmiany zachowania są anulowane zgodnie z RFC 3986 i RFC 3987.

 W ramach zapewniania kanoniczności w Konstruktorze niektóre systemy, stanowi segmenty kropka i pusty (/. /, /... /, a / /) są kompaktowanie (innymi słowy, zostaną usunięte). Schematy, dla których URI kompaktuje te sekwencje obejmują http, https tcp, net.pipe i net.tcp. Dla innych systemów nie są kompaktowanie tych sekwencji. Oto tego kompaktowania wyglądu w praktyce.
  
```  
var uri = new Uri("http://myUrl/../.."); // http scheme, unescaped
OR
var uri = new Uri("http://myUrl/%2E%2E/%2E%2E"); // http scheme, escaped
OR
var uri = new Uri("ftp://myUrl/../.."); // ftp scheme, unescaped
OR
var uri = new Uri("ftp://myUrl/%2E%2E/%2E%2E"); // ftp scheme, escaped

Console.WriteLine(uri.AbsoluteUri);  
Console.WriteLine(uri.PathAndQuery);  
```  
  
 Po wykonaniu tego kodu zwraca następujące dane wyjściowe o zmienionym znaczeniu sekwencji niezmienionym znaczeniu, w razie potrzeby, a następnie skompaktować.

```  
http://myUrl/  
/  
```  
  
 Zawartość można przekształcać <xref:System.Uri> klasy z ucieczki kodowany identyfikator URI odwołania do odwołania do identyfikatora URI do odczytu za pomocą <xref:System.Uri.ToString%2A> metody. Należy pamiętać, że niektóre zastrzeżone znaki mogą nadal być znaki ucieczki w danych wyjściowych <xref:System.Uri.ToString%2A> metody. To jest zapewnienie pomocy technicznej jednoznaczne odbudowy identyfikatora URI z wartością zwróconą przez <xref:System.Uri.ToString%2A>.  
  
 Niektóre identyfikatory URI zawierać fragmentu identyfikatora zapytania i/lub. Identyfikator fragmentu jest tekst znajdujący się znakiem numeru (#), nie włączając znak liczby; tekst fragment jest przechowywany w <xref:System.Uri.Fragment%2A> właściwości. Badanie informacji jest tekstu, który następuje znak zapytania (?) w identyfikatorze URI; Tekst zapytania jest przechowywany w <xref:System.Uri.Query%2A> właściwości.  
  
 W programie .NET Framework w wersji 1.1, jeśli ciąg określony konstruktora zawiera nieznany schemat i "c:\\", identyfikator Uri wstawia klasy "/ /" po dwukropkiem. Na przykład identyfikator URI `xyz:c:\abc` jest konwertowana na `xyz://c:/abc`. W programie .NET Framework w wersji 2.0, ten problem został usunięty i jest przekonwertowanie ciągu na przykład `xyz:c:/abc`.  
  
> [!NOTE]
>  Klasa URI obsługuje adresów IP w notacji zarówno quad dla protokołu IPv4 i dwukropka szesnastkowy dla protokołu IPv6. Należy pamiętać załączyć adres IPv6 w nawiasach kwadratowych, tak jak http://[::1].  
  
## <a name="international-resource-identifier-support"></a>Obsługa identyfikatorów zasobów międzynarodowych  
 Adresy sieci Web są zazwyczaj podawana przy użyciu identyfikatorów URI, które składają się z bardzo ograniczony zestaw znaków:  
  
-   Wielkie i małe litery ASCII litery z alfabetu angielskiego.  
  
-   Cyfry z przedziału od 0 do 9.  
  
-   Mała liczba innych symboli ASCII.  
  
 Specyfikacje identyfikatory URI są udokumentowane w RFC 2396, RFC 2732 RFC 3986 i RFC 3987 opublikowane przez Internet Engineering Task Force (IETF).  
  
 Rozwój Internetu jest rośnie potrzeba zidentyfikuj zasoby przy użyciu języków innych niż angielski. Identyfikatory, które ułatwiają te wymagania i zezwalać na znaki spoza zestawu ASCII (znaki w zestawie znaków Unicode/ISO 10646) są nazywane międzynarodowej identyfikatory zasobów (IRIs). Specyfikacje tęczówki są udokumentowane w 3987 RFC opublikowanych przez grupę roboczą IETF. Przy użyciu IRIs umożliwia adres URL zawiera znaki Unicode.  
  
 Istniejące <xref:System.Uri> klasy został rozszerzony w .NET Framework w wersji 3.5, 3.0 z dodatkiem SP1 i 2.0 z dodatkiem SP1 w celu zapewnienia obsługi IRI oparte na RFC 3987. Użytkownicy wersji systemu .NET Framework, przed wersji 4.5 nie będą widzieli zmiany z zachowaniem .NET Framework 2.0, chyba że jawnie włączyć IRI. Dzięki temu zgodność aplikacji we wcześniejszych wersjach programu .NET Framework.  
  
 Aby włączyć obsługę IRI, konieczne jest następujące zmiany:  
  
-   Określ, czy mają być stosowane podczas analizowania międzynarodowych nazw domen (IDN) na nazwę domeny i czy powinny być stosowane IRI podczas analizowania reguły. Można to zrobić *machine.config* lub *app.config* pliku. Na przykład dodać następujące czynności:  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 Użytkownicy platformy .NET Framework 4.5 i nowszych zawsze mają IRI włączone. Podczas analizowania IRI nie można zmienić za pomocą *.config* pliku.  
  
 Włączanie IDN przekonwertuje wszystkich etykiet Unicode w domenie o nazwie odpowiedniki ciąg Punycode. Ciąg Punycode nazwy zawierają tylko znaki ASCII i zawsze rozpoczyna się od prefiksu xn--. Przyczyną tego jest do obsługi istniejących serwerów DNS w Internecie, ponieważ większość serwery DNS obsługują tylko znaki ASCII (zobacz dokument RFC 3940).  
  
 Włączenie IRI i IDN ma wpływ na wartość <xref:System.Uri.DnsSafeHost%2A?displayProperty=nameWithType> właściwości. Włączenie IRI i IDN można również zmienić zachowanie <xref:System.Uri.Equals%2A>, <xref:System.Uri.OriginalString%2A>, <xref:System.Uri.GetComponents%2A>, i <xref:System.Uri.IsWellFormedOriginalString%2A> metody.  
  
 Istnieją trzy możliwe wartości IDN w zależności od serwerów DNS, które są używane:  
  
-   IDN włączone = All  
  
     Ta wartość przekonwertuje wszystkie nazwy domen Unicode odpowiedniki Punycode (nazwy IDN).  
  
-   IDN włączone = AllExceptIntranet  
  
     Ta wartość przekonwertuje wszystkie nazwy domen Unicode nie w lokalnym intranecie używania odpowiedniki Punycode (nazwy IDN). W takim przypadku do obsługi międzynarodowe nazwy w lokalnym intranecie, serwery DNS, które będą używane dla dostępu z intranetu powinien obsługiwać rozpoznawania nazw Unicode.  
  
-   IDN włączone = Brak  
  
     Ta wartość nie przekonwertuje wszystkie nazwy domen Unicode do użycia Punycode. Jest to wartość domyślna, zgodnie z zachowania programu .NET Framework 2.0.  
  
 Po włączeniu analizowania IRI (iriParsing włączone = `true`) normalizacji i sprawdzanie znak są wykonywane zgodnie z najnowszą regułami IRI w dokumencie RFC 3986 i RFC 3987. Podczas analizowania IRI jest wyłączone, normalizacji i sprawdzanie znak są wykonywane zgodnie z RFC 2396 i RFC 2732 (dla literałów IPv6).  W wersjach programu .NET Framework, przed wersji 4.5, wartością domyślną jest `false`. W .NET Framework w wersji 4.5 lub nowszej, wartością domyślną jest `true`, i włączony stan IRI analizowania nie można zmodyfikować przez ustawienia *.config* pliku.  
  
 IRI i IDN przetwarzania w <xref:System.Uri> klasy można także kontrolować przy użyciu <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType>, <xref:System.Configuration.IdnElement?displayProperty=nameWithType>, i <xref:System.Configuration.UriSection?displayProperty=nameWithType> klasy ustawień konfiguracji. <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> Ustawienie włącza lub wyłącza IRI przetwarzania w <xref:System.Uri> klasy. <xref:System.Configuration.IdnElement?displayProperty=nameWithType> Ustawienie włącza lub wyłącza IDN przetwarzania w <xref:System.Uri> klasy. <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> Ustawienie również pośrednio steruje IDN. Przetwarzanie IRI musi być włączona dla przetwarzania w celu umożliwienia IDN. Po wyłączeniu przetwarzania IRI przetwarzania IDN zostanie ustawiona do ustawienie domyślne, których zachowanie programu .NET Framework 2.0 jest używany dla zgodności i nazwy IDN nie są używane.  
  
 Ustawienia konfiguracji dla <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> i <xref:System.Configuration.IdnElement?displayProperty=nameWithType> zostaną odczytane raz po pierwszym <xref:System.Uri?displayProperty=nameWithType> klasy jest tworzony. Zmiany ustawień konfiguracji po tym czasie są ignorowane.  
  
 <xref:System.GenericUriParser?displayProperty=nameWithType> Również został rozszerzony klasa umożliwia tworzenie można dostosowywać analizator obsługującego IRI i IDN. Zachowanie <xref:System.GenericUriParser?displayProperty=nameWithType> obiektu jest określona przez przekazanie bitowe połączenie wartości, które są dostępne w <xref:System.GenericUriParserOptions?displayProperty=nameWithType> wyliczeniu, aby <xref:System.GenericUriParser?displayProperty=nameWithType> konstruktora. <xref:System.GenericUriParserOptions.IriParsing?displayProperty=nameWithType> Typ wskazuje parser obsługuje podczas analizowania reguły, określona w dokumencie RFC 3987 dla identyfikatorów zasobów międzynarodowych (IRI). Czy jest używana IRI ustawieniem wartości konfiguracji omówionych wcześniej.  
  
 <xref:System.GenericUriParserOptions.Idn?displayProperty=nameWithType> Typ wskazuje parser obsługuje nazwę domeny (IDN) podczas analizowania (IDN) nazw hostów. Czy jest używana IDN ustawieniem wartości konfiguracji omówionych wcześniej.  
  
## <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 Jeśli używasz *Web.config * plik, który zawiera identyfikatory URI w celu zainicjowania czasu aplikacji, dodatkowe jest wymagana do przetwarzania identyfikatory URI, jeśli ich identyfikatorów schematu są niestandardowe. W takim przypadku zainicjować częściami aplikacji, gdy identyfikatory URI są niezbędne w czasie rozpoczęcia.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Uri> klasy i używa jej do utworzenia <xref:System.Net.WebRequest> wystąpienia.  
  
 [!code-cpp[Classic Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>Ze względów bezpieczeństwa aplikacji należy zachować ostrożność podczas akceptowania <see cref="T:System.Uri" /> wystąpień ze źródeł niezaufanych i z <paramref name="dontEscape" /> ustawioną <see langword="true" />. Ciąg URI poprawność można sprawdzić przez wywołanie metody <see cref="M:System.Uri.IsWellFormedOriginalString" /> metody.</para>
    </block>
    <altmember cref="T:System.Configuration.IdnElement" />
    <altmember cref="T:System.Configuration.IriParsingElement" />
    <altmember cref="T:System.Configuration.UriSection" />
    <altmember cref="P:System.Uri.DnsSafeHost" />
    <altmember cref="M:System.Uri.MakeRelative(System.Uri)" />
    <altmember cref="M:System.Uri.IsWellFormedOriginalString" />
    <altmember cref="T:System.UriBuilder" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Uri" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString);" />
      <MemberSignature Language="F#" Value="new Uri : string -&gt; Uri" Usage="new System.Uri uriString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriString">Ciąg identyfikujący zasób może być reprezentowana przez <see cref="T:System.Uri" /> wystąpienia. Należy pamiętać, że adres IPv6 w postaci ciągu musi być ujęta w nawiasy kwadratowe. Na przykład "http://[2607:f8b0:400d:c06::69]".</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Uri" /> klasy z określonym identyfikatorem URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy <xref:System.Uri> wystąpienie ciągu identyfikatora URI. Go analizuje identyfikator URI, umieszcza je w formacie kanonicznej i sprawia, że wszystkie wymagane specjalne kodowania.  
  
 Ten konstruktor nie upewnij się, że <xref:System.Uri> odwołuje się do zasobem.  
  
 Ten konstruktor przy założeniu, że `string` parametr odwołuje się do bezwzględnym identyfikatorem URI i jest odpowiednikiem wywołania <xref:System.Uri.%23ctor%2A> konstruktora z <xref:System.UriKind> ustawioną <xref:System.UriKind.Absolute>. Jeśli `string` parametr przekazany do konstruktora jest względnym identyfikatorem URI, zgłosi ten konstruktor <xref:System.UriFormatException>.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia o identyfikatorze URI "http://www.contoso.com/".  
  
 [!code-cpp[Classic Uri.Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>[.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.FormatException" />zamiast.</para>
          </block>
          <paramref name="uriString" /> jest pusta.  - lub - schemat określony w <paramref name="uriString" /> nie jest poprawnie sformułowany. Zobacz <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  - lub - <paramref name="uriString" /> zawiera zbyt wiele ukośniki.  - lub - hasło określone w <paramref name="uriString" /> jest nieprawidłowy.  - lub - nazwa hosta określona w <paramref name="uriString" /> jest nieprawidłowy.  - lub - nazwa pliku określona w <paramref name="uriString" /> jest nieprawidłowy.  - lub - nazwa użytkownika określona w <paramref name="uriString" /> jest nieprawidłowy.  - lub - nazwa hosta lub urząd określona w <paramref name="uriString" /> nie może być zakończona ukośników odwrotnych.  określony numer portu w - lub - <paramref name="uriString" /> jest nieprawidłowa lub nie można przeanalizować.  - lub - długość <paramref name="uriString" /> przekracza 65519 znaków.  - lub - długość schemat określone w <paramref name="uriString" /> przekracza 1023 znaków.  - lub - brak nieprawidłową sekwencję znaków w <paramref name="uriString" />.  - lub - MS-DOS ścieżce określonej w <paramref name="uriString" /> musi rozpoczynać się od c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Uri (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Uri(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new Uri : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Uri" Usage="new System.Uri (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Wystąpienie <see cref="T:System.Runtime.Serialization.SerializationInfo" /> klasa zawierająca informacje wymagane do serializacji nowej <see cref="T:System.Uri" /> wystąpienia.</param>
        <param name="streamingContext">Wystąpienie <see cref="T:System.Runtime.Serialization.StreamingContext" /> klasa zawierająca źródła serializowanym strumieniu skojarzone z nowym <see cref="T:System.Uri" /> wystąpienia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Uri" /> klasy z wystąpienia określonego <see cref="T:System.Runtime.Serialization.SerializationInfo" /> i <see cref="T:System.Runtime.Serialization.StreamingContext" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor implementuje <xref:System.Runtime.Serialization.ISerializable> interfejs na potrzeby <xref:System.Uri> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serializationInfo" /> Zawiera parametr <see langword="null" /> identyfikatora URI.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="serializationInfo" /> Parametr zawiera identyfikator URI, który jest pusty.  - lub - określony schemat jest nieprawidłowo sformułowany. Zobacz <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  - lub - identyfikator URI zawiera zbyt wiele ukośniki.  - lub - hasło określone w identyfikatorze URI jest nieprawidłowy.  - lub - nazwa hosta określona w identyfikatorze URI nie jest prawidłowy.  - lub - nazwa pliku określona w identyfikatorze URI nie jest prawidłowy.  - lub - nazwa użytkownika określona w identyfikatorze URI nie jest prawidłowy.  - lub - nazwa hosta lub urząd określona w identyfikatorze URI nie może zostać rozwiązana przez ukośników odwrotnych.  - lub - określony w identyfikatorze URI numer portu jest nieprawidłowy lub nie można przeanalizować.  - lub - 65519 znaków przekracza długość identyfikatora URI.  - lub - schematu określony w identyfikatorze URI jest dłuższa niż 1023 znaków.  - lub - brak nieprawidłową sekwencję znaków w identyfikatorze URI.  Ścieżka systemu MS-DOS określony w identyfikatorze URI musi zaczynać się od c: - lub -\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : string * bool -&gt; Uri" Usage="new System.Uri (uriString, dontEscape)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="uriString">Ciąg identyfikujący zasób może być reprezentowana przez <see cref="T:System.Uri" /> wystąpienia. Należy pamiętać, że adres IPv6 w postaci ciągu musi być ujęta w nawiasy kwadratowe. Na przykład "http://[2607:f8b0:400d:c06::69]".</param>
        <param name="dontEscape">
          <see langword="true" /> Jeśli <c>uriString</c> jest całkowicie zmieniony; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Uri" /> klasy z określonego identyfikatora URI za pomocą formantu jawne znaku ucieczki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy <xref:System.Uri> wystąpienie ciągu identyfikatora URI. Analizuje identyfikator URI, a umieszczenie go w formacie kanonicznej.  
  
 `dontEscape` Parametr określa czy zastrzeżone znaki są tłumaczone w sekwencjach specjalnych. Ten parametr powinien mieć ustawioną `true` tylko jeśli masz pewność, że wszystkie zastrzeżone znaki w identyfikatorze URI zostały zmienione znaczenie. Ustawienie wartości `true` dla identyfikatora URI, który nie został całkowicie wyjściowym może spowodować nieoczekiwane zachowanie. Zalecane jest zawsze wartość tego parametru `false`.  
  
 Jeśli `dontEscape` ma ustawioną wartość `false`, konstruktora specjalne znaków zarezerwowanych sprawdzając wszystkie wystąpienia znaku procentu (%) następują Nieprawidłowa sekwencja. Jeśli sekwencja znaków po procent nie jest prawidłowy, wartość procentowa jest zastępowany przez % 25.  
  
 Ten konstruktor nie upewnij się, że <xref:System.Uri> odwołuje się do zasobem.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia dla identyfikatora URI http://www.contoso.com/Hello%20World.htm. Ponieważ identyfikator URI zawartych w niej całkowicie została zmieniona i jest w formie kanonicznej `dontEscape` można ustawić parametru `true`.  
  
 [!code-cpp[Classic Uri.Uri1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="uriString" /> jest pusta lub zawiera tylko spacje.  - lub - schemat określone w <paramref name="uriString" /> jest nieprawidłowy.  - lub - <paramref name="uriString" /> zawiera zbyt wiele ukośniki.  - lub - hasło określone w <paramref name="uriString" /> jest nieprawidłowy.  - lub - nazwa hosta określona w <paramref name="uriString" /> jest nieprawidłowy.  - lub - nazwa pliku określona w <paramref name="uriString" /> jest nieprawidłowy.  - lub - nazwa użytkownika określona w <paramref name="uriString" /> jest nieprawidłowy.  - lub - nazwa hosta lub urząd określona w <paramref name="uriString" /> nie może być zakończona ukośników odwrotnych.  określony numer portu w - lub - <paramref name="uriString" /> jest nieprawidłowa lub nie można przeanalizować.  - lub - długość <paramref name="uriString" /> przekracza 65519 znaków.  - lub - długość schemat określone w <paramref name="uriString" /> przekracza 1023 znaków.  - lub - brak nieprawidłową sekwencję znaków w <paramref name="uriString" />.  - lub - MS-DOS ścieżce określonej w <paramref name="uriString" /> musi rozpoczynać się od c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="new Uri : string * UriKind -&gt; Uri" Usage="new System.Uri (uriString, uriKind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">Ciąg identyfikujący zasób może być reprezentowana przez <see cref="T:System.Uri" /> wystąpienia. Należy pamiętać, że adres IPv6 w postaci ciągu musi być ujęta w nawiasy kwadratowe. Na przykład "http://[2607:f8b0:400d:c06::69]".</param>
        <param name="uriKind">Określa ciąg identyfikatora URI jest względnym identyfikatorem URI, bezwzględnym identyfikatorem URI, lub jest nieokreślony.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Uri" /> klasy z określonym identyfikatorem URI. Ten konstruktor umożliwia określenie, czy ciąg identyfikatora URI jest względnym identyfikatorem URI, bezwzględnym identyfikatorem URI, czy jest nieokreślony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Względne i bezwzględny identyfikator URI mają różne ograniczenia na ich format. Na przykład względny identyfikator URI nie wymaga schemat lub urzędu. Wartość określona w `uriKind` musi odpowiadać typowi identyfikatora URI przekazane `uriString`. Jednak jeśli <xref:System.UriKind.RelativeOrAbsolute> określono ciągu identyfikatora URI może być względna lub bezwzględna.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="uriKind" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>[.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.FormatException" />zamiast.</para>
          </block>
          <paramref name="uriString" /> zawiera względnym identyfikatorem URI i <paramref name="uriKind" /> jest <see cref="F:System.UriKind.Absolute" />.  lub <paramref name="uriString" /> zawiera bezwzględnym identyfikatorem URI i <paramref name="uriKind" /> jest <see cref="F:System.UriKind.Relative" />.  lub <paramref name="uriString" /> jest pusta.  - lub - schemat określony w <paramref name="uriString" /> nie jest poprawnie sformułowany. Zobacz <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  - lub - <paramref name="uriString" /> zawiera zbyt wiele ukośniki.  - lub - hasło określone w <paramref name="uriString" /> jest nieprawidłowy.  - lub - nazwa hosta określona w <paramref name="uriString" /> jest nieprawidłowy.  - lub - nazwa pliku określona w <paramref name="uriString" /> jest nieprawidłowy.  - lub - nazwa użytkownika określona w <paramref name="uriString" /> jest nieprawidłowy.  - lub - nazwa hosta lub urząd określona w <paramref name="uriString" /> nie może być zakończona ukośników odwrotnych.  określony numer portu w - lub - <paramref name="uriString" /> jest nieprawidłowa lub nie można przeanalizować.  - lub - długość <paramref name="uriString" /> przekracza 65519 znaków.  - lub - długość schemat określone w <paramref name="uriString" /> przekracza 1023 znaków.  - lub - brak nieprawidłową sekwencję znaków w <paramref name="uriString" />.  - lub - MS-DOS ścieżce określonej w <paramref name="uriString" /> musi rozpoczynać się od c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseUri">Podstawowy identyfikator URI.</param>
        <param name="relativeUri">Względny identyfikator URI do dodania do podstawowego identyfikatora URI.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Uri" /> klasy na podstawie określonego podstawowy identyfikator URI i względną ciągu identyfikatora URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy <xref:System.Uri> wystąpienia łącząc `baseUri` i `relativeUri`. Jeśli `relativeUri` jest bezwzględnym identyfikatorem URI (zawierający schemat, nazwy hosta i, opcjonalnie, numer portu), <xref:System.Uri> wystąpienia jest tworzony przy użyciu tylko `relativeUri`.  
 
 Jeśli `baseUri` ma względne części (takich jak `/api`), względna musi być zakończony ukośnikiem, a następnie (takich jak `/api/`), jeśli względna `baseUri` mają być zachowane w zbudowany <xref:System.Uri>. 

 Ponadto jeśli `relativeUri` zaczyna się od ukośnika, a następnie spowoduje zastąpienie względną część `baseUri`

 Ten konstruktor nie upewnij się, że <xref:System.Uri> odwołuje się do zasobem.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowe wystąpienie klasy <xref:System.Uri> klasy łącząc względne identyfikatory URI http://www.contoso.com i catalog/shownew.htm do utworzenia bezwzględnym identyfikatorem URI http://www.contoso.com/catalog/shownew.htm.  
  
 [!code-cpp[Classic Uri.Uri3 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri3 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" /> nie jest bezwzględną <see cref="T:System.Uri" /> wystąpienia.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>[.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.FormatException" />, zamiast tego.</para>
          </block> Identyfikator URI utworzony przez połączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest pusta lub zawiera tylko spacje.  - lub - schemat określony w identyfikatorze URI utworzonego przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  - lub - identyfikator URI utworzony przez połączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> zawiera zbyt wiele ukośniki.  - lub - hasło określone w identyfikatorze URI utworzonego przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  Nazwa hosta określona w identyfikatorze URI utworzonego przez łączenie - lub - <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  - lub - nazwa pliku określona w identyfikatorze URI utworzonego przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  Nazwa użytkownika określona w identyfikatorze URI utworzonego przez łączenie - lub - <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  - lub - hosta lub urząd nazwa określona w identyfikatorze URI utworzonego przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> nie może być zakończona ukośników odwrotnych.  numer portu określony w identyfikatorze URI utworzonego przez łączenie - lub - <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowa lub nie można przeanalizować.  - lub - długość identyfikatora URI utworzonego przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> przekracza 65519 znaków.  - lub - długość schemat określony w identyfikatorze URI utworzonego przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> przekracza 1023 znaków.  - lub - brak nieprawidłową sekwencję znaków w identyfikatorze URI utworzonego przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" />.  - lub - MS-DOS ścieżce określonej w <paramref name="uriString" /> musi rozpoczynać się od c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, Uri relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, class System.Uri relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, Uri ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * Uri -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="baseUri">Bezwzględna <see cref="T:System.Uri" /> będący podstawą nowe <see cref="T:System.Uri" /> wystąpienia.</param>
        <param name="relativeUri">Względny <see cref="T:System.Uri" /> wystąpienia, która jest połączona z <c>baseUri</c>.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Uri" /> klasy oparte na kombinacji określonej podstawy <see cref="T:System.Uri" /> wystąpienia i względny <see cref="T:System.Uri" /> wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nowy <xref:System.Uri> wystąpienia łącząc bezwzględnym <xref:System.Uri> wystąpienia, `baseUri`, z względny <xref:System.Uri> wystąpienia, `relativeUri`. Jeśli `relativeUri` jest bezwzględnym <xref:System.Uri> wystąpienia (zawierający schemat, nazwy hosta i, opcjonalnie, numer portu), <xref:System.Uri> wystąpienia jest tworzony przy użyciu tylko `relativeUri`.  
 
 Jeśli `baseUri` ma względne części (takich jak `/api`), względna musi być zakończony ukośnikiem, a następnie (takich jak `/api/`), jeśli względna `baseUri` mają być zachowane w zbudowany <xref:System.Uri>. 

 Ponadto jeśli `relativeUri` zaczyna się od ukośnika, a następnie spowoduje zastąpienie względną część `baseUri`
 
 Ten konstruktor nie upewnij się, że <xref:System.Uri> odwołuje się do zasobem.  
  
   
  
## Examples  
 W tym przykładzie jest tworzony bezwzględnym <xref:System.Uri> wystąpienia, `absoluteUri`i względny <xref:System.Uri> wystąpienia, `relativeUri`. Nowy <xref:System.Uri> wystąpienia, `combinedUri`, zostanie utworzona z tych dwóch wystąpień.  
  
 [!code-cpp[NCLUriEnhancements#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#2)]
 [!code-csharp[NCLUriEnhancements#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#2)]
 [!code-vb[NCLUriEnhancements#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="baseUri" /> nie jest bezwzględną <see cref="T:System.Uri" /> wystąpienia.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" /> nie jest bezwzględną <see cref="T:System.Uri" /> wystąpienia.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>[.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.FormatException" />, zamiast tego.</para>
          </block> Identyfikator URI utworzony przez połączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest pusta lub zawiera tylko spacje.  - lub - schemat określony w identyfikatorze URI utworzonego przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  - lub - identyfikator URI utworzony przez połączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> zawiera zbyt wiele ukośniki.  - lub - hasło określone w identyfikatorze URI utworzonego przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  Nazwa hosta określona w identyfikatorze URI utworzonego przez łączenie - lub - <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  - lub - nazwa pliku określona w identyfikatorze URI utworzonego przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  Nazwa użytkownika określona w identyfikatorze URI utworzonego przez łączenie - lub - <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  - lub - hosta lub urząd nazwa określona w identyfikatorze URI utworzonego przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> nie może być zakończona ukośników odwrotnych.  numer portu określony w identyfikatorze URI utworzonego przez łączenie - lub - <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowa lub nie można przeanalizować.  - lub - długość identyfikatora URI utworzonego przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> przekracza 65519 znaków.  - lub - długość schemat określony w identyfikatorze URI utworzonego przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> przekracza 1023 znaków.  - lub - brak nieprawidłową sekwencję znaków w identyfikatorze URI utworzonego przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" />.  - lub - MS-DOS ścieżce określonej w <paramref name="uriString" /> musi rozpoczynać się od c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string * bool -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri, dontEscape)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="baseUri">Podstawowy identyfikator URI.</param>
        <param name="relativeUri">Względny identyfikator URI do dodania do podstawowego identyfikatora URI.</param>
        <param name="dontEscape">
          <see langword="true" /> Jeśli <c>uriString</c> jest całkowicie zmieniony; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Uri" /> klasy oparte na określonej podstawowej i względne identyfikatory URI, za pomocą formantu jawne znaku ucieczki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy <xref:System.Uri> wystąpienia łącząc `baseUri` i `relativeUri`. Jeśli identyfikator URI przekazane `relativeUri` jest bezwzględnym identyfikatorem URI (zawierający schemat, nazwy hosta i, opcjonalnie, numer portu), <xref:System.Uri> wystąpienia jest tworzony przy użyciu tylko `relativeUri`.  
  
 `dontEscape` Parametr określa czy zastrzeżone znaki są tłumaczone w sekwencjach specjalnych. Ten parametr powinien mieć ustawioną `true` tylko jeśli masz pewność, że wszystkie zastrzeżone znaki w identyfikatorze URI zostały zmienione znaczenie. Ustawienie wartości `true` dla identyfikatora URI, który nie został całkowicie wyjściowym może spowodować nieoczekiwane zachowanie. Zalecane jest zawsze wartość tego parametru `false`. Jeśli `dontEscape` ma ustawioną wartość `false`, konstruktora specjalne znaków zarezerwowanych sprawdzając wszystkie wystąpienia znaku procentu (%) następują Nieprawidłowa sekwencja. Jeśli sekwencja znaków po procent nie jest prawidłowy, wartość procentowa jest zastępowany przez % 25.  
  
 Ten konstruktor nie upewnij się, że <xref:System.Uri> odwołuje się do zasobem.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowe wystąpienie klasy <xref:System.Uri> klasy łącząc względne identyfikatory URI http://www.contoso.com i Hello%20World.htm do utworzenia bezwzględnym identyfikatorem URI.  
  
 [!code-cpp[Classic Uri.Uri4 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri4 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" /> nie jest bezwzględną <see cref="T:System.Uri" /> wystąpienia.</exception>
        <exception cref="T:System.UriFormatException">Identyfikator URI utworzony przez połączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest pusta lub zawiera tylko spacje.  - lub - schemat określony w identyfikatorze URI utworzonego przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  - lub - identyfikator URI utworzony przez połączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> zawiera zbyt wiele ukośniki.  - lub - hasło określone w identyfikatorze URI utworzonego przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  Nazwa hosta określona w identyfikatorze URI utworzonego przez łączenie - lub - <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  - lub - nazwa pliku określona w identyfikatorze URI utworzonego przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  Nazwa użytkownika określona w identyfikatorze URI utworzonego przez łączenie - lub - <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowy.  - lub - hosta lub urząd nazwa określona w identyfikatorze URI utworzonego przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> nie może być zakończona ukośników odwrotnych.  numer portu określony w identyfikatorze URI utworzonego przez łączenie - lub - <paramref name="baseUri" /> i <paramref name="relativeUri" /> jest nieprawidłowa lub nie można przeanalizować.  - lub - długość identyfikatora URI utworzonego przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> przekracza 65519 znaków.  - lub - długość schemat określony w identyfikatorze URI utworzonego przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" /> przekracza 1023 znaków.  - lub - brak nieprawidłową sekwencję znaków w identyfikatorze URI utworzonego przez łączenie <paramref name="baseUri" /> i <paramref name="relativeUri" />.  - lub - MS-DOS ścieżce określonej w <paramref name="uriString" /> musi rozpoczynać się od c:\\\\.</exception>
        <block subset="none" type="usage">
          <para>Ze względów bezpieczeństwa aplikacja należy nie wywołanie tego konstruktora z ciągami identyfikator URI ze źródeł niezaufanych i z <paramref name="dontEscape" /> ustawioną <see langword="true" />. Alternatywnie można sprawdzić poprawność ciągu identyfikatora URI przez wywołanie metody <see cref="M:System.Uri.IsWellFormedOriginalString" /> metody przed wywołaniem tego konstruktora.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AbsolutePath">
      <MemberSignature Language="C#" Value="public string AbsolutePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsolutePath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsolutePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsolutePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsolutePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsolutePath : string" Usage="System.Uri.AbsolutePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę bezwzględnego identyfikatora URI.</summary>
        <value>A <see cref="T:System.String" /> zawierający ścieżka bezwzględna do zasobu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.AbsolutePath%2A> Właściwość zawiera informacje o ścieżce, używany do rozpoznawania żądań, aby uzyskać informacje na serwerze. Zazwyczaj jest to ścieżka do żądanego informacji w systemie plików serwera, chociaż to także oznaczać aplikacji lub skryptu, który serwer musi mieć o podanie informacji.  
  
 Informacje o ścieżce nie ma schematu, nazwa hosta lub części zapytania identyfikatora URI.  
  
   
  
## Examples  
 Poniższy przykład zapisuje /catalog/shownew.htm ścieżki do konsoli.  
  
 [!code-cpp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsolutePath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość dotyczy tylko bezwzględny identyfikator URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="AbsoluteUri">
      <MemberSignature Language="C#" Value="public string AbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsoluteUri As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsoluteUri { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsoluteUri : string" Usage="System.Uri.AbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bezwzględnym identyfikatorem URI.</summary>
        <value>A <see cref="T:System.String" /> zawierające cały identyfikator URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.AbsoluteUri%2A> Właściwości obejmuje cały identyfikator URI przechowywane w <xref:System.Uri> wystąpienia, w tym wszystkie fragmenty i ciągi zapytań.  
  
   
  
## Examples  
 Poniższy przykład zapisuje Pełna zawartość <xref:System.Uri> wystąpienie do konsoli. W przykładzie przedstawionym http://www.contoso.com/catalog/shownew.htm?date=today jest wyświetlony w konsoli.  
  
 [!code-cpp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość dotyczy tylko bezwzględny identyfikator URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Authority">
      <MemberSignature Language="C#" Value="public string Authority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Authority" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Authority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authority As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Authority { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Authority : string" Usage="System.Uri.Authority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę hosta systemu nazw domen (DNS, Domain Name System) lub adres IP i numer portu serwera.</summary>
        <value>A <see cref="T:System.String" /> zawierający składnika wystawcy identyfikatora URI reprezentowanym przez to wystąpienie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Authority%2A> Właściwość jest zwykle nazwa hosta serwera DNS lub adres IP. Ta właściwość może zawierać numeru portu usługi, jeśli jest inny niż domyślny port dla identyfikatora URI. Jeśli <xref:System.Uri.Authority%2A> składnika zawiera zastrzeżone znaki, są one anulowane w wartości ciągu zwracane przez tę właściwość.  
  
   
  
## Examples  
 Poniższy przykład zapisuje nazwy hosta (www.contoso.com) i numer portu (8080) serwera do konsoli.  
  
 [!code-cpp[Classic Uri.Authority Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Authority Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Authority Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Authority Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Authority Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Authority Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość dotyczy tylko bezwzględny identyfikator URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Canonicalize">
      <MemberSignature Language="C#" Value="protected virtual void Canonicalize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Canonicalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Canonicalize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Canonicalize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Canonicalize();" />
      <MemberSignature Language="F#" Value="abstract member Canonicalize : unit -&gt; unit&#xA;override this.Canonicalize : unit -&gt; unit" Usage="uri.Canonicalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje przechowywanych wewnętrznie identyfikatora URI formy kanonicznej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wewnętrznie przechowuje canonical wersji identyfikatora URI.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta metoda jest prawidłowa tylko dla bezwzględny identyfikator URI.</exception>
        <exception cref="T:System.UriFormatException">Identyfikator URI jest niepoprawnie sformułowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="CheckHostName">
      <MemberSignature Language="C#" Value="public static UriHostNameType CheckHostName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UriHostNameType CheckHostName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckHostName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckHostName (name As String) As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UriHostNameType CheckHostName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member CheckHostName : string -&gt; UriHostNameType" Usage="System.Uri.CheckHostName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa hosta do sprawdzania poprawności. Może to być adres IPv4 lub IPv6 lub nazwy hosta w Internecie.</param>
        <summary>Określa, czy określona nazwa hosta jest prawidłową nazwą DNS.</summary>
        <returns>A <see cref="T:System.UriHostNameType" /> wskazujące typ nazwy hosta. Jeśli nie można ustalić typu nazwa hosta lub nazwa hosta jest <see langword="null" /> lub ciągiem o zerowej długości ta metoda zwraca <see cref="F:System.UriHostNameType.Unknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.CheckHostName%2A> Metoda sprawdza, czy podana nazwa hosta ma spełnia wymagania dotyczące prawidłową nazwę hosta Internet. Nie, jednak są wykonywane jest wyszukiwanie nazwy hosta w celu sprawdzenia istnienia hosta.  
  
   
  
## Examples  
 Poniższy przykład sprawdza, czy nazwa hosta jest prawidłowa.  
  
 [!code-cpp[Classic Uri.CheckHostName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.CheckHostName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.CheckHostName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSchemeName">
      <MemberSignature Language="C#" Value="public static bool CheckSchemeName (string schemeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CheckSchemeName(string schemeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSchemeName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckSchemeName (schemeName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CheckSchemeName(System::String ^ schemeName);" />
      <MemberSignature Language="F#" Value="static member CheckSchemeName : string -&gt; bool" Usage="System.Uri.CheckSchemeName schemeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="schemeName">Nazwa schematu do sprawdzania poprawności.</param>
        <summary>Określa, czy nazwa określony schemat jest nieprawidłowy.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, czyli <see langword="true" /> Jeśli nazwa schematu jest prawidłowy; w przeciwnym razie wartość <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza poprawność zgodnie z RFC 2396 domyślnie nazwa schematu. Jeśli włączono międzynarodowej identyfikatory zasobów (IRIs) lub analizowania międzynarodowych nazw domen (IDN), ta metoda sprawdza nazwę schematu dla ważności, zgodnie z RFC 3986. Nazwa schematu musi rozpoczynać się od litery i może zawierać tylko litery, cyfry i znaki ".", "+" lub "-".  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję uwag dla <xref:System.Uri> klasy.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i sprawdza, czy nazwa schematu jest nieprawidłowa.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSecurity">
      <MemberSignature Language="C#" Value="protected virtual void CheckSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CheckSecurity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSecurity" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CheckSecurity ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CheckSecurity();" />
      <MemberSignature Language="F#" Value="abstract member CheckSecurity : unit -&gt; unit&#xA;override this.CheckSecurity : unit -&gt; unit" Usage="uri.CheckSecurity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywołanie tej metody nie ma znaczenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(class System.Uri uri1, class System.Uri uri2, valuetype System.UriComponents partsToCompare, valuetype System.UriFormat compareFormat, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Compare(System.Uri,System.Uri,System.UriComponents,System.UriFormat,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (uri1 As Uri, uri2 As Uri, partsToCompare As UriComponents, compareFormat As UriFormat, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(Uri ^ uri1, Uri ^ uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : Uri * Uri * UriComponents * UriFormat * StringComparison -&gt; int" Usage="System.Uri.Compare (uri1, uri2, partsToCompare, compareFormat, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
        <Parameter Name="partsToCompare" Type="System.UriComponents" />
        <Parameter Name="compareFormat" Type="System.UriFormat" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="uri1">Pierwszy <see cref="T:System.Uri" />.</param>
        <param name="uri2">Drugi <see cref="T:System.Uri" />.</param>
        <param name="partsToCompare">Bitowe połączenie <see cref="T:System.UriComponents" /> wartości, które określa części <c>uri1</c> i <c>uri2</c> do porównania.</param>
        <param name="compareFormat">Jeden z <see cref="T:System.UriFormat" /> wartości, które określa anulowanie znak używany, gdy składniki identyfikatora URI są porównywane.</param>
        <param name="comparisonType">Jeden z <see cref="T:System.StringComparison" /> wartości.</param>
        <summary>Porównuje określonej części dwa identyfikatory URI przy użyciu reguł porównania określony.</summary>
        <returns>
          <see cref="T:System.Int32" /> Wartość, która wskazuje leksykalne relacji między porównany z certyfikatami <see cref="T:System.Uri" /> składników.  
  
 <list type="table"><listheader><term> Wartość </term><description> znaczenie </description></listheader><item><term> mniejsza od zera </term><description><paramref name="uri1" /> jest mniejsza niż <paramref name="uri2" />.  </description></item><item><term> Zero </term><description><paramref name="uri1" /> jest równe <paramref name="uri2" />.  </description></item><item><term> Większa od zera </term><description><paramref name="uri1" /> jest większa niż <paramref name="uri2" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli oba `uri1` i `uri2` są `null`, ta metoda zwraca wartość 0. Porównując wartości identyfikatora URI, względnego identyfikatora URI jest zawsze poniżej bezwzględnym identyfikatorem URI i niezerowy identyfikator URI jest zawsze większa niż pustym identyfikatorem URI. W przypadkach, gdy oba `uri1` i `uri2` nie są `null` oraz zarówno względne identyfikatory URI lub obu bezwzględny identyfikator URI <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> metoda przeprowadza porównanie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> nie jest prawidłową <see cref="T:System.StringComparison" /> wartość.</exception>
      </Docs>
    </Member>
    <Member MemberName="DnsSafeHost">
      <MemberSignature Language="C#" Value="public string DnsSafeHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DnsSafeHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.DnsSafeHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DnsSafeHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DnsSafeHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DnsSafeHost : string" Usage="System.Uri.DnsSafeHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę hosta na które, po trwa niezmienionym znaczeniu w razie potrzeby jest bezpieczny do użycia na potrzeby rozpoznawania nazw DNS.</summary>
        <value>A <see cref="T:System.String" /> zawierający hosta część identyfikatora URI w formacie odpowiednie do rozpoznawania nazw DNS; lub oryginalnego ciągu hosta, jeśli już jest odpowiedni dla rozwiązania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla adresów IPv6, nawiasy kwadratowe są usuwane i <xref:System.Net.IPAddress.ScopeId%2A> właściwość jest ustawiona, jeśli został określony podczas to wystąpienie zostało utworzone.

Jeśli używasz zmienionym ciągu do utworzenia tego wystąpienia (na przykład "http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), następnie DnsSafeHost zwraca ciąg o zmienionym znaczeniu. Unescape wszelkie zmienionym ciąg zwrócony przez `DnsSafeHost` przed użyciem tego ciągu do rozpoznawania nazw DNS (Zobacz przykład). Jeśli użyto nieprawidłowego ciągu niezmienionym znaczeniu do utworzenia tego wystąpienia (na przykład "http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm"), następnie DnsSafeHost zwraca ciąg niezmienionym znaczeniu.
  
 <xref:System.Uri.DnsSafeHost%2A> Właściwość zależy od ustawień konfiguracji, zgodnie z opisem w dalszej części tego tematu. Nie można zmienić ustawienia konfiguracji przez aplikacje ze Sklepu Windows, które mogą prowadzić do niespójnych wyników, korzystając z <xref:System.Uri.DnsSafeHost%2A>. <xref:System.Uri.IdnHost%2A> Właściwość jest dostępna w preferowanym alternatywa dla użycia <xref:System.Uri.DnsSafeHost%2A>, ponieważ <xref:System.Uri.IdnHost%2A> może zawsze być bezpieczne, niezależnie od tego, jakie bieżącego DNS *app.config* ustawienia mogą być.  
  
 <xref:System.Uri.DnsSafeHost%2A> Właściwość został rozszerzony w .NET Framework w wersji 3.5, 3.0 z dodatkiem SP1, a 2.0 z dodatkiem SP1, aby zapewnić międzynarodowej identyfikator zasobów (IRI) obsługuje na podstawie specyfikacji RFC 3987. Bieżąca liczba użytkowników nie będą widzieć wszystkie zmiany z zachowaniem .NET Framework 2.0, chyba że jawnie włączyć IRI. Dzięki temu zgodność aplikacji we wcześniejszych wersjach programu .NET Framework.  
  
 Aby włączyć obsługę IRI, wymagane są następujące zmiany dwóch:  
  
1.  Dodaj następujący wiersz do *machine.config* plik w katalogu .NET Framework 2.0  
  
     \<section name="uri" type="System.Configuration.UriSection, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />  
  
2.  Określ, czy mają być stosowane podczas analizowania międzynarodowych nazw domen (IDN) na nazwę domeny i czy powinny być stosowane IRI podczas analizowania reguły. Można to zrobić *machine.config* lub *app.config* pliku. Na przykład dodać następujące czynności:  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 Włączanie IDN przekonwertuje wszystkich etykiet Unicode w domenie o nazwie odpowiedniki ciąg Punycode. Ciąg Punycode nazwy zawierają tylko znaki ASCII i zawsze rozpoczyna się od prefiksu xn--. Przyczyną tego jest do obsługi istniejących serwerów DNS w Internecie, ponieważ większość serwery DNS obsługują tylko znaki ASCII (zobacz dokument RFC 3940).  
  
 Włączanie IDN wpływa tylko na wartość <xref:System.Uri.DnsSafeHost%2A> właściwości.  
  
 Istnieją trzy możliwe wartości IDN w zależności od serwerów DNS, które są używane:  
  
-   IDN włączone = All  
  
     Ta wartość przekonwertuje wszystkie nazwy domen Unicode odpowiedniki Punycode (nazwy IDN).  
  
-   IDN włączone = AllExceptIntranet  
  
     Ta wartość przekonwertuje wszystkie nazwy domeny Unicode zewnętrznego do użycia Punycode odpowiedniki (nazwy IDN). W takim przypadku do obsługi międzynarodowe nazwy w lokalnym intranecie, serwery DNS, które będą używane dla dostępu z intranetu powinien obsługiwać nazwy Unicode.  
  
-   IDN włączone = Brak  
  
     Ta wartość nie przekonwertuje wszystkie nazwy domen Unicode do użycia Punycode. Jest to wartość domyślna, zgodnie z zachowania programu .NET Framework 2.0.  
  
 Włączenie analizy IRI (iriParsing włączone = `true`) wykona normalizacji i znak sprawdzanie zgodnie z najnowszą IRI reguł w dokumencie RFC 3987. Wartość domyślna to `false` i zostanie nie normalizacji i znak sprawdzanie zgodnie z RFC 2396 i RFC 2732 (dla literałów IPv6).  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję uwag dla <xref:System.Uri> klasy.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia ciągu. Zastosowano różnicy między wartością zwróconą z <xref:System.Uri.Host%2A>, która zwraca nazwę hosta lub adres określony w identyfikatorze URI i wartość zwracana z <xref:System.Uri.DnsSafeHost%2A>, która zwraca adres, który jest bezpieczne programu rozpoznawania nazw DNS.  
  
 [!code-cpp[NCLUriEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#4)]
 [!code-csharp[NCLUriEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#4)]
 [!code-vb[NCLUriEnhancements#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#4)]  

 Zgodnie z objaśnieniem w uwagi, unescape nazwę hosta, przed jego rozwiązania. Można użyć <xref:System.Uri.UnescapeDataString%2A> metodę unescape nazwy hosta, a jego rozwiązaniu przez wywołanie metody <xref:System.Net.Dns.GetHostEntry%2A> metody.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość dotyczy tylko bezwzględny identyfikator URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uri.Equals comparand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand">
          <see cref="T:System.Uri" /> Wystąpienia lub identyfikator URI do porównania z bieżącym wystąpieniem.</param>
        <summary>Porównuje dwa <see cref="T:System.Uri" /> wystąpienia pod kątem równości.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, czyli <see langword="true" /> Jeśli dwa wystąpienia reprezentują ten sam identyfikator URI; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Equals%2A> Metoda porównuje dwa wystąpienia, bez względu na informacje o użytkowniku (<xref:System.Uri.UserInfo%2A>) i fragment (<xref:System.Uri.Fragment%2A>) części, które mogą zawierać. Przykładowo, podana identyfikatory URI http://www.contoso.com/index.htm#search i http://user:password@www.contoso.com/index.htm, <xref:System.Uri.Equals%2A> zwróci metoda `true`.  
  
 Jeśli <xref:System.Uri> wystąpienia został utworzony przy użyciu nazwy hosta Unicode i `comparand` zawiera parametr <xref:System.Uri> wystąpienia lub identyfikator, który został utworzony przy użyciu nazwy hosta, odpowiednik Punycode nazwą hosta będącą, następnie <xref:System.Uri.Equals%2A> zwraca `true` tylko wtedy, gdy obsługa międzynarodowych identyfikator zasobów (IRI) i międzynarodowych nazw domen (IDN) są włączone. Ciąg Punycode nazwy zawierają tylko znaki ASCII i zawsze rozpoczyna się od prefiksu xn--.  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję uwag dla <xref:System.Uri> klasy.  
  
> [!NOTE]
>  W wersji systemu .NET Framework 1.0 i 1.1 <xref:System.Uri.Query%2A> również jest ignorowana.  
  
> [!NOTE]
>  <xref:System.Uri.Equals%2A> Metody może zostać przesłonięta w pochodnej klasie; jako przestępców zamierzających można zmodyfikować metody należy zachować ostrożność. Nie należy używać tej metody do sprawdzania zabezpieczeń, jeśli nie masz pewności, czy to wystąpienie pochodzi z zaufanego źródła.  
  
   
  
## Examples  
 W tym przykładzie tworzy dwa <xref:System.Uri> wystąpień z ciągów i porównuje je, aby określić, czy reprezentują tę samą wartość. `address1` i `address2` są takie same, ponieważ <xref:System.Uri.Fragment%2A> części jest ignorowany dla porównania. Wyniki są zapisywane do konsoli.  
  
 [!code-cpp[NCLUriExamples#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#8)]
 [!code-csharp[NCLUriExamples#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#8)]
 [!code-vb[NCLUriExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#8)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby zapobiec wynikających z częściowo zaufanego kodu <see cref="T:System.Uri" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="protected virtual void Escape ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Escape() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Escape" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Escape ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Escape();" />
      <MemberSignature Language="F#" Value="abstract member Escape : unit -&gt; unit&#xA;override this.Escape : unit -&gt; unit" Usage="uri.Escape " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wszystkie niebezpieczne lub zastrzeżone znaki w składnika ścieżki ich oświadczenia znaków szesnastkowych.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">Identyfikator URI przekazane z konstruktora jest nieprawidłowy. Ten wyjątek może wystąpić, jeśli identyfikator URI ma zbyt wiele znaków lub identyfikator URI jest względny.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeDataString">
      <MemberSignature Language="C#" Value="public static string EscapeDataString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeDataString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeDataString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeDataString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeDataString : string -&gt; string" Usage="System.Uri.EscapeDataString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">Ciąg, aby wyjść.</param>
        <summary>Konwertuje ciąg na jej reprezentację zmienionym znaczeniu.</summary>
        <returns>A <see cref="T:System.String" /> zawierający reprezentację zmienionym <paramref name="stringToEscape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Uri.EscapeDataString%2A> metoda konwertuje wszystkie znaki oprócz RFC 2396 bezwarunkowe znaków na ich szesnastkową reprezentację. Po włączeniu międzynarodowej identyfikatory zasobów (IRIs) lub międzynarodowych nazw domen (IDN) podczas analizowania <xref:System.Uri.EscapeDataString%2A> metoda konwertuje wszystkie znaki oprócz RFC 3986 znaków bezwarunkowe, aby ich szesnastkową reprezentację. Wszystkie znaki Unicode są konwertowane na formacie UTF-8 przed zostanie zmieniona.  
  
 Tę metodę, przy założeniu, że `stringToEscape` nie ma żadnych sekwencji unikowych w go.  
  
 Domyślnie ten ciąg jest wyjściowym zgodnie z RFC 2396. Po włączeniu międzynarodowej identyfikatory zasobów (IRIs) lub międzynarodowych nazw domen (IDN) podczas analizowania ciągu jest wyjściowym zgodnie z RFC 3986 i RFC 3987. Zobacz te dokumenty RFC dla definicji znaków zarezerwowanych i bezwarunkowe.  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję uwag dla <xref:System.Uri> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToEscape" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>[.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.FormatException" />, zamiast tego.</para>
          </block>  Długość <paramref name="stringToEscape" /> przekracza maksymalnie 32 766 znaków.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeString">
      <MemberSignature Language="C#" Value="protected static string EscapeString (string str);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig string EscapeString(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function EscapeString (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::String ^ EscapeString(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member EscapeString : string -&gt; string" Usage="System.Uri.EscapeString str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Ciąg do przekształcenia na jej reprezentację zmienionym znaczeniu.</param>
        <summary>Konwertuje ciąg na jej reprezentację zmienionym znaczeniu.</summary>
        <returns>Zmienionym reprezentację ciągu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.EscapeString%2A> Metoda konwertuje znaki RFC 2396 zastrzeżone i wszystkie znaki o wartości większej niż 127 znaków na szesnastkową reprezentację. Wszystkie znaki Unicode są konwertowane na formacie UTF-8 przed zostanie zmieniona.  
  
 Domyślnie ten ciąg jest wyjściowym zgodnie z RFC 2396. Po włączeniu międzynarodowej identyfikatory zasobów (IRIs) lub międzynarodowych nazw domen (IDN) podczas analizowania ciągu jest wyjściowym zgodnie z RFC 3986 i RFC 3987.  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję uwag dla <xref:System.Uri> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapeUriString">
      <MemberSignature Language="C#" Value="public static string EscapeUriString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeUriString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeUriString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeUriString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeUriString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeUriString : string -&gt; string" Usage="System.Uri.EscapeUriString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">Ciąg, aby wyjść.</param>
        <summary>Konwertuje ciąg identyfikatora URI na jej reprezentację zmienionym znaczeniu.</summary>
        <returns>A <see cref="T:System.String" /> zawierający reprezentację zmienionym <paramref name="stringToEscape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Uri.EscapeUriString%2A> metody, aby przygotować niezmienionym znaczeniu ciągu identyfikatora URI jako parametr <xref:System.Uri.%23ctor%2A> konstruktora.  
  
 Domyślnie <xref:System.Uri.EscapeUriString%2A> metoda konwertuje wszystkie znaki oprócz RFC 2396 znaków bezwarunkowe, do ich szesnastkową reprezentację. Po włączeniu międzynarodowej identyfikatory zasobów (IRIs) lub międzynarodowych nazw domen (IDN) podczas analizowania <xref:System.Uri.EscapeUriString%2A> metoda konwertuje wszystkie znaki oprócz RFC 3986 znaków bezwarunkowe, aby ich szesnastkową reprezentację. Wszystkie znaki Unicode są konwertowane na formacie UTF-8 przed zostanie zmieniona.  
  
 Tę metodę, przy założeniu, że `stringToEscape` nie ma żadnych sekwencji unikowych w go.  
  
 Domyślnie ten ciąg jest wyjściowym zgodnie z RFC 2396. Po włączeniu międzynarodowej identyfikatory zasobów (IRIs) lub międzynarodowych nazw domen (IDN) podczas analizowania ciągu jest wyjściowym zgodnie z RFC 3986 i RFC 3987. Zobacz te dokumenty RFC dla definicji znaków zarezerwowanych i bezwarunkowe.  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję uwag dla <xref:System.Uri> klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToEscape" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>[.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.FormatException" />, zamiast tego.</para>
          </block>  Długość <paramref name="stringToEscape" /> przekracza maksymalnie 32 766 znaków.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fragment">
      <MemberSignature Language="C#" Value="public string Fragment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Fragment" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Fragment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Fragment As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Fragment { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Fragment : string" Usage="System.Uri.Fragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zmienionym fragmentu identyfikatora URI.</summary>
        <value>A <see cref="T:System.String" /> zawiera wszystkie informacje fragmentu identyfikatora URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Fragment%2A> Właściwość pobiera tekst po znacznik fragmentu (#) w identyfikatorze URI, w tym sam znacznik fragmentu. Podany identyfikator URI http://www.contoso.com/index.htm#main, <xref:System.Uri.Fragment%2A> właściwości zwróci #main.  
  
 <xref:System.Uri.Fragment%2A> Właściwość nie jest uwzględniana w dowolnej <xref:System.Uri.Equals%2A> porównania.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i zapisuje te informacje fragmentu w konsoli.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość dotyczy tylko bezwzględny identyfikator URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromHex">
      <MemberSignature Language="C#" Value="public static int FromHex (char digit);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FromHex(char digit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.FromHex(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHex (digit As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FromHex(char digit);" />
      <MemberSignature Language="F#" Value="static member FromHex : char -&gt; int" Usage="System.Uri.FromHex digit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="digit" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="digit">Cyfr szesnastkowych (0-9, a-f, A-F) do konwersji.</param>
        <summary>Pobiera wartość dziesiętna cyfrą szesnastkową.</summary>
        <returns>
          <see cref="T:System.Int32" /> Wartość, która zawiera liczbę z zakresu od 0 do 15, która odpowiada określonym cyfr szesnastkowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.FromHex%2A> Metoda konwertuje znak reprezentujący cyfrą szesnastkową (0-9, a-f, A-F) do wartości dziesiętnej (0-15). Jeśli `digit` nie jest prawidłową cyfrą szesnastkową <xref:System.ArgumentException> wyjątku.  
  
   
  
## Examples  
 Poniższy przykład określa, czy znak jest znaków szesnastkowych, a jeśli tak jest, zapisuje odpowiednie wartości dziesiętnych do konsoli.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="digit" /> nie jest prawidłową cyfrą szesnastkową (0-9, a-f, A-F).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetComponents">
      <MemberSignature Language="C#" Value="public string GetComponents (UriComponents components, UriFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetComponents(valuetype System.UriComponents components, valuetype System.UriFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetComponents(System.UriComponents,System.UriFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetComponents (components As UriComponents, format As UriFormat) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetComponents(UriComponents components, UriFormat format);" />
      <MemberSignature Language="F#" Value="member this.GetComponents : UriComponents * UriFormat -&gt; string" Usage="uri.GetComponents (components, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="components" Type="System.UriComponents" />
        <Parameter Name="format" Type="System.UriFormat" />
      </Parameters>
      <Docs>
        <param name="components">Bitowe połączenie <see cref="T:System.UriComponents" /> wartości, które określa, które części bieżącego wystąpienia, aby powrócić do obiektu wywołującego.</param>
        <param name="format">Jeden z <see cref="T:System.UriFormat" /> wartości, które kontroluje sposób specjalne znaki będą miały zmienione znaczenie.</param>
        <summary>Pobiera określone składniki bieżącego wystąpienia przy użyciu określonego anulowanie w przypadku znaków specjalnych.</summary>
        <returns>A <see cref="T:System.String" /> zawiera składniki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UriComponents.Query>, <xref:System.UriComponents.Fragment>, <xref:System.UriComponents.Scheme>, <xref:System.UriComponents.UserInfo>, <xref:System.UriComponents.Host>, <xref:System.UriComponents.Port>, I <xref:System.UriComponents.Path> składników nie ma ogranicznika. Możesz połączyć ze sobą <xref:System.UriComponents.KeepDelimiter> flagi (przy użyciu bitowego operatora OR) za pomocą dowolnego z tych wartości można pobrać wartości z ogranicznikiem. Dla wszystkich innych <xref:System.UriComponents> wartości i kombinacje wartości, ograniczniki znajdują się w zwracanej wartości.  
  
 Składniki są zwracane w kolejności ich występowania w identyfikatorze URI. Na przykład jeśli <xref:System.UriComponents.Scheme> jest określona, zostanie wyświetlony pierwszy.  
  
 Po włączeniu obsługi międzynarodowej identyfikator zasobów (IRI) i międzynarodowych nazw domen (IDN) liczbę znaków, które są zwracane w <xref:System.String> zwiększa. Nazwy Punycode używane do obsługi IRI zawierać tylko znaki ASCII i zawsze rozpoczyna się od prefiksu xn--. Po włączeniu IRI i IDN Znaki dwuskładnikowe Unicode są obsługiwane prawidłowo przez <xref:System.Uri.GetComponents%2A> metody.  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję uwag dla <xref:System.Uri> klasy.  
  
> [!NOTE]
>  Jeśli <xref:System.Uri.GetComponents%2A> metoda jest wywoływana z `format` ustawioną <xref:System.UriFormat.Unescaped> , wartości zwracanej nie można użyć jako argumentu do <xref:System.Uri.%23ctor%2A> konstruktora w celu utworzenia równoważną <xref:System.Uri>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="components" /> nie jest prawidłową kombinację <see cref="T:System.UriComponents" /> wartości.</exception>
        <exception cref="T:System.InvalidOperationException">Bieżące <see cref="T:System.Uri" /> nie jest bezwzględnym identyfikatorem URI. Względne identyfikatory URI nie można używać z tą metodą.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uri.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość skrótu dla identyfikatora URI.</summary>
        <returns>
          <see cref="T:System.Int32" /> Zawierający wartości skrótu wygenerowane dla tego identyfikatora URI.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i zapisuje skrótu do konsoli.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLeftPart">
      <MemberSignature Language="C#" Value="public string GetLeftPart (UriPartial part);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetLeftPart(valuetype System.UriPartial part) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetLeftPart(System.UriPartial)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLeftPart (part As UriPartial) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetLeftPart(UriPartial part);" />
      <MemberSignature Language="F#" Value="member this.GetLeftPart : UriPartial -&gt; string" Usage="uri.GetLeftPart part" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="part" Type="System.UriPartial" />
      </Parameters>
      <Docs>
        <param name="part">Jeden z <see cref="T:System.UriPartial" /> wartości, które określa koniec części identyfikatora URI do zwrócenia.</param>
        <summary>Pobiera określoną część <see cref="T:System.Uri" /> wystąpienia.</summary>
        <returns>A <see cref="T:System.String" /> zawierający określoną część <see cref="T:System.Uri" /> wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.GetLeftPart%2A> Metoda zwraca ciąg zawierający skrajnej lewej części ciągu identyfikatora URI, kończąc części określony przez `part`.  
  
 <xref:System.Uri.GetLeftPart%2A> zawiera ogranicznik w następujących przypadkach:  
  
-   <xref:System.UriPartial.Scheme> zawiera ogranicznik schematu.  
  
-   <xref:System.UriPartial.Authority> nie ma ogranicznika ścieżki.  
  
-   <xref:System.UriPartial.Path> zawiera ograniczniki w oryginalnej identyfikator URI do ogranicznik zapytania lub fragmentu.  
  
-   <xref:System.UriPartial.Query> zawiera <xref:System.UriPartial.Path>, oraz zapytania i jego ogranicznika.  
  
 W poniższych przykładach pokazano identyfikatora URI i wyniki wywołania <xref:System.Uri.GetLeftPart%2A> z <xref:System.UriPartial.Scheme>, <xref:System.UriPartial.Authority>, <xref:System.UriPartial.Path>, lub <xref:System.UriPartial.Query>.  
  
|Identyfikator URI|Schemat|Urzędu|Ścieżka|Zapytanie|  
|---------|------------|---------------|----------|-----------|  
|http://www.contoso.com/index.htm?date=today|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm?date=today|  
|http://www.contoso.com/index.htm#main|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm|  
|mailto:user@contoso.com? podmiotu = identyfikator uri|mailto:|mailto:user@contoso.com|mailto:user@contoso.com? podmiotu = identyfikator uri|\<Brak >|  
|nntp://news.contoso.com/123456@contoso.com|nntp://|nntp://news.contoso.com|nntp://news.contoso.com/123456@contoso.com|nntp://news.contoso.com/123456@contoso.com|  
|news:123456@contoso.com|grupy dyskusyjne:|news:123456@contoso.com|news:123456@contoso.com|\<Brak >|  
|file://server/filename.ext|File://|File://Server|file://server/filename.ext|file://server/filename.ext|  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i zapisuje ścieżki do konsoli.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący <see cref="T:System.Uri" /> wystąpienia nie jest wystąpieniem bezwzględną.</exception>
        <exception cref="T:System.ArgumentException">Określony <paramref name="part" /> jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="member this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="uri.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiektu zawierającego informacje o wymaganych do zserializowania <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> obiekt zawierający źródłowy i docelowy serializowanego strumienia skojarzonego z <see cref="T:System.Uri" />.</param>
        <summary>Zwraca dane potrzebne do serializacji bieżącego wystąpienia.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby używać metody serializacji. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="HexEscape">
      <MemberSignature Language="C#" Value="public static string HexEscape (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string HexEscape(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexEscape(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexEscape (character As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ HexEscape(char character);" />
      <MemberSignature Language="F#" Value="static member HexEscape : char -&gt; string" Usage="System.Uri.HexEscape character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Znak, który można przekonwertować na szesnastkową reprezentację.</param>
        <summary>Konwertuje określony znak na jego odpowiednik szesnastkową.</summary>
        <returns>Szesnastkową reprezentację określony znak.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład konwertuje znak na jego szesnastkowy i zapisuje go w konsoli.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="character" /> jest większa niż 255.</exception>
      </Docs>
    </Member>
    <Member MemberName="HexUnescape">
      <MemberSignature Language="C#" Value="public static char HexUnescape (string pattern, ref int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char HexUnescape(string pattern, int32&amp; index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexUnescape(System.String,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexUnescape (pattern As String, ByRef index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char HexUnescape(System::String ^ pattern, int % index);" />
      <MemberSignature Language="F#" Value="static member HexUnescape : string *  -&gt; char" Usage="System.Uri.HexUnescape (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="pattern">Szesnastkową reprezentację liczby znaków.</param>
        <param name="index">Lokalizacja w <c>wzorzec</c> którym rozpoczyna się szesnastkową reprezentację liczby znaków.</param>
        <summary>Konwertuje określony szesnastkową reprezentację znaku znak.</summary>
        <returns>Znak reprezentowany przez kodowanie szesnastkowe na pozycji <paramref name="index" />. Jeśli znak na pozycji <paramref name="index" /> nie jest zakodowany szesnastkowy, znak na pozycji <paramref name="index" /> jest zwracany. Wartość <paramref name="index" /> jest zwiększany, aby wskazywał znak ten, który został zwrócony następujący.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poniższy przykład kodu Określa, czy znak jest szesnastkową kodowany i jeśli tak, zapisuje odpowiednik znaku konsoli.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż 0 lub większa niż lub równa liczbie znaków <paramref name="pattern" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Host" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Host : string" Usage="System.Uri.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik hosta tego wystąpienia.</summary>
        <value>A <see cref="T:System.String" /> zawiera nazwę hosta. Jest to zwykle nazwę hosta DNS lub adres IP serwera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W odróżnieniu od <xref:System.Uri.Authority%2A> właściwości, wartość tej właściwości nie ma numer portu.  
  
   
  
## Examples  
 Poniższy przykład zapisuje nazwy hosta (www.contoso.com) serwera do konsoli.  
  
 [!code-cpp[Classic Uri.Host Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Host Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Host Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Host Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Host Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Host Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość dotyczy tylko bezwzględny identyfikator URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="HostNameType">
      <MemberSignature Language="C#" Value="public UriHostNameType HostNameType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.UriHostNameType HostNameType" />
      <MemberSignature Language="DocId" Value="P:System.Uri.HostNameType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HostNameType As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property UriHostNameType HostNameType { UriHostNameType get(); };" />
      <MemberSignature Language="F#" Value="member this.HostNameType : UriHostNameType" Usage="System.Uri.HostNameType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ nazwa hosta określona w identyfikatorze URI.</summary>
        <value>Członek <see cref="T:System.UriHostNameType" /> wyliczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i zapisy <xref:System.Uri.HostNameType%2A> do konsoli.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość dotyczy tylko bezwzględny identyfikator URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="IdnHost">
      <MemberSignature Language="C#" Value="public string IdnHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string IdnHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IdnHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IdnHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ IdnHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IdnHost : string" Usage="System.Uri.IdnHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>RFC 3490 zgodne międzynarodową nazwę domeny hosta, za pomocą Punycode, zależnie od potrzeb. Ten ciąg po trwa niezmienionym znaczeniu w razie potrzeby, jest bezpieczne na potrzeby rozpoznawania nazw DNS.</summary>
        <value>Zwraca nazwę hosta, sformatowane Punycode ze standardem IDN. <see cref="T:System.String" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest udostępniana do użytku protokołów sieciowych niższego poziomu, które wymagają nazwy domeny w postaci Punycode. Jeśli kod nie wymaga tego określonego formatu, użyj <xref:System.Uri.Host%2A> przypadku nazwy hosta.  
  
 Przestarzałe <xref:System.Uri.DnsSafeHost%2A> właściwości jest zależna od *app.config* ustawienia, które nie mogą zostać zmienione przez aplikacje ze Sklepu Windows. IdnHost jest dostępna w preferowanym alternatywa dla użycia <xref:System.Uri.DnsSafeHost%2A>, ponieważ <xref:System.Uri.IdnHost%2A> może zawsze być bezpieczne, niezależnie od tego, jakie bieżącego DNS *app.config* ustawienia mogą być.  

 Jeśli używasz zmienionym ciągu do utworzenia tego wystąpienia (na przykład "http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), następnie IdnHost zwraca ciąg o zmienionym znaczeniu. Należy unescape dowolny ciąg zmienionym zwrócony z IdnHost przed użyciem tego ciągu do rozpoznawania nazw DNS. Należy pamiętać, że jeśli użyto nieprawidłowego ciągu niezmienionym znaczeniu do utworzenia tego wystąpienia (na przykład "http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm"), a następnie IdnHost zwraca ciąg niezmienionym znaczeniu.


 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAbsoluteUri">
      <MemberSignature Language="C#" Value="public bool IsAbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsAbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbsoluteUri As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbsoluteUri { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbsoluteUri : bool" Usage="System.Uri.IsAbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy <see cref="T:System.Uri" /> wystąpienia jest bezwzględna.</summary>
        <value>A <see cref="T:System.Boolean" /> wartość, czyli <see langword="true" /> Jeśli <see cref="T:System.Uri" /> wystąpienie jest bezwzględny; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest `true` Jeśli ciąg lub <xref:System.Uri> wystąpienia, który został przekazany do konstruktora może być analizowana jako bezwzględnym <xref:System.Uri> wystąpienia, która zawiera schemat, Urząd i ścieżkę. W przeciwnym razie <xref:System.Uri> wystąpienia jest traktowany jako względną i może pominąć schemat ani innych składników identyfikatora URI.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBadFileSystemCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsBadFileSystemCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsBadFileSystemCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBadFileSystemCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsBadFileSystemCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsBadFileSystemCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsBadFileSystemCharacter : char -&gt; bool&#xA;override this.IsBadFileSystemCharacter : char -&gt; bool" Usage="uri.IsBadFileSystemCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">
          <see cref="T:System.Char" /> Do testowania.</param>
        <summary>Pobiera informację, czy znak jest nieprawidłowy w nazwie pliku systemu.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, czyli <see langword="true" /> , jeśli określony znak jest nieprawidłowy; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znak zostanie przeanalizowany zgodnie z regułami systemu plików NTFS.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBaseOf">
      <MemberSignature Language="C#" Value="public bool IsBaseOf (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsBaseOf(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBaseOf(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsBaseOf(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.IsBaseOf : Uri -&gt; bool" Usage="uri.IsBaseOf uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">Określony <see cref="T:System.Uri" /> wystąpienie do testowania.</param>
        <summary>Określa, czy bieżący <see cref="T:System.Uri" /> wystąpienie jest podstawą określonego <see cref="T:System.Uri" /> wystąpienia.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący <see cref="T:System.Uri" /> wystąpienie jest podstawą <paramref name="uri" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsBaseOf%2A> Służy do porównywania bieżącego <xref:System.Uri> wystąpienia określonej <xref:System.Uri> do ustalenia, czy ten identyfikator URI jest podstawowy dla określonego <xref:System.Uri>. Podczas porównywania dwóch <xref:System.Uri> obiektów, aby ustalić relacji podstawowych informacji o użytkowniku (<xref:System.Uri.UserInfo%2A>) nie jest obliczane. Podczas porównywania dwóch identyfikatory URI (identyfikatorach uri1 i uri2), identyfikator uri1 jest podstawą uri2 podczas ignorować wszystkie elementy uri2 po ostatnim ukośnika (/), dwa identyfikatory URI są identyczne. Przy użyciu http://host/path/path/file?query jako podstawowy identyfikator URI w poniższej tabeli przedstawiono czy podstawa innych identyfikatorów URI.  
  
|Identyfikator URI|http://host/path/path/file?query jest podstawa|  
|---------|------------------------------------------------------|  
|http://host/path/path/file/|tak|  
|http://host/path/path/#fragment|tak|  
|http://host/path/path/MoreDir/"|tak|  
|http://host/path/path/OtherFile?Query|tak|  
|http://host/path/path/|tak|  
|http://host/path/path/file|tak|  
|http://host/path/path|Brak|  
|http://host/path/path?query|Brak|  
|http://host/path/path#Fragment|Brak|  
|http://host/path/path2/|Brak|  
: //host/path/path2/MoreDir|Brak|  
|http://host/path/File|Brak|  
  
   
  
## Examples  
 Ten przykład tworzy <xref:System.Uri> wystąpienia, który reprezentuje podstawę <xref:System.Uri> wystąpienia. Następnie tworzy drugi <xref:System.Uri> wystąpienia ciągu. Wywołuje <xref:System.Uri.IsBaseOf%2A> do ustalenia, czy wystąpienie podstawowego jest podstawą drugie wystąpienie. Wyniki są zapisywane do konsoli.  
  
 [!code-cpp[NCLUriEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#6)]
 [!code-csharp[NCLUriEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#6)]
 [!code-vb[NCLUriEnhancements#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uri" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefaultPort">
      <MemberSignature Language="C#" Value="public bool IsDefaultPort { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefaultPort" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsDefaultPort" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDefaultPort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDefaultPort { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefaultPort : bool" Usage="System.Uri.IsDefaultPort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje, czy wartość port identyfikatora URI jest ustawieniem domyślnym dla tego systemu.</summary>
        <value>A <see cref="T:System.Boolean" /> wartość, czyli <see langword="true" /> Jeśli wartość w <see cref="P:System.Uri.Port" /> właściwość jest ustawieniem domyślnym porcie ten schemat; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i sprawdza, czy ma być używany domyślny port.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość dotyczy tylko bezwzględny identyfikator URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsExcludedCharacter">
      <MemberSignature Language="C#" Value="protected static bool IsExcludedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool IsExcludedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsExcludedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function IsExcludedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static bool IsExcludedCharacter(char character);" />
      <MemberSignature Language="F#" Value="static member IsExcludedCharacter : char -&gt; bool" Usage="System.Uri.IsExcludedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">
          <see cref="T:System.Char" /> Do testowania.</param>
        <summary>Pobiera informacje, czy określony znak powinien być zmienione znaczenie.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, czyli <see langword="true" /> Jeśli określony znak ma być zmieniony; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFile">
      <MemberSignature Language="C#" Value="public bool IsFile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFile" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsFile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFile As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFile { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFile : bool" Usage="System.Uri.IsFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy określonego <see cref="T:System.Uri" /> jest plikiem identyfikatora URI.</summary>
        <value>A <see cref="T:System.Boolean" /> wartość, czyli <see langword="true" /> Jeśli <see cref="T:System.Uri" /> jest plikiem URI; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsFile%2A> Właściwość jest `true` podczas <xref:System.Uri.Scheme%2A> równa właściwości <xref:System.Uri.UriSchemeFile>.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy jest to plik identyfikatora URI.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość dotyczy tylko bezwzględny identyfikator URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsHexDigit">
      <MemberSignature Language="C#" Value="public static bool IsHexDigit (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexDigit(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexDigit (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexDigit(char character);" />
      <MemberSignature Language="F#" Value="static member IsHexDigit : char -&gt; bool" Usage="System.Uri.IsHexDigit character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Znak do sprawdzania poprawności.</param>
        <summary>Określa, czy określony znak jest prawidłową cyfrą szesnastkową.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, czyli <see langword="true" /> Jeśli znak jest cyfrą szesnastkową prawidłowe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cyfry szesnastkowe są cyfry od 0 do 9 i litery A-F lub a-f.  
  
   
  
## Examples  
 Poniższy przykład określa, czy znak jest znaków szesnastkowych, a jeśli tak jest, zapisuje odpowiednie wartości dziesiętnych do konsoli.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHexEncoding">
      <MemberSignature Language="C#" Value="public static bool IsHexEncoding (string pattern, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexEncoding(string pattern, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexEncoding(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexEncoding (pattern As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexEncoding(System::String ^ pattern, int index);" />
      <MemberSignature Language="F#" Value="static member IsHexEncoding : string * int -&gt; bool" Usage="System.Uri.IsHexEncoding (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pattern">Ciąg do sprawdzenia.</param>
        <param name="index">Lokalizacja w <c>wzorzec</c> do sprawdzenia kodowanie szesnastkowe.</param>
        <summary>Określa, czy znak w ciągu jest szesnastkową zakodowany.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, czyli <see langword="true" /> Jeśli <paramref name="pattern" /> jest szesnastkowa zakodowane w określonej lokalizacji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsHexEncoding%2A> Metoda sprawdza, czy szesnastkowe kodowanie, które jest zgodny ze wzorcem "% hexhex" w ciągu, gdzie "szesnastkowych" jest cyfrą z zakresu od 0 do 9 lub litery od A-F (bez uwzględniania wielkości liter).  
  
   
  
## Examples  
 Poniższy przykład kodu Określa, czy znak jest szesnastkową kodowany i jeśli tak, zapisuje odpowiednik znaku konsoli.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public bool IsLoopback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsLoopback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoopback { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoopback : bool" Usage="System.Uri.IsLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy określonego <see cref="T:System.Uri" /> odwołuje się do hosta lokalnego.</summary>
        <value>A <see cref="T:System.Boolean" /> wartość, czyli <see langword="true" /> Jeśli <see cref="T:System.Uri" /> odwołuje się do hosta lokalnego; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsLoopback%2A> Zwraca `true` Jeśli identyfikator URI określony podczas tworzenia tego wystąpienia sprzężenia zwrotnego, 127.0.0.1 lub localhost, lub jeśli nie określono identyfikatora URI hosta informacji (na przykład file:///c:Dir/file.txt). Wszystkie inne zwracane identyfikatorów URI `false`.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy odwołuje się hosta lokalnego.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość dotyczy tylko bezwzględny identyfikator URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReservedCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsReservedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsReservedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsReservedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsReservedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsReservedCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsReservedCharacter : char -&gt; bool&#xA;override this.IsReservedCharacter : char -&gt; bool" Usage="uri.IsReservedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">
          <see cref="T:System.Char" /> Do testowania.</param>
        <summary>Pobiera informację, czy określony znak jest zarezerwowany znak.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, czyli <see langword="true" /> , jeśli określony znak jest zarezerwowany znak, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnc">
      <MemberSignature Language="C#" Value="public bool IsUnc { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnc" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsUnc" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnc As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnc { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnc : bool" Usage="System.Uri.IsUnc" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy określonego <see cref="T:System.Uri" /> jest ścieżka uniwersalną konwencją nazewnictwa (UNC).</summary>
        <value>A <see cref="T:System.Boolean" /> wartość, czyli <see langword="true" /> Jeśli <see cref="T:System.Uri" /> jest ścieżką UNC; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsUnc%2A> Właściwość jest `true` Jeśli określonego <xref:System.Uri> wystąpienie jest w formacie UNC (takich jak \\\server\folder lub file://server/folder). Ta właściwość zawsze zwraca `true` Jeśli identyfikator URI ma ze schematem file:// i określa składnik hosta.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy należy ścieżką UNC.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość dotyczy tylko bezwzględny identyfikator URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedOriginalString">
      <MemberSignature Language="C#" Value="public bool IsWellFormedOriginalString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsWellFormedOriginalString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedOriginalString" />
      <MemberSignature Language="VB.NET" Value="Public Function IsWellFormedOriginalString () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsWellFormedOriginalString();" />
      <MemberSignature Language="F#" Value="member this.IsWellFormedOriginalString : unit -&gt; bool" Usage="uri.IsWellFormedOriginalString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy ten ciąg jest używany do utworzenia to <see cref="T:System.Uri" /> został poprawnie sformułowany i nie jest wymagane dalsze być zmienione znaczenie.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, czyli <see langword="true" /> Jeśli ciąg jest poprawnie sformułowanym; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten ciąg jest uważana poprawnie sformułowanym zgodnie z RFC 2396 i RFC 2732 domyślnie. Po włączeniu międzynarodowej identyfikatory zasobów (IRIs) lub międzynarodowych nazw domen (IDN) podczas analizowania ciągu jest uznawane za poprawnie sformułowanym zgodnie z RFC 3986 i RFC 3987  
  
 Ten ciąg jest uważany za źle sformułowany, powodując metoda zwróci wartość false, jeśli którykolwiek z następujących warunków problemów.  
  
|Błąd|Przykład|  
|-----------|-------------|  
|Ciąg nie jest prawidłowo wpisywany.|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) Nazwa|  
|Ten ciąg jest bezwzględnym <xref:System.Uri> reprezentujący plik niejawne <xref:System.Uri>.|c:\\\directory\filename|  
|Ten ciąg jest bezwzględnym identyfikatorem URI Brak ukośnika przed ścieżką.|File://c:/Directory/filename|  
|Ciąg zawiera niezmienionym znaczeniu ukośników odwrotnych, nawet wtedy, gdy są one traktowane jako kreskami ukośnymi.|http:\\\host/path/file|  
|Ciąg reprezentuje hierarchiczny bezwzględną <xref:System.Uri> i nie zawiera "://".|www.contoso.com/path/file|  
|Analizator dla <xref:System.Uri.Scheme%2A?displayProperty=nameWithType> wskazuje, że oryginalnego ciągu nie jest poprawnie sformułowany.|Przykład zależy od schemat identyfikatora URI.|  
  
 Domyślnie ten ciąg jest używany do utworzenia to <xref:System.Uri> są traktowane jako poprawnie sformułowana w zgodnie z RFC 2396 i RFC 2732.  
  
 Jeżeli międzynarodowej identyfikator zasobów (IRI) i obsługa międzynarodowych nazw domen (IDN) są włączone, ciąg używany do utworzenia to <xref:System.Uri> są traktowane jako poprawnie sformułowana w zgodnie z RFC 3986 i RFC 3987. Nazwy Punycode używane do obsługi IRI zawierać tylko znaki ASCII i zawsze rozpoczyna się od prefiksu xn--.  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję uwag dla <xref:System.Uri> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedUriString">
      <MemberSignature Language="C#" Value="public static bool IsWellFormedUriString (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWellFormedUriString(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedUriString(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWellFormedUriString(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="static member IsWellFormedUriString : string * UriKind -&gt; bool" Usage="System.Uri.IsWellFormedUriString (uriString, uriKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">Ciąg używany do podjęto próbę stworzenia <see cref="T:System.Uri" />.</param>
        <param name="uriKind">Typ <see cref="T:System.Uri" /> w <c>uriString</c>.</param>
        <summary>Wskazuje, czy ten ciąg jest poprawnie sformułowany, próba utworzenia identyfikatora URI z ciągu i zapewnia, że ciąg nie wymaga dalszych anulowanie.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, czyli <see langword="true" /> Jeśli ciąg jest poprawnie sformułowanym; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wersjach programu .NET przed wersji 4.5 domyślnie ten ciąg jest uważany za poprawnie sformułowanym w zgodnie z RFC 2396 i RFC 2732. Identyfikatory zasobów międzynarodowych (IRIs) lub analizowania międzynarodowych nazw domen (IDN) są włączone, jest uważany za poprawnie sformułowanym w zgodnie z RFC 3986 i RFC 3987 przez ciąg.  
  
 Począwszy od platformy .NET 4.5, ciągi są zawsze traktowane jako poprawnie sformułowana w zgodnie z RFC 3986 i RFC 3987 czy IRI lub IDN są włączone. Należy jednak pamiętać, że to jest tylko wartość true dla aplikacji przeznaczonych dla platformy .NET 4.5 lub nowszej. Aplikacje, które odnoszą się do programu .NET 4.0 wywołanie kodu zgodności i wystąpić stare zachowanie (pre-4.5).  
  
 Ten ciąg jest uznawany za źle sformułowany, co powoduje metoda zwróci wartość false, jeśli wystąpienia któregokolwiek z następujących warunków  
  
|Błąd|Przykład|  
|-----------|-------------|  
|Ciąg nie jest prawidłowo wpisywany.|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) Nazwa|  
|Ten ciąg jest bezwzględnym <xref:System.Uri> reprezentujący plik niejawne <xref:System.Uri>.|c:\\\directory\filename|  
|Ten ciąg jest bezwzględnym identyfikatorem URI Brak ukośnika przed ścieżką.|File://c:/Directory/filename|  
|Ciąg zawiera niezmienionym znaczeniu ukośników odwrotnych, nawet wtedy, gdy będą one traktowane jako ukośniki|http:\\\host/path/file|  
|Ciąg reprezentuje hierarchiczny bezwzględną <xref:System.Uri> i nie zawiera "://"|www.contoso.com/path/file|  
|Analizator dla <xref:System.Uri.Scheme%2A> wskazuje, że oryginalnego ciągu nie jest poprawnie sformułowany.|Przykład zależy od schemat identyfikatora URI.|  
|Począwszy od platformy .NET 4.5, względne identyfikatory URI dwukropkiem (': ') w ich pierwszy segment nie są uznawane za poprawnie sformułowany.|2013.05.29_14:33:41|  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję uwag dla <xref:System.Uri> klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalPath">
      <MemberSignature Language="C#" Value="public string LocalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalPath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.LocalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LocalPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalPath : string" Usage="System.Uri.LocalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera reprezentację lokalnego systemu operacyjnego nazwy pliku.</summary>
        <value>A <see cref="T:System.String" /> zawierający lokalnego systemu operacyjnego reprezentację nazwę pliku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę właściwość jest w niezmienionym znaczeniu. Jeśli ścieżka jest rozpoznawana jako ścieżka pliku systemu Windows, wszystkie ukośnikami (/) są zastępowane przez ukośniki z poprzednimi wersjami (\\).  
  
 Dla identyfikatora URI `file://computer/file.ext`, jest ścieżka bezwzględna `/file.ext` i ścieżka lokalna jest `\\computer\file.ext`.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i zapisuje ścieżka lokalna do konsoli.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość dotyczy tylko bezwzględny identyfikator URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelative">
      <MemberSignature Language="C#" Value="public string MakeRelative (Uri toUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MakeRelative(class System.Uri toUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelative(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function MakeRelative (toUri As Uri) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MakeRelative(Uri ^ toUri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelative : Uri -&gt; string" Usage="uri.MakeRelative toUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. Please use MakeRelativeUri(Uri uri). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="toUri">Identyfikator URI do porównania z bieżącym identyfikatorem URI.</param>
        <summary>Określa różnicę między dwiema <see cref="T:System.Uri" /> wystąpień.</summary>
        <returns>Jeśli nazwy hosta i schemat tego wystąpienia identyfikatora URI i <paramref name="toUri" /> są takie same, a następnie ta metoda zwraca <see cref="T:System.String" /> reprezentujący względnym identyfikatorem URI, który daje podczas dołączany do bieżącego wystąpienia identyfikatora URI, <paramref name="toUri" /> parametru.  Jeśli nazwa hosta lub schemat jest inny, a następnie ta metoda zwraca <see cref="T:System.String" /> reprezentujący <paramref name="toUri" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono wystąpienia identyfikatora URI `toUri`, a wyniki wywołania <xref:System.Uri.MakeRelative%2A>.  
  
|Bieżące wystąpienie identyfikatora URI|`toUri`|Wartość zwracana|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|test/test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|.. /|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|test1/test1.txt|  
  
 Informacje o użytkowniku, jeśli jest obecny w identyfikatorze URI, jest ignorowana.  
  
   
  
## Examples  
 Poniższy przykład tworzy 2 <xref:System.Uri> wystąpień. Różnica w informacje o ścieżce jest wyświetlony w konsoli.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toUri" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta metoda jest prawidłowa tylko dla bezwzględny identyfikator URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelativeUri">
      <MemberSignature Language="C#" Value="public Uri MakeRelativeUri (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Uri MakeRelativeUri(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelativeUri(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri ^ MakeRelativeUri(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelativeUri : Uri -&gt; Uri" Usage="uri.MakeRelativeUri uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">Identyfikator URI do porównania z bieżącym identyfikatorem URI.</param>
        <summary>Określa różnicę między dwiema <see cref="T:System.Uri" /> wystąpień.</summary>
        <returns>Jeśli nazwa hosta i schemat tego wystąpienia identyfikatora URI i <paramref name="uri" /> są takie same, a następnie ta metoda zwraca względny <see cref="T:System.Uri" /> , gdy dołączany do bieżącego wystąpienia identyfikatora URI, daje <paramref name="uri" />.  Jeśli nazwa hosta lub schemat jest inny, a następnie ta metoda zwraca <see cref="T:System.Uri" /> reprezentujący <paramref name="uri" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono wystąpienia identyfikatora URI `toUri`, a wyniki wywołania <xref:System.Uri.MakeRelativeUri%2A>.  
  
|Bieżące wystąpienie identyfikatora URI|`toUri`|Wartość zwracana|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|test/test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|.. /|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|test1/test1.txt|  
  
 Informacje o użytkowniku, jeśli jest obecny w identyfikatorze URI, jest ignorowana.  
  
   
  
## Examples  
 Poniższy przykład tworzy 2 <xref:System.Uri> wystąpień. Różnica w informacje o ścieżce jest wyświetlony w konsoli.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uri" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość dotyczy tylko bezwzględny identyfikator URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Equality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Uri * Uri -&gt; bool" Usage="uri1 = uri2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">A <see cref="T:System.Uri" /> wystąpienie do porównania z <c>uri2</c>.</param>
        <param name="uri2">A <see cref="T:System.Uri" /> wystąpienie do porównania z <c>uri1</c>.</param>
        <summary>Określa, czy dwa <see cref="T:System.Uri" /> wystąpienia mają taką samą wartość.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, czyli <see langword="true" /> Jeśli <see cref="T:System.Uri" /> wystąpienia są równoważne; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie używa <xref:System.Uri.Equals%2A> metodę, aby określić, czy dwa <xref:System.Uri> wystąpienia są równoważne. <xref:System.Uri.UserInfo%2A> i <xref:System.Uri.Fragment%2A> zawartości jest ignorowany podczas wprowadzania to porównanie.  
  
   
  
## Examples  
 W tym przykładzie tworzy trzy <xref:System.Uri> wystąpień z ciągów i porównuje je, aby określić, czy reprezentują tę samą wartość. `Address1` i `Address2` są takie same, ponieważ <xref:System.Uri.Fragment%2A> części jest ignorowany dla porównania. Wyniki są zapisywane do konsoli.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Inequality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Uri * Uri -&gt; bool" Usage="System.Uri.op_Inequality (uri1, uri2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">A <see cref="T:System.Uri" /> wystąpienie do porównania z <c>uri2</c>.</param>
        <param name="uri2">A <see cref="T:System.Uri" /> wystąpienie do porównania z <c>uri1</c>.</param>
        <summary>Określa, czy dwa <see cref="T:System.Uri" /> wystąpień nie mają tej samej wartości.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, czyli <see langword="true" /> Jeśli dwa <see cref="T:System.Uri" /> wystąpień nie są równe; w przeciwnym razie <see langword="false" />. Jeśli parametr albo ma <see langword="null" />, ta metoda zwraca <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie używa <xref:System.Uri.Equals%2A> metodę, aby określić, czy dwa <xref:System.Uri> wystąpień nie są równoważne. <xref:System.Uri.UserInfo%2A> i <xref:System.Uri.Fragment%2A> zawartości jest ignorowany podczas wprowadzania to porównanie.  
  
   
  
## Examples  
 W tym przykładzie tworzy trzy <xref:System.Uri> wystąpień z ciągów i porównuje je, aby określić, czy reprezentują tę samą wartość. `Address2` i `Address3` nie są, tym samym ponieważ `Address3` zawiera <xref:System.Uri.Query%2A> który nie został znaleziony w `Address2`. Wyniki są zapisywane do konsoli.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalString">
      <MemberSignature Language="C#" Value="public string OriginalString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OriginalString" />
      <MemberSignature Language="DocId" Value="P:System.Uri.OriginalString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OriginalString { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalString : string" Usage="System.Uri.OriginalString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera oryginalnego ciągu identyfikatora URI, który został przekazany do <see cref="T:System.Uri" /> konstruktora.</summary>
        <value>A <see cref="T:System.String" /> zawierające dokładny identyfikator URI określony podczas to wystąpienie zostało utworzone; w przeciwnym razie <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli identyfikator URI określony do konstruktora zawiera początkowe lub końcowe spacje, zostaną zachowane te magazynowania.  
  
 Wartość zwrócona przez tę właściwość różni się od <xref:System.Uri.ToString%2A> i <xref:System.Uri.AbsoluteUri%2A>. <xref:System.Uri.ToString%2A> Zwraca URI w postaci canonically niezmienionym znaczeniu. <xref:System.Uri.AbsoluteUri%2A> Zwraca canonically zmienionym formularza identyfikatora URI.  
  
 Po włączeniu obsługi międzynarodowej identyfikator zasobów (IRI) i międzynarodowych nazw domen (IDN) <xref:System.Uri.OriginalString%2A> zwraca oryginalnego ciągu z systemem innym niż znormalizowane z nazwą hosta ciąg Punycode, gdy zostało ono użyte do zainicjowania <xref:System.Uri> wystąpienia. Ciąg Punycode nazwy zawierają tylko znaki ASCII i zawsze rozpoczyna się od prefiksu xn--.  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję uwag dla <xref:System.Uri> klasy.  
  
 Gdy <xref:System.Uri> serializowany jest obiekt, <xref:System.Uri.OriginalString%2A> nie są zachowywane. Proces serializacji korzysta z w pełni zmienionym i postaci kanonicznej <xref:System.Uri.AbsoluteUri%2A> właściwość podczas serializacji. Dla <xref:System.Uri> zawierający adres IPv6, adres IPv6 i identyfikator zakresu są uwzględniane w zserializowana <xref:System.Uri> obiektu.  
  
   
  
## Examples  
 Poniższy przykład tworzy nową <xref:System.Uri> wystąpienia ciągu. Zastosowano różnicy między wartością zwróconą z <xref:System.Uri.OriginalString%2A>, która zwraca ciąg, który został przekazany do konstruktora, a po wywołaniu <xref:System.Uri.ToString%2A>, która zwraca forma kanoniczna ciągu.  
  
 [!code-cpp[NCLUriEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#3)]
 [!code-csharp[NCLUriEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#3)]
 [!code-vb[NCLUriEnhancements#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość dotyczy tylko bezwzględny identyfikator URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="protected virtual void Parse ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Parse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Parse" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Parse ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Parse();" />
      <MemberSignature Language="F#" Value="abstract member Parse : unit -&gt; unit&#xA;override this.Parse : unit -&gt; unit" Usage="uri.Parse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po analizie identyfikatora URI bieżącego wystąpienia, aby upewnić się, że zawiera wszystkie elementy wymagane do prawidłowego identyfikatora URI.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">Identyfikator Uri przekazane z konstruktora jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="PathAndQuery">
      <MemberSignature Language="C#" Value="public string PathAndQuery { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathAndQuery" />
      <MemberSignature Language="DocId" Value="P:System.Uri.PathAndQuery" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathAndQuery As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathAndQuery { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathAndQuery : string" Usage="System.Uri.PathAndQuery" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="P:System.Uri.AbsolutePath" /> i <see cref="P:System.Uri.Query" /> właściwości oddzielone znakiem zapytania (?).</summary>
        <value>A <see cref="T:System.String" /> zawierający <see cref="P:System.Uri.AbsolutePath" /> i <see cref="P:System.Uri.Query" /> właściwości oddzielone znakiem zapytania (?).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.PathAndQuery%2A> Właściwość zawiera ścieżki bezwzględnej na serwerze i informacje o kwerendzie wysyłane z żądaniem. Jest on identyczny łączenie <xref:System.Uri.AbsolutePath%2A> i <xref:System.Uri.Query%2A> właściwości.  
  
 <xref:System.Uri.PathAndQuery%2A> Właściwości została zmieniona zgodnie z RFC 2396 domyślnie. Po włączeniu międzynarodowej identyfikatory zasobów (IRIs) lub międzynarodowych nazw domen (IDN) podczas analizowania <xref:System.Uri.PathAndQuery%2A> właściwości została zmieniona zgodnie z RFC 3986 i RFC 3987.  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję uwag dla <xref:System.Uri> klasy.  
  
   
  
## Examples  
 Poniższy przykład zapisuje ścieżka identyfikatora URI (/ catalog/shownew.htm) i zapytania (Data = dzisiaj) informacje do konsoli.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.PathAndQuery Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość dotyczy tylko bezwzględny identyfikator URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Port">
      <MemberSignature Language="C#" Value="public int Port { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Port" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Port" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Port As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Port { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Port : int" Usage="System.Uri.Port" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera numer portu z tego identyfikatora URI.</summary>
        <value>
          <see cref="T:System.Int32" /> Wartość zawierającą numer portu dla tego identyfikatora URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numer portu Określa port protokół używany do kontaktowania się z serwera, do którego odwołuje się identyfikator URI. Jeśli port nie jest określony jako część identyfikatora URI <xref:System.Uri.Port%2A> właściwość zwraca wartość domyślną dla protokołu. W przypadku nie domyślny numer portu, ta właściwość zwraca wartość -1.  
  
   
  
## Examples  
 Poniższy przykład zapisuje numer portu z identyfikatora URI do konsoli. W takim przypadku wartość jest domyślny numer portu dla protokołu HTTP, port 80.  
  
 [!code-cpp[Classic Uri.Port Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Port Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Port Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Port Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Port Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Port Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość dotyczy tylko bezwzględny identyfikator URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Query">
      <MemberSignature Language="C#" Value="public string Query { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Query" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Query" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Query As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Query { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Query : string" Usage="System.Uri.Query" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje o żadnych zapytania, dołączone do określonego identyfikatora URI.</summary>
        <value>A <see cref="T:System.String" /> zawierający informacje o żadnych zapytania, dołączone do określonego identyfikatora URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Query%2A> Właściwość zawiera informacje kwerendy zawarte w identyfikatorze URI. Badanie informacji jest oddzielony od informacje o ścieżce znakiem zapytania (?) i kontynuuje na końcu identyfikatora URI. Zwrócone informacje zapytania zawiera znak znaku zapytania.  
  
 Dane zapytania została zmieniona zgodnie z RFC 2396 domyślnie. Po włączeniu międzynarodowej identyfikatory zasobów (IRIs) lub międzynarodowych nazw domen (IDN) podczas analizowania informacji zapytania została zmieniona zgodnie z RFC 3986 i RFC 3987.  
  
 Aby uzyskać więcej informacji na temat obsługi IRI, zobacz sekcję uwag dla <xref:System.Uri> klasy.  
  
   
  
## Examples  
 Poniższy przykład zapisuje zapytania? Data = dzisiaj do konsoli.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#2)]
 [!code-vb[Classic Uri.PathAndQuery Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość dotyczy tylko bezwzględny identyfikator URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheme : string" Usage="System.Uri.Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę schematu dla tego identyfikatora URI.</summary>
        <value>A <see cref="T:System.String" /> zawierający schemat dla tego identyfikatora URI przekształcone na małe litery.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Scheme%2A> Właściwość zwraca Schemat używany do inicjowania <xref:System.Uri> wystąpienia. Ta właściwość wskazuje, że schemat używany do inicjowania <xref:System.Uri> wystąpienie zostało rozpoznane.  
  
 W poniższej tabeli przedstawiono przykłady niektórych możliwych wartości zwracanych przez <xref:System.Uri.Scheme%2A> właściwości.  
  
|Schemat|Opis|  
|------------|-----------------|  
|— plik|Zasób jest plik na komputerze lokalnym.|  
|FTP|Zasób jest dostępny za pośrednictwem FTP.|  
|gopher|Zasób jest dostępny za pośrednictwem protokołu Gopher.|  
|http|Zasób jest dostępny za pośrednictwem protokołu HTTP.|  
|Protokół HTTPS|Zasób jest dostępny za pośrednictwem protokołu HTTP z protokołem szyfrowania SSL.|  
|LDAP|Zasób jest dostępny za pośrednictwem protokołu LDAP.|  
|mailto|Zasób jest adres e-mail i dostępne za pośrednictwem protokołu SMTP.|  
|net.pipe|Zasób jest dostępny za pośrednictwem nazwanego potoku.|  
|net.tcp|Zasób jest dostępny punkt końcowy protokołu TCP.|  
|grupy dyskusyjne|Zasób jest dostępny za pośrednictwem protokołu NNTP.|  
|NNTP|Zasób jest dostępny za pośrednictwem protokołu NNTP.|  
|telnet|Zasób jest dostępny za pośrednictwem protokołu TELNET.|  
|uuid|Zasób jest dostępny za pośrednictwem unikatową nazwę punktu końcowego UUID komunikacji z usługą.|  
  
   
  
## Examples  
 Poniższy przykład zapisuje nazwę schematu (http) do konsoli dla http://www.contoso.com/ identyfikatora URI.  
  
 [!code-cpp[Classic Uri.Scheme Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Scheme Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Scheme Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Scheme Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość dotyczy tylko bezwzględny identyfikator URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemeDelimiter">
      <MemberSignature Language="C#" Value="public static readonly string SchemeDelimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string SchemeDelimiter" />
      <MemberSignature Language="DocId" Value="F:System.Uri.SchemeDelimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SchemeDelimiter As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ SchemeDelimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable SchemeDelimiter : string" Usage="System.Uri.SchemeDelimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa znaki rozdzielające schemat protokołu komunikacji z części adresu URI. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy ciąg z <xref:System.Uri.UriSchemeHttp>, <xref:System.Uri.SchemeDelimiter>, a adres. A <xref:System.Uri> wystąpienie zostanie utworzona z ciągu.  
  
 [!code-cpp[NCLUriExamples#17](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#17)]
 [!code-csharp[NCLUriExamples#17](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#17)]
 [!code-vb[NCLUriExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Segments">
      <MemberSignature Language="C#" Value="public string[] Segments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Segments" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Segments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Segments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Segments { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Segments : string[]" Usage="System.Uri.Segments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera tablicę zawierającą segmentów ścieżki, które tworzą określonego identyfikatora URI.</summary>
        <value>A <see cref="T:System.String" /> tablica, która zawiera ścieżkę segmenty wchodzących w skład określonego identyfikatora URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.Segments%2A> Właściwość zwraca tablicę ciągów, które zawierają "segmentów" (podciągów) tworzących bezwzględna ścieżka identyfikatora URI. Pierwszy segment są uzyskiwane przez podczas analizowania ścieżki bezwzględnej od jego pierwszego znaku, aż dojdziesz ukośnika (/) ani końca ścieżki. Każdy z segmentów dodatkowe rozpoczyna się od pierwszego znaku po poprzedniego segmentu i kończy się ukośnikiem dalej lub końca ścieżki. (Ścieżka bezwzględnego identyfikatora URI zawiera wszystko, co po hosta i portu, a przed zapytań i fragmentu).  
  
 W poniższym przykładzie przedstawiono ścieżkę bezwzględną oraz segmentów dwa identyfikatory URI. Drugim przykładzie przedstawiono fragment i zapytania nie są częścią ścieżki bezwzględnej i dlatego nie są one segmentów.  
  
 Bezwzględny identyfikator URI:  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm  
  
 Bezwzględna ścieżka:  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Segmenty:  
 - /
 - Rozdziałach /
 - Chapter1 /
 - Sekcje /
 - Section1.htm  
  
 Bezwzględny identyfikator URI:  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm#page1?answer=NO  
  
 Bezwzględna ścieżka:  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Segmenty:  
 - /
 - Rozdziałach /
 - Chapter1 /
 - Sekcje /
 - Section1.htm  
  
 Należy pamiętać, że, ponieważ ścieżka bezwzględna rozpoczyna się od '/', pierwszy segment zawiera on i nic innego.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia z 3 segmentów i wyświetla segmenty na ekranie.  
  
 [!code-cpp[NCLUriExamples#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#5)]
 [!code-csharp[NCLUriExamples#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#5)]
 [!code-vb[NCLUriExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość dotyczy tylko bezwzględny identyfikator URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiektu zawierającego informacje o wymaganych do zserializowania <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> obiekt zawierający źródłowy i docelowy serializowanego strumienia skojarzonego z <see cref="T:System.Uri" />.</param>
        <summary>Zwraca dane potrzebne do serializacji bieżącego wystąpienia.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby używać metody serializacji. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="uri.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera reprezentacji w postaci kanonicznej ciągu dla określonego <see cref="T:System.Uri" /> wystąpienia.</summary>
        <returns>A <see cref="T:System.String" /> wystąpienia, które zawiera niezmienionym znaczeniu reprezentacja canonical <see cref="T:System.Uri" /> wystąpienia. Niezmienionym znaczeniu są wszystkie znaki oprócz #,? i %.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długość ciągu zwróconego przez tę metodę nie zawiera informacji o porcie Jeśli port jest domyślny port dla schematu.  
  
> [!NOTE]
>  Długość ciągu zwróconego przez <xref:System.Uri.ToString%2A> metoda może zawierać znaków kontrolnych, które może doprowadzić do uszkodzenia aplikacji konsoli. Można użyć <xref:System.Uri.GetComponents%2A> metody z <xref:System.UriFormat.SafeUnescaped?displayProperty=nameWithType> format do usunięcia z zwracany ciąg znaków kontrolnych.  
  
   
  
## Examples  
 Poniższy przykład tworzy nową <xref:System.Uri> wystąpienia ciągu. Zastosowano różnicy między wartością zwróconą z <xref:System.Uri.OriginalString%2A>, która zwraca ciąg, który został przekazany do konstruktora, a po wywołaniu <xref:System.Uri.ToString%2A>, która zwraca forma kanoniczna ciągu.  
  
 [!code-cpp[NCLUriExamples#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#7)]
 [!code-csharp[NCLUriExamples#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#7)]
 [!code-vb[NCLUriExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#7)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby zapobiec wynikających z częściowo zaufanego kodu <see cref="T:System.Uri" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryCreate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowy <see cref="T:System.Uri" />. Nie zgłasza wyjątek, jeśli <see cref="T:System.Uri" /> nie można utworzyć.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (string uriString, UriKind uriKind, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(string uriString, valuetype System.UriKind uriKind, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.String,System.UriKind,System.Uri@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(System::String ^ uriString, UriKind uriKind, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : string * UriKind *  -&gt; bool" Usage="System.Uri.TryCreate (uriString, uriKind, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
        <Parameter Name="result" Type="System.Uri&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="uriString">
          <see cref="T:System.String" /> Reprezentujący <see cref="T:System.Uri" />.</param>
        <param name="uriKind">Typ identyfikatora URI.</param>
        <param name="result">Po powrocie z tej metody zawiera zbudowany <see cref="T:System.Uri" />.</param>
        <summary>Tworzy nowy <see cref="T:System.Uri" /> przy użyciu określonego <see cref="T:System.String" /> wystąpienia i <see cref="T:System.UriKind" />.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, czyli <see langword="true" /> Jeśli <see cref="T:System.Uri" /> został pomyślnie utworzony; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta metoda zwraca `true`, nowe <xref:System.Uri> w `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, string relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, string relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.String,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As String, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, System::String ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * string *  -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="result" Type="System.Uri&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">Podstawowym <see cref="T:System.Uri" />.</param>
        <param name="relativeUri">Względne <see cref="T:System.Uri" />, reprezentowana jako <see cref="T:System.String" />, aby dodać do podstawy <see cref="T:System.Uri" />.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.Uri" /> utworzone na podstawie <c>baseUri</c> i <c>relativeUri</c>. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Tworzy nowy <see cref="T:System.Uri" /> przy użyciu określonego typu podstawowego i względna <see cref="T:System.String" /> wystąpień.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, czyli <see langword="true" /> Jeśli <see cref="T:System.Uri" /> został pomyślnie utworzony; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta metoda zwraca `true`, nowe <xref:System.Uri> w `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, Uri relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, class System.Uri relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.Uri,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As Uri, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, Uri ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * Uri *  -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
        <Parameter Name="result" Type="System.Uri&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">Podstawowym <see cref="T:System.Uri" />.</param>
        <param name="relativeUri">Względne <see cref="T:System.Uri" /> do dodania do podstawy <see cref="T:System.Uri" />.</param>
        <param name="result">Po powrocie z tej metody zawiera <see cref="T:System.Uri" /> utworzone na podstawie <c>baseUri</c> i <c>relativeUri</c>. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Tworzy nowy <see cref="T:System.Uri" /> przy użyciu określonego typu podstawowego i względna <see cref="T:System.Uri" /> wystąpień.</summary>
        <returns>A <see cref="T:System.Boolean" /> wartość, czyli <see langword="true" /> Jeśli <see cref="T:System.Uri" /> został pomyślnie utworzony; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta metoda zwraca `true`, nowe <xref:System.Uri> w `result`.  
  
 Ta metoda tworzy identyfikator URI, umieszcza je w formie kanonicznej i weryfikuje ją. Jeśli wystąpi nieobsługiwany wyjątek, ta metoda połowy go. Jeśli chcesz utworzyć <xref:System.Uri> i get wyjątki, użyj jednej z <xref:System.Uri.%23ctor%2A> konstruktorów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="protected virtual string Unescape (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string Unescape(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Unescape (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ Unescape(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member Unescape : string -&gt; string&#xA;override this.Unescape : string -&gt; string" Usage="uri.Unescape path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">
          <see cref="T:System.String" /> Do przekonwertowania.</param>
        <summary>Konwertuje określony ciąg przez zamianę wszelkich sekwencji unikowych ich reprezentacja niezmienionym znaczeniu.</summary>
        <returns>A <see cref="T:System.String" /> zawierający wartość niezmienionym znaczeniu <paramref name="path" /> parametru.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnescapeDataString">
      <MemberSignature Language="C#" Value="public static string UnescapeDataString (string stringToUnescape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UnescapeDataString(string stringToUnescape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.UnescapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnescapeDataString (stringToUnescape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UnescapeDataString(System::String ^ stringToUnescape);" />
      <MemberSignature Language="F#" Value="static member UnescapeDataString : string -&gt; string" Usage="System.Uri.UnescapeDataString stringToUnescape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToUnescape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToUnescape">Ciąg do unescape.</param>
        <summary>Konwertuje ciąg na jej reprezentację niezmienionym znaczeniu.</summary>
        <returns>A <see cref="T:System.String" /> zawierający reprezentację niezmienionym znaczeniu <paramref name="stringToUnescape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody należy używać ostrożnie. Ciąg, który został wcześniej niezmienionym znaczeniu unescaping może prowadzić do niejednoznaczności i błędów.  
  
 Wiele przeglądarek sieci Web escape spacje wewnątrz bloków URI w plus znaków ("+"); Jednak metoda UnescapeDataString nie przekonwertować oraz znaków w funkcji miejsca do, ponieważ to zachowanie nie jest standard we wszystkich schematy identyfikatorów URI.  
  
   
  
## Examples  
 Poniższy przykład kodu unescapes identyfikator URI, a następnie konwertuje wszelkie oraz znaków ("+") w funkcji miejsca do.  
  
 [!code-csharp[NCLUriExamples#19](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToUnescape" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Uri.EscapeDataString(System.String)" />
        <altmember cref="M:System.Uri.EscapeUriString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFile">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFile" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFile As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFile;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFile : string" Usage="System.Uri.UriSchemeFile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że identyfikator URI jest wskaźnika do pliku. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W .NET Framework w wersji 1.1 "`file:///path`"URI została przekonwertowana na stronę"`file:/path`". Ten został rozwiązany dla wersji 2.0.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy schemat jest <xref:System.Uri.UriSchemeFile>.  
  
 [!code-cpp[NCLUriExamples#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#10)]
 [!code-csharp[NCLUriExamples#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#10)]
 [!code-vb[NCLUriExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFtp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFtp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFtp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFtp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFtp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFtp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFtp : string" Usage="System.Uri.UriSchemeFtp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy identyfikator URI jest dostępna za pośrednictwem protokołu FTP (File Transfer). To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy schemat jest <xref:System.Uri.UriSchemeFtp>.  
  
 [!code-cpp[NCLUriExamples#15](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#15)]
 [!code-csharp[NCLUriExamples#15](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#15)]
 [!code-vb[NCLUriExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeGopher">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeGopher;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeGopher" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeGopher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeGopher As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeGopher;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeGopher : string" Usage="System.Uri.UriSchemeGopher" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że identyfikator URI jest dostępny za pośrednictwem protokołu Gopher. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy schemat jest <xref:System.Uri.UriSchemeGopher>.  
  
 [!code-cpp[NCLUriExamples#14](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#14)]
 [!code-csharp[NCLUriExamples#14](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#14)]
 [!code-vb[NCLUriExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttp : string" Usage="System.Uri.UriSchemeHttp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy identyfikator URI jest dostępna za pośrednictwem protokołu HTTP (Hypertext Transfer). To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy schemat jest <xref:System.Uri.UriSchemeHttp>.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttps">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttps;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttps" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttps" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttps As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttps;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttps : string" Usage="System.Uri.UriSchemeHttps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy identyfikator URI jest dostępna za pośrednictwem Secure Hypertext Transfer Protocol (HTTPS). To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy schemat jest <xref:System.Uri.UriSchemeHttps>.  
  
 [!code-cpp[NCLUriExamples#16](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#16)]
 [!code-csharp[NCLUriExamples#16](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#16)]
 [!code-vb[NCLUriExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeMailto">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeMailto;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeMailto" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeMailto" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeMailto As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeMailto;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeMailto : string" Usage="System.Uri.UriSchemeMailto" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że identyfikator URI jest adres e-mail i jest dostępny za pośrednictwem transportu protokołu SMTP (Simple Mail). To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy schemat jest <xref:System.Uri.UriSchemeMailto>.  
  
 [!code-cpp[NCLUriExamples#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#11)]
 [!code-csharp[NCLUriExamples#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#11)]
 [!code-vb[NCLUriExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetPipe">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetPipe;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetPipe" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetPipe" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetPipe As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetPipe;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetPipe : string" Usage="System.Uri.UriSchemeNetPipe" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że identyfikator URI jest dostępny za pośrednictwem systemu NetPipe używany przez Windows Communication Foundation (WCF). To pole jest tylko do odczytu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetTcp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetTcp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetTcp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetTcp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetTcp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetTcp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetTcp : string" Usage="System.Uri.UriSchemeNetTcp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że identyfikator URI jest dostępny za pośrednictwem systemu NetTcp używany przez Windows Communication Foundation (WCF). To pole jest tylko do odczytu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNews">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNews;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNews" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNews" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNews As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNews;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNews : string" Usage="System.Uri.UriSchemeNews" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że identyfikator URI jest grupą wiadomości Internet i jest dostępna za pośrednictwem transportu protokołu NNTP (Network News). To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy schemat jest <xref:System.Uri.UriSchemeNews>.  
  
 [!code-cpp[NCLUriExamples#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#12)]
 [!code-csharp[NCLUriExamples#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#12)]
 [!code-vb[NCLUriExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNntp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNntp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNntp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNntp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNntp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNntp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNntp : string" Usage="System.Uri.UriSchemeNntp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że identyfikator URI jest grupą wiadomości Internet i jest dostępna za pośrednictwem transportu protokołu NNTP (Network News). To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 NNTP <xref:System.Uri> analizowanie błędów w programie .NET Framework w wersji 1.1 zostały skorygowane.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy schemat jest <xref:System.Uri.UriSchemeNntp>.  
  
 [!code-cpp[NCLUriExamples#13](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#13)]
 [!code-csharp[NCLUriExamples#13](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#13)]
 [!code-vb[NCLUriExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserEscaped">
      <MemberSignature Language="C#" Value="public bool UserEscaped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UserEscaped" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserEscaped" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserEscaped As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UserEscaped { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserEscaped : bool" Usage="System.Uri.UserEscaped" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, że ciągu identyfikatora URI całkowicie zostało anulowane przed <see cref="T:System.Uri" /> wystąpienie zostało utworzone.</summary>
        <value>A <see cref="T:System.Boolean" /> wartość, czyli <see langword="true" /> Jeśli <paramref name="dontEscape" /> ustawiono parametr <see langword="true" /> podczas <see cref="T:System.Uri" /> wystąpienie zostało utworzone, a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.UserEscaped%2A> Właściwość jest ustawiona na `true` aby wskazać, że ten ciąg jest używany do tworzenia <xref:System.Uri> wystąpienia całkowicie zostało anulowane, zanim został przekazany do konstruktora; `dontEscape` parametru wywołania konstruktora ustawiono `true`.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i określa, czy jakiej została pełni zmieniona podczas jej tworzenia.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInfo">
      <MemberSignature Language="C#" Value="public string UserInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserInfo" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserInfo { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInfo : string" Usage="System.Uri.UserInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę użytkownika, hasło lub inne informacje specyficzne dla użytkownika, skojarzone z określonym identyfikatorem URI.</summary>
        <value>A <see cref="T:System.String" /> zawierający informacje o użytkowniku skojarzonych z identyfikatorem URI. Zwrócona wartość nie obejmuje "@" znaku zarezerwowanego oddzielającego informacje użytkownika część identyfikatora URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez tę właściwość jest zwykle w formacie "USERNAME".  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Uri> wystąpienia i zapisuje informacje o użytkowniku w konsoli.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">To wystąpienie reprezentuje względny identyfikator URI, a ta właściwość dotyczy tylko bezwzględny identyfikator URI.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
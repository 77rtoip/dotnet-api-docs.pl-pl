<Type Name="Lazy&lt;T&gt;" FullName="System.Lazy&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="11826166fef32f2564da98bcfb9954709a20fbc7" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53524022" /></Metadata><TypeSignature Language="C#" Value="public class Lazy&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Lazy`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Lazy`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Lazy(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Lazy" />
  <TypeSignature Language="F#" Value="type Lazy&lt;'T&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.System_LazyDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Typ obiektu, który jest inicjowany opóźnieniem.</typeparam>
    <summary>Zapewnia obsługę inicjowania z opóźnieniem.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj inicjacji z opóźnieniem, które mają być odroczone Tworzenie obiektu dużych lub dużej ilości zasobów lub wykonywania zadań intensywnie korzystających z zasobów, zwłaszcza w przypadku takich utworzenie lub wykonanie nie może wystąpić w okresie istnienia programu.  
  
 Aby przygotować się do inicjowania z opóźnieniem, należy utworzyć wystąpienie <xref:System.Lazy%601>. Argument typu <xref:System.Lazy%601> obiekt, który tworzysz Określa typ obiektu, który chcesz zainicjować opóźnieniem. Konstruktor, który umożliwia tworzenie <xref:System.Lazy%601> obiektu określa właściwości inicjowania. Inicjalizacja z opóźnieniem występuje po raz pierwszy <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> dostępu do właściwości.  
  
 W większości przypadków wybór konstruktora zależy od odpowiedzi na dwa pytania:  
  
-   Opóźnieniem zainicjowanego obiektu uzyskuje się dostęp z więcej niż jeden wątek? Jeśli tak, <xref:System.Lazy%601> obiektu może utworzyć ją na żadnym z wątków. Można użyć jednego z konstruktorów prosty, którego domyślne zachowanie jest utworzenie obsługujące wielowątkowość <xref:System.Lazy%601> obiektu, tak że tylko jedno wystąpienie opóźnieniem wystąpień obiektu jest tworzony niezależnie od tego, jak wiele wątków próbuje uzyskać do niego dostęp. Aby utworzyć <xref:System.Lazy%601> obiektu, który nie jest bezpieczny dla wątków, należy użyć konstruktora, który pozwala na określenie nie bezpieczeństwo wątkowe.  
  
    > [!CAUTION]
    >  Tworzenie <xref:System.Lazy%601> obiektu wątkowo nie chroni opóźnieniem zainicjowanego obiektu. Jeśli wiele wątków może uzyskać dostęp do opóźnieniem zainicjowanego obiektu, musisz wprowadzić jej właściwości i metody bezpieczne, aby uzyskać dostęp do wielu wątków.  
  
-   Inicjalizacja z opóźnieniem wymaga dużej ilości kodu lub opóźnieniem zainicjowanego obiektu ma domyślnego konstruktora, który wykonuje wszystko, czego potrzebujesz i nie wyrzuca wyjątków? Jeśli należy napisać kod inicjujący lub wyjątki, które muszą być obsługiwani, użyj jednego z konstruktorów, które przyjmuje metoda fabryki. Napisz swój kod inicjowania w metodzie fabryki.  
  
 W poniższej tabeli przedstawiono konstruktora do wyboru, w oparciu o te dwa czynniki:  
  
|Obiekt będzie uzyskiwał dostęp|Jeśli jest wymagany żaden kod inicjalizacji (konstruktora domyślnego), użyj|Jeśli wymagany jest kod inicjowania, użyć|  
|--------------------------------|------------------------------------------------------------------------|---------------------------------------------|  
|Wiele wątków|<xref:System.Lazy%601.%23ctor>|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>|  
|Jeden wątek|<xref:System.Lazy%601.%23ctor%28System.Boolean%29> za pomocą `isThreadSafe` równa `false`.|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> za pomocą `isThreadSafe` równa `false`.|  
  
 Wyrażenie lambda można użyć, aby określić metodę fabryki. Dzięki temu całego kodu inicjowania w jednym miejscu. Wyrażenie lambda przechwytuje kontekst, w tym dowolne argumenty, które są przekazywane do konstruktora obiektu opóźnieniem zainicjowane.  
  
 **Buforowanie wyjątek** korzystając z metodami factory, wyjątki są buforowane. Oznacza to, jeśli metoda fabryki zgłasza wyjątek pierwszego czasu wątku próbuje uzyskać dostęp <xref:System.Lazy%601.Value%2A> właściwość <xref:System.Lazy%601> obiektu, ten sam wyjątek jest zgłaszany w każdej kolejnej próby. Gwarantuje to, że każde wywołanie <xref:System.Lazy%601.Value%2A> właściwość daje ten sam wynik i pozwala uniknąć powstawania błędów, które mogą wystąpić, jeśli różne wyniki w różnych wątkach. <xref:System.Lazy%601> Oznacza rzeczywistej `T` , w przeciwnym razie mogłyby zostały zainicjowane w pewnym momencie wcześniej, zazwyczaj podczas uruchamiania. Błąd w tego jest zwykle błąd krytyczny. W przypadku potencjalnych awarii możliwe do odzyskania, firma Microsoft zaleca wbuduj logikę ponowień w procedura inicjowania (w tym przypadku metoda fabryki), podobnie jak w przypadku nie przy użyciu inicjowania z opóźnieniem.  
  
 **Alternatywa dla blokowania** w niektórych sytuacjach możesz chcieć uniknąć konieczności <xref:System.Lazy%601> obiektu domyślne zachowanie blokowania. W rzadkich przypadkach może być ryzyko zakleszczenia. W takich przypadkach można użyć <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> lub <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> konstruktora, a następnie określ <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Dzięki temu <xref:System.Lazy%601> obiekt, aby utworzyć kopię obiektu opóźnieniem zainicjowane na każdym z kilku wątków, jeśli wywołanie wątki <xref:System.Lazy%601.Value%2A> właściwości jednocześnie. <xref:System.Lazy%601> Obiektu gwarantuje, że wszystkie wątki używa tego samego wystąpienia obiektu opóźnieniem zainicjowane, a następnie odrzuca wszystkie wystąpienia, które nie są używane. W związku z tym koszt zmniejszając obciążenie blokowania jest program może czasami tworzenie i odrzucić dodatkowych kopii obiektu kosztowne. W większości przypadków jest to mało prawdopodobne. Przykłady dla <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> i <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> konstruktory demonstrują takie zachowanie.  
  
> [!IMPORTANT]
>  Po określeniu <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, wyjątki są nigdy nie w pamięci podręcznej, nawet jeśli określisz metoda fabryki.  
  
 **Konstruktory równoważne** zbiorczymi użytkowania <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> i <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> konstruktory można duplikować funkcjonalność innych konstruktorów. W poniższej tabeli przedstawiono wartości parametrów, które dają równoważne zachowanie.  
  
|Aby utworzyć <xref:System.Lazy%601> obiekt|Dla konstruktorów, które mają `LazyThreadSafetyMode` `mode` zestaw parametrów, `mode` do|Dla konstruktorów, które mają atrybut typu wartość logiczna `isThreadSafe` zestaw parametrów, `isThreadSafe` do|Dla konstruktorów bez parametrów bezpieczeństwa wątków|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|-------------------------------------------------------|  
|W pełni wątkowo; zastosowań blokowania, aby upewnić się, że tylko jeden wątek inicjuje wartość.|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|Wszystkie takie konstruktory są całkowicie bezpieczne dla wątków.|  
|Nie bezpieczne dla wątków.|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|Nie dotyczy.|  
|W pełni wątkowo; Wyścig wątków do inicjacji wartości.|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|Nie dotyczy.|Nie dotyczy.|  
  
 **Inne możliwości** uzyskać informacji na temat użytkowania <xref:System.Lazy%601> za pomocą pola statyczne wątku lub jako magazyn zapasowy właściwości, zobacz [inicjowania z opóźnieniem](~/docs/framework/performance/lazy-initialization.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Lazy%601> Aby klasa zapewniała inicjowania z opóźnieniem z dostępem z wielu wątków.  
  
> [!NOTE]
>  W przykładzie użyto <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> konstruktora. Ilustruje też użycie <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> konstruktora (Określanie `true` dla `isThreadSafe`) i <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> konstruktora (Określanie <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> dla `mode`). Aby przełączyć się do innego konstruktora, można zmienić konstruktorów, które są oznaczone jako komentarz.  
>   
>  Aby uzyskać przykład, który przedstawia wyjątek buforowania, za pomocą tego samego konstruktorów, zobacz <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> konstruktora.  
  
 W przykładzie zdefiniowano `LargeObject` klasę, która będzie inicjowana z opóźnieniem przez jeden z kilku wątków. Cztery kluczowe części kodu ilustrują tworzenie inicjatora, metoda fabryki, rzeczywiste inicjowania i Konstruktor `LargeObject` klasy, która wyświetla komunikat, gdy obiekt zostanie utworzony. Na początku `Main` metody, w przykładzie jest tworzony wątkowo inicjatora działającego z opóźnieniem dla `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#newlazy)]  
  
 Metoda fabryki pokazano tworzenie obiektu, z symbolem zastępczym dla dalszych inicjowania:  
  
 [!code-csharp[System.Lazy\`1#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#factoryfunc)]  
  
 Należy zwrócić uwagę na to, że sekcje kodu w pierwszych dwóch można łączyć za pomocą funkcji lambda, jak pokazano poniżej:  
  
 [!code-csharp[System.Lazy\`1#InitWithLambda](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/lambda.cs#initwithlambda)]
 [!code-vb[System.Lazy\`1#InitWithLambda](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/lambda.vb#initwithlambda)]  
  
 W przykładzie wstrzymano, aby wskazać, że przez czas nieokreślony może upłynąć, zanim wystąpi inicjowania z opóźnieniem. Po naciśnięciu klawisza **Enter** klucza, przykład tworzy i uruchamia trzy wątków. `ThreadProc` Metodę, która jest używana przez wszystkie wywołania trzech wątków <xref:System.Lazy%601.Value%2A> właściwości. Dzieje się tak, po raz pierwszy `LargeObject` tworzone jest wystąpienie:  
  
 [!code-csharp[System.Lazy\`1#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#valueprop)]  
  
 Konstruktor obiektu `LargeObject` klasy, która obejmuje klucza ostatniej części kodu, zostanie wyświetlony komunikat i rejestruje tożsamość wątku inicjowania. Dane wyjściowe programu pojawia się na końcu listy pełnego kodu.  
  
 [!code-csharp[System.Lazy\`1#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#largector)]  
  
> [!NOTE]
>  Dla uproszczenia w tym przykładzie użyto globalnego wystąpienia <xref:System.Lazy%601>, a wszystkie metody są `static` (`Shared` w języku Visual Basic). Nie są wymogi, od których zależy możliwość inicjowania z opóźnieniem.  
  
 [!code-csharp[System.Lazy\`1#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#all)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Domyślnie wszystkie publiczne i chronione elementy członkowskie <see cref="T:System.Lazy`1" /> klasy są bezpieczne dla wątków i mogą być używane jednocześnie z wielu wątków. (Opcjonalnie) i każdego wystąpienia, przy użyciu parametrów do konstruktorów typu, mogą zostać usunięte tych gwarancji bezpieczeństwa wątków.</threadsafe>
    <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
    <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inicjalizacja z opóźnieniem</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Lazy`1" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Lazy`1" /> klasy. W przypadku inicjowania z opóźnieniem jest używany domyślny konstruktor obiektu na typ docelowy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utworzone za pomocą tego konstruktora wystąpienia mogą być używane jednocześnie z wielu wątków.  
  
 Tryb bezpieczeństwa wątków <xref:System.Lazy%601> wystąpienie, który jest inicjowany za pomocą tego konstruktora jest <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. Tryb awaryjny wątku opisano zachowanie, gdy wiele wątków próbuje zainicjować <xref:System.Lazy%601> wystąpienia.  
  
 A <xref:System.Lazy%601> wystąpienia utworzone za pomocą tego konstruktora nie będzie buforować wyjątków. Aby uzyskać więcej informacji, zobacz <xref:System.Lazy%601> klasy lub <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie tego konstruktora. Ilustruje także użycie <xref:System.Lazy%601.%23ctor%28System.Boolean%29> konstruktora (Określanie `true` dla `isThreadSafe`) i <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> konstruktora (Określanie <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> dla `mode`). Aby przełączyć się do innego konstruktora, można zmienić konstruktorów, które są oznaczone jako komentarz.  
  
 W przykładzie zdefiniowano `LargeObject` klasę, która będzie inicjowana z opóźnieniem przez jeden z kilku wątków. Dwa kluczowe wiersze kodu, w tym przykładzie są tworzenia inicjatora i rzeczywiste inicjowania. Na początku `Main` metody, w przykładzie jest tworzony wątkowo inicjatora działającego z opóźnieniem dla `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#newlazy)]  
  
 Przykład tworzy i uruchamia trzy wątki, które blokują na <xref:System.Threading.ManualResetEvent> obiektu, tak aby przykładu można zwolnić wątków jednocześnie. `ThreadProc` Metodę, która jest używana przez wszystkie wywołania trzech wątków <xref:System.Lazy%601.Value%2A> właściwości do pobrania `LargeObject` wystąpienie:  
  
 [!code-csharp[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#valueprop)]  
  
 <xref:System.Lazy%601> Klasa udostępnia blokowania, dzięki czemu można utworzyć tylko jeden wątek `LargeObject` wystąpienia. W przykładzie pokazano, że wszystkie wątki uzyskać tego samego wystąpienia.  
  
> [!NOTE]
>  Dla uproszczenia w tym przykładzie użyto globalnego wystąpienia <xref:System.Lazy%601>, a wszystkie metody są `static` (`Shared` w języku Visual Basic). Nie są wymogi, od których zależy możliwość inicjowania z opóźnieniem.  
  
 [!code-csharp[System.Lazy\`1.ctor#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctor#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inicjalizacja z opóźnieniem</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; isThreadSafe" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isThreadSafe"><see langword="true" /> Aby tego wystąpienia można używać jednocześnie z wielu wątków; <see langword="false" /> aby wystąpienie można używać tylko jednego wątku w danym momencie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Lazy`1" /> klasy. W przypadku inicjowania z opóźnieniem domyślny konstruktor obiektu typu docelowego i tryb inicjowania określonej są używane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tryb bezpieczeństwa wątków <xref:System.Lazy%601> wystąpienie, który jest inicjowany za pomocą tego konstruktora jest <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> Jeśli `isThreadSafe` jest `true`; w przeciwnym razie jest to tryb <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. Tryb awaryjny wątku opisano zachowanie, gdy wiele wątków próbuje zainicjować <xref:System.Lazy%601> wystąpienia. Aby określić <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> trybie użyj <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> lub <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> konstruktora.  
  
 A <xref:System.Lazy%601> wystąpienia utworzone za pomocą tego konstruktora nie będzie buforować wyjątków. Aby uzyskać więcej informacji, zobacz <xref:System.Lazy%601> klasy lub <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie tego konstruktora, aby utworzyć inicjatora działającego z opóźnieniem, który nie jest bezpieczny wątkowo, dla scenariuszy, w którym występuje wszelki dostęp do obiektu opóźnieniem zainicjowane na tym samym wątku. Ilustruje też użycie <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> konstruktora (Określanie <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> dla `mode`. Aby przełączyć się do innego konstruktora, można zmienić konstruktora jest opatrzona komentarzem.  
  
> [!NOTE]
>  Dla kodu, który pokazuje, jak użyć tego konstruktora w scenariuszach wielowątkowych (Określanie `true` dla `isThreadSafe`), zobacz przykład <xref:System.Lazy%601.%23ctor> konstruktora.  
  
 W przykładzie zdefiniowano `LargeObject` klasę, która będzie inicjowana z opóźnieniem. W `Main` metody, w przykładzie jest tworzony <xref:System.Lazy%601> wystąpienia, a następnie pauzy. Po naciśnięciu klawisza **Enter** klucza, przykład uzyskuje dostęp do <xref:System.Lazy%601.Value%2A> właściwość <xref:System.Lazy%601> wystąpienia, co powoduje, że inicjowania wystąpienia. Konstruktor obiektu `LargeObject` klasa wyświetla komunikat na konsoli.  
  
> [!NOTE]
>  Dla uproszczenia w tym przykładzie użyto globalnego wystąpienia <xref:System.Lazy%601>, a wszystkie metody są `static` (`Shared` w języku Visual Basic). Nie są wymogi, od których zależy możliwość inicjowania z opóźnieniem.  
  
 [!code-csharp[System.Lazy\`1.ctorBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inicjalizacja z opóźnieniem</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; valueFactory" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Delegat, który jest wywoływane w celu utworzenia wartości opóźnieniem zainicjowany po jest wymagana.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Lazy`1" /> klasy. W przypadku inicjowania z opóźnieniem jest używana funkcja określonego inicjowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utworzone za pomocą tego konstruktora wystąpienia mogą być używane jednocześnie z wielu wątków.  
  
 Tryb bezpieczeństwa wątków <xref:System.Lazy%601> wystąpienie, który jest inicjowany za pomocą tego konstruktora jest <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. Tryb awaryjny wątku opisano zachowanie, gdy wiele wątków próbuje zainicjować <xref:System.Lazy%601> wystąpienia.  
  
 Wyjątki wyrzucane przez `valueFactory` są buforowane. Aby uzyskać więcej informacji, zobacz <xref:System.Lazy%601> klasy lub <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie tego konstruktora, aby zapewnić inicjowania z opóźnieniem przy użyciu buforowania wyjątek. Ilustruje też użycie <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> konstruktora (Określanie `true` dla `isThreadSafe`) i <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> konstruktora (Określanie <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> dla `mode`). Aby przełączyć się do innego konstruktora, można zmienić konstruktorów, które są oznaczone jako komentarz.  
  
 W przykładzie zdefiniowano `LargeObject` klasę, która będzie inicjowana z opóźnieniem przez jeden z kilku wątków. Trzy kluczowe części kodu ilustrują tworzenie inicjatora, rzeczywiste inicjowania i Konstruktor `LargeObject` klasy, która przedstawia wyjątek buforowania. Na początku `Main` metody, w przykładzie jest tworzony wątkowo inicjatora działającego z opóźnieniem dla `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#newlazy)]  
  
 Przykład tworzy i uruchamia trzy wątków. `ThreadProc` Metodę, która jest używana przez wszystkie wywołania trzech wątków <xref:System.Lazy%601.Value%2A> właściwości do pobrania `LargeObject` wystąpienie:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#valueprop)]  
  
 W Konstruktorze typu `LargeObject` klasy, trzecia sekcja klucza kodu zgłasza wyjątek, po raz pierwszy `LargeObject` wystąpienie jest tworzone, ale następnie umożliwia tworzenie wystąpienia występuje:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#largector)]  
  
 Gdy ten przykład zostanie uruchomiony, pierwszym wątkiem, który podejmie próbę utworzenia wystąpienia `LargeObject` kończy się niepowodzeniem, a wyjątek zostaje przechwycony. Można by oczekiwać, że następny wątek pomyślnie utworzyć wystąpienie, ale <xref:System.Lazy%601> obiekt ma pamięci podręcznej wyjątku. W związku z tym wszystkie wątki trzy zgłosić wyjątek.  
  
> [!NOTE]
>  Dla uproszczenia w tym przykładzie użyto globalnego wystąpienia <xref:System.Lazy%601>, a wszystkie metody są `static` (`Shared` w języku Visual Basic). Nie są wymogi, od których zależy możliwość inicjowania z opóźnieniem.  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFunc#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" /> jest <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inicjalizacja z opóźnieniem</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; mode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="mode">Jedna z wartości wyliczenia, które określa tryb bezpieczeństwa wątków.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Lazy`1" /> klasę, która korzysta z domyślnego konstruktora <paramref name="T" /> i tryb bezpieczeństwo wątków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tryb bezpieczeństwa wątków <xref:System.Lazy%601> wystąpienia opisano zachowanie, gdy wiele wątków próbuje zainicjować <xref:System.Lazy%601> wystąpienia.  
  
 A <xref:System.Lazy%601> wystąpienia utworzone za pomocą tego konstruktora nie będzie buforować wyjątków. Aby uzyskać więcej informacji, zobacz <xref:System.Lazy%601> klasy lub <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie tego konstruktora, aby utworzyć inicjatora działającego z opóźnieniem, umożliwiającą wielu wątków wyścigu do utworzenia obiektu opóźnieniem. Wiele wątków może się powieść podczas tworzenia wystąpienia, ale wszystkie wątki użyć wystąpienia, który został utworzony jako pierwszy.  
  
> [!NOTE]
>  Na przykład demonstrujący, jak używać tego konstruktora w scenariuszach jednowątkowe (Określanie <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> dla `mode`), zobacz <xref:System.Lazy%601.%23ctor%28System.Boolean%29> konstruktora. Aby uzyskać przykład, który demonstruje sposób użyć tego konstruktora, aby zapewnić blokowanie zamiast wyścigu w scenariusze wielowątkowe (Określanie <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> dla `mode`), zobacz <xref:System.Lazy%601.%23ctor> konstruktora.  
  
 W przykładzie zdefiniowano `LargeObject` klasę, która będzie inicjowana z opóźnieniem przez żaden z kilku wątków. Trzy kluczowe części kodu ilustrują tworzenie inicjatora, rzeczywiste inicjowania i Konstruktor i finalizatora `LargeObject` klasy. Na początku `Main` metody, w przykładzie jest tworzony <xref:System.Lazy%601> obiekt, który wykonuje inicjowanie z opóźnieniem `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#newlazy)]  
  
 Przykład tworzy i uruchamia trzy wątki, które blokują na <xref:System.Threading.ManualResetEvent> obiektu, tak aby przykładu można zwolnić wątków jednocześnie. W `ThreadProc` metodę, która jest używana przez wszystkich trzech wątków podczas wywoływania <xref:System.Lazy%601.Value%2A> tworzy właściwość `LargeObject` wystąpienie:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#valueprop)]  
  
 Ponieważ Konstruktor <xref:System.Lazy%601> określonego wystąpienia <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, wszystkie trzy wątki mogą tworzyć `LargeObject` wystąpień. W przykładzie pokazano to w Konstruktorze i finalizatora, wyświetlając komunikaty konsoli `LargeObject` klasy:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#ctorfinalizer)]  
  
 Jednak <xref:System.Lazy%601> obiektu gwarantuje, że tylko jedno wystąpienie jest używany przez wszystkie wątki. Dane wyjściowe z przykładu pokazuje, że wszystkie wątki trzy używają tego samego wystąpienia, a także pokazuje, że dwa wystąpienia można odzyskać przez wyrzucanie elementów bezużytecznych.  
  
> [!NOTE]
>  Dla uproszczenia w tym przykładzie użyto globalnego wystąpienia <xref:System.Lazy%601>, a wszystkie metody są `static` (`Shared` w języku Visual Basic). Nie są wymogi, od których zależy możliwość inicjowania z opóźnieniem.  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> zawiera nieprawidłową wartość.</exception>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inicjalizacja z opóźnieniem</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(T value);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : 'T -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, isThreadSafe)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Delegat, który jest wywoływane w celu utworzenia wartości opóźnieniem zainicjowany po jest wymagana.</param>
        <param name="isThreadSafe"><see langword="true" /> Aby tego wystąpienia można używać jednocześnie z wielu wątków; <see langword="false" /> się tego wystąpienia można używać tylko jednego wątku w danym momencie.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Lazy`1" /> klasy. W przypadku inicjowania z opóźnieniem inicjowania określonej funkcji i tryb inicjowania są używane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tryb bezpieczeństwa wątków <xref:System.Lazy%601> wystąpienie, który jest inicjowany za pomocą tego konstruktora jest <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> Jeśli `isThreadSafe` jest `true`; w przeciwnym razie jest to tryb <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. Tryb awaryjny wątku opisano zachowanie, gdy wiele wątków próbuje zainicjować <xref:System.Lazy%601> wystąpienia.  
  
 Aby określić <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> trybie użyj <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> lub <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> konstruktora.  
  
 Wyjątki wyrzucane przez `valueFactory` są buforowane. Aby uzyskać więcej informacji, zobacz <xref:System.Lazy%601> klasy lub <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie tego konstruktora, aby zapewnić inicjowania z opóźnieniem dla wyjątków, w przypadku scenariusza z jednym wątkiem. Ilustruje też użycie <xref:System.Lazy%601.%23ctor%2A> konstruktora (Określanie <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> dla `mode`). Aby przełączyć się do tego konstruktora, można zmienić konstruktora jest opatrzona komentarzem.  
  
> [!NOTE]
>  Dla kodu, który pokazuje, jak użyć tego konstruktora w scenariuszach wielowątkowych (Określanie `true` dla `isThreadSafe`), zobacz przykład <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> konstruktora.  
  
 W przykładzie zdefiniowano `LargeObject` klasę, która będzie inicjowana z opóźnieniem przez jeden z kilku wątków. Trzy kluczowe części kodu ilustrują tworzenie inicjatora, rzeczywiste inicjowania i Konstruktor `LargeObject` klasy, która przedstawia wyjątek buforowania. Na początku `Main` metody, w przykładzie jest tworzony wątkowo inicjatora działającego z opóźnieniem dla `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#newlazy)]  
  
 W wywołaniu konstruktora `isThreadSafe` parametr jest `false`, więc <xref:System.Lazy%601> nie jest wątek bezpieczne. Ponieważ nie jest bezpieczny dla wątków, przykład wywołuje <xref:System.Lazy%601.Value%2A> właściwość trzy razy w tym samym wątku:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#valueprop)]  
  
 W Konstruktorze typu `LargeObject` klasy, trzecia sekcja klucza kodu zgłasza wyjątek, po raz pierwszy `LargeObject` wystąpienie jest tworzone, ale następnie umożliwia tworzenie wystąpienia występuje:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#largector)]  
  
 Gdy ten przykład zostanie uruchomiony, pierwsza próba utworzenia instancji `LargeObject` kończy się niepowodzeniem, a wyjątek zostaje przechwycony. Można by oczekiwać, że powiedzie się następnej próby, ale <xref:System.Lazy%601> obiekt ma pamięci podręcznej wyjątku. W związku z tym wszystkie trzy próby zgłosić wyjątek.  
  
> [!NOTE]
>  Dla uproszczenia w tym przykładzie użyto globalnego wystąpienia <xref:System.Lazy%601>, a wszystkie metody są `static` (`Shared` w języku Visual Basic). Nie są wymogi, od których zależy możliwość inicjowania z opóźnieniem.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" /> jest <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inicjalizacja z opóźnieniem</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Delegat, który jest wywoływane w celu utworzenia wartości opóźnieniem zainicjowany po jest wymagana.</param>
        <param name="mode">Jedna z wartości wyliczenia, które określa tryb bezpieczeństwa wątków.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Lazy`1" /> klasę, która korzysta z trybu inicjowania określonej funkcji i bezpieczeństwo wątków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tryb bezpieczeństwa wątków <xref:System.Lazy%601> wystąpienia opisano zachowanie, gdy wiele wątków próbuje zainicjować <xref:System.Lazy%601> wystąpienia.  
  
 Wyjątki wyrzucane przez `valueFactory` są buforowane, chyba że `mode` jest <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Aby uzyskać więcej informacji, zobacz <xref:System.Lazy%601> klasy lub <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie tego konstruktora, aby utworzyć inicjatora działającego z opóźnieniem, umożliwiającą wielu wątków wyścigu do utworzenia obiektu opóźnieniem. Wiele wątków może się powieść podczas tworzenia wystąpienia, ale wszystkie wątki użyć wystąpienia, który został utworzony jako pierwszy. Ponadto w przykładzie pokazano, aby wyjątki nigdy nie są buforowane, po określeniu <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, nawet jeśli inicjowanie odbywa się przez funkcję, a nie przez domyślny konstruktor obiektu opóźnieniem utworzony typ.  
  
> [!NOTE]
>  Na przykład demonstrujący, jak używać tego konstruktora w scenariuszach jednowątkowe (Określanie <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> dla `mode`), zobacz <xref:System.Lazy%601.%23ctor%28System.Boolean%29> konstruktora. Aby uzyskać przykład, który demonstruje sposób użyć tego konstruktora, aby zapewnić blokowanie zamiast wyścigu w scenariusze wielowątkowe (Określanie <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> dla `mode`), zobacz <xref:System.Lazy%601.%23ctor> konstruktora.  
  
 W przykładzie zdefiniowano `LargeObject` klasę, która będzie inicjowana z opóźnieniem przez żaden z kilku wątków. Cztery kluczowe części kodu ilustrują tworzenie inicjatora, rzeczywiste inicjowania, funkcji inicjowania i Konstruktor i finalizatora `LargeObject` klasy. Na początku `Main` metody, w przykładzie jest tworzony <xref:System.Lazy%601> obiekt, który wykonuje inicjowanie z opóźnieniem `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#newlazy)]  
  
 Inicjatora działającego z opóźnieniem funkcja używana do wykonywania inicjowania. W takim przypadku funkcja jest wymagana, ponieważ nie istnieje żaden domyślny konstruktor dla `LargeObject` klasy.  
  
 Przykład tworzy i uruchamia trzy wątki, które blokują na <xref:System.Threading.ManualResetEvent> obiektu, tak aby przykładu można zwolnić wątków jednocześnie. W `ThreadProc` metodę, która jest używana przez wszystkich trzech wątków podczas wywoływania <xref:System.Lazy%601.Value%2A> tworzy właściwość `LargeObject` wystąpienie:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#valueprop)]  
  
 W trzeciej kluczy sekcji kodu, funkcja inicjowania z opóźnieniem jest wywoływana, aby utworzyć `LargeObject` wystąpienia. Funkcja zgłasza wyjątku pierwszej czas jest o nazwie:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#factoryfunc)]  
  
 Wszystkie inne <xref:System.Threading.LazyThreadSafetyMode> ustawienie nieobsługiwanego wyjątku w funkcji inicjowania będzie buforowana. Jednak <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> wyłącza buforowanie wyjątku. Dane wyjściowe z przykładu pokazuje, że kolejna próba zainicjowania obiektu zakończy się pomyślnie.  
  
> [!NOTE]
>  Komunikat o wyjątku zwykle pojawia się po komunikaty wskazujące, że inne wątki zostały pomyślnie zainicjował obiekt. Jest to z powodu opóźnienia wynikające z tworzenia i przechwytywania wyjątków.  
  
 Ponieważ Konstruktor <xref:System.Lazy%601> określonego wystąpienia <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, wszystkie trzy wątki mogą tworzyć `LargeObject` wystąpień. W przykładzie pokazano to w Konstruktorze i finalizatora, wyświetlając komunikaty konsoli `LargeObject` klasy:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#ctorfinalizer)]  
  
 <xref:System.Lazy%601> Obiektu gwarantuje, że tylko jedno wystąpienie jest używany przez wszystkie wątki (z wyjątkiem wątku, w którym zgłasza wyjątek, funkcja inicjowania). Dane wyjściowe z przykładu pokazują to.  
  
> [!NOTE]
>  Dla uproszczenia w tym przykładzie użyto globalnego wystąpienia <xref:System.Lazy%601>, a wszystkie metody są `static` (`Shared` w języku Visual Basic). Nie są wymogi, od których zależy możliwość inicjowania z opóźnieniem.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" /> jest <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inicjalizacja z opóźnieniem</related>
      </Docs>
    </Member>
    <Member MemberName="IsValueCreated">
      <MemberSignature Language="C#" Value="public bool IsValueCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueCreated" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.IsValueCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueCreated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueCreated : bool" Usage="System.Lazy&lt;'T&gt;.IsValueCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wartość została utworzona w tym <see cref="T:System.Lazy`1" /> wystąpienia.</summary>
        <value><see langword="true" /> Jeśli wartość została utworzona w tym <see cref="T:System.Lazy`1" /> wystąpienia; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wystąpi inicjowania z opóźnieniem dla <xref:System.Lazy%601> wystąpienia, może to spowodować wartość tworzona lub wyjątku. Jeśli wyjątek jest wyrzucony, kolejne zachowanie <xref:System.Lazy%601> wystąpienia zależy od tego, czy wyjątek pamięć podręczna jest włączona. Jeśli <xref:System.Lazy%601> wystąpienie zostało utworzone za pomocą konstruktora, który nie określa funkcję inicjowania, a następnie buforowanie wyjątek nie jest włączone. Kolejna próba zainicjowania <xref:System.Lazy%601> może się powieść i po pomyślnym zainicjowaniu <xref:System.Lazy%601.IsValueCreated%2A> właściwość zwraca `true`. Jeśli <xref:System.Lazy%601> wystąpienie zostało utworzone za pomocą funkcji inicjowania (określony przez `valueFactory` parametru <xref:System.Lazy%601> konstruktora), a następnie buforowanie wyjątek jest kontrolowana przez tryb awaryjny wątku.  
  
-   Jeśli tryb jest <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> lub <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, nie ma żadnych drugą szansę, aby zainicjować <xref:System.Lazy%601> wystąpienia. Jeśli wyjątek wystąpi, jest nieobsługiwany w funkcji inicjowania tego wyjątku jest buforowana i zgłaszany ponownie na kolejne uzyskuje dostęp do programu <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> właściwości. Wartość nie jest tworzony, jeśli wyjątek jest generowany, więc w takich przypadkach <xref:System.Lazy%601.IsValueCreated%2A> zwraca `false`.  
  
-   Jeśli tryb jest <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, pierwszy wątek, który zakończy się pomyślnie w działania funkcji inicjowania (lub domyślnego konstruktora) tworzy wartość <xref:System.Lazy%601> wystąpienia. Jeśli funkcja inicjowania zgłasza wyjątek w jednym wątku, inne wątki nadal może podjąć próbę zainicjowania <xref:System.Lazy%601> wystąpienia. Do momentu utworzenia wartość <xref:System.Lazy%601.IsValueCreated%2A> właściwość zwraca `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inicjalizacja z opóźnieniem</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="lazy.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy i zwraca reprezentację ciągu <see cref="P:System.Lazy`1.Value" /> właściwość dla tego wystąpienia.</summary>
        <returns>Wynik wywołania metody <see cref="M:System.Object.ToString" /> metody <see cref="P:System.Lazy`1.Value" /> właściwość dla tego wystąpienia, jeśli wartość została utworzona (to znaczy, jeśli <see cref="P:System.Lazy`1.IsValueCreated" /> właściwość zwraca <see langword="true" />). W przeciwnym razie ciąg, który wskazuje, że wartości nie został utworzony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody nie powoduje inicjowania.  
  
 <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> Właściwość może być `null` po inicjowania z opóźnieniem, jeśli metoda fabryki, która została określona dla `valueFactory` parametru <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, lub <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> Konstruktor zwraca `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><see cref="P:System.Lazy`1.Value" /> Właściwość <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public T Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Value" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T Value { T get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : 'T" Usage="System.Lazy&lt;'T&gt;.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość opóźnieniem zainicjowane bieżącego <see cref="T:System.Lazy`1" /> wystąpienia.</summary>
        <value>Wartość opóźnieniem zainicjowane bieżącego <see cref="T:System.Lazy`1" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Lazy%601.IsValueCreated%2A?displayProperty=nameWithType> właściwość `false`, uzyskiwania dostępu do <xref:System.Lazy%601.Value%2A> właściwość wymusza inicjowania.  
  
 Oprócz wyjątków, które są wyświetlane <xref:System.Lazy%601.Value%2A> właściwość może zgłosić nieobsługiwany wyjątek, który jest generowany przez metoda fabryki, który został przekazany do `valueFactory` parametru <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, lub <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> Konstruktor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><see cref="T:System.Lazy`1" /> Zainicjowano wystąpienia, aby użyć domyślnego konstruktora typu, który jest inicjowany opóźnieniem i brak uprawnienia do dostępu do konstruktora.</exception>
        <exception cref="T:System.MissingMemberException"><see cref="T:System.Lazy`1" /> Zainicjowano wystąpienia, aby użyć domyślnego konstruktora typu, który jest inicjowany opóźnieniem i ten typ nie ma publiczny konstruktor bez parametrów.</exception>
        <exception cref="T:System.InvalidOperationException">Funkcja inicjowania próbuje uzyskać dostęp do <see cref="P:System.Lazy`1.Value" /> w tym wystąpieniu.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inicjalizacja z opóźnieniem</related>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Lazy&lt;T&gt;" FullName="System.Lazy&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ad53c03faf661b5a698d5ef0c4fcd9d0451bbc14" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30744416" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Lazy&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Lazy`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Lazy`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Lazy(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Lazy" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.System_LazyDebugView`1))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Typ obiektu, który jest inicjowany opóźnieniem.</typeparam>
    <summary>Zapewnia obsługę Inicjalizacja z opóźnieniem.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj inicjacji z opóźnieniem, które mają być odroczone Tworzenie obiektu duże lub wymagają dużej ilości zasobów lub wykonywania zadań intensywnie, zwłaszcza w przypadku takich tworzenie i wykonywanie nie mogą występować podczas okresu istnienia programu.  
  
 Aby przygotować się do inicjowania z opóźnieniem, należy utworzyć wystąpienie <xref:System.Lazy%601>. Argument typu <xref:System.Lazy%601> obiektu, który utworzono Określa typ obiektu, który chcesz zainicjować opóźnieniem. Konstruktor, który jest używany do utworzenia <xref:System.Lazy%601> obiektu określa właściwości inicjowania. Inicjalizacja z opóźnieniem występuje po raz pierwszy <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> dostępu do właściwości.  
  
 W większości przypadków wybór konstruktora zależy od odpowiedzi na pytania dwóch:  
  
-   Obiekt opóźnieniem zainicjowane uzyskuje się dostęp z więcej niż jednego wątku? Jeśli tak, <xref:System.Lazy%601> obiektu może utworzyć ją na którymkolwiek wątku. Można użyć jednego z konstruktorów proste, którego domyślne zachowanie jest utworzenie obsługującej wielowątkowość <xref:System.Lazy%601> obiektu, tak że tylko jedno wystąpienie opóźnieniem wystąpień obiektu jest tworzony niezależnie od tego, jak wiele wątków próbuje uzyskać do niego dostęp. Aby utworzyć <xref:System.Lazy%601> obiektu, który nie jest bezpieczne dla wątków, należy użyć konstruktora, który umożliwia określenie nie bezpieczeństwa wątków.  
  
    > [!CAUTION]
    >  Tworzenie <xref:System.Lazy%601> obiektu wielowątkowość nie chroni opóźnieniem zainicjowanego obiektu. Jeśli wiele wątków można uzyskać dostępu do obiektu opóźnieniem zainicjowane, musisz wprowadzić jego właściwości i metody bezpiecznego dostępu wielowątkowe.  
  
-   Inicjalizacja z opóźnieniem wymaga dużej ilości kodu lub opóźnieniem zainicjowanego obiektu ma domyślny konstruktor, który jest wymagane i nie zgłaszają wyjątki? Należy napisać kod inicjujący lub wyjątki muszą być obsługiwani, użyj jednej z konstruktorów metoda fabryki. Wpisz swój kod inicjowania w metodzie fabryki.  
  
 W poniższej tabeli przedstawiono które konstruktora, aby wybrać, w oparciu o te dwa czynniki:  
  
|Obiekt będą mieli dostęp przez|Jeśli wymagana jest nie kod inicjujący (domyślny konstruktor), użyj|Jeśli wymagana jest kod inicjujący, użyj|  
|--------------------------------|------------------------------------------------------------------------|---------------------------------------------|  
|Wiele wątków|<xref:System.Lazy%601.%23ctor>|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>|  
|Jeden wątek|<xref:System.Lazy%601.%23ctor%28System.Boolean%29> z `isThreadSafe` ustawioną `false`.|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> z `isThreadSafe` ustawioną `false`.|  
  
 Wyrażenia lambda służy do określania metody fabryki. Dzięki temu cały kod inicjowania w jednym miejscu. Wyrażenia lambda przechwytuje kontekstu, tym żadnych argumentów, które przekazujesz do konstruktora obiektu opóźnieniem zainicjowane.  
  
 **Buforowanie wyjątek** korzystając z metodami factory, wyjątki są buforowane. Oznacza to, jeśli metoda fabryki zgłasza wyjątek pierwszy Czas wątku próbuje uzyskać dostęp <xref:System.Lazy%601.Value%2A> właściwość <xref:System.Lazy%601> obiektu o tej samej wyjątku przy każdej próbie kolejne. Gwarantuje to, że każdego wywołania <xref:System.Lazy%601.Value%2A> właściwość tworzy takiego samego wyniku i pozwala uniknąć subtelnych błędów, które mogą wystąpić, jeśli inne wątki uzyskać różne wyniki. <xref:System.Lazy%601> Oznacza rzeczywistych `T` które w przeciwnym razie będzie zostały zainicjowane w pewnym momencie wcześniej, zazwyczaj podczas uruchamiania. Błąd w tego jest zwykle krytyczny. Istnieje możliwość dla niepowodzenia możliwe do odzyskania, zaleca się tworzenie logikę ponawiania do procedura inicjowania (w tym przypadku metoda fabryki), tak samo, jak gdyby nie zostały przy użyciu inicjowania z opóźnieniem.  
  
 **Zamiast blokowania** w niektórych sytuacjach możesz chcieć uniknąć ponoszenia dodatkowych nakładów na <xref:System.Lazy%601> obiektu domyślne zachowanie blokowania. W rzadkich przypadkach może być możliwe zakleszczenie. W takich przypadkach można użyć <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> lub <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> konstruktora i określ <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Dzięki temu <xref:System.Lazy%601> obiekt, aby utworzyć kopię obiektu opóźnieniem zainicjowane w każdym kilka wątków rozmowy telefonicznej wątki <xref:System.Lazy%601.Value%2A> właściwości jednocześnie. <xref:System.Lazy%601> Obiektu gwarantuje, że wszystkie wątki używa tego samego wystąpienia obiektu opóźnieniem zainicjowane i odrzuca wszystkie wystąpienia, które nie są używane. W związku z tym koszt zmniejszenie nakładów pracy blokowania jest program może czasami tworzenie i odrzucić dodatkowych kopii obiektu kosztowne. W większości przypadków jest to mało prawdopodobne. Przykłady dla <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> i <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> konstruktorów demonstrują takie zachowanie.  
  
> [!IMPORTANT]
>  Po określeniu <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, wyjątki są nigdy nie pamięci podręcznej, nawet w przypadku wybrania metody fabryki.  
  
 **Konstruktory równoważne** oprócz umożliwia używanie <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> i <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> Konstruktory mogą powielają funkcjonalność innych konstruktorów. W poniższej tabeli przedstawiono wartości parametrów, które powodują powstanie równoważne zachowanie.  
  
|Aby utworzyć <xref:System.Lazy%601> obiekt|Dla konstruktorów, które mają `LazyThreadSafetyMode` `mode` ustawić parametr `mode` do|Dla konstruktorów, które mają wartość logiczną `isThreadSafe` ustawić parametr `isThreadSafe` do|Dla konstruktorów bez parametrów bezpieczeństwa wątków|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|-------------------------------------------------------|  
|Pełni wielowątkowość; używa blokowania, aby upewnić się, że tylko jeden wątek inicjuje wartość.|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|Wszystkie takie konstruktorów pełni są bezpieczne dla wątków.|  
|Nie bezpieczne dla wątków.|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|Nie dotyczy.|  
|Pełni wielowątkowość; wątki wyścigu zainicjować wartość.|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|Nie dotyczy.|Nie dotyczy.|  
  
 **Inne funkcje** informacje dotyczące korzystania z <xref:System.Lazy%601> z pola statyczne dla wątku lub jako magazynu zapasowego dla właściwości, zobacz [Incjalizacji](~/docs/framework/performance/lazy-initialization.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Lazy%601> klasy, aby zapewnić dostęp wiele wątków Inicjalizacja z opóźnieniem.  
  
> [!NOTE]
>  W przykładzie użyto <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> konstruktora. Również zademonstrowano użycie <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> — Konstruktor (Określanie `true` dla `isThreadSafe`) i <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> konstruktora (Określanie <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> dla `mode`). Aby przełączyć się do innego konstruktora, można zmienić konstruktorów, które są oznaczone jako komentarz.  
>   
>  Na przykład, który pokazuje wyjątek buforowanie przy użyciu tego samego konstruktorów, zobacz <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> konstruktora.  
  
 W przykładzie zdefiniowano `LargeObject` klasy, która zostanie zainicjowana w trybie opóźnienia przez jeden z kilku wątków. Cztery sekcje klucza kodu zilustrować tworzenie inicjatora, metoda fabryki rzeczywiste inicjowania i konstruktora `LargeObject` klasy, która wyświetla komunikat po utworzeniu obiektu. Na początku `Main` metody w przykładzie jest tworzony wątkowo opóźnieniem inicjator `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#newlazy)]  
  
 Metoda fabryki pokazano tworzenie obiektu, z symbolem zastępczym dla dalszego inicjowania:  
  
 [!code-csharp[System.Lazy\`1#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#factoryfunc)]  
  
 Należy pamiętać, że sekcji kodu dwóch pierwszych można łączyć za pomocą funkcji lambda, jak pokazano poniżej:  
  
 [!code-csharp[System.Lazy\`1#InitWithLambda](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/lambda.cs#initwithlambda)]
 [!code-vb[System.Lazy\`1#InitWithLambda](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/lambda.vb#initwithlambda)]  
  
 W przykładzie wstrzymano, aby wskazać, że nieokreślony może upłynąć, zanim nastąpi jego inicjowania z opóźnieniem. Po naciśnięciu **Enter** klucza, przykładzie utworzenie i uruchomienie trzech wątków. `ThreadProc` Metodę, która jest używana przez wszystkie wątki trzy wywołania <xref:System.Lazy%601.Value%2A> właściwości. Po raz pierwszy dzieje się tak, `LargeObject` jest tworzone wystąpienie:  
  
 [!code-csharp[System.Lazy\`1#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#valueprop)]  
  
 Konstruktor obiektu `LargeObject` klasy, która obejmuje klucza ostatniej części kodu, zostanie wyświetlony komunikat i rejestruje tożsamość inicjowania wątku. Dane wyjściowe z programu pojawia się na końcu listy pełnego kodu.  
  
 [!code-csharp[System.Lazy\`1#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#largector)]  
  
> [!NOTE]
>  Dla uproszczenia, w tym przykładzie używane globalne wystąpienie <xref:System.Lazy%601>, i są wszystkie metody `static` (`Shared` w języku Visual Basic). Nie są wymogi, od których zależy możliwość inicjowania z opóźnieniem.  
  
 [!code-csharp[System.Lazy\`1#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#all)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Domyślnie wszystkie publiczne i chronione elementy członkowskie <see cref="T:System.Lazy`1" /> klasy są bezpieczne dla wątków i mogą być używane jednocześnie wiele wątków. (Opcjonalnie) i dla każdego wystąpienia, przy użyciu parametrów konstruktorów typu można usunąć tych gwarancji bezpieczeństwa wątków.</threadsafe>
    <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Lazy`1" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Lazy`1" /> klasy. W przypadku inicjowania z opóźnieniem jest używany domyślny konstruktor obiektu typu docelowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie, który jest tworzony w tym konstruktorze mogą być używane jednocześnie wiele wątków.  
  
 Tryb awaryjny wątku z <xref:System.Lazy%601> wystąpienie, które jest inicjowany z tego konstruktora jest <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. Tryb awaryjny wątku określa zachowanie, gdy wiele wątków próbuje zainicjować <xref:System.Lazy%601> wystąpienia.  
  
 A <xref:System.Lazy%601> wystąpienia, który jest tworzony w tym konstruktorze nie będzie buforować wyjątków. Aby uzyskać więcej informacji, zobacz <xref:System.Lazy%601> klasy lub <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> wyliczenia.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie tego konstruktora. Również ilustruje użycie <xref:System.Lazy%601.%23ctor%28System.Boolean%29> — Konstruktor (Określanie `true` dla `isThreadSafe`) i <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> — Konstruktor (Określanie <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> dla `mode`). Aby przełączyć się do innego konstruktora, można zmienić konstruktorów, które są oznaczone jako komentarz.  
  
 W przykładzie zdefiniowano `LargeObject` klasy, która zostanie zainicjowana w trybie opóźnienia przez jeden z kilku wątków. Dwa wiersze klucza kodu w tym przykładzie są tworzenia Inicjator i rzeczywistego inicjowania. Na początku `Main` metody w przykładzie jest tworzony wątkowo opóźnieniem inicjator `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#newlazy)]  
  
 Przykład utworzenie i uruchomienie trzech wątków, które blokują na <xref:System.Threading.ManualResetEvent> obiektu, dzięki czemu przykładzie można zwolnić wątków jednocześnie. `ThreadProc` Metodę, która jest używana przez wszystkie wątki trzy wywołania <xref:System.Lazy%601.Value%2A> właściwości do pobrania `LargeObject` wystąpienie:  
  
 [!code-csharp[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#valueprop)]  
  
 <xref:System.Lazy%601> Klasa udostępnia blokowania, tak aby tylko jeden wątek może tworzyć `LargeObject` wystąpienia. W przykładzie pokazano, że wszystkie wątki uzyskać tego samego wystąpienia.  
  
> [!NOTE]
>  Dla uproszczenia, w tym przykładzie używane globalne wystąpienie <xref:System.Lazy%601>, i są wszystkie metody `static` (`Shared` w języku Visual Basic). Nie są wymogi, od których zależy możliwość inicjowania z opóźnieniem.  
  
 [!code-csharp[System.Lazy\`1.ctor#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctor#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(bool isThreadSafe);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isThreadSafe">
          <see langword="true" /> Aby to wystąpienie można używać jednocześnie przez wiele wątków; <see langword="false" /> aby wystąpienie można było używać tylko jednego wątku naraz.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Lazy`1" /> klasy. Podczas inicjowania z opóźnieniem są używane domyślny konstruktor obiektu typ docelowy i tryb określonego inicjowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tryb awaryjny wątku z <xref:System.Lazy%601> wystąpienie, które jest inicjowany z tego konstruktora jest <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> Jeśli `isThreadSafe` jest `true`; w przeciwnym razie jest to tryb <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. Tryb awaryjny wątku określa zachowanie, gdy wiele wątków próbuje zainicjować <xref:System.Lazy%601> wystąpienia. Aby określić <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> trybie, używając <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> lub <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> konstruktora.  
  
 A <xref:System.Lazy%601> wystąpienia, który jest tworzony w tym konstruktorze nie będzie buforować wyjątków. Aby uzyskać więcej informacji, zobacz <xref:System.Lazy%601> klasy lub <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> wyliczenia.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie tego konstruktora w celu utworzenia opóźnieniem inicjatora, który nie jest bezpieczne w scenariuszach, w której występuje dostęp do obiektu opóźnieniem zainicjowana na tym samym wątku dla wątku. Użycie ilustruje też <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> — Konstruktor (Określanie <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> dla `mode`. Aby przełączyć się do innego konstruktora, można zmienić Konstruktor, który jest oznaczone jako komentarz.  
  
> [!NOTE]
>  Dla kodu, który demonstruje sposób używania tego konstruktora w scenariuszach wielowątkowe (Określanie `true` dla `isThreadSafe`), zobacz przykład <xref:System.Lazy%601.%23ctor> konstruktora.  
  
 W przykładzie zdefiniowano `LargeObject` klasy, która zostanie zainicjowana w trybie opóźnienia. W `Main` metody w przykładzie jest tworzony <xref:System.Lazy%601> wystąpienia, a następnie pauzy. Po naciśnięciu **Enter** klucza, uzyskuje dostęp przykładzie <xref:System.Lazy%601.Value%2A> właściwość <xref:System.Lazy%601> wystąpienia, co powoduje, że inicjowania występuje. Konstruktor obiektu `LargeObject` klasa wyświetla komunikat konsoli.  
  
> [!NOTE]
>  Dla uproszczenia, w tym przykładzie używane globalne wystąpienie <xref:System.Lazy%601>, i są wszystkie metody `static` (`Shared` w języku Visual Basic). Nie są wymogi, od których zależy możliwość inicjowania z opóźnieniem.  
  
 [!code-csharp[System.Lazy\`1.ctorBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Delegat, który jest wywoływane w celu tworzy opóźnieniem zainicjowane wartości, gdy jest to potrzebne.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Lazy`1" /> klasy. W przypadku inicjowania z opóźnieniem funkcji inicjowania określony jest używany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie, który jest tworzony w tym konstruktorze mogą być używane jednocześnie wiele wątków.  
  
 Tryb awaryjny wątku z <xref:System.Lazy%601> wystąpienie, które jest inicjowany z tego konstruktora jest <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. Tryb awaryjny wątku określa zachowanie, gdy wiele wątków próbuje zainicjować <xref:System.Lazy%601> wystąpienia.  
  
 Wyjątki, które są generowane przez `valueFactory` są buforowane. Aby uzyskać więcej informacji, zobacz <xref:System.Lazy%601> klasy lub <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> wyliczenia.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie tego konstruktora, aby zapewnić Inicjalizacja z opóźnieniem z buforowaniem wyjątek. Również zademonstrowano użycie <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> — Konstruktor (Określanie `true` dla `isThreadSafe`) i <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> konstruktora (Określanie <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> dla `mode`). Aby przełączyć się do innego konstruktora, można zmienić konstruktorów, które są oznaczone jako komentarz.  
  
 W przykładzie zdefiniowano `LargeObject` klasy, która zostanie zainicjowana w trybie opóźnienia przez jeden z kilku wątków. Trzy kluczowe fragmentów kodu zilustrować tworzenie inicjatora, rzeczywista inicjowania i konstruktora `LargeObject` klasy, która przedstawia buforowanie wyjątku. Na początku `Main` metody w przykładzie jest tworzony wątkowo opóźnieniem inicjator `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#newlazy)]  
  
 Przykład utworzenie i uruchomienie trzech wątków. `ThreadProc` Metodę, która jest używana przez wszystkie wątki trzy wywołania <xref:System.Lazy%601.Value%2A> właściwości do pobrania `LargeObject` wystąpienie:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#valueprop)]  
  
 W Konstruktorze `LargeObject` klasy, trzeci klucza sekcji kodu zgłasza wyjątek po raz pierwszy `LargeObject` wystąpienie zostało utworzone, ale następnie umożliwia utworzenie wystąpienia występuje:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#largector)]  
  
 Podczas uruchamiania przykładzie, pierwszy wątku, który próbuje utworzyć wystąpienie `LargeObject` zakończy się niepowodzeniem i wyjątek zostanie przechwycony. Może oczekiwać, że następnego wątku pomyślnie utworzyć wystąpienia, ale <xref:System.Lazy%601> obiektu buforowanych wyjątek. W związku z tym wszystkie wątki trzy zgłoszenie wyjątku.  
  
> [!NOTE]
>  Dla uproszczenia, w tym przykładzie używane globalne wystąpienie <xref:System.Lazy%601>, i są wszystkie metody `static` (`Shared` w języku Visual Basic). Nie są wymogi, od których zależy możliwość inicjowania z opóźnieniem.  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFunc#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="valueFactory" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(System::Threading::LazyThreadSafetyMode mode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="mode">Jedna z wartości wyliczenia, które określa tryb awaryjny wątku.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Lazy`1" /> klasy, która korzysta z domyślnego konstruktora elementu <paramref name="T" /> i tryb bezpieczeństwo wątków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tryb awaryjny wątku z <xref:System.Lazy%601> wystąpienia określa zachowanie, gdy wiele wątków próbuje zainicjować <xref:System.Lazy%601> wystąpienia.  
  
 A <xref:System.Lazy%601> wystąpienia, który jest tworzony w tym konstruktorze nie będzie buforować wyjątków. Aby uzyskać więcej informacji, zobacz <xref:System.Lazy%601> klasy lub <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> wyliczenia.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie tego konstruktora w celu utworzenia opóźnieniem inicjatora, umożliwiającą wielu wątków, aby zastępować do utworzenia obiektu opóźnieniem. Wiele wątków może się powieść, podczas tworzenia wystąpienia, ale wszystkie wątki Użyj wystąpienia, z którego został utworzony jako pierwszy.  
  
> [!NOTE]
>  Na przykład, który demonstruje sposób używania tego konstruktora w scenariuszach jednowątkowe (Określanie <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> dla `mode`), zobacz <xref:System.Lazy%601.%23ctor%28System.Boolean%29> konstruktora. Na przykład, który demonstruje sposób używania tego konstruktora zapewnienie blokowania zamiast wyścigu w scenariuszach wielowątkowe (Określanie <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> dla `mode`), zobacz <xref:System.Lazy%601.%23ctor> konstruktora.  
  
 W przykładzie zdefiniowano `LargeObject` klasy, która zostanie zainicjowana opóźnieniem przy użyciu jednej z kilku wątków. Trzy kluczowe fragmentów kodu zilustrować tworzenie inicjatora, rzeczywista inicjowania i Konstruktor i finalizatora `LargeObject` klasy. Na początku `Main` metody w przykładzie jest tworzony <xref:System.Lazy%601> obiektu wykonującego Inicjalizacja z opóźnieniem elementu `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#newlazy)]  
  
 Przykład utworzenie i uruchomienie trzech wątków, które blokują na <xref:System.Threading.ManualResetEvent> obiektu, dzięki czemu przykładzie można zwolnić wątków jednocześnie. W `ThreadProc` metodę, która jest używana przez wszystkie wątki trzy, wywoływania <xref:System.Lazy%601.Value%2A> tworzy właściwość `LargeObject` wystąpienie:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#valueprop)]  
  
 Ponieważ Konstruktor <xref:System.Lazy%601> określonego wystąpienia <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, wszystkie trzy wątki mogą tworzyć `LargeObject` wystąpień. W przykładzie pokazano to w Konstruktorze i finalizatora, wyświetlając komunikaty konsoli `LargeObject` klasy:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#ctorfinalizer)]  
  
 Jednak <xref:System.Lazy%601> obiektu gwarantuje, że tylko jedno wystąpienie jest używany przez wszystkie wątki. Dane wyjściowe z przykładu pokazuje, że wszystkie wątki trzy używać tego samego wystąpienia, a także pokazuje, że dwa wystąpienia, będzie można odzyskać przez wyrzucanie elementów bezużytecznych.  
  
> [!NOTE]
>  Dla uproszczenia, w tym przykładzie używane globalne wystąpienie <xref:System.Lazy%601>, i są wszystkie metody `static` (`Shared` w języku Visual Basic). Nie są wymogi, od których zależy możliwość inicjowania z opóźnieniem.  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> zawiera nieprawidłową wartość.</exception>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(T value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, bool isThreadSafe);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Delegat, który jest wywoływane w celu tworzy opóźnieniem zainicjowane wartości, gdy jest to potrzebne.</param>
        <param name="isThreadSafe">
          <see langword="true" /> Aby to wystąpienie można używać jednocześnie przez wiele wątków; <see langword="false" /> Aby to wystąpienie można było używać tylko jednego wątku naraz.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Lazy`1" /> klasy. Podczas inicjowania z opóźnieniem są używane funkcji określonej inicjowania i tryb inicjowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tryb awaryjny wątku z <xref:System.Lazy%601> wystąpienie, które jest inicjowany z tego konstruktora jest <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> Jeśli `isThreadSafe` jest `true`; w przeciwnym razie jest to tryb <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. Tryb awaryjny wątku określa zachowanie, gdy wiele wątków próbuje zainicjować <xref:System.Lazy%601> wystąpienia.  
  
 Aby określić <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> trybie, używając <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> lub <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> konstruktora.  
  
 Wyjątki, które są generowane przez `valueFactory` są buforowane. Aby uzyskać więcej informacji, zobacz <xref:System.Lazy%601> klasy lub <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> wyliczenia.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie tego konstruktora zapewnienie Inicjalizacja z opóźnieniem z wyjątkiem buforowania, w przypadku scenariusza z jednym wątkiem. Użycie ilustruje też <xref:System.Lazy%601.%23ctor%2A> — Konstruktor (Określanie <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> dla `mode`). Aby przełączyć się do tego konstruktora, można zmienić Konstruktor, który jest oznaczone jako komentarz.  
  
> [!NOTE]
>  Dla kodu, który demonstruje sposób używania tego konstruktora w scenariuszach wielowątkowe (Określanie `true` dla `isThreadSafe`), zobacz przykład <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> konstruktora.  
  
 W przykładzie zdefiniowano `LargeObject` klasy, która zostanie zainicjowana w trybie opóźnienia przez jeden z kilku wątków. Trzy kluczowe fragmentów kodu zilustrować tworzenie inicjatora, rzeczywista inicjowania i konstruktora `LargeObject` klasy, która przedstawia buforowanie wyjątku. Na początku `Main` metody w przykładzie jest tworzony wątkowo opóźnieniem inicjator `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#newlazy)]  
  
 W wywołaniu konstruktora `isThreadSafe` parametr jest `false`, więc <xref:System.Lazy%601> nie jest wątku bezpieczne. Ponieważ nie jest bezpieczne dla wątków, przykład wywołuje <xref:System.Lazy%601.Value%2A> właściwości trzy razy w tym samym wątku:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#valueprop)]  
  
 W Konstruktorze `LargeObject` klasy, trzeci klucza sekcji kodu zgłasza wyjątek po raz pierwszy `LargeObject` wystąpienie zostało utworzone, ale następnie umożliwia utworzenie wystąpienia występuje:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#largector)]  
  
 Podczas uruchamiania przykładzie, pierwsza próba utworzenia wystąpienia `LargeObject` zakończy się niepowodzeniem i wyjątek zostanie przechwycony. Może spodziewać się, że dalej próba powiedzie się, ale <xref:System.Lazy%601> obiektu buforowanych wyjątek. W związku z tym wszystkie trzy próby zgłoszenie wyjątku.  
  
> [!NOTE]
>  Dla uproszczenia, w tym przykładzie używane globalne wystąpienie <xref:System.Lazy%601>, i są wszystkie metody `static` (`Shared` w języku Visual Basic). Nie są wymogi, od których zależy możliwość inicjowania z opóźnieniem.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="valueFactory" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, System::Threading::LazyThreadSafetyMode mode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Delegat, który jest wywoływane w celu tworzy opóźnieniem zainicjowane wartości, gdy jest to potrzebne.</param>
        <param name="mode">Jedna z wartości wyliczenia, które określa tryb awaryjny wątku.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Lazy`1" /> klasy, która korzysta z trybu inicjowania określonej funkcji i bezpieczeństwo wątków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tryb awaryjny wątku z <xref:System.Lazy%601> wystąpienia określa zachowanie, gdy wiele wątków próbuje zainicjować <xref:System.Lazy%601> wystąpienia.  
  
 Wyjątki, które są generowane przez `valueFactory` są buforowane, chyba że `mode` jest <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Aby uzyskać więcej informacji, zobacz <xref:System.Lazy%601> klasy lub <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType> wyliczenia.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie tego konstruktora w celu utworzenia opóźnieniem inicjatora, umożliwiającą wielu wątków, aby zastępować do utworzenia obiektu opóźnieniem. Wiele wątków może się powieść, podczas tworzenia wystąpienia, ale wszystkie wątki Użyj wystąpienia, z którego został utworzony jako pierwszy. Ponadto w przykładzie pokazano, wyjątki nigdy nie są buforowane po określeniu <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>nawet wtedy, gdy inicjowania jest wykonywane przez funkcję, a nie przez domyślny konstruktor obiektu opóźnieniem utworzony typ.  
  
> [!NOTE]
>  Na przykład, który demonstruje sposób używania tego konstruktora w scenariuszach jednowątkowe (Określanie <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> dla `mode`), zobacz <xref:System.Lazy%601.%23ctor%28System.Boolean%29> konstruktora. Na przykład, który demonstruje sposób używania tego konstruktora zapewnienie blokowania zamiast wyścigu w scenariuszach wielowątkowe (Określanie <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> dla `mode`), zobacz <xref:System.Lazy%601.%23ctor> konstruktora.  
  
 W przykładzie zdefiniowano `LargeObject` klasy, która zostanie zainicjowana opóźnieniem przy użyciu jednej z kilku wątków. Cztery sekcje klucza kodu zilustrować tworzenie inicjatora, rzeczywista inicjowania, funkcji inicjowania i Konstruktor i finalizatora `LargeObject` klasy. Na początku `Main` metody w przykładzie jest tworzony <xref:System.Lazy%601> obiektu wykonującego Inicjalizacja z opóźnieniem elementu `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#newlazy)]  
  
 Inicjator opóźnieniem korzysta z funkcji do wykonania inicjowania. W takim przypadku funkcja jest wymagana, ponieważ nie ma domyślnego konstruktora dla `LargeObject` klasy.  
  
 Przykład utworzenie i uruchomienie trzech wątków, które blokują na <xref:System.Threading.ManualResetEvent> obiektu, dzięki czemu przykładzie można zwolnić wątków jednocześnie. W `ThreadProc` metodę, która jest używana przez wszystkie wątki trzy, wywoływania <xref:System.Lazy%601.Value%2A> tworzy właściwość `LargeObject` wystąpienie:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#valueprop)]  
  
 W trzecim klucza sekcji kodu funkcji inicjowania z opóźnieniem jest wywoływana w celu utworzenia `LargeObject` wystąpienia. Funkcja zwraca pierwszy wyjątek, gdy jest to:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#factoryfunc)]  
  
 Wszystkie inne <xref:System.Threading.LazyThreadSafetyMode> ustawienie nieobsługiwany wyjątek w funkcji inicjowania będzie buforowana. Jednak <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> pomija buforowanie wyjątku. Dane wyjściowe w przykładzie pokazano, że kolejne próby zainicjowania obiektu zakończy się pomyślnie.  
  
> [!NOTE]
>  Komunikat o wyjątku pojawia się zwykle po wiadomości wskazujący, że inne wątki zostały pomyślnie zainicjowano obiektu. Jest to spowodowane opóźnieniem wprowadzonych zgłaszanie i przechwytywanie wyjątku.  
  
 Ponieważ Konstruktor <xref:System.Lazy%601> określonego wystąpienia <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, wszystkie trzy wątki mogą tworzyć `LargeObject` wystąpień. W przykładzie pokazano to w Konstruktorze i finalizatora, wyświetlając komunikaty konsoli `LargeObject` klasy:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#ctorfinalizer)]  
  
 <xref:System.Lazy%601> Obiektu gwarantuje, że tylko jedno wystąpienie jest używany przez wszystkie wątki (z wyjątkiem wątku, w którym funkcja inicjowania zgłasza wyjątek). Dane wyjściowe w przykładzie pokazano to.  
  
> [!NOTE]
>  Dla uproszczenia, w tym przykładzie używane globalne wystąpienie <xref:System.Lazy%601>, i są wszystkie metody `static` (`Shared` w języku Visual Basic). Nie są wymogi, od których zależy możliwość inicjowania z opóźnieniem.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> zawiera nieprawidłową wartość.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="valueFactory" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsValueCreated">
      <MemberSignature Language="C#" Value="public bool IsValueCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueCreated" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.IsValueCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueCreated { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wartość została utworzona dla tej <see cref="T:System.Lazy`1" /> wystąpienia.</summary>
        <value>
          <see langword="true" /> Jeśli utworzono wartość dla tego <see cref="T:System.Lazy`1" /> wystąpienia; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wystąpi Inicjalizacja z opóźnieniem dla <xref:System.Lazy%601> wystąpienia, może to spowodować wartość tworzona lub wyjątek. Jeśli wyjątek jest element zgłaszany, kolejne działanie <xref:System.Lazy%601> wystąpienia zależy od tego, czy buforowanie wyjątku jest włączona. Jeśli <xref:System.Lazy%601> wystąpienie zostało utworzone za pomocą konstruktora, który nie określa funkcji inicjowania, a następnie buforowanie wyjątku nie jest włączone. Kolejna próba zainicjowania <xref:System.Lazy%601> może się powieść, a po pomyślnym zainicjowaniu <xref:System.Lazy%601.IsValueCreated%2A> zwraca właściwość `true`. Jeśli <xref:System.Lazy%601> wystąpienie zostało utworzone z funkcji inicjowania (określonego przez `valueFactory` parametr <xref:System.Lazy%601> Konstruktor), następnie buforowanie wyjątku jest kontrolowany przez tryb awaryjny wątku.  
  
-   Jeśli tryb jest <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> lub <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, nie istnieje żadne drugiej szansy zainicjować <xref:System.Lazy%601> wystąpienia. Wyjątek występuje, jest nieobsługiwany w funkcji inicjowania tego wyjątku jest buforowany i zgłoszony w kolejnych uzyskuje dostęp do programu <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> właściwości. Wartość nie jest tworzony, jeśli jest zgłaszany wyjątek, dlatego w takich przypadkach <xref:System.Lazy%601.IsValueCreated%2A> zwraca `false`.  
  
-   Jeśli tryb jest <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, pierwszy wątku, który zakończy się pomyślnie w uruchomienia funkcji inicjowania (lub konstruktora domyślnego) tworzy wartość <xref:System.Lazy%601> wystąpienia. Jeśli funkcja inicjowania zgłasza wyjątek w jednym wątku, inne wątki nadal spróbuj zainicjować <xref:System.Lazy%601> wystąpienia. Dopóki wartość nie zostanie utworzona, <xref:System.Lazy%601.IsValueCreated%2A> zwraca właściwość `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy i zwraca reprezentację ciągu <see cref="P:System.Lazy`1.Value" /> właściwość dla tego wystąpienia.</summary>
        <returns>Wyniku wywołania metody <see cref="M:System.Object.ToString" /> metoda <see cref="P:System.Lazy`1.Value" /> właściwość dla tego wystąpienia, jeśli wartość została utworzona (to znaczy, jeśli <see cref="P:System.Lazy`1.IsValueCreated" /> zwraca <see langword="true" />). W przeciwnym razie ciąg wskazujący, że wartości nie został utworzony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody nie powoduje inicjowania.  
  
 <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> Właściwość może być `null` po incjalizacji, jeśli metoda fabryki, która została określona dla `valueFactory` parametr <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, lub <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> zwraca konstruktora `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <see cref="P:System.Lazy`1.Value" /> Jest właściwość <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public T Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Value" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T Value { T get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość opóźnieniem zainicjowane bieżącego <see cref="T:System.Lazy`1" /> wystąpienia.</summary>
        <value>Zainicjowane w trybie opóźnienia wartość bieżącej klasy <see cref="T:System.Lazy`1" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Lazy%601.IsValueCreated%2A?displayProperty=nameWithType> właściwość jest `false`, podczas uzyskiwania dostępu do <xref:System.Lazy%601.Value%2A> właściwość wymusza inicjowania.  
  
 Oprócz wyjątków, które są wyświetlane <xref:System.Lazy%601.Value%2A> właściwości może zgłosić nieobsługiwany wyjątek, zgłoszonego przez metodę fabryka, która została przekazana do `valueFactory` parametr <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, lub <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> Konstruktor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <see cref="T:System.Lazy`1" /> Zainicjowano wystąpienia, aby użyć domyślnego konstruktora typu, który jest inicjowany opóźnieniem i Brak uprawnień dostępu konstruktora.</exception>
        <exception cref="T:System.MissingMemberException">
          <see cref="T:System.Lazy`1" /> Zainicjowano wystąpienia, aby użyć domyślnego konstruktora typu, który jest inicjowany opóźnieniem, a ten typ nie ma publicznego konstruktora bez parametrów.</exception>
        <exception cref="T:System.InvalidOperationException">Funkcja inicjowania próbuje uzyskać dostęp do <see cref="P:System.Lazy`1.Value" /> w tym wystąpieniu.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
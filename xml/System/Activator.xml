<Type Name="Activator" FullName="System.Activator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f08f871f06a5bb5712acbc5adee12315d853a99c" />
    <Meta Name="ms.sourcegitcommit" Value="29c771f79cf4eac4f49e5fae5f1aa8b457acf146" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/21/2018" />
    <Meta Name="ms.locfileid" Value="36299054" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Activator : System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Activator extends System.Object implements class System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="DocId" Value="T:System.Activator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Activator&#xA;Implements _Activator" />
  <TypeSignature Language="C++ CLI" Value="public ref class Activator sealed : System::Runtime::InteropServices::_Activator" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Activator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Activator))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zawiera metody służące do tworzenia typów obiektów lokalnie lub zdalnie lub uzyskać odwołania do istniejących obiektów zdalnego. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Activator.CreateInstance%2A> Metoda tworzy wystąpienia typu zdefiniowany w zestawie, wywołując konstruktora, który najlepiej pasuje określonych argumentów. Jeśli nie podano argumentów, wywoływane jest konstruktor, który nie przyjmuje żadnych parametrów, czyli konstruktora domyślnego.  
  
 Musi mieć wystarczających uprawnień, aby wyszukać i wywołać konstruktora; w przeciwnym wypadku jest zwracany wyjątek. Domyślnie tylko konstruktorów publicznych są traktowane jako podczas wyszukiwania dla konstruktora. W przypadku nieodnalezienia nie konstruktora lub konstruktora domyślnego, jest zwracany wyjątek.  
  
 Parametr integratora określa obiekt, który wyszukuje zestawu dla odpowiedniego konstruktora. Możesz określić własne integratora i kryteria wyszukiwania. Jeśli żaden integrator nie jest określony, jest używany domyślny integrator. Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.Binder?displayProperty=nameWithType> i <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> klasy.  
  
 Parametr dowód wpływa na zasady zabezpieczeń i uprawnienia do konstruktora. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Policy.Evidence?displayProperty=nameWithType> klasy.  
  
 W lokacji lokalnych lub zdalnych można utworzyć wystąpienia typu. Jeśli typ jest tworzony zdalnie, parametru atrybutu aktywacji Określa identyfikator URI lokacji zdalnej. Wywołanie w celu utworzenia wystąpienia może upłynąć do pośredniczącej witrynach osiągnie lokacji zdalnej. Inne atrybuty aktywacji można zmodyfikować środowiska lub kontekstu wywołania działa w lokacjach zdalnych i pośredniczące.  
  
 Jeśli wystąpienie jest tworzony lokalnie, zwracane jest odwołanie do tego obiektu. Jeśli wystąpienie jest tworzony zdalnie, zwracane jest odwołanie do serwera proxy. Obiektu zdalnego sterowany przez serwer proxy tak, jakby był on obiektem lokalnym.  
  
 <xref:System.Activator.GetObject%2A> Metoda tworzy serwer proxy do obiektu zdalnego obecnie uruchomiona, serwer aktywowany dobrze znane obiekty lub usługi XML sieci Web. Można określić średniej połączenia, oznacza to, że kanał. Aby uzyskać więcej informacji, zobacz <xref:System.Runtime.Remoting.Channels.ChannelServices?displayProperty=nameWithType> klasy.  
  
 Zestaw nie zawiera definicji typu. <xref:System.Activator.CreateInstance%2A> Metoda tworzy wystąpienie typu z aktualnie uruchomioną zestawu. <xref:System.Activator.CreateInstanceFrom%2A> Metoda tworzy wystąpienie z pliku, który zawiera zestaw. <xref:System.Activator.CreateComInstanceFrom%2A> Metoda tworzy wystąpienie obiektu COM z pliku, który zawiera zestaw.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Activator> klasy dynamicznie utworzyć obiektów w czasie wykonywania.  
  
 [!code-cpp[ActivatorX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#1)]
 [!code-csharp[ActivatorX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#1)]
 [!code-vb[ActivatorX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy wystąpienie obiektu COM, którego nazwa jest określona.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa pliku zawiera zestaw w którym typ o nazwie <c>typeName</c> ma być uzyskane.</param>
        <param name="typeName">Nazwa typu preferowany.</param>
        <summary>Tworzy wystąpienie obiektu COM, którego nazwa jest określona, przy użyciu pliku o nazwie zestawu i domyślnego konstruktora.</summary>
        <returns>Dojście, który musi znajdować się bez otoki dostępu nowo utworzone wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartości zwracanej.  
  
 A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atrybutu o wartości `true` należy zastosować jawnie lub domyślnie na typ modelu COM więc <xref:System.Activator.CreateComInstanceFrom%2A> metody można utworzyć wystąpienia tego typu; w przeciwnym razie <xref:System.TypeLoadException> jest generowany.  
  
 Informacje o innych wyjątki, które mogą być generowane przez wywołanej metody, zobacz sekcję wyjątki <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> i <xref:System.Activator.CreateInstance%2A> metody.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda służy do tworzenia typów niepubliczne, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw grant zestawu, który zawiera typy niepubliczne jest ograniczone do obiektu wywołującego. Udziel Ustaw lub ich podzestaw. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> lub <paramref name="assemblyName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Nie można utworzyć wystąpienia za pomocą modelu COM.  - lub - <paramref name="typename" /> nie został znaleziony w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> nie zostanie znaleziony, lub próby załadowania modułu nie określa rozszerzenie nazwy pliku.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej.  - lub - tego elementu członkowskiego został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> jest pustym ciągiem ("").</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do typów niepubliczne, niezależnie od ich zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa pliku zawiera zestaw w którym typ o nazwie <c>typeName</c> ma być uzyskane.</param>
        <param name="typeName">Nazwa typu preferowany.</param>
        <param name="hashValue">Wartość obliczana wartość skrótu.</param>
        <param name="hashAlgorithm">Algorytm wyznaczania wartości skrótu używany do tworzenia skrótów plików i generowania silnej nazwy.</param>
        <summary>Tworzy wystąpienie obiektu COM, którego nazwa jest określona, przy użyciu pliku o nazwie zestawu i domyślnego konstruktora.</summary>
        <returns>Dojście, który musi znajdować się bez otoki dostępu nowo utworzone wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartości zwracanej.  
  
 A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atrybutu o wartości `true` należy zastosować jawnie lub domyślnie na typ modelu COM więc <xref:System.Activator.CreateComInstanceFrom%2A> metody można utworzyć wystąpienia tego typu; w przeciwnym razie <xref:System.TypeLoadException> jest generowany.  
  
 Informacje o innych wyjątki, które mogą być generowane przez wywołanej metody, zobacz sekcję wyjątki <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> i <xref:System.Activator.CreateInstance%2A> metody.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda służy do tworzenia typów niepubliczne, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw grant zestawu, który zawiera typy niepubliczne jest ograniczone do obiektu wywołującego. Udziel Ustaw lub ich podzestaw. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> lub <paramref name="assemblyName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> jest pustym ciągiem ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.
 - lub - <paramref name="assemblyName" /> jest dłuższa niż zdefiniowana w systemie długość maksymalna.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> nie zostanie znaleziony, lub próby załadowania modułu nie określa rozszerzenie nazwy pliku.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyName" /> został znaleziony, lecz nie może zostać załadowany.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> nie jest prawidłowym zestawem.</exception>
        <exception cref="T:System.Security.SecurityException">Podstawowy kod, który rozpoczyna się od "file://" został określony bez wymaganego <see langword="WebPermission" />.</exception>
        <exception cref="T:System.TypeLoadException">Nie można utworzyć wystąpienia za pomocą modelu COM.  - lub - <paramref name="typename" /> nie został znaleziony w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej.  - lub - tego elementu członkowskiego został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może zapewnić atrybuty activation dla obiekt, który nie dziedziczy z <see cref="T:System.MarshalByRefObject" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do typów niepubliczne, niezależnie od ich zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania identyfikatora URI, który rozpoczyna się od "file://". Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy wystąpienie określonego typu za pomocą konstruktora, który najlepiej odpowiada określonych parametrów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">Określa obiekt, aby utworzyć obiekt kontekstu aktywacji.</param>
        <summary>Tworzy wystąpienia typu wskazywany przez określony <see cref="T:System.ActivationContext" /> obiektu.</summary>
        <returns>Uchwyt musi być odkodowany dostępu do nowo utworzonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartości zwracanej.  
  
 Kontekst aktywacji jest używany podczas aktywację w oparciu o manifest, aby skonfigurować zasady domeny i zapewnienie model zabezpieczeń oparty na aplikacji. <xref:System.ActivationContext> Klasa zawiera <xref:System.ApplicationIdentity> obiekt, który zapewnia dostęp do manifestu aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Policy.ApplicationSecurityManager> klasy.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Typ obiektu do utworzenia.</param>
        <summary>Tworzy wystąpienie określonego typu przy użyciu tego typu domyślnego konstruktora.</summary>
        <returns>Odwołanie do nowo utworzony obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor do wywołania musi być dostępna.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda umożliwia dostęp do typów niepubliczne, jeśli przyznano wywołującego <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw grant zestawu, który zawiera typy niepubliczne jest ograniczone do obiektu wywołującego. Udziel Ustaw lub ich podzestaw. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób wywoływania <xref:System.Activator.CreateInstance%28System.Type%29> metody. Tworzone są wystąpienia z wielu różnych typów i ich wartości domyślne są wyświetlane.  
  
 [!code-cpp[ActivatorX#4](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/source2.cpp#4)]
 [!code-csharp[ActivatorX#4](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/source2.cs#4)]
 [!code-vb[ActivatorX#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/source2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie jest <see langword="RuntimeType" />.  - lub - <paramref name="type" /> jest otwartym typem ogólnym (to znaczy <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> nie może być <see cref="T:System.Reflection.Emit.TypeBuilder" />.  - lub - tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> nie jest obsługiwane typy i tablice tych typów.  - lub - zestawu, który zawiera <paramref name="type" /> jest dynamicznego zestawu, który został utworzony z <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor wywoływany zgłasza wyjątek.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para> [.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.MemberAccessException" />, zamiast tego.  </para>
          </block>  Obiekt wywołujący nie ma uprawnienia do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para> [.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.MissingMemberException" />, zamiast tego.  </para>
          </block>  Brak pasującego konstruktora publicznego został znaleziony.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> to obiekt COM, ale identyfikator klasy stosowane w celu uzyskania typu jest nieprawidłowy lub zidentyfikowanych klasa nie jest zarejestrowana.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> nie jest prawidłowym typem.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do typów niepubliczne, niezależnie od ich zestawami uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext, string[] activationCustomData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext, string[] activationCustomData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext, cli::array &lt;System::String ^&gt; ^ activationCustomData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
        <Parameter Name="activationCustomData" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="activationContext">Określa obiekt, aby utworzyć obiekt kontekstu aktywacji.</param>
        <param name="activationCustomData">Tablica ciągów Unicode, które zawierają dane niestandardowe aktywacji.</param>
        <summary>Tworzy wystąpienia typu, który został wybrany przez określony <see cref="T:System.ActivationContext" /> obiektu i aktywować przy użyciu danych określone uaktywnianie niestandardowych.</summary>
        <returns>Uchwyt musi być odkodowany dostępu do nowo utworzonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartości zwracanej.  
  
 Kontekst aktywacji jest używany podczas aktywację w oparciu o manifest, aby skonfigurować zasady domeny i zapewnienie model zabezpieczeń oparty na aplikacji. <xref:System.ActivationContext> Klasa zawiera <xref:System.ApplicationIdentity> obiekt, który zapewnia dostęp do manifestu aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Policy.ApplicationSecurityManager> klasy.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa zestawu, w którym typ o nazwie <c>typeName</c> ma być uzyskane. Jeśli <c>assemblyName</c> jest <see langword="null" />, przeszukiwany jest wykonywany zestaw.</param>
        <param name="typeName">Pełna nazwa typu preferowany.</param>
        <summary>Tworzy wystąpienie tego typu, którego nazwa jest określona, przy użyciu nazwanego zestawu i domyślnego konstruktora.</summary>
        <returns>Dojście, który musi znajdować się bez otoki dostępu nowo utworzone wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> do odkodowania wartości zwracanej.  
  
 `assemblyName` może być jedną z następujących czynności:  
  
-   Prosta nazwa zestawu, bez jego rozszerzenia pliku lub ścieżki. Na przykład, należy określić `TypeExtensions` dla zestawu w ścieżce i nazwie są.\bin\TypeExtensions.dll.  
  
-   Pełną nazwą podpisanych zestawu, który składa się z prostą nazwę, wersję, kulturę i token klucza publicznego; na przykład "TypeExtensions, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = 181869f2f7435b51".  
  
 Aby uzyskać więcej informacji dotyczących sposobu środowisko uruchomieniowe języka wspólnego identyfikuje i ładuje zestawy, zobacz [jak zestawy środowiska wykonawczego lokalizuje](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md). Uzyskać przy użyciu pliku konfiguracji aplikacji, aby zdefiniować lokalizacje zestawu, zobacz [Określanie lokalizacji zestawu](~/docs/framework/configure-apps/specify-assembly-location.md). Jeśli `assemblyName` zostanie znaleziony, jest ładowany w kontekście domyślnym.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda służy do tworzenia typów niepubliczne, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw grant zestawu, który zawiera typy niepubliczne jest ograniczone do obiektu wywołującego. Udziel Ustaw lub ich podzestaw. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano klasę o nazwie `Person` w zestawie o nazwie `PersonInfo`. Należy pamiętać, że `Person` klasa ma dwa konstruktory, z których jeden jest bez parametrów.  
  
 [!code-csharp[System.Activator.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/personinfo.cs#1)]
 [!code-vb[System.Activator.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/personinfo.vb#1)]  
  
 Następujące przykładowe wywołania <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29> metody tworzenia wystąpienia `Person` klasy. Wymaga to odwołanie do PersonInfo.dll mają zostać dodane do projektu. Ponieważ <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29> wywołania metody `Person` Konstruktor klasy przykładzie przypisuje wartość do jego `Name` właściwości.  
  
 [!code-csharp[System.Activator.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1.cs#2)]
 [!code-vb[System.Activator.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1.vb#2)]  
  
 Jednak <xref:System.Activator.CreateInstance%2A> jest często nazywany można utworzyć wystąpienia typu, który przecina granic lub nie jest znany w czasie projektowania. W takim przypadku nie może zawierać odwołania do zestawu w projekcie i nie może wykonywać wywołania z wczesnym wiązaniem do elementów członkowskich typu. Aby obejść to ograniczenie, w poniższym przykładzie użyto <xref:System.Activator.CreateInstance%2A> metody wraz z odbiciem można przypisać wartości do `Person` obiektu `Name` właściwości i wyświetlić jej wartość.  
  
 [!code-csharp[System.Activator.CreateInstance#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1a.cs#3)]
 [!code-vb[System.Activator.CreateInstance#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1a.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej lub ten element członkowski został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, która została wywołana przez odbicie, wywołało wyjątek.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">Tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> nie jest obsługiwane typy i tablice tych typów.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowany, oraz <paramref name="assemblyName" /> został skompilowany dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowany. Należy pamiętać, że wersje .NET Framework 2.0, 3.0 i 3.5 CLR w wersji 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.  - lub - nazwa zestawu lub kod jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do typów niepubliczne, niezależnie od ich zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, bool nonPublic);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Typ obiektu do utworzenia.</param>
        <param name="nonPublic">
          <see langword="true" /> Jeśli konstruktora domyślnego publicznego lub niepubliczne może dopasować; <see langword="false" /> jeśli tylko może dopasować publicznego konstruktora domyślnego.</param>
        <summary>Tworzy wystąpienie określonego typu przy użyciu tego typu domyślnego konstruktora.</summary>
        <returns>Odwołanie do nowo utworzony obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda może służyć do dostęp niepubliczne typy i składniki, jeśli przyznano wywołującego <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw grant zestawu, który zawiera niepubliczne typy i składniki jest ograniczony do obiektu wywołującego udzielić ustawiona lub jej podzbioru. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie jest <see langword="RuntimeType" />.  - lub - <paramref name="type" /> jest otwartym typem ogólnym (to znaczy <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> nie może być <see cref="T:System.Reflection.Emit.TypeBuilder" />.  - lub - tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> nie jest obsługiwane typy i tablice tych typów.  - lub - zestawu, który zawiera <paramref name="type" /> jest dynamicznego zestawu, który został utworzony z <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor wywoływany zgłasza wyjątek.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> to obiekt COM, ale identyfikator klasy stosowane w celu uzyskania typu jest nieprawidłowy lub zidentyfikowanych klasa nie jest zarejestrowana.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> nie jest prawidłowym typem.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do niepubliczne typy i składniki niezależnie od ich zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Typ obiektu do utworzenia.</param>
        <param name="args">Tablica argumentów, które odpowiada w polu numer zamówienia i wpisz parametry konstruktora do wywołania. Jeśli <c>argumentów</c> jest pusta tablica lub <see langword="null" />, wywołaniu konstruktora, który nie przyjmuje żadnych parametrów (konstruktora domyślnego).</param>
        <summary>Tworzy wystąpienie określonego typu za pomocą konstruktora, który najlepiej odpowiada określonych parametrów.</summary>
        <returns>Odwołanie do nowo utworzony obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor do wywołania musi być dostępny i podać najbardziej zgodne z listą określonego argumentu.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda umożliwia dostęp do typów niepubliczne, jeśli przyznano wywołującego <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw grant zestawu, który zawiera typy niepubliczne jest ograniczone do obiektu wywołującego. Udziel Ustaw lub ich podzestaw. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> metodę w celu utworzenia <xref:System.String> obiektu. Wywołuje <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Konstruktor do tworzenia wystąpienia ciąg, który zawiera 10 elementów z tablicy znaków, zaczynając od pozycji czternastego.  
  
 [!code-csharp[System.Activator.CreateInstance#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/CreateInstance5.cs#5)]
 [!code-vb[System.Activator.CreateInstance#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/CreateInstance5.vb#5)]  
  
 Poniższy przykład tworzy tablicy nieregularnej, której elementy są argumenty do przekazania do <xref:System.String> konstruktora. Przykład następnie przekazuje każdej macierzy do <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> metodę można wywołać konstruktora, odpowiedni ciąg.  
  
 [!code-csharp[System.Activator.CreateInstance#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstance2.cs#4)]
 [!code-vb[System.Activator.CreateInstance#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstance2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie jest <see langword="RuntimeType" />.  - lub - <paramref name="type" /> jest otwartym typem ogólnym (to znaczy <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> nie może być <see cref="T:System.Reflection.Emit.TypeBuilder" />.  - lub - tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> nie jest obsługiwane typy i tablice tych typów.  - lub - zestawu, który zawiera <paramref name="type" /> jest dynamicznego zestawu, który został utworzony z <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  - lub - Konstruktor, który najlepiej pasuje <paramref name="args" /> ma <see langword="varargs" /> argumentów.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor wywoływany zgłasza wyjątek.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para> [.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.MemberAccessException" />, zamiast tego.  </para>
          </block>  Obiekt wywołujący nie ma uprawnienia do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para> [.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.MissingMemberException" />, zamiast tego.  </para>
          </block>  Brak pasującego konstruktora publicznego został znaleziony.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> to obiekt COM, ale identyfikator klasy stosowane w celu uzyskania typu jest nieprawidłowy lub zidentyfikowanych klasa nie jest zarejestrowana.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> nie jest prawidłowym typem.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do typów niepubliczne, niezależnie od ich zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (domain As AppDomain, assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="domain">Domeny zdalnej, której typ o nazwie <c>typeName</c> jest tworzony.</param>
        <param name="assemblyName">Nazwa zestawu, w którym typ o nazwie <c>typeName</c> ma być uzyskane. Jeśli <c>assemblyName</c> jest <see langword="null" />, przeszukiwany jest wykonywany zestaw.</param>
        <param name="typeName">Pełna nazwa typu preferowany.</param>
        <summary>Tworzy wystąpienie tego typu, którego nazwa jest określona w określonej domenie zdalnego, przy użyciu nazwanego zestawu i domyślnego konstruktora.</summary>
        <returns>Dojście, który musi znajdować się bez otoki dostępu nowo utworzone wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Activator.CreateInstance%2A> Jeśli jakiś host wymaga wykonanie kodu w domenie aplikacji, która ma ograniczone uprawnienia zabezpieczeń.  
  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> do odkodowania wartości zwracanej.  
  
> [!NOTE]
>  Ta metoda używa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> wymagające do bezpośredniego obiektu wywołującego ma pełne zaufanie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> lub <paramref name="domain" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia typu abstrakcyjnego.  - lub - tego elementu członkowskiego został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, która została wywołana przez odbicie, wywołało wyjątek.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">Tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> nie jest obsługiwane typy i tablice tych typów.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowany, oraz <paramref name="assemblyName" /> został skompilowany dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowany. Należy pamiętać, że wersje .NET Framework 2.0, 3.0 i 3.5 CLR w wersji 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.  - lub - nazwa zestawu lub kod jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa zestawu, w którym typ o nazwie <c>typeName</c> ma być uzyskane. Jeśli <c>assemblyName</c> jest <see langword="null" />, przeszukiwany jest wykonywany zestaw.</param>
        <param name="typeName">Pełna nazwa typu preferowany.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie tego typu, którego nazwa jest określona, przy użyciu nazwanego zestawu i domyślnego konstruktora.</summary>
        <returns>Dojście, który musi znajdować się bez otoki dostępu nowo utworzone wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> do odkodowania wartości zwracanej.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda służy do tworzenia typów niepubliczne, jeśli element wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw grant niepubliczne typów jest ograniczone do obiektu wywołującego zestawu lub jej podzbioru. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">Tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> nie jest obsługiwane typy i tablice tych typów.  - lub - <paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzony nie pochodzi od <see cref="T:System.MarshalByRefObject" />.  - lub - <paramref name="activationAttributes" /> nie jest <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> tablicy.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowany, oraz <paramref name="assemblyName" /> został skompilowany dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowany. Należy pamiętać, że wersje .NET Framework 2.0, 3.0 i 3.5 CLR w wersji 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.  - lub - nazwa zestawu lub kod jest nieprawidłowy.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Wystąpił błąd podczas próby aktywacji zdalnej w docelowej, określone w <paramref name="activationAttributes" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do typów niepubliczne, niezależnie od ich zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, object[] args, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[],System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="type">Typ obiektu do utworzenia.</param>
        <param name="args">Tablica argumentów, które odpowiada w polu numer zamówienia i wpisz parametry konstruktora do wywołania. Jeśli <c>argumentów</c> jest pusta tablica lub <see langword="null" />, wywołaniu konstruktora, który nie przyjmuje żadnych parametrów (konstruktora domyślnego).</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie określonego typu za pomocą konstruktora, który najlepiej odpowiada określonych parametrów.</summary>
        <returns>Odwołanie do nowo utworzony obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor do wywołania musi być dostępny i podać najbardziej zgodne z listą określonego argumentu.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda umożliwia dostęp do typów niepubliczne, jeśli przyznano wywołującego <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw grant zestawu, który zawiera typy niepubliczne jest ograniczone do obiektu wywołującego. Udziel Ustaw lub ich podzestaw. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie jest <see langword="RuntimeType" />.  - lub - <paramref name="type" /> jest otwartym typem ogólnym (to znaczy <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> nie może być <see cref="T:System.Reflection.Emit.TypeBuilder" />.  - lub - tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> nie jest obsługiwane typy i tablice tych typów.  - lub - <paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzony nie pochodzi od <see cref="T:System.MarshalByRefObject" />.  - lub - zestawu, który zawiera <paramref name="type" /> jest dynamicznego zestawu, który został utworzony z <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  - lub - Konstruktor, który najlepiej pasuje <paramref name="args" /> ma <see langword="varargs" /> argumentów.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor wywoływany zgłasza wyjątek.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> to obiekt COM, ale identyfikator klasy stosowane w celu uzyskania typu jest nieprawidłowy lub zidentyfikowanych klasa nie jest zarejestrowana.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> nie jest prawidłowym typem.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do typów niepubliczne, niezależnie od ich zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="type">Typ obiektu do utworzenia.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie <c>typu</c> konstruktora. Jeśli <c>bindingAttr</c> jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który używa <c>bindingAttr</c> i <c>argumentów</c> do wyszukiwania i identyfikacji <c>typu</c> konstruktora. Jeśli <c>integratora</c> jest <see langword="null" />, używany jest domyślny integrator.</param>
        <param name="args">Tablica argumentów, które odpowiada w polu numer zamówienia i wpisz parametry konstruktora do wywołania. Jeśli <c>argumentów</c> jest pusta tablica lub <see langword="null" />, wywołaniu konstruktora, który nie przyjmuje żadnych parametrów (konstruktora domyślnego).</param>
        <param name="culture">Informacje specyficzne dla kultury, które kontroluje koercja z <c>argumentów</c> typom posiadanie zadeklarowanym dla <c>typu</c> konstruktora. Jeśli <c>kultury</c> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> służy bieżącego wątku.</param>
        <summary>Tworzy wystąpienie określonego typu za pomocą konstruktora, który najlepiej odpowiada określonych parametrów.</summary>
        <returns>Odwołanie do nowo utworzony obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor wywoływanej podaj najbardziej zgodna z listy określony argument w obszarze ograniczenia określony obiekt wiążący i powiązania atrybutów.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda może służyć do dostęp niepubliczne typy i składniki, jeśli przyznano wywołującego <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw grant zestawu, który zawiera niepubliczne typy i składniki jest ograniczony do obiektu wywołującego udzielić ustawiona lub jej podzbioru. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie jest <see langword="RuntimeType" />.  - lub - <paramref name="type" /> jest otwartym typem ogólnym (to znaczy <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> nie może być <see cref="T:System.Reflection.Emit.TypeBuilder" />.  - lub - tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> nie jest obsługiwane typy i tablice tych typów.  - lub - zestawu, który zawiera <paramref name="type" /> jest dynamicznego zestawu, który został utworzony z <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  - lub - Konstruktor, który najlepiej pasuje <paramref name="args" /> ma <see langword="varargs" /> argumentów.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor wywoływany zgłasza wyjątek.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> to obiekt COM, ale identyfikator klasy stosowane w celu uzyskania typu jest nieprawidłowy lub zidentyfikowanych klasa nie jest zarejestrowana.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> nie jest prawidłowym typem.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do niepubliczne typy i składniki niezależnie od ich zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="type">Typ obiektu do utworzenia.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie <c>typu</c> konstruktora. Jeśli <c>bindingAttr</c> jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który używa <c>bindingAttr</c> i <c>argumentów</c> do wyszukiwania i identyfikacji <c>typu</c> konstruktora. Jeśli <c>integratora</c> jest <see langword="null" />, używany jest domyślny integrator.</param>
        <param name="args">Tablica argumentów, które odpowiada w polu numer zamówienia i wpisz parametry konstruktora do wywołania. Jeśli <c>argumentów</c> jest pusta tablica lub <see langword="null" />, wywołaniu konstruktora, który nie przyjmuje żadnych parametrów (konstruktora domyślnego).</param>
        <param name="culture">Informacje specyficzne dla kultury, które kontroluje koercja z <c>argumentów</c> typom posiadanie zadeklarowanym dla <c>typu</c> konstruktora. Jeśli <c>kultury</c> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> służy bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie określonego typu za pomocą konstruktora, który najlepiej odpowiada określonych parametrów.</summary>
        <returns>Odwołanie do nowo utworzony obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor wywoływanej podaj najbardziej zgodna z listy określony argument w obszarze ograniczenia określony obiekt wiążący i powiązania atrybutów.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda może służyć do dostęp niepubliczne typy i składniki, jeśli przyznano wywołującego <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw grant niepubliczne typów i członków jest ograniczone do obiektu wywołującego zestaw uprawnień lub do podzbioru jej. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> nie jest <see langword="RuntimeType" />.  - lub - <paramref name="type" /> jest otwartym typem ogólnym (to znaczy <see cref="P:System.Type.ContainsGenericParameters" /> zwraca <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> nie może być <see cref="T:System.Reflection.Emit.TypeBuilder" />.  - lub - tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> nie jest obsługiwane typy i tablice tych typów.  - lub - <paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzony nie pochodzi od <see cref="T:System.MarshalByRefObject" />.  - lub - zestawu, który zawiera <paramref name="type" /> jest dynamicznego zestawu, który został utworzony z <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  - lub - Konstruktor, który najlepiej pasuje <paramref name="args" /> ma <see langword="varargs" /> argumentów.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor wywoływany zgłasza wyjątek.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> to obiekt COM, ale identyfikator klasy stosowane w celu uzyskania typu jest nieprawidłowy lub zidentyfikowanych klasa nie jest zarejestrowana.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> nie jest prawidłowym typem.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać podanie dowód. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do niepubliczne typy i składniki niezależnie od ich zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa zestawu, w którym typ o nazwie <c>typeName</c> ma być uzyskane. Jeśli <c>assemblyName</c> jest <see langword="null" />, przeszukiwany jest wykonywany zestaw.</param>
        <param name="typeName">Pełna nazwa typu preferowany.</param>
        <param name="ignoreCase">
          <see langword="true" /> Aby określić, że wyszukiwanie <c>typeName</c> nie jest rozróżniana wielkość liter; <see langword="false" /> do określenia, czy wyszukiwanie jest rozróżniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie <c>typeName</c> konstruktora. Jeśli <c>bindingAttr</c> jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który używa <c>bindingAttr</c> i <c>argumentów</c> do wyszukiwania i identyfikacji <c>typeName</c> konstruktora. Jeśli <c>integratora</c> jest <see langword="null" />, używany jest domyślny integrator.</param>
        <param name="args">Tablica argumentów, które odpowiada w polu numer zamówienia i wpisz parametry konstruktora do wywołania. Jeśli <c>argumentów</c> jest pusta tablica lub <see langword="null" />, wywołaniu konstruktora, który nie przyjmuje żadnych parametrów (konstruktora domyślnego).</param>
        <param name="culture">Informacje specyficzne dla kultury, które kontroluje koercja z <c>argumentów</c> typom posiadanie zadeklarowanym dla <c>typeName</c> konstruktora. Jeśli <c>kultury</c> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> służy bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie tego typu, którego nazwa jest określona, przy użyciu nazwanego zestawu i Konstruktor, który najlepiej odpowiada określonych parametrów.</summary>
        <returns>Dojście, który musi znajdować się bez otoki dostępu nowo utworzone wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> do odkodowania wartości zwracanej.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda może służyć do tworzenia niepubliczne typy i składniki, jeśli przyznano wywołującego <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw grant zestawu, który zawiera niepubliczne typy i składniki jest ograniczony do obiektu wywołującego udzielić ustawiona lub jej podzbioru. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)42d9dc2a-8fcc-4ff3-b002-4ff260ef3dc5.)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, która została wywołana przez odbicie, wywołało wyjątek.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">Tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> nie jest obsługiwane typy i tablice tych typów.  - lub - <paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzony nie pochodzi od <see cref="T:System.MarshalByRefObject" />.  - lub - Konstruktor, który najlepiej pasuje <paramref name="args" /> ma <see langword="varargs" /> argumentów.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowany, oraz <paramref name="assemblyName" /> został skompilowany dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowany. Należy pamiętać, że wersje .NET Framework 2.0, 3.0 i 3.5 CLR w wersji 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.  - lub - nazwa zestawu lub kod jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do niepubliczne typy i składniki niezależnie od ich zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="domain">Domeny, której typ o nazwie <c>typeName</c> jest tworzony.</param>
        <param name="assemblyName">Nazwa zestawu, w którym typ o nazwie <c>typeName</c> ma być uzyskane. Jeśli <c>assemblyName</c> jest <see langword="null" />, przeszukiwany jest wykonywany zestaw.</param>
        <param name="typeName">Pełna nazwa typu preferowany.</param>
        <param name="ignoreCase">
          <see langword="true" /> Aby określić, że wyszukiwanie <c>typeName</c> nie jest rozróżniana wielkość liter; <see langword="false" /> do określenia, czy wyszukiwanie jest rozróżniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie <c>typeName</c> konstruktora. Jeśli <c>bindingAttr</c> jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który używa <c>bindingAttr</c> i <c>argumentów</c> do wyszukiwania i identyfikacji <c>typeName</c> konstruktora. Jeśli <c>integratora</c> jest <see langword="null" />, używany jest domyślny integrator.</param>
        <param name="args">Tablica argumentów, które odpowiada w polu numer zamówienia i wpisz parametry konstruktora do wywołania. Jeśli <c>argumentów</c> jest pusta tablica lub <see langword="null" />, wywołaniu konstruktora, który nie przyjmuje żadnych parametrów (konstruktora domyślnego).</param>
        <param name="culture">Informacje specyficzne dla kultury, które kontroluje koercja z <c>argumentów</c> typom posiadanie zadeklarowanym dla <c>typeName</c> konstruktora. Jeśli <c>kultury</c> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> służy bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienia typu, którego nazwa jest określona w określonej domenie zdalnego, przy użyciu nazwanego zestawu i Konstruktor, który najlepiej odpowiada określonych parametrów.</summary>
        <returns>Dojście, który musi znajdować się bez otoki dostępu nowo utworzone wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Activator.CreateInstance%2A> Jeśli jakiś host wymaga wykonanie kodu w domenie aplikacji, która ma ograniczone uprawnienia zabezpieczeń.  
  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> do odkodowania wartości zwracanej.  
  
> [!NOTE]
>  Ta metoda używa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> wymagające do bezpośredniego obiektu wywołującego ma pełne zaufanie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, która została wywołana przez odbicie, wywołało wyjątek.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">Tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> nie jest obsługiwane typy i tablice tych typów.  - lub - <paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzony nie pochodzi od <see cref="T:System.MarshalByRefObject" />.  - lub - Konstruktor, który najlepiej pasuje <paramref name="args" /> ma <see langword="varargs" /> argumentów.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowany, oraz <paramref name="assemblyName" /> został skompilowany dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowany. Należy pamiętać, że wersje .NET Framework 2.0, 3.0 i 3.5 CLR w wersji 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.  - lub - nazwa zestawu lub kod jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa zestawu, w którym typ o nazwie <c>typeName</c> ma być uzyskane. Jeśli <c>assemblyName</c> jest <see langword="null" />, przeszukiwany jest wykonywany zestaw.</param>
        <param name="typeName">Pełna nazwa typu preferowany.</param>
        <param name="ignoreCase">
          <see langword="true" /> Aby określić, że wyszukiwanie <c>typeName</c> nie jest rozróżniana wielkość liter; <see langword="false" /> do określenia, czy wyszukiwanie jest rozróżniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie <c>typeName</c> konstruktora. Jeśli <c>bindingAttr</c> jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który używa <c>bindingAttr</c> i <c>argumentów</c> do wyszukiwania i identyfikacji <c>typeName</c> konstruktora. Jeśli <c>integratora</c> jest <see langword="null" />, używany jest domyślny integrator.</param>
        <param name="args">Tablica argumentów, które odpowiada w polu numer zamówienia i wpisz parametry konstruktora do wywołania. Jeśli <c>argumentów</c> jest pusta tablica lub <see langword="null" />, wywołaniu konstruktora, który nie przyjmuje żadnych parametrów (konstruktora domyślnego).</param>
        <param name="culture">Informacje specyficzne dla kultury, które kontroluje koercja z <c>argumentów</c> typom posiadanie zadeklarowanym dla <c>typeName</c> konstruktora. Jeśli <c>kultury</c> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> służy bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <param name="securityInfo">Informacje używane do decyzje zasady zabezpieczeń i udzielanie uprawnień kodu.</param>
        <summary>Tworzy wystąpienie tego typu, którego nazwa jest określona, przy użyciu nazwanego zestawu i Konstruktor, który najlepiej odpowiada określonych parametrów.</summary>
        <returns>Dojście, który musi znajdować się bez otoki dostępu nowo utworzone wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> do odkodowania wartości zwracanej.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda może służyć do tworzenia niepubliczne typy i składniki, jeśli przyznano wywołującego <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw grant zestawu, który zawiera niepubliczne typy i składniki jest ograniczony do obiektu wywołującego udzielić ustawiona lub jej podzbioru. (Zobacz [zagadnienia dotyczące zabezpieczeń dla odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, należy docelowy aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, która została wywołana przez odbicie, wywołało wyjątek.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">Tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> nie jest obsługiwane typy i tablice tych typów.  - lub - <paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzony nie pochodzi od <see cref="T:System.MarshalByRefObject" />.  - lub - Konstruktor, który najlepiej pasuje <paramref name="args" /> ma <see langword="varargs" /> argumentów.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowany, oraz <paramref name="assemblyName" /> został skompilowany dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowany. Należy pamiętać, że wersje .NET Framework 2.0, 3.0 i 3.5 CLR w wersji 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.  - lub - nazwa zestawu lub kod jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do niepubliczne typy i składniki niezależnie od ich zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="domain">Domeny, której typ o nazwie <c>typeName</c> jest tworzony.</param>
        <param name="assemblyName">Nazwa zestawu, w którym typ o nazwie <c>typeName</c> ma być uzyskane. Jeśli <c>assemblyName</c> jest <see langword="null" />, przeszukiwany jest wykonywany zestaw.</param>
        <param name="typeName">Pełna nazwa typu preferowany.</param>
        <param name="ignoreCase">
          <see langword="true" /> Aby określić, że wyszukiwanie <c>typeName</c> nie jest rozróżniana wielkość liter; <see langword="false" /> do określenia, czy wyszukiwanie jest rozróżniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie <c>typeName</c> konstruktora. Jeśli <c>bindingAttr</c> jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który używa <c>bindingAttr</c> i <c>argumentów</c> do wyszukiwania i identyfikacji <c>typeName</c> konstruktora. Jeśli <c>integratora</c> jest <see langword="null" />, używany jest domyślny integrator.</param>
        <param name="args">Tablica argumentów, które odpowiada w polu numer zamówienia i wpisz parametry konstruktora do wywołania. Jeśli <c>argumentów</c> jest pusta tablica lub <see langword="null" />, wywołaniu konstruktora, który nie przyjmuje żadnych parametrów (konstruktora domyślnego).</param>
        <param name="culture">Informacje specyficzne dla kultury, które kontroluje koercja z <c>argumentów</c> typom posiadanie zadeklarowanym dla <c>typeName</c> konstruktora. Jeśli <c>kultury</c> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> służy bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu. <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> Określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.</param>
        <param name="securityAttributes">Informacje używane do decyzje zasady zabezpieczeń i udzielanie uprawnień kodu.</param>
        <summary>Tworzy wystąpienia typu, którego nazwa jest określona w określonej domenie zdalnego, przy użyciu nazwanego zestawu i Konstruktor, który najlepiej odpowiada określonych parametrów.</summary>
        <returns>Dojście, który musi znajdować się bez otoki dostępu nowo utworzone wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Activator.CreateInstance%2A> Jeśli jakiś host wymaga wykonanie kodu w domenie aplikacji, która ma ograniczone uprawnienia zabezpieczeń.  
  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> do odkodowania wartości zwracanej.  
  
> [!NOTE]
>  Ta metoda używa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> wymagające do bezpośredniego obiektu wywołującego ma pełne zaufanie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, która została wywołana przez odbicie, wywołało wyjątek.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">Tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> nie jest obsługiwane typy i tablice tych typów.  - lub - <paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzony nie pochodzi od <see cref="T:System.MarshalByRefObject" />.  - lub - Konstruktor, który najlepiej pasuje <paramref name="args" /> ma <see langword="varargs" /> argumentów.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> nie jest prawidłowym zestawem.  - lub - środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowany, oraz <paramref name="assemblyName" /> został skompilowany dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowany. Należy pamiętać, że wersje .NET Framework 2.0, 3.0 i 3.5 CLR w wersji 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.  - lub - nazwa zestawu lub kod jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CreateInstance&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CreateInstance&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T CreateInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Typ do utworzenia.</typeparam>
        <summary>Tworzy wystąpienie wskazywany przez parametr typu ogólnego określonego typu za pomocą konstruktora bez parametrów.</summary>
        <returns>Odwołanie do nowo utworzony obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Activator.CreateInstance%60%601> Metoda rodzajowa jest używany przez kompilatory do wykonania podczas tworzenia wystąpienia typu określonego przez parametry typu. Na przykład w następującej metody rodzajowe wykonania `new T()` (`gcnew T()` w języku C++) używa <xref:System.Activator.CreateInstance%60%601> metody rodzajowej.  
  
 [!code-cpp[System.Activation.CreateInstance~~1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cpp/remarks.cpp#1)]
 [!code-csharp[System.Activation.CreateInstance~~1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cs/remarks.cs#1)]
 [!code-vb[System.Activation.CreateInstance~~1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activation.createinstance~~1/vb/remarks.vb#1)]  
  
 Ogólnie rzecz biorąc, nie jest używana dla <xref:System.Activator.CreateInstance%60%601> kod metody rodzajowej w aplikacji, ponieważ typ musi być znane w czasie kompilacji. Jeśli typ jest znany w czasie kompilacji, można używać składni normalnego wystąpienia (`new` operatora w języku C# `New` w języku Visual Basic `gcnew` w języku C++). Jeśli typ nie jest znany w czasie kompilacji, można wywoływać przeciążenia nieogólnego <xref:System.Activator.CreateInstance%2A>.  
  
 Nie ma żadnych przeciążeń <xref:System.Activator.CreateInstance%60%601> metody ogólnej prowadzące listy argumentów, ponieważ inny niż ogólny overloads z <xref:System.Activator.CreateInstance%2A> już zapewnić rozpoznawanie konstruktora z późnym wiązaniem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para> [.NET dla aplikacji ze Sklepu Windows] (http://go.microsoft.com/fwlink/?LinkID=247912) lub [przenośne Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) klasy, catch wyjątku klasy podstawowej <see cref="T:System.MissingMemberException" />, zamiast tego.  </para>
          </block>  Typ określony dla <paramref name="T" /> nie ma konstruktora bez parametrów.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy wystąpienie tego typu, którego nazwa jest określona, przy użyciu pliku o nazwie zestawu i Konstruktor, który najlepiej odpowiada określonych parametrów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku zawiera zestaw w którym typ o nazwie <c>typeName</c> ma być uzyskane.</param>
        <param name="typeName">Nazwa typu preferowany.</param>
        <summary>Tworzy wystąpienie tego typu, którego nazwa jest określona, za pomocą konstruktora nazwany zestaw plików i domyślne.</summary>
        <returns>Dojście, który musi znajdować się bez otoki dostępu nowo utworzone wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartości zwracanej.  
  
 Informacje o innych wyjątki, które mogą być generowane przez wywołanej metody, zobacz sekcję wyjątki <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> i <xref:System.Activator.CreateInstance%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób wywoływania <xref:System.Activator.CreateInstanceFrom%2A> metody. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Activator> klasy.  
  
 [!code-cpp[ActivatorX#3](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#3)]
 [!code-csharp[ActivatorX#3](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#3)]
 [!code-vb[ActivatorX#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, która została wywołana przez odbicie, wywołało wyjątek.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący mają wymaganych <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  - lub - środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowany, oraz <paramref name="assemblyName" /> został skompilowany dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowany. Należy pamiętać, że wersje .NET Framework 2.0, 3.0 i 3.5 CLR w wersji 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać możliwość ścieżki katalogu wyszukiwania i ich zawartość do odczytu. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do typów niepubliczne, niezależnie od ich zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (domain As AppDomain, assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="domain">Domeny zdalnej, której typ o nazwie <c>typeName</c> jest tworzony.</param>
        <param name="assemblyFile">Nazwa pliku zawiera zestaw w którym typ o nazwie <c>typeName</c> ma być uzyskane.</param>
        <param name="typeName">Nazwa typu preferowany.</param>
        <summary>Tworzy wystąpienia typu, którego nazwa jest określona w określonej domenie zdalnego, za pomocą konstruktora nazwany zestaw plików i domyślne.</summary>
        <returns>Dojście, który musi znajdować się bez otoki dostępu nowo utworzone wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Activator.CreateInstanceFrom%2A> Jeśli jakiś host wymaga wykonanie kodu w domenie aplikacji, która ma ograniczone uprawnienia zabezpieczeń.  
  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartości zwracanej.  
  
> [!NOTE]
>  Ta metoda używa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> wymagające do bezpośredniego obiektu wywołującego ma pełne zaufanie.  
  
 Informacje o innych wyjątki, które mogą być generowane przez wywołanej metody, zobacz sekcję wyjątki <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> i <xref:System.Activator.CreateInstance%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, która została wywołana przez odbicie, wywołało wyjątek.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący mają wymaganych <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  - lub - środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowany, oraz <paramref name="assemblyName" /> został skompilowany dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowany. Należy pamiętać, że wersje .NET Framework 2.0, 3.0 i 3.5 CLR w wersji 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać możliwość ścieżki katalogu wyszukiwania i ich zawartość do odczytu. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku zawiera zestaw w którym typ o nazwie <c>typeName</c> ma być uzyskane.</param>
        <param name="typeName">Nazwa typu preferowany.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie tego typu, którego nazwa jest określona, za pomocą konstruktora nazwany zestaw plików i domyślne.</summary>
        <returns>Dojście, który musi znajdować się bez otoki dostępu nowo utworzone wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartości zwracanej.  
  
 Informacje o innych wyjątki, które mogą być generowane przez wywołanej metody, zobacz sekcję wyjątki <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> i <xref:System.Activator.CreateInstance%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, która została wywołana przez odbicie, wywołało wyjątek.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzony nie pochodzi od <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący mają wymaganych <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  - lub - środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowany, oraz <paramref name="assemblyName" /> został skompilowany dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowany. Należy pamiętać, że wersje .NET Framework 2.0, 3.0 i 3.5 CLR w wersji 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać możliwość ścieżki katalogu wyszukiwania i ich zawartość do odczytu. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do typów niepubliczne, niezależnie od ich zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku zawiera zestaw w którym typ o nazwie <c>typeName</c> ma być uzyskane.</param>
        <param name="typeName">Nazwa typu preferowany.</param>
        <param name="ignoreCase">
          <see langword="true" /> Aby określić, że wyszukiwanie <c>typeName</c> nie jest rozróżniana wielkość liter; <see langword="false" /> do określenia, czy wyszukiwanie jest rozróżniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie <c>typeName</c> konstruktora. Jeśli <c>bindingAttr</c> jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który używa <c>bindingAttr</c> i <c>argumentów</c> do wyszukiwania i identyfikacji <c>typeName</c> konstruktora. Jeśli <c>integratora</c> jest <see langword="null" />, używany jest domyślny integrator.</param>
        <param name="args">Tablica argumentów, które odpowiada w polu numer zamówienia i wpisz parametry konstruktora do wywołania. Jeśli <c>argumentów</c> jest pusta tablica lub <see langword="null" />, wywołaniu konstruktora, który nie przyjmuje żadnych parametrów (konstruktora domyślnego).</param>
        <param name="culture">Informacje specyficzne dla kultury, które kontroluje koercja z <c>argumentów</c> typom posiadanie zadeklarowanym dla <c>typeName</c> konstruktora. Jeśli <c>kultury</c> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> służy bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie tego typu, którego nazwa jest określona, przy użyciu pliku o nazwie zestawu i Konstruktor, który najlepiej odpowiada określonych parametrów.</summary>
        <returns>Dojście, który musi znajdować się bez otoki dostępu nowo utworzone wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartości zwracanej.  
  
 Informacje o innych wyjątki, które mogą być generowane przez wywołanej metody, zobacz sekcję wyjątki <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> i <xref:System.Activator.CreateInstance%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, która została wywołana przez odbicie, wywołało wyjątek.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzony nie pochodzi od <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  - lub - środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowany, oraz <paramref name="assemblyName" /> został skompilowany dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowany. Należy pamiętać, że wersje .NET Framework 2.0, 3.0 i 3.5 CLR w wersji 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać możliwość ścieżki katalogu wyszukiwania i ich zawartość do odczytu. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do niepubliczne typy i składniki niezależnie od ich zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="domain">Domeny zdalnej, której typ o nazwie <c>typeName</c> jest tworzony.</param>
        <param name="assemblyFile">Nazwa pliku zawiera zestaw w którym typ o nazwie <c>typeName</c> ma być uzyskane.</param>
        <param name="typeName">Nazwa typu preferowany.</param>
        <param name="ignoreCase">
          <see langword="true" /> Aby określić, że wyszukiwanie <c>typeName</c> nie jest rozróżniana wielkość liter; <see langword="false" /> do określenia, czy wyszukiwanie jest rozróżniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie <c>typeName</c> konstruktora. Jeśli <c>bindingAttr</c> jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który używa <c>bindingAttr</c> i <c>argumentów</c> do wyszukiwania i identyfikacji <c>typeName</c> konstruktora. Jeśli <c>integratora</c> jest <see langword="null" />, używany jest domyślny integrator.</param>
        <param name="args">Tablica argumentów, które odpowiada w polu numer zamówienia i wpisz parametry konstruktora do wywołania. Jeśli <c>argumentów</c> jest pusta tablica lub <see langword="null" />, wywołaniu konstruktora, który nie przyjmuje żadnych parametrów (konstruktora domyślnego).</param>
        <param name="culture">Informacje specyficzne dla kultury, które kontroluje koercja z <c>argumentów</c> typom posiadanie zadeklarowanym dla <c>typeName</c> konstruktora. Jeśli <c>kultury</c> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> służy bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienia typu, którego nazwa jest określona w określonej domenie zdalnego, przy użyciu pliku o nazwie zestawu i Konstruktor, który najlepiej odpowiada określonych parametrów.</summary>
        <returns>Dojście, który musi znajdować się bez otoki dostępu nowo utworzone wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Activator.CreateInstanceFrom%2A> Jeśli jakiś host wymaga wykonanie kodu w domenie aplikacji, która ma ograniczone uprawnienia zabezpieczeń.  
  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartości zwracanej.  
  
 Informacje o innych wyjątki, które mogą być generowane przez wywołanej metody, zobacz sekcje wyjątki <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> i <xref:System.Activator.CreateInstance%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, która została wywołana przez odbicie, wywołało wyjątek.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący mają wymaganych <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzony nie pochodzi od <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  - lub - <paramref name="assemblyName" /> została skompilowana dla wersji środowiska CLR, która jest nowsza niż wersja, który jest aktualnie załadowany.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać podanie dowód. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać możliwość ścieżki katalogu wyszukiwania i ich zawartość do odczytu. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do niepubliczne typy i składniki niezależnie od ich zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku zawiera zestaw w którym typ o nazwie <c>typeName</c> ma być uzyskane.</param>
        <param name="typeName">Nazwa typu preferowany.</param>
        <param name="ignoreCase">
          <see langword="true" /> Aby określić, że wyszukiwanie <c>typeName</c> nie jest rozróżniana wielkość liter; <see langword="false" /> do określenia, czy wyszukiwanie jest rozróżniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie <c>typeName</c> konstruktora. Jeśli <c>bindingAttr</c> jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który używa <c>bindingAttr</c> i <c>argumentów</c> do wyszukiwania i identyfikacji <c>typeName</c> konstruktora. Jeśli <c>integratora</c> jest <see langword="null" />, używany jest domyślny integrator.</param>
        <param name="args">Tablica argumentów, które odpowiada w polu numer zamówienia i wpisz parametry konstruktora do wywołania. Jeśli <c>argumentów</c> jest pusta tablica lub <see langword="null" />, wywołaniu konstruktora, który nie przyjmuje żadnych parametrów (konstruktora domyślnego).</param>
        <param name="culture">Informacje specyficzne dla kultury, które kontroluje koercja z <c>argumentów</c> typom posiadanie zadeklarowanym dla <c>typeName</c> konstruktora. Jeśli <c>kultury</c> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> służy bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <param name="securityInfo">Informacje używane do decyzje zasady zabezpieczeń i udzielanie uprawnień kodu.</param>
        <summary>Tworzy wystąpienie tego typu, którego nazwa jest określona, przy użyciu pliku o nazwie zestawu i Konstruktor, który najlepiej odpowiada określonych parametrów.</summary>
        <returns>Dojście, który musi znajdować się bez otoki dostępu nowo utworzone wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartości zwracanej.  
  
 Informacje o innych wyjątki, które mogą być generowane przez wywołanej metody, zobacz sekcję wyjątki <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> i <xref:System.Activator.CreateInstance%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, która została wywołana przez odbicie, wywołało wyjątek.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzony nie pochodzi od <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  - lub - środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowany, oraz <paramref name="assemblyName" /> został skompilowany dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowany. Należy pamiętać, że wersje .NET Framework 2.0, 3.0 i 3.5 CLR w wersji 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać możliwość ścieżki katalogu wyszukiwania i ich zawartość do odczytu. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do niepubliczne typy i składniki niezależnie od ich zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Methods which use Evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="domain">Domeny zdalnej, której typ o nazwie <c>typeName</c> jest tworzony.</param>
        <param name="assemblyFile">Nazwa pliku zawiera zestaw w którym typ o nazwie <c>typeName</c> ma być uzyskane.</param>
        <param name="typeName">Nazwa typu preferowany.</param>
        <param name="ignoreCase">
          <see langword="true" /> Aby określić, że wyszukiwanie <c>typeName</c> nie jest rozróżniana wielkość liter; <see langword="false" /> do określenia, czy wyszukiwanie jest rozróżniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które mają wpływ na wyszukiwanie <c>typeName</c> konstruktora. Jeśli <c>bindingAttr</c> jest zero, wyszukiwanie jest przeprowadzane konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który używa <c>bindingAttr</c> i <c>argumentów</c> do wyszukiwania i identyfikacji <c>typeName</c> konstruktora. Jeśli <c>integratora</c> jest <see langword="null" />, używany jest domyślny integrator.</param>
        <param name="args">Tablica argumentów, które odpowiada w polu numer zamówienia i wpisz parametry konstruktora do wywołania. Jeśli <c>argumentów</c> jest pusta tablica lub <see langword="null" />, wywołaniu konstruktora, który nie przyjmuje żadnych parametrów (konstruktora domyślnego).</param>
        <param name="culture">Informacje specyficzne dla kultury, które kontroluje koercja z <c>argumentów</c> typom posiadanie zadeklarowanym dla <c>typeName</c> konstruktora. Jeśli <c>kultury</c> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> służy bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  Ten parametr jest związane z obiektami, klient jest aktywowany. Aktywacja klienta jest technologią starszej wersji, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <param name="securityAttributes">Informacje używane do decyzje zasady zabezpieczeń i udzielanie uprawnień kodu.</param>
        <summary>Tworzy wystąpienia typu, którego nazwa jest określona w określonej domenie zdalnego, przy użyciu pliku o nazwie zestawu i Konstruktor, który najlepiej odpowiada określonych parametrów.</summary>
        <returns>Dojście, który musi znajdować się bez otoki dostępu nowo utworzone wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Activator.CreateInstanceFrom%2A> Jeśli jakiś host wymaga wykonanie kodu w domenie aplikacji, która ma ograniczone uprawnienia zabezpieczeń.  
  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartości zwracanej.  
  
> [!NOTE]
>  Ta metoda używa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> wymagające do bezpośredniego obiektu wywołującego ma pełne zaufanie.  
  
 Informacje o innych wyjątki, które mogą być generowane przez wywołanej metody, zobacz sekcję wyjątki <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> i <xref:System.Activator.CreateInstance%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> Nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z mechanizmem późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, która została wywołana przez odbicie, wywołało wyjątek.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący mają wymaganych <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzony nie pochodzi od <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  - lub - środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowany, oraz <paramref name="assemblyName" /> został skompilowany dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowany. Należy pamiętać, że wersje .NET Framework 2.0, 3.0 i 3.5 CLR w wersji 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać podanie dowód. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać możliwość ścieżki katalogu wyszukiwania i ich zawartość do odczytu. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do niepubliczne typy i składniki niezależnie od ich zestawu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy serwer proxy dla obiekt dobrze znanego lub usługi XML sieci Web.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ dobrze znane obiekty, do którego chcesz się połączyć.</param>
        <param name="url">Adres URL dobrze znanego obiektu.</param>
        <summary>Tworzy serwer proxy dla obiekt dobrze znanego wskazywanym przez określony typ i adres URL.</summary>
        <returns>Serwer proxy, która wskazuje punkt końcowy obsługiwanej przez dobrze znanego żądanego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie serwera proxy do wysyłania komunikatów do obiektu zdalnego. Nie komunikaty są wysyłane za pośrednictwem sieci, dopóki metoda jest wywoływana na serwerze proxy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> lub <paramref name="url" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="type" /> nie jest przekazywane przez odwołanie i nie jest interfejsem.</exception>
        <exception cref="T:System.MemberAccessException">Ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="type">Typ dobrze znane obiekty, do którego chcesz się połączyć.</param>
        <param name="url">Adres URL dobrze znanego obiektu.</param>
        <param name="state">Kanał danych lub <see langword="null" />.</param>
        <summary>Tworzy serwer proxy dla obiekt dobrze znanego wskazywanym przez określony typ, adres URL i kanału danych.</summary>
        <returns>Serwer proxy, która wskazuje punkt końcowy obsługiwanej przez dobrze znanego żądanego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie serwera proxy do wysyłania komunikatów do obiektu zdalnego. Nie komunikaty są wysyłane za pośrednictwem sieci, dopóki metoda jest wywoływana na serwerze proxy.  
  
 `state` Parametru komunikuje się informacji do kanału i jest przekazywana do <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> lub <paramref name="url" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="type" /> nie jest przekazywane przez odwołanie i nie jest interfejsem.</exception>
        <exception cref="T:System.MemberAccessException">Ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Activator.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Activator.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Activator::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="rgszNames">Tablica przekazany w nazw do mapowania.</param>
        <param name="cNames">Liczba nazw do mapowania.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</param>
        <param name="rgDispId">Tablica przydzielone przez obiekt wywołujący odbiera identyfikatory, odpowiadających nazwy.</param>
        <summary>Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do zarządzanych klas z kodem niezarządzanym i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetIDsOfNames`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Activator.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informacje o typie, który będzie zwracany.</param>
        <param name="lcid">Identyfikator regionalny dla informacji o typie.</param>
        <param name="ppTInfo">Obiekt, który odbiera Wskaźnik do obiektu informacji żądanego typu.</param>
        <summary>Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do zarządzanych klas z kodem niezarządzanym i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfo`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Activator.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Gdy metoda zwróci wartość, zawiera wskaźnik do lokalizacji, która odbiera liczba interfejsów informacji typu dostarczanych przez obiekt. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do zarządzanych klas z kodem niezarządzanym i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfoCount`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.Invoke">
      <MemberSignature Language="C#" Value="void _Activator.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Activator.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Activator::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identyfikator wysyłania, która identyfikuje element członkowski.</param>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</param>
        <param name="wFlags">Flagi opisujące kontekst wywołania.</param>
        <param name="pDispParams">Wskaźnik do struktury, która zawiera tablicę argumentów, tablicy argumentu identyfikator DISPID dla argumentów nazwanych i liczba Liczba elementów w tablicach.</param>
        <param name="pVarResult">Wskaźnik do lokalizacji, w którym ma być przechowywany wynik.</param>
        <param name="pExcepInfo">Wskaźnik do struktury, która zawiera informacje o wyjątku.</param>
        <param name="puArgErr">Indeks pierwszego argumentu, który zawiera błąd.</param>
        <summary>Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do zarządzanych klas z kodem niezarządzanym i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::Invoke`, zobacz bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem za pomocą modelu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Activator" FullName="System.Activator">
  <Metadata><Meta Name="ms.openlocfilehash" Value="598e53cc199b66ed30cb710e0d1b094b88632f49" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52603273" /></Metadata><TypeSignature Language="C#" Value="public sealed class Activator : System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Activator extends System.Object implements class System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="DocId" Value="T:System.Activator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Activator&#xA;Implements _Activator" />
  <TypeSignature Language="C++ CLI" Value="public ref class Activator sealed : System::Runtime::InteropServices::_Activator" />
  <TypeSignature Language="F#" Value="type Activator = class&#xA;    interface _Activator" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Activator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Activator))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zawiera metody służące do tworzenia typów obiektów, lokalnie lub zdalnie lub uzyskanie odwołania do istniejących obiektów zdalnego. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Activator.CreateInstance%2A> Metoda tworzy wystąpienie typu zdefiniowanego w zestawie, wywołując konstruktora, która najlepiej pasuje określonych argumentów. Jeśli nie określono żadnych argumentów, Konstruktor, który nie przyjmuje żadnych parametrów, oznacza to, że Konstruktor domyślny, zostanie wywołana.  
  
 Musi mieć wystarczające uprawnienia, aby wyszukać i wywołać konstruktora; w przeciwnym razie jest zgłaszany wyjątek. Domyślnie tylko publiczne konstruktory są uwzględniane podczas wyszukiwania dla konstruktora. Jeśli można znaleźć nie konstruktora lub domyślnego konstruktora, jest zgłaszany wyjątek.  
  
 Parametr integratora określa obiekt, który wyszukuje zestaw dla odpowiedniego konstruktora. Można określić własne integratorów modeli i kryteria wyszukiwania. Jeśli żaden integrator nie jest określona, jest używany domyślny integrator. Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.Binder?displayProperty=nameWithType> i <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> klasy.  
  
 Parametr dowód wpływa na zasady zabezpieczeń i uprawnienia dla konstruktora. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Policy.Evidence?displayProperty=nameWithType> klasy.  
  
 Można utworzyć wystąpienia typu w lokacji lokalnych lub zdalnych. Jeśli typ jest tworzony zdalnie, parametr atrybutu aktywacji Określa identyfikator URI lokacji zdalnej. Wywołanie w celu utworzenia wystąpienia może przechodzić przez pośredniczące lokacji, przed osiągnięciem przez nią lokacji zdalnej. Inne atrybuty aktywacji można zmodyfikować środowiska lub kontekst, w którym wywołanie działania w lokacjach zdalnych i pośrednie.  
  
 Jeśli wystąpienie jest tworzony lokalnie, zwracany jest odwołanie do tego obiektu. Jeśli tworzone jest zdalne wystąpienie, zwracany jest odwołanie do serwera proxy. Obiektu zdalnego jest przetwarzany przez serwer proxy, tak jakby obiekt lokalny.  
  
 <xref:System.Activator.GetObject%2A> Metoda tworzy to obiekt pośredniczący dla obiektu uruchomioną obecnie zdalnego, serwer aktywowany obiekt dobrze znane lub usługi sieci Web XML. Można określić średni połączenia, oznacza to, że kanał. Aby uzyskać więcej informacji, zobacz <xref:System.Runtime.Remoting.Channels.ChannelServices?displayProperty=nameWithType> klasy.  
  
 Zestawy zawierają definicje typów. <xref:System.Activator.CreateInstance%2A> Metoda tworzy wystąpienie typu z uruchomionego zestawu. <xref:System.Activator.CreateInstanceFrom%2A> Metoda tworzy wystąpienie z pliku, który zawiera zestaw. <xref:System.Activator.CreateComInstanceFrom%2A> Metoda tworzy wystąpienie obiektu modelu COM z pliku, który zawiera zestaw.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Activator> klasy, aby dynamicznie konstruowania obiektów w czasie wykonywania.  
  
 [!code-cpp[ActivatorX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#1)]
 [!code-csharp[ActivatorX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#1)]
 [!code-vb[ActivatorX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy wystąpienie obiektu COM, którego nazwa jest określona.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa pliku, który zawiera zestaw gdzie typ o nazwie <paramref name="typeName" /> poszukiwane są.</param>
        <param name="typeName">Nazwa typu preferowany.</param>
        <summary>Tworzy wystąpienie obiektu COM, którego nazwa jest określona, przy użyciu pliku o nazwie zestawu i domyślnego konstruktora.</summary>
        <returns>Uchwyt, który musi być nieopakowane dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartość zwracaną.  
  
 A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atrybutu o wartości `true` musi dotyczyć jawnie lub domyślnie typ COM więc <xref:System.Activator.CreateComInstanceFrom%2A> metody można utworzyć wystąpienia tego typu; w przeciwnym razie <xref:System.TypeLoadException> zgłaszany.  
  
 Aby uzyskać informacje o innych wyjątków, które mogą zostać zgłoszone przez metody wywołane, zobacz sekcję wyjątki <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> i <xref:System.Activator.CreateInstance%2A> metody.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do tworzenia typów niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw uprawnień zestawu, który zawiera typów niepublicznych jest ograniczony do obiektu wywołującego przyznania Ustaw lub jego podzbioru. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> lub <paramref name="assemblyName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Nie można utworzyć wystąpienia za pomocą modelu COM.  
  
—lub— 
 <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> nie zostanie znaleziony, lub moduł, który chcesz załadować nie określa rozszerzenie nazwy pliku.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej.  
  
—lub— 
Ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może dostarczyć atrybutów aktywacji obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyName" /> ciąg pusty ("").</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do typów niepublicznych, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateComInstanceFrom (assemblyName, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa pliku, który zawiera zestaw gdzie typ o nazwie <paramref name="typeName" /> poszukiwane są.</param>
        <param name="typeName">Nazwa typu preferowany.</param>
        <param name="hashValue">Wartość obliczona wartość skrótu.</param>
        <param name="hashAlgorithm">Algorytm wyznaczania wartości skrótu używany do tworzenia skrótów plików i wygenerowanie silnej nazwy.</param>
        <summary>Tworzy wystąpienie obiektu COM, którego nazwa jest określona, przy użyciu pliku o nazwie zestawu i domyślnego konstruktora.</summary>
        <returns>Uchwyt, który musi być nieopakowane dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartość zwracaną.  
  
 A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atrybutu o wartości `true` musi dotyczyć jawnie lub domyślnie typ COM więc <xref:System.Activator.CreateComInstanceFrom%2A> metody można utworzyć wystąpienia tego typu; w przeciwnym razie <xref:System.TypeLoadException> zgłaszany.  
  
 Aby uzyskać informacje o innych wyjątków, które mogą zostać zgłoszone przez metody wywołane, zobacz sekcję wyjątki <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> i <xref:System.Activator.CreateInstance%2A> metody.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do tworzenia typów niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw uprawnień zestawu, który zawiera typów niepublicznych jest ograniczony do obiektu wywołującego przyznania Ustaw lub jego podzbioru. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> lub <paramref name="assemblyName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyName" /> ciąg pusty ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.
        
—lub— 
 <paramref name="assemblyName" /> jest większa niż zdefiniowana w systemie długość maksymalna.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> nie zostanie znaleziony, lub moduł, który chcesz załadować nie określa rozszerzenie nazwy pliku.</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="assemblyName" /> zostanie znaleziony, ale nie może zostać załadowany.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> nie jest prawidłowym zestawem.</exception>
        <exception cref="T:System.Security.SecurityException">Bazy kodu, który nie zaczyna się od "file://" został określony bez wymaganych <see langword="WebPermission" />.</exception>
        <exception cref="T:System.TypeLoadException">Nie można utworzyć wystąpienia za pomocą modelu COM.  
  
—lub— 
 <paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej.  
  
—lub— 
Ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może dostarczyć atrybutów aktywacji obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do typów niepublicznych, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania identyfikatora URI, który rozpoczyna się od "file://". Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy wystąpienie określonego typu przy użyciu konstruktora, który najlepiej odpowiada określonych parametrów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : ActivationContext -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance activationContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">Obiekt kontekstu aktywacji, który określa obiekt, aby utworzyć.</param>
        <summary>Tworzy wystąpienie typu wyznaczony przez określony <see cref="T:System.ActivationContext" /> obiektu.</summary>
        <returns>Uchwyt, który musi być nieopakowane dostępu do nowo utworzonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartość zwracaną.  
  
 Kontekst aktywacji jest używana podczas aktywacji opartej na manifestu, aby skonfigurować zasady domeny i zapewnienie model zabezpieczeń oparty na aplikacji. <xref:System.ActivationContext> Klasa zawiera <xref:System.ApplicationIdentity> obiektu, który zapewnia dostęp do manifestu aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Policy.ApplicationSecurityManager> klasy.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type -&gt; obj" Usage="System.Activator.CreateInstance type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Typ obiektu do utworzenia.</param>
        <summary>Tworzy wystąpienie określonego typu przy użyciu tego typu domyślnego konstruktora.</summary>
        <returns>Odwołanie do nowo utworzonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor wywoływanej muszą być dostępne.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda umożliwia dostęp do typów niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw uprawnień zestawu, który zawiera typów niepublicznych jest ograniczony do obiektu wywołującego przyznania Ustaw lub jego podzbioru. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób wywołania <xref:System.Activator.CreateInstance%28System.Type%29> metody. Są tworzone wystąpienia kilku różnych typów i ich wartości domyślne są wyświetlane.  
  
 [!code-cpp[ActivatorX#4](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/source2.cpp#4)]
 [!code-csharp[ActivatorX#4](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/source2.cs#4)]
 [!code-vb[ActivatorX#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/source2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> nie jest <see langword="RuntimeType" />.  
  
—lub— 
 <paramref name="type" /> jest to otwarty typ ogólny (czyli <see cref="P:System.Type.ContainsGenericParameters" /> właściwość zwraca <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="type" /> nie może być <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
—lub— 
Tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> typów lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
Zestaw, który zawiera <paramref name="type" /> jest zestawu dynamicznego, który został utworzony za pomocą <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktora wywołuje się, że zgłasza wyjątek.</exception>
        <exception cref="T:System.MethodAccessException"><block subset="none" type="note">
            <para>  
 W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.MemberAccessException" />, a zamiast tego.  
  
</para>
          </block>  
  
 Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException"><block subset="none" type="note">
            <para>  
 W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.MissingMemberException" />, a zamiast tego.  
  
</para>
          </block>  
  
 Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="type" /> jest obiektem COM, ale identyfikator klasy stosowane w celu uzyskania typu jest nieprawidłowy lub wskazany klasa nie jest zarejestrowana.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="type" /> nie jest prawidłowym typem.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do typów niepublicznych, niezależnie od ich przydział zestawów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext, string[] activationCustomData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext, string[] activationCustomData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext, cli::array &lt;System::String ^&gt; ^ activationCustomData);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : ActivationContext * string[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (activationContext, activationCustomData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
        <Parameter Name="activationCustomData" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="activationContext">Obiekt kontekstu aktywacji, który określa obiekt, aby utworzyć.</param>
        <param name="activationCustomData">Tablica ciągów znaków Unicode, które zawierają dane niestandardowe aktywacji.</param>
        <summary>Tworzy wystąpienie typu, który jest wyznaczone przez określony <see cref="T:System.ActivationContext" /> obiektu i aktywować przy użyciu danych określone uaktywnianie niestandardowych.</summary>
        <returns>Uchwyt, który musi być nieopakowane dostępu do nowo utworzonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartość zwracaną.  
  
 Kontekst aktywacji jest używana podczas aktywacji opartej na manifestu, aby skonfigurować zasady domeny i zapewnienie model zabezpieczeń oparty na aplikacji. <xref:System.ActivationContext> Klasa zawiera <xref:System.ApplicationIdentity> obiektu, który zapewnia dostęp do manifestu aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Policy.ApplicationSecurityManager> klasy.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa zestawu, gdzie typ o nazwie <paramref name="typeName" /> poszukiwane są. Jeśli <paramref name="assemblyName" /> jest <see langword="null" />, przeszukiwany jest wykonywanie zestawu.</param>
        <param name="typeName">W pełni kwalifikowana nazwa preferowany typ.</param>
        <summary>Tworzy wystąpienie tego typu, którego nazwa jest określona, przy użyciu nazwanego zestawu i domyślnego konstruktora.</summary>
        <returns>Uchwyt, który musi być nieopakowane dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> do odkodowania wartość zwracaną.  
  
 `assemblyName` może być jedną z następujących czynności:  
  
-   Prosta nazwa zestawu, bez jego rozszerzenie pliku lub ścieżki. Na przykład, należy określić `TypeExtensions` dla zestawu, którego ścieżka i nazwa są.\bin\TypeExtensions.dll.  
  
-   Pełna nazwa podpisanego zestawu, który składa się z prostą nazwę, wersję, kulturę i token klucza publicznego; na przykład "TypeExtensions, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = 181869f2f7435b51".  
  
 Aby uzyskać więcej informacji na temat jak środowisko uruchomieniowe języka wspólnego identyfikuje i ładuje zestawy, zobacz [jak środowisko uruchomieniowe lokalizuje zestawy](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md). Aby uzyskać informacji na temat definiowania lokalizacji zestawu przy użyciu pliku konfiguracji aplikacji, zobacz [Określanie lokalizacji zestawu](~/docs/framework/configure-apps/specify-assembly-location.md). Jeśli `assemblyName` zostanie znaleziony, jest ładowany w kontekście domyślnym.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do tworzenia typów niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw uprawnień zestawu, który zawiera typów niepublicznych jest ograniczony do obiektu wywołującego przyznania Ustaw lub jego podzbioru. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano klasę o nazwie `Person` w zestawie o nazwie `PersonInfo`. Należy pamiętać, że `Person` klasa ma dwa konstruktory, z których jedna jest bez parametrów.  
  
 [!code-csharp[System.Activator.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/personinfo.cs#1)]
 [!code-vb[System.Activator.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/personinfo.vb#1)]  
  
 Poniższy przykład wywołuje <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29> metodę, aby utworzyć wystąpienie `Person` klasy. Wymaga to dodania odwołania do PersonInfo.dll mają zostać dodane do projektu. Ponieważ <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29> wywołania metody `Person` domyślny konstruktor klasy przykład przypisuje wartość do jego `Name` właściwości.  
  
 [!code-csharp[System.Activator.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1.cs#2)]
 [!code-vb[System.Activator.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1.vb#2)]  
  
 Jednak <xref:System.Activator.CreateInstance%2A> często jest wywoływana w celu utworzenia wystąpienia typu, który przekracza granic lub nie jest znany w czasie projektowania. W tym przypadku nie może zawierać odwołanie do zestawu w projekcie i nie może wykonywać wywołania wczesnym wiązaniem do elementów członkowskich typu. Aby obejść to ograniczenie, w poniższym przykładzie użyto <xref:System.Activator.CreateInstance%2A> metoda wraz z odbicia do przypisania wartości do `Person` obiektu `Name` właściwości i wyświetlić jego wartość.  
  
 [!code-csharp[System.Activator.CreateInstance#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1a.cs#3)]
 [!code-vb[System.Activator.CreateInstance#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1a.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej lub ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktora, który został wywołany przez odbicie, zgłosiła wyjątek.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">Tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> typów lub tablic tych typów nie jest obsługiwane.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowana, a <paramref name="assemblyName" /> została skompilowana dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowanych. Należy pamiętać, że .NET Framework w wersji 2.0, 3.0 i 3.5 używają wersji CLR 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.  
  
—lub— 
Nazwa zestawu lub podstawowy kod jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do typów niepublicznych, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, bool nonPublic);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * bool -&gt; obj" Usage="System.Activator.CreateInstance (type, nonPublic)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Typ obiektu do utworzenia.</param>
        <param name="nonPublic"><see langword="true" /> Jeśli konstruktor publiczny lub niepublicznych może dopasować; <see langword="false" /> czy tylko może odnosić się do publicznego konstruktora domyślnego.</param>
        <summary>Tworzy wystąpienie określonego typu przy użyciu tego typu domyślnego konstruktora.</summary>
        <returns>Odwołanie do nowo utworzonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do dostępu do typów niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw uprawnień zestawu, który zawiera do typów niepublicznych jest ograniczony do obiektu wywołującego udzielić ustawione lub jego podzbioru. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> nie jest <see langword="RuntimeType" />.  
  
—lub— 
 <paramref name="type" /> jest to otwarty typ ogólny (czyli <see cref="P:System.Type.ContainsGenericParameters" /> właściwość zwraca <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="type" /> nie może być <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
—lub— 
Tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> typów lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
Zestaw, który zawiera <paramref name="type" /> jest zestawu dynamicznego, który został utworzony za pomocą <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktora wywołuje się, że zgłasza wyjątek.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="type" /> jest obiektem COM, ale identyfikator klasy stosowane w celu uzyskania typu jest nieprawidłowy lub wskazany klasa nie jest zarejestrowana.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="type" /> nie jest prawidłowym typem.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do niepublicznych typy i elementy członkowskie, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Typ obiektu do utworzenia.</param>
        <param name="args">Tablica argumentów, które są zgodne w liczby, kolejności i typów parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest pusta tablica lub <see langword="null" />, Konstruktor, który nie przyjmuje żadnych parametrów (Konstruktor domyślny) jest wywoływana.</param>
        <summary>Tworzy wystąpienie określonego typu przy użyciu konstruktora, który najlepiej odpowiada określonych parametrów.</summary>
        <returns>Odwołanie do nowo utworzonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor wywoływanej muszą być dostępne i podać bardziej konkretny od pozostałych dopasowania z określoną listę argumentów.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda umożliwia dostęp do typów niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw uprawnień zestawu, który zawiera typów niepublicznych jest ograniczony do obiektu wywołującego przyznania Ustaw lub jego podzbioru. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> metodę w celu utworzenia <xref:System.String> obiektu. Wywołuje <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> konstruktora w celu utworzenia wystąpienia ciągu, który zawiera 10 elementów z tablicy znaków, zaczynając od pozycji czternastego.  
  
 [!code-csharp[System.Activator.CreateInstance#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/CreateInstance5.cs#5)]
 [!code-vb[System.Activator.CreateInstance#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/CreateInstance5.vb#5)]  
  
 Poniższy przykład tworzy tablicę nieregularną, której elementy są argumenty do przekazania do <xref:System.String> konstruktora. Przykład następnie przekazuje macierzy w celu <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> metody do wywołania konstruktora odpowiedni ciąg.  
  
 [!code-csharp[System.Activator.CreateInstance#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstance2.cs#4)]
 [!code-vb[System.Activator.CreateInstance#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstance2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> nie jest <see langword="RuntimeType" />.  
  
—lub— 
 <paramref name="type" /> jest to otwarty typ ogólny (czyli <see cref="P:System.Type.ContainsGenericParameters" /> właściwość zwraca <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="type" /> nie może być <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
—lub— 
Tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> typów lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
Zestaw, który zawiera <paramref name="type" /> jest zestawu dynamicznego, który został utworzony za pomocą <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
—lub— 
Konstruktor, który najlepszych dopasowań <paramref name="args" /> ma <see langword="varargs" /> argumentów.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktora wywołuje się, że zgłasza wyjątek.</exception>
        <exception cref="T:System.MethodAccessException"><block subset="none" type="note">
            <para>  
 W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.MemberAccessException" />, a zamiast tego.  
  
</para>
          </block>  
  
 Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException"><block subset="none" type="note">
            <para>  
 W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.MissingMemberException" />, a zamiast tego.  
  
</para>
          </block>  
  
 Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="type" /> jest obiektem COM, ale identyfikator klasy stosowane w celu uzyskania typu jest nieprawidłowy lub wskazany klasa nie jest zarejestrowana.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="type" /> nie jest prawidłowym typem.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do typów niepublicznych, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (domain As AppDomain, assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="domain">Domena zdalna, gdzie typ o nazwie <paramref name="typeName" /> zostanie utworzony.</param>
        <param name="assemblyName">Nazwa zestawu, gdzie typ o nazwie <paramref name="typeName" /> poszukiwane są. Jeśli <paramref name="assemblyName" /> jest <see langword="null" />, przeszukiwany jest wykonywanie zestawu.</param>
        <param name="typeName">W pełni kwalifikowana nazwa preferowany typ.</param>
        <summary>Tworzy wystąpienie tego typu, którego nazwa jest określona w podanej domenie zdalnego przy użyciu nazwanego zestawu i domyślnego konstruktora.</summary>
        <returns>Uchwyt, który musi być nieopakowane dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Activator.CreateInstance%2A> Jeśli jakiś host wymaga wykonania kodu w domenie aplikacji, które ma ograniczone uprawnienia zabezpieczeń.  
  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> do odkodowania wartość zwracaną.  
  
> [!NOTE]
>  Ta metoda używa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> wymagać bezpośredniego obiektu wywołującego do pełnego zaufania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> lub <paramref name="domain" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia typu abstrakcyjnego.  
  
—lub— 
Ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktora, który został wywołany przez odbicie, zgłosiła wyjątek.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">Tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> typów lub tablic tych typów nie jest obsługiwane.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowana, a <paramref name="assemblyName" /> została skompilowana dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowanych. Należy pamiętać, że .NET Framework w wersji 2.0, 3.0 i 3.5 używają wersji CLR 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.  
  
—lub— 
Nazwa zestawu lub podstawowy kod jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa zestawu, gdzie typ o nazwie <paramref name="typeName" /> poszukiwane są. Jeśli <paramref name="assemblyName" /> jest <see langword="null" />, przeszukiwany jest wykonywanie zestawu.</param>
        <param name="typeName">W pełni kwalifikowana nazwa preferowany typ.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie tego typu, którego nazwa jest określona, przy użyciu nazwanego zestawu i domyślnego konstruktora.</summary>
        <returns>Uchwyt, który musi być nieopakowane dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> do odkodowania wartość zwracaną.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do tworzenia typów niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw uprawnień typów niepublicznych jest ograniczony, aby zestaw uprawnień obiektu wywołującego lub jego podzbioru. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">Tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> typów lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
 <paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzonego nie pochodzi od <see cref="T:System.MarshalByRefObject" />.  
  
—lub— 
 <paramref name="activationAttributes" /> nie jest <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />  
  
Tablica.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowana, a <paramref name="assemblyName" /> została skompilowana dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowanych. Należy pamiętać, że .NET Framework w wersji 2.0, 3.0 i 3.5 używają wersji CLR 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.  
  
—lub— 
Nazwa zestawu lub podstawowy kod jest nieprawidłowy.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Wystąpił błąd podczas próby aktywacji zdalnej w określone w elemencie docelowym <paramref name="activationAttributes" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do typów niepublicznych, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, object[] args, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[],System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * obj[] * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, args, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="type">Typ obiektu do utworzenia.</param>
        <param name="args">Tablica argumentów, które są zgodne w liczby, kolejności i typów parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest pusta tablica lub <see langword="null" />, Konstruktor, który nie przyjmuje żadnych parametrów (Konstruktor domyślny) jest wywoływana.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie określonego typu przy użyciu konstruktora, który najlepiej odpowiada określonych parametrów.</summary>
        <returns>Odwołanie do nowo utworzonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor wywoływanej muszą być dostępne i podać bardziej konkretny od pozostałych dopasowania z określoną listę argumentów.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda umożliwia dostęp do typów niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw uprawnień zestawu, który zawiera typów niepublicznych jest ograniczony do obiektu wywołującego przyznania Ustaw lub jego podzbioru. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> nie jest <see langword="RuntimeType" />.  
  
—lub— 
 <paramref name="type" /> jest to otwarty typ ogólny (czyli <see cref="P:System.Type.ContainsGenericParameters" /> właściwość zwraca <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="type" /> nie może być <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
—lub— 
Tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> typów lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
 <paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzonego nie pochodzi od <see cref="T:System.MarshalByRefObject" />.  
  
—lub— 
Zestaw, który zawiera <paramref name="type" /> jest zestawu dynamicznego, który został utworzony za pomocą <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
—lub— 
Konstruktor, który najlepszych dopasowań <paramref name="args" /> ma <see langword="varargs" /> argumentów.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktora wywołuje się, że zgłasza wyjątek.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="type" /> jest obiektem COM, ale identyfikator klasy stosowane w celu uzyskania typu jest nieprawidłowy lub wskazany klasa nie jest zarejestrowana.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="type" /> nie jest prawidłowym typem.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do typów niepublicznych, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="System.Activator.CreateInstance (type, bindingAttr, binder, args, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="type">Typ obiektu do utworzenia.</param>
        <param name="bindingAttr">Kombinacja flag bitowych zero lub więcej, które wpływają na wyszukiwanie <paramref name="type" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest zero, wyszukiwanie jest przeprowadzane przez konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który używa <paramref name="bindingAttr" /> i <paramref name="args" /> aby wyszukać i zidentyfikować <paramref name="type" /> konstruktora. Jeśli <paramref name="binder" /> jest <see langword="null" />, jest używany domyślny integrator.</param>
        <param name="args">Tablica argumentów, które są zgodne w liczby, kolejności i typów parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest pusta tablica lub <see langword="null" />, Konstruktor, który nie przyjmuje żadnych parametrów (Konstruktor domyślny) jest wywoływana.</param>
        <param name="culture">Informacje specyficzne dla kultury, które regulują Wymuszanie <paramref name="args" /> do formalnych typów zadeklarowane dla <paramref name="type" /> konstruktora. Jeśli <paramref name="culture" /> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> dla bieżącego wątku jest używana.</param>
        <summary>Tworzy wystąpienie określonego typu przy użyciu konstruktora, który najlepiej odpowiada określonych parametrów.</summary>
        <returns>Odwołanie do nowo utworzonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor do wywołania, musisz podać najbardziej zgodna z określoną listę argumentów w ramach ograniczenia określony obiekt wiążący i atrybutów powiązania.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do dostępu do typów niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw uprawnień zestawu, który zawiera do typów niepublicznych jest ograniczony do obiektu wywołującego udzielić ustawione lub jego podzbioru. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> nie jest <see langword="RuntimeType" />.  
  
—lub— 
 <paramref name="type" /> jest to otwarty typ ogólny (czyli <see cref="P:System.Type.ContainsGenericParameters" /> właściwość zwraca <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="type" /> nie może być <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
—lub— 
Tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> typów lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
Zestaw, który zawiera <paramref name="type" /> jest zestawu dynamicznego, który został utworzony za pomocą <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
—lub— 
Konstruktor, który najlepszych dopasowań <paramref name="args" /> ma <see langword="varargs" /> argumentów.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktora wywołuje się, że zgłasza wyjątek.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="type" /> jest obiektem COM, ale identyfikator klasy stosowane w celu uzyskania typu jest nieprawidłowy lub wskazany klasa nie jest zarejestrowana.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="type" /> nie jest prawidłowym typem.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do niepublicznych typy i elementy członkowskie, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="type">Typ obiektu do utworzenia.</param>
        <param name="bindingAttr">Kombinacja flag bitowych zero lub więcej, które wpływają na wyszukiwanie <paramref name="type" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest zero, wyszukiwanie jest przeprowadzane przez konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który używa <paramref name="bindingAttr" /> i <paramref name="args" /> aby wyszukać i zidentyfikować <paramref name="type" /> konstruktora. Jeśli <paramref name="binder" /> jest <see langword="null" />, jest używany domyślny integrator.</param>
        <param name="args">Tablica argumentów, które są zgodne w liczby, kolejności i typów parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest pusta tablica lub <see langword="null" />, Konstruktor, który nie przyjmuje żadnych parametrów (Konstruktor domyślny) jest wywoływana.</param>
        <param name="culture">Informacje specyficzne dla kultury, które regulują Wymuszanie <paramref name="args" /> do formalnych typów zadeklarowane dla <paramref name="type" /> konstruktora. Jeśli <paramref name="culture" /> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> dla bieżącego wątku jest używana.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie określonego typu przy użyciu konstruktora, który najlepiej odpowiada określonych parametrów.</summary>
        <returns>Odwołanie do nowo utworzonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor do wywołania, musisz podać najbardziej zgodna z określoną listę argumentów w ramach ograniczenia określony obiekt wiążący i atrybutów powiązania.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], Metoda ta może służyć do dostępu do typów niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagi i jeśli zestaw uprawnień do typów niepublicznych jest ograniczony do obiektu wywołującego przyznania zestawu lub do jego podzbioru. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> nie jest <see langword="RuntimeType" />.  
  
—lub— 
 <paramref name="type" /> jest to otwarty typ ogólny (czyli <see cref="P:System.Type.ContainsGenericParameters" /> właściwość zwraca <see langword="true" />).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="type" /> nie może być <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
—lub— 
Tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> typów lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
 <paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzonego nie pochodzi od <see cref="T:System.MarshalByRefObject" />.  
  
—lub— 
Zestaw, który zawiera <paramref name="type" /> jest zestawu dynamicznego, który został utworzony za pomocą <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />.  
  
—lub— 
Konstruktor, który najlepszych dopasowań <paramref name="args" /> ma <see langword="varargs" /> argumentów.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktora wywołuje się, że zgłasza wyjątek.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="type" /> jest obiektem COM, ale identyfikator klasy stosowane w celu uzyskania typu jest nieprawidłowy lub wskazany klasa nie jest zarejestrowana.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="type" /> nie jest prawidłowym typem.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla podanie dowodów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do niepublicznych typy i elementy członkowskie, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa zestawu, gdzie typ o nazwie <paramref name="typeName" /> poszukiwane są. Jeśli <paramref name="assemblyName" /> jest <see langword="null" />, przeszukiwany jest wykonywanie zestawu.</param>
        <param name="typeName">W pełni kwalifikowana nazwa preferowany typ.</param>
        <param name="ignoreCase"><see langword="true" /> Aby określić, że wyszukiwanie <paramref name="typeName" /> nie jest rozróżniana wielkość liter; <see langword="false" /> do określenia, czy w wyszukiwaniu jest uwzględniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja flag bitowych zero lub więcej, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest zero, wyszukiwanie jest przeprowadzane przez konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który używa <paramref name="bindingAttr" /> i <paramref name="args" /> aby wyszukać i zidentyfikować <paramref name="typeName" /> konstruktora. Jeśli <paramref name="binder" /> jest <see langword="null" />, jest używany domyślny integrator.</param>
        <param name="args">Tablica argumentów, które są zgodne w liczby, kolejności i typów parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest pusta tablica lub <see langword="null" />, Konstruktor, który nie przyjmuje żadnych parametrów (Konstruktor domyślny) jest wywoływana.</param>
        <param name="culture">Informacje specyficzne dla kultury, które regulują Wymuszanie <paramref name="args" /> do formalnych typów zadeklarowane dla <paramref name="typeName" /> konstruktora. Jeśli <paramref name="culture" /> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> dla bieżącego wątku jest używana.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie tego typu, którego nazwa jest określona, przy użyciu nazwanego zestawu i Konstruktor, który najlepiej pasuje do określonych parametrów.</summary>
        <returns>Uchwyt, który musi być nieopakowane dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> do odkodowania wartość zwracaną.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda może służyć do tworzenia do typów niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw uprawnień zestawu, który zawiera do typów niepublicznych jest ograniczony do obiektu wywołującego udzielić ustawione lub jego podzbioru. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktora, który został wywołany przez odbicie, zgłosiła wyjątek.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">Tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> typów lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
 <paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzonego nie pochodzi od <see cref="T:System.MarshalByRefObject" />.  
  
—lub— 
Konstruktor, który najlepszych dopasowań <paramref name="args" /> ma <see langword="varargs" /> argumentów.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowana, a <paramref name="assemblyName" /> została skompilowana dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowanych. Należy pamiętać, że .NET Framework w wersji 2.0, 3.0 i 3.5 używają wersji CLR 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.  
  
—lub— 
Nazwa zestawu lub podstawowy kod jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do niepublicznych typy i elementy członkowskie, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="domain">Domeny, której typ o nazwie <paramref name="typeName" /> zostanie utworzony.</param>
        <param name="assemblyName">Nazwa zestawu, gdzie typ o nazwie <paramref name="typeName" /> poszukiwane są. Jeśli <paramref name="assemblyName" /> jest <see langword="null" />, przeszukiwany jest wykonywanie zestawu.</param>
        <param name="typeName">W pełni kwalifikowana nazwa preferowany typ.</param>
        <param name="ignoreCase"><see langword="true" /> Aby określić, że wyszukiwanie <paramref name="typeName" /> nie jest rozróżniana wielkość liter; <see langword="false" /> do określenia, czy w wyszukiwaniu jest uwzględniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja flag bitowych zero lub więcej, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest zero, wyszukiwanie jest przeprowadzane przez konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który używa <paramref name="bindingAttr" /> i <paramref name="args" /> aby wyszukać i zidentyfikować <paramref name="typeName" /> konstruktora. Jeśli <paramref name="binder" /> jest <see langword="null" />, jest używany domyślny integrator.</param>
        <param name="args">Tablica argumentów, które są zgodne w liczby, kolejności i typów parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest pusta tablica lub <see langword="null" />, Konstruktor, który nie przyjmuje żadnych parametrów (Konstruktor domyślny) jest wywoływana.</param>
        <param name="culture">Informacje specyficzne dla kultury, które regulują Wymuszanie <paramref name="args" /> do formalnych typów zadeklarowane dla <paramref name="typeName" /> konstruktora. Jeśli <paramref name="culture" /> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> dla bieżącego wątku jest używana.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie typu, którego nazwa jest określona w podanej domenie zdalnego przy użyciu nazwanego zestawu i Konstruktor, który najlepiej pasuje do określonych parametrów.</summary>
        <returns>Uchwyt, który musi być nieopakowane dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Activator.CreateInstance%2A> Jeśli jakiś host wymaga wykonania kodu w domenie aplikacji, które ma ograniczone uprawnienia zabezpieczeń.  
  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> do odkodowania wartość zwracaną.  
  
> [!NOTE]
>  Ta metoda używa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> wymagać bezpośredniego obiektu wywołującego do pełnego zaufania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="domain" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktora, który został wywołany przez odbicie, zgłosiła wyjątek.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">Tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> typów lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
 <paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzonego nie pochodzi od <see cref="T:System.MarshalByRefObject" />.  
  
—lub— 
Konstruktor, który najlepszych dopasowań <paramref name="args" /> ma <see langword="varargs" /> argumentów.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowana, a <paramref name="assemblyName" /> została skompilowana dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowanych. Należy pamiętać, że .NET Framework w wersji 2.0, 3.0 i 3.5 używają wersji CLR 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.  
  
—lub— 
Nazwa zestawu lub podstawowy kod jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa zestawu, gdzie typ o nazwie <paramref name="typeName" /> poszukiwane są. Jeśli <paramref name="assemblyName" /> jest <see langword="null" />, przeszukiwany jest wykonywanie zestawu.</param>
        <param name="typeName">W pełni kwalifikowana nazwa preferowany typ.</param>
        <param name="ignoreCase"><see langword="true" /> Aby określić, że wyszukiwanie <paramref name="typeName" /> nie jest rozróżniana wielkość liter; <see langword="false" /> do określenia, czy w wyszukiwaniu jest uwzględniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja flag bitowych zero lub więcej, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest zero, wyszukiwanie jest przeprowadzane przez konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który używa <paramref name="bindingAttr" /> i <paramref name="args" /> aby wyszukać i zidentyfikować <paramref name="typeName" /> konstruktora. Jeśli <paramref name="binder" /> jest <see langword="null" />, jest używany domyślny integrator.</param>
        <param name="args">Tablica argumentów, które są zgodne w liczby, kolejności i typów parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest pusta tablica lub <see langword="null" />, Konstruktor, który nie przyjmuje żadnych parametrów (Konstruktor domyślny) jest wywoływana.</param>
        <param name="culture">Informacje specyficzne dla kultury, które regulują Wymuszanie <paramref name="args" /> do formalnych typów zadeklarowane dla <paramref name="typeName" /> konstruktora. Jeśli <paramref name="culture" /> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> dla bieżącego wątku jest używana.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <param name="securityInfo">Informacje używane do decyzje zasad zabezpieczeń i przyznawanie uprawnień kodu.</param>
        <summary>Tworzy wystąpienie tego typu, którego nazwa jest określona, przy użyciu nazwanego zestawu i Konstruktor, który najlepiej pasuje do określonych parametrów.</summary>
        <returns>Uchwyt, który musi być nieopakowane dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> do odkodowania wartość zwracaną.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda może służyć do tworzenia do typów niepublicznych, jeśli obiekt wywołujący zostało udzielone <xref:System.Security.Permissions.ReflectionPermission> z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagę i jeśli zestaw uprawnień zestawu, który zawiera do typów niepublicznych jest ograniczony do obiektu wywołującego udzielić ustawione lub jego podzbioru. (Zobacz [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Aby używać tej funkcji, powinien dotyczyć aplikacji [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] lub nowszej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktora, który został wywołany przez odbicie, zgłosiła wyjątek.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">Tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> typów lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
 <paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzonego nie pochodzi od <see cref="T:System.MarshalByRefObject" />.  
  
—lub— 
Konstruktor, który najlepszych dopasowań <paramref name="args" /> ma <see langword="varargs" /> argumentów.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowana, a <paramref name="assemblyName" /> została skompilowana dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowanych. Należy pamiętać, że .NET Framework w wersji 2.0, 3.0 i 3.5 używają wersji CLR 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.  
  
—lub— 
Nazwa zestawu lub podstawowy kod jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do niepublicznych typy i elementy członkowskie, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="domain">Domeny, której typ o nazwie <paramref name="typeName" /> zostanie utworzony.</param>
        <param name="assemblyName">Nazwa zestawu, gdzie typ o nazwie <paramref name="typeName" /> poszukiwane są. Jeśli <paramref name="assemblyName" /> jest <see langword="null" />, przeszukiwany jest wykonywanie zestawu.</param>
        <param name="typeName">W pełni kwalifikowana nazwa preferowany typ.</param>
        <param name="ignoreCase"><see langword="true" /> Aby określić, że wyszukiwanie <paramref name="typeName" /> nie jest rozróżniana wielkość liter; <see langword="false" /> do określenia, czy w wyszukiwaniu jest uwzględniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja flag bitowych zero lub więcej, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest zero, wyszukiwanie jest przeprowadzane przez konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który używa <paramref name="bindingAttr" /> i <paramref name="args" /> aby wyszukać i zidentyfikować <paramref name="typeName" /> konstruktora. Jeśli <paramref name="binder" /> jest <see langword="null" />, jest używany domyślny integrator.</param>
        <param name="args">Tablica argumentów, które są zgodne w liczby, kolejności i typów parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest pusta tablica lub <see langword="null" />, Konstruktor, który nie przyjmuje żadnych parametrów (Konstruktor domyślny) jest wywoływana.</param>
        <param name="culture">Informacje specyficzne dla kultury, które regulują Wymuszanie <paramref name="args" /> do formalnych typów zadeklarowane dla <paramref name="typeName" /> konstruktora. Jeśli <paramref name="culture" /> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> dla bieżącego wątku jest używana.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu. <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> Określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.</param>
        <param name="securityAttributes">Informacje używane do decyzje zasad zabezpieczeń i przyznawanie uprawnień kodu.</param>
        <summary>Tworzy wystąpienie typu, którego nazwa jest określona w podanej domenie zdalnego przy użyciu nazwanego zestawu i Konstruktor, który najlepiej pasuje do określonych parametrów.</summary>
        <returns>Uchwyt, który musi być nieopakowane dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Activator.CreateInstance%2A> Jeśli jakiś host wymaga wykonania kodu w domenie aplikacji, które ma ograniczone uprawnienia zabezpieczeń.  
  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> do odkodowania wartość zwracaną.  
  
> [!NOTE]
>  Ta metoda używa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> wymagać bezpośredniego obiektu wywołującego do pełnego zaufania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="domain" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktora, który został wywołany przez odbicie, zgłosiła wyjątek.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ modelu COM nie uzyskano za pośrednictwem <see cref="Overload:System.Type.GetTypeFromProgID" /> lub <see cref="Overload:System.Type.GetTypeFromCLSID" />.</exception>
        <exception cref="T:System.NotSupportedException">Tworzenie <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" />, i <see cref="T:System.RuntimeArgumentHandle" /> typów lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
 <paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzonego nie pochodzi od <see cref="T:System.MarshalByRefObject" />.  
  
—lub— 
Konstruktor, który najlepszych dopasowań <paramref name="args" /> ma <see langword="varargs" /> argumentów.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowana, a <paramref name="assemblyName" /> została skompilowana dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowanych. Należy pamiętać, że .NET Framework w wersji 2.0, 3.0 i 3.5 używają wersji CLR 2.0.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.  
  
—lub— 
Nazwa zestawu lub podstawowy kod jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CreateInstance&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CreateInstance&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T CreateInstance();" />
      <MemberSignature Language="F#" Value="static member CreateInstance : unit -&gt; 'T" Usage="System.Activator.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Typ do utworzenia.</typeparam>
        <summary>Tworzy wystąpienie typu wyznaczony przez parametr określonego typu ogólnego przy użyciu konstruktora bez parametrów.</summary>
        <returns>Odwołanie do nowo utworzonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Activator.CreateInstance%60%601> Metody ogólnej jest używany przez kompilatory do zaimplementowania podczas tworzenia wystąpienia typu określonego przez parametry typu. Na przykład w następujących metody ogólnej implementacji `new T()` (`gcnew T()` w języku C++) używa <xref:System.Activator.CreateInstance%60%601> metody rodzajowej.  
  
 [!code-cpp[System.Activation.CreateInstance~~1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cpp/remarks.cpp#1)]
 [!code-csharp[System.Activation.CreateInstance~~1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cs/remarks.cs#1)]
 [!code-vb[System.Activation.CreateInstance~~1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activation.createinstance~~1/vb/remarks.vb#1)]  
  
 Ogólnie rzecz biorąc, nie jest używana dla <xref:System.Activator.CreateInstance%60%601> kod metody ogólnej w aplikacji, ponieważ typ musi być znane w czasie kompilacji. Jeśli typ jest znany w czasie kompilacji, można używać składni normalnego wystąpienia (`new` operatora w języku C# `New` w języku Visual Basic `gcnew` w języku C++). Jeśli typ nie jest znany w czasie kompilacji, możesz wywołać przeciążenie metody nieogólnego <xref:System.Activator.CreateInstance%2A>.  
  
 Istnieją przeciążenia nie <xref:System.Activator.CreateInstance%60%601> metody rodzajowej, które umożliwiają wykorzystywanie listy argumentów, ponieważ przeciążenia niepodstawowy <xref:System.Activator.CreateInstance%2A> już zapewnić rozpoznawanie późnego wiązania konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MissingMethodException"><block subset="none" type="note">
            <para>  
 W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.MissingMemberException" />, a zamiast tego.  
  
</para>
          </block>  
  
 Typ, który jest określony dla <paramref name="T" /> nie ma konstruktora bez parametrów.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy wystąpienie tego typu, którego nazwa jest określona, przy użyciu pliku o nazwie zestawu i Konstruktor, który najlepiej pasuje do określonych parametrów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw gdzie typ o nazwie <paramref name="typeName" /> poszukiwane są.</param>
        <param name="typeName">Nazwa typu preferowany.</param>
        <summary>Tworzy wystąpienie tego typu, którego nazwa jest określona, za pomocą konstruktora nazwany zestaw plików i domyślne.</summary>
        <returns>Uchwyt, który musi być nieopakowane dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartość zwracaną.  
  
 Aby uzyskać informacje o innych wyjątków, które mogą zostać zgłoszone przez metody wywołane, zobacz sekcję wyjątki <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> i <xref:System.Activator.CreateInstance%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób wywołania <xref:System.Activator.CreateInstanceFrom%2A> metody. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Activator> klasy.  
  
 [!code-cpp[ActivatorX#3](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#3)]
 [!code-csharp[ActivatorX#3](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#3)]
 [!code-vb[ActivatorX#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktora, który został wywołany przez odbicie, zgłosiła wyjątek.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący ma wymagane <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowana, a <paramref name="assemblyName" /> została skompilowana dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowanych. Należy pamiętać, że .NET Framework w wersji 2.0, 3.0 i 3.5 używają wersji CLR 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać możliwość wyszukiwania ścieżek katalogów i przeczytać ich zawartość. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do typów niepublicznych, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (domain As AppDomain, assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="domain">Domena zdalna, gdzie typ o nazwie <paramref name="typeName" /> zostanie utworzony.</param>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw gdzie typ o nazwie <paramref name="typeName" /> poszukiwane są.</param>
        <param name="typeName">Nazwa typu preferowany.</param>
        <summary>Tworzy wystąpienie typu, którego nazwa jest określona w podanej domenie zdalnego za pomocą konstruktora nazwany zestaw plików i domyślne.</summary>
        <returns>Uchwyt, który musi być nieopakowane dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Activator.CreateInstanceFrom%2A> Jeśli jakiś host wymaga wykonania kodu w domenie aplikacji, które ma ograniczone uprawnienia zabezpieczeń.  
  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartość zwracaną.  
  
> [!NOTE]
>  Ta metoda używa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> wymagać bezpośredniego obiektu wywołującego do pełnego zaufania.  
  
 Aby uzyskać informacje o innych wyjątków, które mogą zostać zgłoszone przez metody wywołane, zobacz sekcję wyjątki <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> i <xref:System.Activator.CreateInstance%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="domain" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktora, który został wywołany przez odbicie, zgłosiła wyjątek.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący ma wymagane <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowana, a <paramref name="assemblyName" /> została skompilowana dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowanych. Należy pamiętać, że .NET Framework w wersji 2.0, 3.0 i 3.5 używają wersji CLR 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać możliwość wyszukiwania ścieżek katalogów i przeczytać ich zawartość. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw gdzie typ o nazwie <paramref name="typeName" /> poszukiwane są.</param>
        <param name="typeName">Nazwa typu preferowany.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie tego typu, którego nazwa jest określona, za pomocą konstruktora nazwany zestaw plików i domyślne.</summary>
        <returns>Uchwyt, który musi być nieopakowane dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartość zwracaną.  
  
 Aby uzyskać informacje o innych wyjątków, które mogą zostać zgłoszone przez metody wywołane, zobacz sekcję wyjątki <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> i <xref:System.Activator.CreateInstance%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktora, który został wywołany przez odbicie, zgłosiła wyjątek.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzonego nie pochodzi od <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący ma wymagane <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowana, a <paramref name="assemblyName" /> została skompilowana dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowanych. Należy pamiętać, że .NET Framework w wersji 2.0, 3.0 i 3.5 używają wersji CLR 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać możliwość wyszukiwania ścieżek katalogów i przeczytać ich zawartość. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do typów niepublicznych, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw gdzie typ o nazwie <paramref name="typeName" /> poszukiwane są.</param>
        <param name="typeName">Nazwa typu preferowany.</param>
        <param name="ignoreCase"><see langword="true" /> Aby określić, że wyszukiwanie <paramref name="typeName" /> nie jest rozróżniana wielkość liter; <see langword="false" /> do określenia, czy w wyszukiwaniu jest uwzględniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja flag bitowych zero lub więcej, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest zero, wyszukiwanie jest przeprowadzane przez konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który używa <paramref name="bindingAttr" /> i <paramref name="args" /> aby wyszukać i zidentyfikować <paramref name="typeName" /> konstruktora. Jeśli <paramref name="binder" /> jest <see langword="null" />, jest używany domyślny integrator.</param>
        <param name="args">Tablica argumentów, które są zgodne w liczby, kolejności i typów parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest pusta tablica lub <see langword="null" />, Konstruktor, który nie przyjmuje żadnych parametrów (Konstruktor domyślny) jest wywoływana.</param>
        <param name="culture">Informacje specyficzne dla kultury, które regulują Wymuszanie <paramref name="args" /> do formalnych typów zadeklarowane dla <paramref name="typeName" /> konstruktora. Jeśli <paramref name="culture" /> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> dla bieżącego wątku jest używana.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie tego typu, którego nazwa jest określona, przy użyciu pliku o nazwie zestawu i Konstruktor, który najlepiej pasuje do określonych parametrów.</summary>
        <returns>Uchwyt, który musi być nieopakowane dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartość zwracaną.  
  
 Aby uzyskać informacje o innych wyjątków, które mogą zostać zgłoszone przez metody wywołane, zobacz sekcję wyjątki <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> i <xref:System.Activator.CreateInstance%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktora, który został wywołany przez odbicie, zgłosiła wyjątek.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzonego nie pochodzi od <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowana, a <paramref name="assemblyName" /> została skompilowana dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowanych. Należy pamiętać, że .NET Framework w wersji 2.0, 3.0 i 3.5 używają wersji CLR 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać możliwość wyszukiwania ścieżek katalogów i przeczytać ich zawartość. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do niepublicznych typy i elementy członkowskie, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="domain">Domena zdalna, gdzie typ o nazwie <paramref name="typeName" /> zostanie utworzony.</param>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw gdzie typ o nazwie <paramref name="typeName" /> poszukiwane są.</param>
        <param name="typeName">Nazwa typu preferowany.</param>
        <param name="ignoreCase"><see langword="true" /> Aby określić, że wyszukiwanie <paramref name="typeName" /> nie jest rozróżniana wielkość liter; <see langword="false" /> do określenia, czy w wyszukiwaniu jest uwzględniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja flag bitowych zero lub więcej, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest zero, wyszukiwanie jest przeprowadzane przez konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który używa <paramref name="bindingAttr" /> i <paramref name="args" /> aby wyszukać i zidentyfikować <paramref name="typeName" /> konstruktora. Jeśli <paramref name="binder" /> jest <see langword="null" />, jest używany domyślny integrator.</param>
        <param name="args">Tablica argumentów, które są zgodne w liczby, kolejności i typów parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest pusta tablica lub <see langword="null" />, Konstruktor, który nie przyjmuje żadnych parametrów (Konstruktor domyślny) jest wywoływana.</param>
        <param name="culture">Informacje specyficzne dla kultury, które regulują Wymuszanie <paramref name="args" /> do formalnych typów zadeklarowane dla <paramref name="typeName" /> konstruktora. Jeśli <paramref name="culture" /> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> dla bieżącego wątku jest używana.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie typu, którego nazwa jest określona w podanej domenie zdalnego przy użyciu pliku o nazwie zestawu i Konstruktor, który najlepiej pasuje do określonych parametrów.</summary>
        <returns>Uchwyt, który musi być nieopakowane dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Activator.CreateInstanceFrom%2A> Jeśli jakiś host wymaga wykonania kodu w domenie aplikacji, które ma ograniczone uprawnienia zabezpieczeń.  
  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartość zwracaną.  
  
 Aby uzyskać informacje o innych wyjątków, które mogą zostać zgłoszone przez metody wywołane, zobacz sekcje wyjątki <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> i <xref:System.Activator.CreateInstance%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="domain" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktora, który został wywołany przez odbicie, zgłosiła wyjątek.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący ma wymagane <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzonego nie pochodzi od <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="assemblyName" /> został skompilowany dla wersji środowiska CLR, która jest nowsza niż wersja, która jest aktualnie załadowana.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla podanie dowodów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać możliwość wyszukiwania ścieżek katalogów i przeczytać ich zawartość. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do niepublicznych typy i elementy członkowskie, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw gdzie typ o nazwie <paramref name="typeName" /> poszukiwane są.</param>
        <param name="typeName">Nazwa typu preferowany.</param>
        <param name="ignoreCase"><see langword="true" /> Aby określić, że wyszukiwanie <paramref name="typeName" /> nie jest rozróżniana wielkość liter; <see langword="false" /> do określenia, czy w wyszukiwaniu jest uwzględniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja flag bitowych zero lub więcej, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest zero, wyszukiwanie jest przeprowadzane przez konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który używa <paramref name="bindingAttr" /> i <paramref name="args" /> aby wyszukać i zidentyfikować <paramref name="typeName" /> konstruktora. Jeśli <paramref name="binder" /> jest <see langword="null" />, jest używany domyślny integrator.</param>
        <param name="args">Tablica argumentów, które są zgodne w liczby, kolejności i typów parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest pusta tablica lub <see langword="null" />, Konstruktor, który nie przyjmuje żadnych parametrów (Konstruktor domyślny) jest wywoływana.</param>
        <param name="culture">Informacje specyficzne dla kultury, które regulują Wymuszanie <paramref name="args" /> do formalnych typów zadeklarowane dla <paramref name="typeName" /> konstruktora. Jeśli <paramref name="culture" /> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> dla bieżącego wątku jest używana.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <param name="securityInfo">Informacje używane do decyzje zasad zabezpieczeń i przyznawanie uprawnień kodu.</param>
        <summary>Tworzy wystąpienie tego typu, którego nazwa jest określona, przy użyciu pliku o nazwie zestawu i Konstruktor, który najlepiej pasuje do określonych parametrów.</summary>
        <returns>Uchwyt, który musi być nieopakowane dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartość zwracaną.  
  
 Aby uzyskać informacje o innych wyjątków, które mogą zostać zgłoszone przez metody wywołane, zobacz sekcję wyjątki <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> i <xref:System.Activator.CreateInstance%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktora, który został wywołany przez odbicie, zgłosiła wyjątek.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzonego nie pochodzi od <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowana, a <paramref name="assemblyName" /> została skompilowana dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowanych. Należy pamiętać, że .NET Framework w wersji 2.0, 3.0 i 3.5 używają wersji CLR 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać możliwość wyszukiwania ścieżek katalogów i przeczytać ich zawartość. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do niepublicznych typy i elementy członkowskie, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use Evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="domain">Domena zdalna, gdzie typ o nazwie <paramref name="typeName" /> zostanie utworzony.</param>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw gdzie typ o nazwie <paramref name="typeName" /> poszukiwane są.</param>
        <param name="typeName">Nazwa typu preferowany.</param>
        <param name="ignoreCase"><see langword="true" /> Aby określić, że wyszukiwanie <paramref name="typeName" /> nie jest rozróżniana wielkość liter; <see langword="false" /> do określenia, czy w wyszukiwaniu jest uwzględniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja flag bitowych zero lub więcej, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest zero, wyszukiwanie jest przeprowadzane przez konstruktorów publicznych.</param>
        <param name="binder">Obiekt, który używa <paramref name="bindingAttr" /> i <paramref name="args" /> aby wyszukać i zidentyfikować <paramref name="typeName" /> konstruktora. Jeśli <paramref name="binder" /> jest <see langword="null" />, jest używany domyślny integrator.</param>
        <param name="args">Tablica argumentów, które są zgodne w liczby, kolejności i typów parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest pusta tablica lub <see langword="null" />, Konstruktor, który nie przyjmuje żadnych parametrów (Konstruktor domyślny) jest wywoływana.</param>
        <param name="culture">Informacje specyficzne dla kultury, które regulują Wymuszanie <paramref name="args" /> do formalnych typów zadeklarowane dla <paramref name="typeName" /> konstruktora. Jeśli <paramref name="culture" /> jest <see langword="null" />, <see cref="T:System.Globalization.CultureInfo" /> dla bieżącego wątku jest używana.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Zazwyczaj jest to tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiektu, który określa adres URL, który jest wymagany do aktywacji obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektów aktywacji klienta. Aktywacja klienta jest technologią starszą, która została zachowana na potrzeby zgodności z poprzednimi wersjami, ale nie jest zalecane w przypadku nowych wdrożeń. Aplikacje rozproszone zamiast tego należy używać programu Windows Communication Foundation.</param>
        <param name="securityAttributes">Informacje używane do decyzje zasad zabezpieczeń i przyznawanie uprawnień kodu.</param>
        <summary>Tworzy wystąpienie typu, którego nazwa jest określona w podanej domenie zdalnego przy użyciu pliku o nazwie zestawu i Konstruktor, który najlepiej pasuje do określonych parametrów.</summary>
        <returns>Uchwyt, który musi być nieopakowane dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Activator.CreateInstanceFrom%2A> Jeśli jakiś host wymaga wykonania kodu w domenie aplikacji, które ma ograniczone uprawnienia zabezpieczeń.  
  
 Użyj <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> metody do odkodowania wartość zwracaną.  
  
> [!NOTE]
>  Ta metoda używa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> wymagać bezpośredniego obiektu wywołującego do pełnego zaufania.  
  
 Aby uzyskać informacje o innych wyjątków, które mogą zostać zgłoszone przez metody wywołane, zobacz sekcję wyjątki <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> i <xref:System.Activator.CreateInstance%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="domain" /> lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" /> Nie znaleziono w <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej, lub ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktora, który został wywołany przez odbicie, zgłosiła wyjątek.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący ma wymagane <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="activationAttributes" /> nie jest pusta tablica, a typ tworzonego nie pochodzi od <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2.0 lub nowszej jest aktualnie załadowana, a <paramref name="assemblyName" /> została skompilowana dla wersji środowiska CLR, która jest nowsza niż wersja aktualnie załadowanych. Należy pamiętać, że .NET Framework w wersji 2.0, 3.0 i 3.5 używają wersji CLR 2.0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla podanie dowodów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać możliwość wyszukiwania ścieżek katalogów i przeczytać ich zawartość. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Aby uzyskać dostęp do niepublicznych typy i elementy członkowskie, niezależnie od ich zestawu uprawnień. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy serwer proxy dla obiektu dobrze znanego lub usługi sieci Web XML.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member GetObject : Type * string -&gt; obj" Usage="System.Activator.GetObject (type, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Typ obiektu dobrze znanego, do którego chcesz się połączyć.</param>
        <param name="url">Adres URL dobrze znane obiekty.</param>
        <summary>Tworzy serwer proxy dla obiektu dobrze znanego, wskazywanym przez określonego typu i adres URL.</summary>
        <returns>Serwer proxy, który wskazuje na obsługiwany przez żądany obiekt dobrze znanego punktu końcowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie serwera proxy, aby wysyłać komunikaty do obiektu zdalnego. Nie komunikaty są wysyłane za pośrednictwem sieci, dopóki metoda jest wywoływana na serwerze proxy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> lub <paramref name="url" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="type" /> nie jest przekazywany przez odwołanie i nie jest interfejsem.</exception>
        <exception cref="T:System.MemberAccessException">Ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member GetObject : Type * string * obj -&gt; obj" Usage="System.Activator.GetObject (type, url, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="type">Typ obiektu dobrze znanego, do którego chcesz się połączyć.</param>
        <param name="url">Adres URL dobrze znane obiekty.</param>
        <param name="state">Dane specyficzne dla kanału lub <see langword="null" />.</param>
        <summary>Tworzy serwer proxy dla obiektu dobrze znanego, wskazywanym przez określonego typu, adres URL i kanału danych.</summary>
        <returns>Serwer proxy, który wskazuje na obsługiwany przez żądany obiekt dobrze znanego punktu końcowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie serwera proxy, aby wysyłać komunikaty do obiektu zdalnego. Nie komunikaty są wysyłane za pośrednictwem sieci, dopóki metoda jest wywoływana na serwerze proxy.  
  
 `state` Parametr przekazuje informacje do kanału i jest przekazywany do <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> lub <paramref name="url" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="type" /> nie jest przekazywany przez odwołanie i nie jest interfejsem.</exception>
        <exception cref="T:System.MemberAccessException">Ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Activator.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Activator.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Activator::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="rgszNames">Przekazana tablica nazw do mapowania.</param>
        <param name="cNames">Liczba nazw do mapowania.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</param>
        <param name="rgDispId">Tablica przydzielana przez obiekt wywołujący, który otrzymuje numery identyfikacyjne odpowiadających nazw.</param>
        <summary>Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetIDsOfNames`, zobacz: Biblioteka MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Activator.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informacje o typie, który będzie zwracany.</param>
        <param name="lcid">Identyfikator regionalny dla informacji o typie.</param>
        <param name="ppTInfo">Obiekt, który otrzymuje wskaźnik do obiektu informacji żądanego typu.</param>
        <summary>Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfo`, zobacz: Biblioteka MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Activator.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Po powrocie z tej metody zawiera wskaźnik do lokalizacji, która odbiera numer typu informacji dostarczanych przez obiekt. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::GetTypeInfoCount`, zobacz: Biblioteka MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.Invoke">
      <MemberSignature Language="C#" Value="void _Activator.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Activator.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Activator::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identyfikator wysyłania, która identyfikuje element członkowski.</param>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</param>
        <param name="wFlags">Flagi opisujące kontekst wywołania.</param>
        <param name="pDispParams">Wskaźnik do struktury, która zawiera tablicę argumentów, tablicę identyfikatorów DISPID argumentu dla nazwanych argumentów i zlicza liczbę elementów w tablicach.</param>
        <param name="pVarResult">Wskaźnik do lokalizacji, w którym ma być przechowywany wynik.</param>
        <param name="pExcepInfo">Wskaźnik do struktury, która zawiera informacje o wyjątku.</param>
        <param name="puArgErr">Indeks pierwszego argumentu, który zawiera błąd.</param>
        <summary>Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia dostęp do klas zarządzanych z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Aby uzyskać więcej informacji na temat `IDispatch::Invoke`, zobacz: Biblioteka MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu COM <c>IDispatch</c> interfejs nie jest obsługiwany.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
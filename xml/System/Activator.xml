<Type Name="Activator" FullName="System.Activator">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8a3eb47b62fb7e8bcfcbecfed18ceb733f15be7b" /><Meta Name="ms.sourcegitcommit" Value="e7974886b08aa83a8fb461e8550f31a7d4331ee3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/23/2019" /><Meta Name="ms.locfileid" Value="68398397" /></Metadata><TypeSignature Language="C#" Value="public sealed class Activator : System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Activator extends System.Object implements class System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="DocId" Value="T:System.Activator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Activator&#xA;Implements _Activator" />
  <TypeSignature Language="C++ CLI" Value="public ref class Activator sealed : System::Runtime::InteropServices::_Activator" />
  <TypeSignature Language="F#" Value="type Activator = class&#xA;    interface _Activator" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Activator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Activator))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zawiera metody do lokalnego lub zdalnego tworzenia typów obiektów lub uzyskiwania odwołań do istniejących obiektów zdalnych. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Activator.CreateInstance%2A> Metoda tworzy wystąpienie typu zdefiniowanego w zestawie przez wywoływanie konstruktora, który najlepiej pasuje do określonych argumentów. Jeśli nie określono argumentów, Konstruktor, który nie przyjmuje parametrów, czyli Konstruktor bez parametrów, jest wywoływany.  
  
 Musisz mieć wystarczające uprawnienia do wyszukiwania i wywoływania konstruktora; w przeciwnym razie jest zgłaszany wyjątek. Domyślnie tylko konstruktory publiczne są brane pod uwagę podczas wyszukiwania konstruktora. Jeśli nie można znaleźć konstruktora ani konstruktora bez parametrów, zgłaszany jest wyjątek.  
  
 Parametr spinacza określa obiekt, który przeszukuje zestaw dla odpowiedniego konstruktora. Możesz określić własny spinacz i kryteria wyszukiwania. Jeśli nie zostanie określony spinacz, używany jest domyślny spinacz. Aby uzyskać więcej informacji, zobacz <xref:System.Reflection.Binder?displayProperty=nameWithType> klasy <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> i.  
  
 Parametr dowodu ma wpływ na zasady zabezpieczeń i uprawnienia konstruktora. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Policy.Evidence?displayProperty=nameWithType> Klasa.  
  
 Wystąpienie typu można utworzyć w lokacji lokalnej lub zdalnej. Jeśli typ zostanie utworzony zdalnie, parametr atrybutu aktywacji określa identyfikator URI witryny zdalnej. Wywołanie tworzenia wystąpienia może przechodzić przez lokacje pośredniczące przed przystąpieniem do lokacji zdalnej. Inne atrybuty aktywacji mogą modyfikować środowisko lub kontekst, w którym wywołanie działa w lokacjach zdalnych i pośrednich.  
  
 Jeśli wystąpienie jest tworzone lokalnie, zwracane jest odwołanie do tego obiektu. Jeśli wystąpienie jest tworzone zdalnie, zwracane jest odwołanie do serwera proxy. Obiekt zdalny jest manipulowany przez serwer proxy tak, jakby był obiektem lokalnym.  
  
 <xref:System.Activator.GetObject%2A> Metoda tworzy serwer proxy do aktualnie uruchomionego obiektu zdalnego, dobrze znanego obiektu lub usługi sieci Web XML. Możesz określić nośnik połączenia, czyli kanał. Aby uzyskać więcej informacji, zobacz <xref:System.Runtime.Remoting.Channels.ChannelServices?displayProperty=nameWithType> Klasa.  
  
 Zestawy zawierają definicje typów. <xref:System.Activator.CreateInstance%2A> Metoda tworzy wystąpienie typu z aktualnie działającego zestawu. <xref:System.Activator.CreateInstanceFrom%2A> Metoda tworzy wystąpienie z pliku, który zawiera zestaw. <xref:System.Activator.CreateComInstanceFrom%2A> Metoda tworzy wystąpienie obiektu com z pliku, który zawiera zestaw.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Activator> jak używać klasy do dynamicznego konstruowania obiektów w czasie wykonywania.  
  
 [!code-cpp[ActivatorX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#1)]
 [!code-csharp[ActivatorX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#1)]
 [!code-vb[ActivatorX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy wystąpienie obiektu COM, którego nazwa jest określona.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa pliku, który zawiera zestaw, do którego poszukuje się typ o <paramref name="typeName" /> nazwie.</param>
        <param name="typeName">Nazwa preferowanego typu.</param>
        <summary>Tworzy wystąpienie obiektu COM, którego nazwa jest określona, przy użyciu nazwanego pliku zestawu i konstruktora bez parametrów.</summary>
        <returns>Dojście, które musi zostać rozpakowane, aby uzyskać dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Użyj metody, aby rozwinąć wartość zwracaną.  
  
 Atrybut o <xref:System.Activator.CreateComInstanceFrom%2A> wartości musi być stosowany jawnie lub domyślnie do typu com, aby Metoda mogła utworzyć wystąpienie tego typu; w przeciwnym razie <xref:System.TypeLoadException> jest zgłaszane. `true` <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>  
  
 Aby uzyskać informacje o innych wyjątkach, które mogą być zgłaszane przez wywoływanych metod, zobacz sekcję <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> wyjątki <xref:System.Activator.CreateInstance%2A> metod i.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może służyć do tworzenia typów niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw uprawnień zestawu, który zawiera typy niepubliczne, jest ograniczony do przydzielenia przez wywołującego [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Ustaw lub do podzbioru. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />lub <paramref name="assemblyName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Nie można utworzyć wystąpienia za poorednictwem modelu COM.  
  
—lub— 
 <paramref name="typename" />nie została znaleziona <paramref name="assemblyName" />w.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie została znaleziona lub moduł, który próbujesz załadować, nie określa rozszerzenia nazwy pliku.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej.  
  
 —lub—  
  
 Ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może udostępnić atrybutów aktywacji dla obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />po elemencie.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyName" />jest ciągiem pustym ("").</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">do uzyskiwania dostępu do typów niepublicznych niezależnie od ich zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateComInstanceFrom (assemblyName, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa pliku, który zawiera zestaw, do którego poszukuje się typ o <paramref name="typeName" /> nazwie.</param>
        <param name="typeName">Nazwa preferowanego typu.</param>
        <param name="hashValue">Wartość obliczonego kodu skrótu.</param>
        <param name="hashAlgorithm">Algorytm wyznaczania wartości skrótu używany do tworzenia skrótów plików i generowania silnej nazwy.</param>
        <summary>Tworzy wystąpienie obiektu COM, którego nazwa jest określona, przy użyciu nazwanego pliku zestawu i konstruktora bez parametrów.</summary>
        <returns>Dojście, które musi zostać rozpakowane, aby uzyskać dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Użyj metody, aby rozwinąć wartość zwracaną.  
  
 Atrybut o <xref:System.Activator.CreateComInstanceFrom%2A> wartości musi być stosowany jawnie lub domyślnie do typu com, aby Metoda mogła utworzyć wystąpienie tego typu; w przeciwnym razie <xref:System.TypeLoadException> jest zgłaszane. `true` <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>  
  
 Aby uzyskać informacje o innych wyjątkach, które mogą być zgłaszane przez wywoływanych metod, zobacz sekcję <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> wyjątki <xref:System.Activator.CreateInstance%2A> metod i.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może służyć do tworzenia typów niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw uprawnień zestawu, który zawiera typy niepubliczne, jest ograniczony do przydzielenia przez wywołującego [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Ustaw lub do podzbioru. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />lub <paramref name="assemblyName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyName" />jest ciągiem pustym ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.
        
—lub— 
 <paramref name="assemblyName" />jest dłuższa niż zdefiniowana w systemie długość maksymalna.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie została znaleziona lub moduł, który próbujesz załadować, nie określa rozszerzenia nazwy pliku.</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="assemblyName" />został znaleziony, ale nie można go załadować.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" />nie jest prawidłowym zestawem.</exception>
        <exception cref="T:System.Security.SecurityException">Baza kodu, która nie zaczyna się od "file://", została określona bez wymogu <see langword="WebPermission" />.</exception>
        <exception cref="T:System.TypeLoadException">Nie można utworzyć wystąpienia za poorednictwem modelu COM.  
  
—lub— 
 <paramref name="typename" />nie została znaleziona <paramref name="assemblyName" />w.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej.  
  
 —lub—  
  
 Ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.NotSupportedException">Obiekt wywołujący nie może udostępnić atrybutów aktywacji dla obiektu, który nie dziedziczy <see cref="T:System.MarshalByRefObject" />po elemencie.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">do uzyskiwania dostępu do typów niepublicznych niezależnie od ich zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania identyfikatora URI rozpoczynającego się od ciągu "file://". Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy wystąpienie określonego typu przy użyciu konstruktora, który najlepiej pasuje do określonych parametrów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : ActivationContext -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance activationContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8" />
      </Parameters>
      <Docs>
        <param name="activationContext">Obiekt kontekstu aktywacji, który określa obiekt do utworzenia.</param>
        <summary>Tworzy wystąpienie typu wyznaczony przez określony <see cref="T:System.ActivationContext" /> obiekt.</summary>
        <returns>Dojście, które musi zostać rozpakowane, aby uzyskać dostęp do nowo utworzonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Użyj metody, aby rozwinąć wartość zwracaną.  
  
 Kontekst aktywacji jest używany podczas aktywacji przy użyciu manifestu w celu skonfigurowania zasad domeny i zapewnienia modelu zabezpieczeń opartego na aplikacji. <xref:System.ActivationContext> Klasa<xref:System.ApplicationIdentity> zawiera obiekt, który zapewnia dostęp do manifestu aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Policy.ApplicationSecurityManager> Klasa.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type -&gt; obj" Usage="System.Activator.CreateInstance type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Typ obiektu do utworzenia.</param>
        <summary>Tworzy wystąpienie określonego typu za pomocą konstruktora bez parametrów tego typu.</summary>
        <returns>Odwołanie do nowo utworzonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor, który ma zostać wywołany, musi być dostępny.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana do uzyskiwania dostępu do typów niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw uprawnień zestawu, który zawiera typy niepubliczne, jest ograniczony do przydzielenia obiektu wywołującego [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Ustaw lub do podzbioru. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób wywołania <xref:System.Activator.CreateInstance%28System.Type%29> metody. Tworzone są wystąpienia kilku różnych typów i są wyświetlane ich wartości domyślne.  
  
 [!code-cpp[ActivatorX#4](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/source2.cpp#4)]
 [!code-csharp[ActivatorX#4](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/source2.cs#4)]
 [!code-vb[ActivatorX#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/source2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" />nie <see langword="RuntimeType" />jest.  
  
—lub— 
 <paramref name="type" />jest otwartym typem ogólnym (oznacza to, <see cref="P:System.Type.ContainsGenericParameters" /> że właściwość <see langword="true" />zwraca).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="type" />nie może być <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
—lub— 
<see cref="T:System.ArgIterator" />Tworzenie typów <see cref="T:System.TypedReference" />, ,<see cref="T:System.Void" />, i<see cref="T:System.RuntimeArgumentHandle" /> lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
Zestaw, który zawiera <paramref name="type" /> , jest zestawem dynamicznym, który <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />został utworzony przy użyciu.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Wywoływany Konstruktor zgłasza wyjątek.</exception>
        <exception cref="T:System.MethodAccessException"><block subset="none" type="note">
            <para>  
 W programie <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET dla aplikacji ze sklepu Windows</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">przenośnej biblioteki klas</see>Przechwyć wyjątek <see cref="T:System.MemberAccessException" />klasy bazowej, zamiast tego.  
  
</para>
          </block>  
  
 Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej lub ten element członkowski został wywołany przy użyciu mechanizmu późnego wiązania.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ com nie został uzyskany za <see cref="Overload:System.Type.GetTypeFromProgID" /> pomocą <see cref="Overload:System.Type.GetTypeFromCLSID" />lub.</exception>
        <exception cref="T:System.MissingMethodException"><block subset="none" type="note">
            <para>  
 W programie <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET dla aplikacji ze sklepu Windows</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">przenośnej biblioteki klas</see>Przechwyć wyjątek <see cref="T:System.MissingMemberException" />klasy bazowej, zamiast tego.  
  
</para>
          </block>  
  
 Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="type" />jest obiektem COM, ale identyfikator klasy używany do uzyskania typu jest nieprawidłowy lub zidentyfikowana Klasa nie jest zarejestrowana.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="type" />nie jest prawidłowym typem.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">do uzyskiwania dostępu do typów niepublicznych niezależnie od ich zestawów uprawnień. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext, string[] activationCustomData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext, string[] activationCustomData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext, cli::array &lt;System::String ^&gt; ^ activationCustomData);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : ActivationContext * string[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (activationContext, activationCustomData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8" />
        <Parameter Name="activationCustomData" Type="System.String[]" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8" />
      </Parameters>
      <Docs>
        <param name="activationContext">Obiekt kontekstu aktywacji, który określa obiekt do utworzenia.</param>
        <param name="activationCustomData">Tablica ciągów Unicode, które zawierają dane aktywacji niestandardowej.</param>
        <summary>Tworzy wystąpienie typu, który jest wyznaczony przez określony <see cref="T:System.ActivationContext" /> obiekt i aktywowany przy użyciu określonych danych aktywacji niestandardowej.</summary>
        <returns>Dojście, które musi zostać rozpakowane, aby uzyskać dostęp do nowo utworzonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Użyj metody, aby rozwinąć wartość zwracaną.  
  
 Kontekst aktywacji jest używany podczas aktywacji przy użyciu manifestu w celu skonfigurowania zasad domeny i zapewnienia modelu zabezpieczeń opartego na aplikacji. <xref:System.ActivationContext> Klasa<xref:System.ApplicationIdentity> zawiera obiekt, który zapewnia dostęp do manifestu aplikacji. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Policy.ApplicationSecurityManager> Klasa.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa zestawu, do którego jest poszukiwany <paramref name="typeName" /> typ o nazwie. Jeśli <paramref name="assemblyName" /> jest<see langword="null" />, przeszukiwany jest zestaw wykonywany.</param>
        <param name="typeName">W pełni kwalifikowana nazwa preferowanego typu.</param>
        <summary>Tworzy wystąpienie typu, którego nazwa jest określona, przy użyciu nazwanego zestawu i konstruktora bez parametrów.</summary>
        <returns>Dojście, które musi zostać rozpakowane, aby uzyskać dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Służy <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> do odpakowania wartości zwracanej.  
  
 `assemblyName`może być jedną z następujących wartości:  
  
-   Prosta nazwa zestawu, bez jego ścieżki lub rozszerzenia pliku. Na przykład należy określić `TypeExtensions` dla zestawu, którego ścieżką i nazwą jest .\bin\TypeExtensions.dll.  
  
-   Pełna nazwa podpisanego zestawu, która składa się z jego prostej nazwy, wersji, kultury i tokenu klucza publicznego; na przykład "TypeExtensions, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = 181869f2f7435b51".  
  
 Aby uzyskać więcej informacji na temat identyfikowania i ładowania zestawów przez środowisko uruchomieniowe języka wspólnego, zobacz [jak środowisko uruchomieniowe lokalizuje zestawy](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md). Aby uzyskać informacje na temat używania pliku konfiguracji aplikacji do definiowania lokalizacji zestawów, zobacz [Określanie lokalizacji zestawu](~/docs/framework/configure-apps/specify-assembly-location.md). Jeśli `assemblyName` zostanie znaleziony, jest ładowany w kontekście domyślnym.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może służyć do tworzenia typów niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw uprawnień zestawu, który zawiera typy niepubliczne, jest ograniczony do przydzielenia przez wywołującego [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Ustaw lub do podzbioru. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano klasę o `Person` nazwie w zestawie o `PersonInfo`nazwie. Należy zauważyć, `Person` że Klasa ma dwa konstruktory, z których jeden jest bez parametrów.  
  
 [!code-csharp[System.Activator.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/personinfo.cs#1)]
 [!code-vb[System.Activator.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/personinfo.vb#1)]  
  
 Poniższy przykład wywołuje <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29> metodę w celu `Person` utworzenia wystąpienia klasy. Wymaga odwołania do PersonInfo. dll, aby można było dodać do projektu. Ponieważ metoda wywołuje Konstruktor bez parametrów `Name` klasy,przykładprzypisujewartośćdojejwłaściwości.`Person` <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29>  
  
 [!code-csharp[System.Activator.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1.cs#2)]
 [!code-vb[System.Activator.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1.vb#2)]  
  
 <xref:System.Activator.CreateInstance%2A> Jednak jest często wywoływana w celu utworzenia wystąpienia typu, który przecina granice maszyny lub nie jest znany w czasie projektowania. W tym przypadku nie można uwzględnić odwołania do zestawu w projekcie i nie może wprowadzać wczesnych wywołań do elementów członkowskich typu. Aby obejść to ograniczenie, w poniższym przykładzie zastosowano <xref:System.Activator.CreateInstance%2A> metodę wraz z odbiciem, aby przypisać wartość `Person` do `Name` właściwości obiektu i wyświetlić jej wartość.  
  
 [!code-csharp[System.Activator.CreateInstance#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1a.cs#3)]
 [!code-vb[System.Activator.CreateInstance#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1a.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyName" />w.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej lub ten element członkowski został wywołany za pomocą mechanizmu późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, który został wywołany przez odbicie, wywołał wyjątek.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ com nie został uzyskany za <see cref="Overload:System.Type.GetTypeFromProgID" /> pomocą <see cref="Overload:System.Type.GetTypeFromCLSID" />lub.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.ArgIterator" />Tworzenie typów <see cref="T:System.TypedReference" />, ,<see cref="T:System.Void" />, i<see cref="T:System.RuntimeArgumentHandle" /> lub tablic tych typów nie jest obsługiwane.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" />nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2,0 lub nowszej jest obecnie załadowane i <paramref name="assemblyName" /> zostało skompilowane dla wersji środowiska CLR, która jest nowsza niż aktualnie załadowana wersja. Należy zauważyć, że .NET Framework wersje 2,0, 3,0 i 3,5 używają środowiska CLR w wersji 2,0.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.  
  
 —lub—  
  
 Nazwa zestawu lub baza kodu jest nieprawidłowa.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">do uzyskiwania dostępu do typów niepublicznych niezależnie od ich zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, bool nonPublic);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * bool -&gt; obj" Usage="System.Activator.CreateInstance (type, nonPublic)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="nonPublic" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Typ obiektu do utworzenia.</param>
        <param name="nonPublic"><see langword="true" />Jeśli publiczny lub niepubliczny konstruktor bez parametrów może być zgodny; <see langword="false" /> jeśli tylko publiczny Konstruktor bez parametrów może być zgodny.</param>
        <summary>Tworzy wystąpienie określonego typu za pomocą konstruktora bez parametrów tego typu.</summary>
        <returns>Odwołanie do nowo utworzonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana do uzyskiwania dostępu do typów niepublicznych i członków, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw uprawnień zestawu, który zawiera typy niepubliczne i składowe, jest ograniczony [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] do przydzielenia obiektu wywołującego lub jego podzbioru. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" />nie <see langword="RuntimeType" />jest.  
  
—lub— 
 <paramref name="type" />jest otwartym typem ogólnym (oznacza to, <see cref="P:System.Type.ContainsGenericParameters" /> że właściwość <see langword="true" />zwraca).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="type" />nie może być <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
—lub— 
<see cref="T:System.ArgIterator" />Tworzenie typów <see cref="T:System.TypedReference" />, ,<see cref="T:System.Void" />, i<see cref="T:System.RuntimeArgumentHandle" /> lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
Zestaw, który zawiera <paramref name="type" /> , jest zestawem dynamicznym, który <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />został utworzony przy użyciu.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Wywoływany Konstruktor zgłasza wyjątek.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej lub ten element członkowski został wywołany przy użyciu mechanizmu późnego wiązania.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ com nie został uzyskany za <see cref="Overload:System.Type.GetTypeFromProgID" /> pomocą <see cref="Overload:System.Type.GetTypeFromCLSID" />lub.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="type" />jest obiektem COM, ale identyfikator klasy używany do uzyskania typu jest nieprawidłowy lub zidentyfikowana Klasa nie jest zarejestrowana.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="type" />nie jest prawidłowym typem.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">do uzyskiwania dostępu do niepublicznych typów i członków, niezależnie od ich zestawu dotacji. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Typ obiektu do utworzenia.</param>
        <param name="args">Tablica argumentów, które pasują do wartości Number, Order i Type parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest tablicą pustą <see langword="null" />lub, Konstruktor, który nie pobiera parametrów (Konstruktor bez parametrów) jest wywoływany.</param>
        <summary>Tworzy wystąpienie określonego typu przy użyciu konstruktora, który najlepiej pasuje do określonych parametrów.</summary>
        <returns>Odwołanie do nowo utworzonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor, który ma zostać wywołany, musi być dostępny i musi zawierać najbardziej szczegółowe dopasowanie z określoną listą argumentów.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana do uzyskiwania dostępu do typów niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw uprawnień zestawu, który zawiera typy niepubliczne, jest ograniczony do przydzielenia obiektu wywołującego [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Ustaw lub do podzbioru. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
   
  
## Examples  
 Poniższy przykład wywołuje metodę, <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> aby <xref:System.String> utworzyć obiekt. Wywołuje <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> konstruktora, aby utworzyć wystąpienie ciągu, który zawiera dziesięć elementów z tablicy znaków, zaczynając od pozycji czternastej.  
  
 [!code-csharp[System.Activator.CreateInstance#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/CreateInstance5.cs#5)]
 [!code-vb[System.Activator.CreateInstance#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/CreateInstance5.vb#5)]  
  
 Poniższy przykład tworzy tablicę nieregularną, której elementy są argumentami, które mają <xref:System.String> być przekazane do konstruktora. Następnie przykład przekazuje każdą tablicę <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> do metody, aby wywołać odpowiedni Konstruktor ciągu.  
  
 [!code-csharp[System.Activator.CreateInstance#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstance2.cs#4)]
 [!code-vb[System.Activator.CreateInstance#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstance2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" />nie <see langword="RuntimeType" />jest.  
  
—lub— 
 <paramref name="type" />jest otwartym typem ogólnym (oznacza to, <see cref="P:System.Type.ContainsGenericParameters" /> że właściwość <see langword="true" />zwraca).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="type" />nie może być <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
—lub— 
<see cref="T:System.ArgIterator" />Tworzenie typów <see cref="T:System.TypedReference" />, ,<see cref="T:System.Void" />, i<see cref="T:System.RuntimeArgumentHandle" /> lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
Zestaw, który zawiera <paramref name="type" /> , jest zestawem dynamicznym, który <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />został utworzony przy użyciu.  
  
—lub— 
Konstruktor, który najlepiej pasuje <paramref name="args" /> , <see langword="varargs" /> ma argumenty.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Wywoływany Konstruktor zgłasza wyjątek.</exception>
        <exception cref="T:System.MethodAccessException"><block subset="none" type="note">
            <para>  
 W programie <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET dla aplikacji ze sklepu Windows</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">przenośnej biblioteki klas</see>Przechwyć wyjątek <see cref="T:System.MemberAccessException" />klasy bazowej, zamiast tego.  
  
</para>
          </block>  
  
 Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej lub ten element członkowski został wywołany przy użyciu mechanizmu późnego wiązania.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ com nie został uzyskany za <see cref="Overload:System.Type.GetTypeFromProgID" /> pomocą <see cref="Overload:System.Type.GetTypeFromCLSID" />lub.</exception>
        <exception cref="T:System.MissingMethodException"><block subset="none" type="note">
            <para>  
 W programie <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET dla aplikacji ze sklepu Windows</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">przenośnej biblioteki klas</see>Przechwyć wyjątek <see cref="T:System.MissingMemberException" />klasy bazowej, zamiast tego.  
  
</para>
          </block>  
  
 Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="type" />jest obiektem COM, ale identyfikator klasy używany do uzyskania typu jest nieprawidłowy lub zidentyfikowana Klasa nie jest zarejestrowana.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="type" />nie jest prawidłowym typem.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">do uzyskiwania dostępu do typów niepublicznych niezależnie od ich zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (domain As AppDomain, assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="domain">Domena zdalna, w której tworzony <paramref name="typeName" /> jest typ o nazwie.</param>
        <param name="assemblyName">Nazwa zestawu, do którego jest poszukiwany <paramref name="typeName" /> typ o nazwie. Jeśli <paramref name="assemblyName" /> jest<see langword="null" />, przeszukiwany jest zestaw wykonywany.</param>
        <param name="typeName">W pełni kwalifikowana nazwa preferowanego typu.</param>
        <summary>Tworzy wystąpienie typu, którego nazwa jest określona w określonej domenie zdalnej przy użyciu nazwanego zestawu i konstruktora bez parametrów.</summary>
        <returns>Dojście, które musi zostać rozpakowane, aby uzyskać dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Activator.CreateInstance%2A> , gdy host musi wykonać kod w domenie aplikacji, która ma ograniczone uprawnienia zabezpieczeń.  
  
 Służy <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> do odpakowania wartości zwracanej.  
  
> [!NOTE]
>  Ta metoda używa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> do żądania bezpośredniego wywołującego do posiadania pełnego zaufania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />lub <paramref name="domain" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyName" />w.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia typu abstrakcyjnego.  
  
 —lub—  
  
 Ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, który został wywołany przez odbicie, wywołał wyjątek.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ com nie został uzyskany za <see cref="Overload:System.Type.GetTypeFromProgID" /> pomocą <see cref="Overload:System.Type.GetTypeFromCLSID" />lub.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.ArgIterator" />Tworzenie typów <see cref="T:System.TypedReference" />, ,<see cref="T:System.Void" />, i<see cref="T:System.RuntimeArgumentHandle" /> lub tablic tych typów nie jest obsługiwane.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" />nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2,0 lub nowszej jest obecnie załadowane i <paramref name="assemblyName" /> zostało skompilowane dla wersji środowiska CLR, która jest nowsza niż aktualnie załadowana wersja. Należy zauważyć, że .NET Framework wersje 2,0, 3,0 i 3,5 używają środowiska CLR w wersji 2,0.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.  
  
 —lub—  
  
 Nazwa zestawu lub baza kodu jest nieprawidłowa.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa zestawu, do którego jest poszukiwany <paramref name="typeName" /> typ o nazwie. Jeśli <paramref name="assemblyName" /> jest<see langword="null" />, przeszukiwany jest zestaw wykonywany.</param>
        <param name="typeName">W pełni kwalifikowana nazwa preferowanego typu.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Jest to zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie typu, którego nazwa jest określona, przy użyciu nazwanego zestawu i konstruktora bez parametrów.</summary>
        <returns>Dojście, które musi zostać rozpakowane, aby uzyskać dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Służy <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> do odpakowania wartości zwracanej.  
  
> [!NOTE]
>  Począwszy od programu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda może być używana do tworzenia typów niepublicznych, jeśli obiekt wywołujący został <xref:System.Security.Permissions.ReflectionPermission> udzielony z <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flagą i jeśli zestaw grantu typów niepublicznych jest ograniczony do zestawu przypisań lub jego podzbioru. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyName" />w.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej lub ten element członkowski został wywołany przy użyciu mechanizmu późnego wiązania.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ com nie został uzyskany za <see cref="Overload:System.Type.GetTypeFromProgID" /> pomocą <see cref="Overload:System.Type.GetTypeFromCLSID" />lub.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.ArgIterator" />Tworzenie typów <see cref="T:System.TypedReference" />, ,<see cref="T:System.Void" />, i<see cref="T:System.RuntimeArgumentHandle" /> lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
 <paramref name="activationAttributes" />nie jest pustą tablicą, a tworzony typ nie pochodzi od <see cref="T:System.MarshalByRefObject" />.  
  
—lub— 
 <paramref name="activationAttributes" />nie jest<see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />  
  
macierzy.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" />nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2,0 lub nowszej jest obecnie załadowane i <paramref name="assemblyName" /> zostało skompilowane dla wersji środowiska CLR, która jest nowsza niż aktualnie załadowana wersja. Należy zauważyć, że .NET Framework wersje 2,0, 3,0 i 3,5 używają środowiska CLR w wersji 2,0.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.  
  
 —lub—  
  
 Nazwa zestawu lub baza kodu jest nieprawidłowa.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Wystąpił błąd podczas próby aktywacji zdalnej w miejscu docelowym określonym w <paramref name="activationAttributes" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">do uzyskiwania dostępu do typów niepublicznych niezależnie od ich zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, object[] args, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[],System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * obj[] * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, args, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Typ obiektu do utworzenia.</param>
        <param name="args">Tablica argumentów, które pasują do wartości Number, Order i Type parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest tablicą pustą <see langword="null" />lub, Konstruktor, który nie pobiera parametrów (Konstruktor bez parametrów) jest wywoływany.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Jest to zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie określonego typu przy użyciu konstruktora, który najlepiej pasuje do określonych parametrów.</summary>
        <returns>Odwołanie do nowo utworzonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor, który ma zostać wywołany, musi być dostępny i musi zawierać najbardziej szczegółowe dopasowanie z określoną listą argumentów.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana do uzyskiwania dostępu do typów niepublicznych, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw uprawnień zestawu, który zawiera typy niepubliczne, jest ograniczony do przydzielenia obiektu wywołującego [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Ustaw lub do podzbioru. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" />nie <see langword="RuntimeType" />jest.  
  
—lub— 
 <paramref name="type" />jest otwartym typem ogólnym (oznacza to, <see cref="P:System.Type.ContainsGenericParameters" /> że właściwość <see langword="true" />zwraca).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="type" />nie może być <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
—lub— 
<see cref="T:System.ArgIterator" />Tworzenie typów <see cref="T:System.TypedReference" />, ,<see cref="T:System.Void" />, i<see cref="T:System.RuntimeArgumentHandle" /> lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
 <paramref name="activationAttributes" />nie jest pustą tablicą, a tworzony typ nie pochodzi od <see cref="T:System.MarshalByRefObject" />.  
  
—lub— 
Zestaw, który zawiera <paramref name="type" /> , jest zestawem dynamicznym, który <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />został utworzony przy użyciu.  
  
—lub— 
Konstruktor, który najlepiej pasuje <paramref name="args" /> , <see langword="varargs" /> ma argumenty.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Wywoływany Konstruktor zgłasza wyjątek.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej lub ten element członkowski został wywołany przy użyciu mechanizmu późnego wiązania.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ com nie został uzyskany za <see cref="Overload:System.Type.GetTypeFromProgID" /> pomocą <see cref="Overload:System.Type.GetTypeFromCLSID" />lub.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="type" />jest obiektem COM, ale identyfikator klasy używany do uzyskania typu jest nieprawidłowy lub zidentyfikowana Klasa nie jest zarejestrowana.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="type" />nie jest prawidłowym typem.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">do uzyskiwania dostępu do typów niepublicznych niezależnie od ich zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="System.Activator.CreateInstance (type, bindingAttr, binder, args, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Typ obiektu do utworzenia.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które wpływają na wyszukiwanie <paramref name="type" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest równa zero, wykonywane jest wyszukiwanie dla konstruktorów publicznych z uwzględnieniem wielkości liter.</param>
        <param name="binder">Obiekt, który używa <paramref name="bindingAttr" /> i <paramref name="args" /> <paramref name="type" /> do wyszukiwania i identyfikowania konstruktora. Jeśli <paramref name="binder" /> jest<see langword="null" />, używany jest domyślny spinacz.</param>
        <param name="args">Tablica argumentów, które pasują do wartości Number, Order i Type parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest tablicą pustą <see langword="null" />lub, Konstruktor, który nie pobiera parametrów (Konstruktor bez parametrów) jest wywoływany.</param>
        <param name="culture">Informacje specyficzne <paramref name="args" /> <paramref name="type" /> dla kultury, które regulują rzutowanie na typy formalne zadeklarowane dla konstruktora. Jeśli <paramref name="culture" /> ma <see langword="null" />wartość ,<see cref="T:System.Globalization.CultureInfo" /> jest używany dla bieżącego wątku.</param>
        <summary>Tworzy wystąpienie określonego typu przy użyciu konstruktora, który najlepiej pasuje do określonych parametrów.</summary>
        <returns>Odwołanie do nowo utworzonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor, który ma być wywoływany, musi zapewniać najbardziej dokładne dopasowanie z określoną listą argumentów w ramach ograniczeń określonych atrybutów spinacza i powiązania.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może być używana do uzyskiwania dostępu do typów niepublicznych i członków, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw uprawnień zestawu, który zawiera typy niepubliczne i składowe, jest ograniczony [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] do przydzielenia obiektu wywołującego lub jego podzbioru. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" />nie <see langword="RuntimeType" />jest.  
  
—lub— 
 <paramref name="type" />jest otwartym typem ogólnym (oznacza to, <see cref="P:System.Type.ContainsGenericParameters" /> że właściwość <see langword="true" />zwraca).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="type" />nie może być <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
—lub— 
<see cref="T:System.ArgIterator" />Tworzenie typów <see cref="T:System.TypedReference" />, ,<see cref="T:System.Void" />, i<see cref="T:System.RuntimeArgumentHandle" /> lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
Zestaw, który zawiera <paramref name="type" /> , jest zestawem dynamicznym, który <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />został utworzony przy użyciu.  
  
—lub— 
Konstruktor, który najlepiej pasuje <paramref name="args" /> , <see langword="varargs" /> ma argumenty.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Wywoływany Konstruktor zgłasza wyjątek.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej lub ten element członkowski został wywołany przy użyciu mechanizmu późnego wiązania.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ com nie został uzyskany za <see cref="Overload:System.Type.GetTypeFromProgID" /> pomocą <see cref="Overload:System.Type.GetTypeFromCLSID" />lub.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="type" />jest obiektem COM, ale identyfikator klasy używany do uzyskania typu jest nieprawidłowy lub zidentyfikowana Klasa nie jest zarejestrowana.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="type" />nie jest prawidłowym typem.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">do uzyskiwania dostępu do niepublicznych typów i członków, niezależnie od ich zestawu dotacji. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Typ obiektu do utworzenia.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które wpływają na wyszukiwanie <paramref name="type" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest równa zero, wykonywane jest wyszukiwanie dla konstruktorów publicznych z uwzględnieniem wielkości liter.</param>
        <param name="binder">Obiekt, który używa <paramref name="bindingAttr" /> i <paramref name="args" /> <paramref name="type" /> do wyszukiwania i identyfikowania konstruktora. Jeśli <paramref name="binder" /> jest<see langword="null" />, używany jest domyślny spinacz.</param>
        <param name="args">Tablica argumentów, które pasują do wartości Number, Order i Type parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest tablicą pustą <see langword="null" />lub, Konstruktor, który nie pobiera parametrów (Konstruktor bez parametrów) jest wywoływany.</param>
        <param name="culture">Informacje specyficzne <paramref name="args" /> <paramref name="type" /> dla kultury, które regulują rzutowanie na typy formalne zadeklarowane dla konstruktora. Jeśli <paramref name="culture" /> ma <see langword="null" />wartość ,<see cref="T:System.Globalization.CultureInfo" /> jest używany dla bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Jest to zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie określonego typu przy użyciu konstruktora, który najlepiej pasuje do określonych parametrów.</summary>
        <returns>Odwołanie do nowo utworzonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor, który ma być wywoływany, musi zapewniać najbardziej dokładne dopasowanie z określoną listą argumentów w ramach ograniczeń określonych atrybutów spinacza i powiązania.  
  
> [!NOTE]
>  Począwszy od programu [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], ta metoda może być używana do uzyskiwania dostępu do typów niepublicznych i członków, jeśli obiekt wywołujący został <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> udzielony <xref:System.Security.Permissions.ReflectionPermission> z flagą i jeśli zestaw grantu typów niepublicznych i składowych jest ograniczony do zestawu uprawnień obiektu wywołującego lub do podzbioru. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" />nie <see langword="RuntimeType" />jest.  
  
—lub— 
 <paramref name="type" />jest otwartym typem ogólnym (oznacza to, <see cref="P:System.Type.ContainsGenericParameters" /> że właściwość <see langword="true" />zwraca).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="type" />nie może być <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
—lub— 
<see cref="T:System.ArgIterator" />Tworzenie typów <see cref="T:System.TypedReference" />, ,<see cref="T:System.Void" />, i<see cref="T:System.RuntimeArgumentHandle" /> lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
 <paramref name="activationAttributes" />nie jest pustą tablicą, a tworzony typ nie pochodzi od <see cref="T:System.MarshalByRefObject" />.  
  
—lub— 
Zestaw, który zawiera <paramref name="type" /> , jest zestawem dynamicznym, który <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" />został utworzony przy użyciu.  
  
—lub— 
Konstruktor, który najlepiej pasuje <paramref name="args" /> , <see langword="varargs" /> ma argumenty.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Wywoływany Konstruktor zgłasza wyjątek.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej lub ten element członkowski został wywołany przy użyciu mechanizmu późnego wiązania.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ com nie został uzyskany za <see cref="Overload:System.Type.GetTypeFromProgID" /> pomocą <see cref="Overload:System.Type.GetTypeFromCLSID" />lub.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="type" />jest obiektem COM, ale identyfikator klasy używany do uzyskania typu jest nieprawidłowy lub zidentyfikowana Klasa nie jest zarejestrowana.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="type" />nie jest prawidłowym typem.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do dostarczania dowodów. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">do uzyskiwania dostępu do niepublicznych typów i członków, niezależnie od ich zestawu dotacji. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa zestawu, do którego jest poszukiwany <paramref name="typeName" /> typ o nazwie. Jeśli <paramref name="assemblyName" /> jest<see langword="null" />, przeszukiwany jest zestaw wykonywany.</param>
        <param name="typeName">W pełni kwalifikowana nazwa preferowanego typu.</param>
        <param name="ignoreCase"><see langword="true" />Aby określić, czy w wyszukiwaniu <paramref name="typeName" /> nie jest rozróżniana wielkość liter; <see langword="false" /> aby określić, czy w wyszukiwaniu jest uwzględniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest równa zero, wykonywane jest wyszukiwanie dla konstruktorów publicznych z uwzględnieniem wielkości liter.</param>
        <param name="binder">Obiekt, który używa <paramref name="bindingAttr" /> i <paramref name="args" /> <paramref name="typeName" /> do wyszukiwania i identyfikowania konstruktora. Jeśli <paramref name="binder" /> jest<see langword="null" />, używany jest domyślny spinacz.</param>
        <param name="args">Tablica argumentów, które pasują do wartości Number, Order i Type parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest tablicą pustą <see langword="null" />lub, Konstruktor, który nie pobiera parametrów (Konstruktor bez parametrów) jest wywoływany.</param>
        <param name="culture">Informacje specyficzne <paramref name="args" /> <paramref name="typeName" /> dla kultury, które regulują rzutowanie na typy formalne zadeklarowane dla konstruktora. Jeśli <paramref name="culture" /> ma <see langword="null" />wartość ,<see cref="T:System.Globalization.CultureInfo" /> jest używany dla bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Jest to zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie typu, którego nazwa jest określona, przy użyciu nazwanego zestawu i konstruktora, który najlepiej pasuje do określonych parametrów.</summary>
        <returns>Dojście, które musi zostać rozpakowane, aby uzyskać dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Służy <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> do odpakowania wartości zwracanej.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może służyć do tworzenia typów niepublicznych i członków, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw uprawnień zestawu, który zawiera typy niepubliczne i składowe, jest ograniczony [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] do przydzielenia obiektu wywołującego lub jego podzbioru. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyName" />w.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej lub ten element członkowski został wywołany przy użyciu mechanizmu późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, który został wywołany przez odbicie, wywołał wyjątek.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ com nie został uzyskany za <see cref="Overload:System.Type.GetTypeFromProgID" /> pomocą <see cref="Overload:System.Type.GetTypeFromCLSID" />lub.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.ArgIterator" />Tworzenie typów <see cref="T:System.TypedReference" />, ,<see cref="T:System.Void" />, i<see cref="T:System.RuntimeArgumentHandle" /> lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
 <paramref name="activationAttributes" />nie jest pustą tablicą, a tworzony typ nie pochodzi od <see cref="T:System.MarshalByRefObject" />.  
  
—lub— 
Konstruktor, który najlepiej pasuje <paramref name="args" /> , <see langword="varargs" /> ma argumenty.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" />nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2,0 lub nowszej jest obecnie załadowane i <paramref name="assemblyName" /> zostało skompilowane dla wersji środowiska CLR, która jest nowsza niż aktualnie załadowana wersja. Należy zauważyć, że .NET Framework wersje 2,0, 3,0 i 3,5 używają środowiska CLR w wersji 2,0.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.  
  
 —lub—  
  
 Nazwa zestawu lub baza kodu jest nieprawidłowa.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">do uzyskiwania dostępu do niepublicznych typów i członków, niezależnie od ich zestawu dotacji. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyName" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="5" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="6" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="7" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="8" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="domain">Domena, w której jest tworzony <paramref name="typeName" /> typ o nazwie.</param>
        <param name="assemblyName">Nazwa zestawu, do którego jest poszukiwany <paramref name="typeName" /> typ o nazwie. Jeśli <paramref name="assemblyName" /> jest<see langword="null" />, przeszukiwany jest zestaw wykonywany.</param>
        <param name="typeName">W pełni kwalifikowana nazwa preferowanego typu.</param>
        <param name="ignoreCase"><see langword="true" />Aby określić, czy w wyszukiwaniu <paramref name="typeName" /> nie jest rozróżniana wielkość liter; <see langword="false" /> aby określić, czy w wyszukiwaniu jest uwzględniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest równa zero, wykonywane jest wyszukiwanie dla konstruktorów publicznych z uwzględnieniem wielkości liter.</param>
        <param name="binder">Obiekt, który używa <paramref name="bindingAttr" /> i <paramref name="args" /> <paramref name="typeName" /> do wyszukiwania i identyfikowania konstruktora. Jeśli <paramref name="binder" /> jest<see langword="null" />, używany jest domyślny spinacz.</param>
        <param name="args">Tablica argumentów, które pasują do wartości Number, Order i Type parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest tablicą pustą <see langword="null" />lub, Konstruktor, który nie pobiera parametrów (Konstruktor bez parametrów) jest wywoływany.</param>
        <param name="culture">Informacje specyficzne <paramref name="args" /> <paramref name="typeName" /> dla kultury, które regulują rzutowanie na typy formalne zadeklarowane dla konstruktora. Jeśli <paramref name="culture" /> ma <see langword="null" />wartość ,<see cref="T:System.Globalization.CultureInfo" /> jest używany dla bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Jest to zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie typu, którego nazwa jest określona w określonej domenie zdalnej przy użyciu nazwanego zestawu i konstruktora, który najlepiej pasuje do określonych parametrów.</summary>
        <returns>Dojście, które musi zostać rozpakowane, aby uzyskać dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Activator.CreateInstance%2A> , gdy host musi wykonać kod w domenie aplikacji, która ma ograniczone uprawnienia zabezpieczeń.  
  
 Służy <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> do odpakowania wartości zwracanej.  
  
> [!NOTE]
>  Ta metoda używa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> do żądania bezpośredniego wywołującego do posiadania pełnego zaufania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="domain" />lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyName" />w.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej lub ten element członkowski został wywołany przy użyciu mechanizmu późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, który został wywołany przez odbicie, wywołał wyjątek.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ com nie został uzyskany za <see cref="Overload:System.Type.GetTypeFromProgID" /> pomocą <see cref="Overload:System.Type.GetTypeFromCLSID" />lub.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.ArgIterator" />Tworzenie typów <see cref="T:System.TypedReference" />, ,<see cref="T:System.Void" />, i<see cref="T:System.RuntimeArgumentHandle" /> lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
 <paramref name="activationAttributes" />nie jest pustą tablicą, a tworzony typ nie pochodzi od <see cref="T:System.MarshalByRefObject" />.  
  
—lub— 
Konstruktor, który najlepiej pasuje <paramref name="args" /> , <see langword="varargs" /> ma argumenty.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" />nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2,0 lub nowszej jest obecnie załadowane i <paramref name="assemblyName" /> zostało skompilowane dla wersji środowiska CLR, która jest nowsza niż aktualnie załadowana wersja. Należy zauważyć, że .NET Framework wersje 2,0, 3,0 i 3,5 używają środowiska CLR w wersji 2,0.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.  
  
 —lub—  
  
 Nazwa zestawu lub baza kodu jest nieprawidłowa.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nazwa zestawu, do którego jest poszukiwany <paramref name="typeName" /> typ o nazwie. Jeśli <paramref name="assemblyName" /> jest<see langword="null" />, przeszukiwany jest zestaw wykonywany.</param>
        <param name="typeName">W pełni kwalifikowana nazwa preferowanego typu.</param>
        <param name="ignoreCase"><see langword="true" />Aby określić, czy w wyszukiwaniu <paramref name="typeName" /> nie jest rozróżniana wielkość liter; <see langword="false" /> aby określić, czy w wyszukiwaniu jest uwzględniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest równa zero, wykonywane jest wyszukiwanie dla konstruktorów publicznych z uwzględnieniem wielkości liter.</param>
        <param name="binder">Obiekt, który używa <paramref name="bindingAttr" /> i <paramref name="args" /> <paramref name="typeName" /> do wyszukiwania i identyfikowania konstruktora. Jeśli <paramref name="binder" /> jest<see langword="null" />, używany jest domyślny spinacz.</param>
        <param name="args">Tablica argumentów, które pasują do wartości Number, Order i Type parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest tablicą pustą <see langword="null" />lub, Konstruktor, który nie pobiera parametrów (Konstruktor bez parametrów) jest wywoływany.</param>
        <param name="culture">Informacje specyficzne <paramref name="args" /> <paramref name="typeName" /> dla kultury, które regulują rzutowanie na typy formalne zadeklarowane dla konstruktora. Jeśli <paramref name="culture" /> ma <see langword="null" />wartość ,<see cref="T:System.Globalization.CultureInfo" /> jest używany dla bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Jest to zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <param name="securityInfo">Informacje używane do podejmowania decyzji dotyczących zasad zabezpieczeń i udzielania uprawnień kodu.</param>
        <summary>Tworzy wystąpienie typu, którego nazwa jest określona, przy użyciu nazwanego zestawu i konstruktora, który najlepiej pasuje do określonych parametrów.</summary>
        <returns>Dojście, które musi zostać rozpakowane, aby uzyskać dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Służy <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> do odpakowania wartości zwracanej.  
  
> [!NOTE]
>  Począwszy od <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , ta metoda może służyć do tworzenia typów niepublicznych i członków, jeśli obiekt wywołujący został udzielony z flagą i jeśli zestaw uprawnień zestawu, który zawiera typy niepubliczne i składowe, jest ograniczony [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] do przydzielenia obiektu wywołującego lub jego podzbioru. (Zobacz [zagadnienia dotyczące zabezpieczeń w przypadku odbicia](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)).  
>   
>  Aby można było korzystać z tej funkcji, aplikacja powinna [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] być ukierunkowana na lub później.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyName" />w.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej lub ten element członkowski został wywołany przy użyciu mechanizmu późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, który został wywołany przez odbicie, wywołał wyjątek.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ com nie został uzyskany za <see cref="Overload:System.Type.GetTypeFromProgID" /> pomocą <see cref="Overload:System.Type.GetTypeFromCLSID" />lub.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.ArgIterator" />Tworzenie typów <see cref="T:System.TypedReference" />, ,<see cref="T:System.Void" />, i<see cref="T:System.RuntimeArgumentHandle" /> lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
 <paramref name="activationAttributes" />nie jest pustą tablicą, a tworzony typ nie pochodzi od <see cref="T:System.MarshalByRefObject" />.  
  
—lub— 
Konstruktor, który najlepiej pasuje <paramref name="args" /> , <see langword="varargs" /> ma argumenty.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" />nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2,0 lub nowszej jest obecnie załadowane i <paramref name="assemblyName" /> zostało skompilowane dla wersji środowiska CLR, która jest nowsza niż aktualnie załadowana wersja. Należy zauważyć, że .NET Framework wersje 2,0, 3,0 i 3,5 używają środowiska CLR w wersji 2,0.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.  
  
 —lub—  
  
 Nazwa zestawu lub baza kodu jest nieprawidłowa.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">do uzyskiwania dostępu do niepublicznych typów i członków, niezależnie od ich zestawu dotacji. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="6" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="7" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="8" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="9" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="domain">Domena, w której jest tworzony <paramref name="typeName" /> typ o nazwie.</param>
        <param name="assemblyName">Nazwa zestawu, do którego jest poszukiwany <paramref name="typeName" /> typ o nazwie. Jeśli <paramref name="assemblyName" /> jest<see langword="null" />, przeszukiwany jest zestaw wykonywany.</param>
        <param name="typeName">W pełni kwalifikowana nazwa preferowanego typu.</param>
        <param name="ignoreCase"><see langword="true" />Aby określić, czy w wyszukiwaniu <paramref name="typeName" /> nie jest rozróżniana wielkość liter; <see langword="false" /> aby określić, czy w wyszukiwaniu jest uwzględniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest równa zero, wykonywane jest wyszukiwanie dla konstruktorów publicznych z uwzględnieniem wielkości liter.</param>
        <param name="binder">Obiekt, który używa <paramref name="bindingAttr" /> i <paramref name="args" /> <paramref name="typeName" /> do wyszukiwania i identyfikowania konstruktora. Jeśli <paramref name="binder" /> jest<see langword="null" />, używany jest domyślny spinacz.</param>
        <param name="args">Tablica argumentów, które pasują do wartości Number, Order i Type parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest tablicą pustą <see langword="null" />lub, Konstruktor, który nie pobiera parametrów (Konstruktor bez parametrów) jest wywoływany.</param>
        <param name="culture">Informacje specyficzne <paramref name="args" /> <paramref name="typeName" /> dla kultury, które regulują rzutowanie na typy formalne zadeklarowane dla konstruktora. Jeśli <paramref name="culture" /> ma <see langword="null" />wartość ,<see cref="T:System.Globalization.CultureInfo" /> jest używany dla bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Jest to zazwyczaj tablica, która zawiera pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt. <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> Określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.</param>
        <param name="securityAttributes">Informacje używane do podejmowania decyzji dotyczących zasad zabezpieczeń i udzielania uprawnień kodu.</param>
        <summary>Tworzy wystąpienie typu, którego nazwa jest określona w określonej domenie zdalnej przy użyciu nazwanego zestawu i konstruktora, który najlepiej pasuje do określonych parametrów.</summary>
        <returns>Dojście, które musi zostać rozpakowane, aby uzyskać dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Activator.CreateInstance%2A> , gdy host musi wykonać kod w domenie aplikacji, która ma ograniczone uprawnienia zabezpieczeń.  
  
 Służy <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> do odpakowania wartości zwracanej.  
  
> [!NOTE]
>  Ta metoda używa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> do żądania bezpośredniego wywołującego do posiadania pełnego zaufania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="domain" />lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyName" />w.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyName" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej lub ten element członkowski został wywołany przy użyciu mechanizmu późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, który został wywołany przez odbicie, wywołał wyjątek.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Typ com nie został uzyskany za <see cref="Overload:System.Type.GetTypeFromProgID" /> pomocą <see cref="Overload:System.Type.GetTypeFromCLSID" />lub.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.ArgIterator" />Tworzenie typów <see cref="T:System.TypedReference" />, ,<see cref="T:System.Void" />, i<see cref="T:System.RuntimeArgumentHandle" /> lub tablic tych typów nie jest obsługiwane.  
  
—lub— 
 <paramref name="activationAttributes" />nie jest pustą tablicą, a tworzony typ nie pochodzi od <see cref="T:System.MarshalByRefObject" />.  
  
—lub— 
Konstruktor, który najlepiej pasuje <paramref name="args" /> , <see langword="varargs" /> ma argumenty.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" />nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2,0 lub nowszej jest obecnie załadowane i <paramref name="assemblyName" /> zostało skompilowane dla wersji środowiska CLR, która jest nowsza niż aktualnie załadowana wersja. Należy zauważyć, że .NET Framework wersje 2,0, 3,0 i 3,5 używają środowiska CLR w wersji 2,0.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.  
  
 —lub—  
  
 Nazwa zestawu lub baza kodu jest nieprawidłowa.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Wywoływanie operacji na wszystkich elementach członkowskich typów. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CreateInstance&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CreateInstance&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T CreateInstance();" />
      <MemberSignature Language="F#" Value="static member CreateInstance : unit -&gt; 'T" Usage="System.Activator.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Typ do utworzenia.</typeparam>
        <summary>Tworzy wystąpienie typu wyznaczony przez określony parametr typu generycznego przy użyciu konstruktora bez parametrów.</summary>
        <returns>Odwołanie do nowo utworzonego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda <xref:System.Activator.CreateInstance%60%601> generyczna jest używana przez kompilatory do implementowania wystąpienia typów określonych przez parametry typu. Na przykład w poniższej metodzie ogólnej implementacja `new T()` programu (`gcnew T()` in C++) używa <xref:System.Activator.CreateInstance%60%601> metody generycznej.  
  
 [!code-cpp[System.Activation.CreateInstance~~1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cpp/remarks.cpp#1)]
 [!code-csharp[System.Activation.CreateInstance~~1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cs/remarks.cs#1)]
 [!code-vb[System.Activation.CreateInstance~~1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activation.createinstance~~1/vb/remarks.vb#1)]  
  
 Ogólnie rzecz biorąc nie istnieje użycie <xref:System.Activator.CreateInstance%60%601> metody generycznej w kodzie aplikacji, ponieważ typ musi być znany w czasie kompilacji. Jeśli typ jest znany w czasie kompilacji, można użyć normalnej`new` składni tworzenia wystąpienia (operator in C#, `New` w Visual Basic, `gcnew` in C++). Jeśli typ nie jest znany w czasie kompilacji, można wywołać nieogólne Przeciążenie elementu <xref:System.Activator.CreateInstance%2A>.  
  
 Brak przeciążeń <xref:System.Activator.CreateInstance%60%601> metody ogólnej, która przyjmuje listy argumentów, ponieważ <xref:System.Activator.CreateInstance%2A> przeciążenia inne niż ogólne zapewniają już bardziej powiązane rozwiązanie konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MissingMethodException"><block subset="none" type="note">
            <para>  
 W programie <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET dla aplikacji ze sklepu Windows</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">przenośnej biblioteki klas</see>Przechwyć wyjątek <see cref="T:System.MissingMemberException" />klasy bazowej, zamiast tego.  
  
</para>
          </block>  
  
 Typ określony dla <paramref name="T" /> nie ma konstruktora bez parametrów.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy wystąpienie typu, którego nazwa jest określona, przy użyciu nazwanego pliku zestawu i konstruktora, który najlepiej pasuje do określonych parametrów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw, do którego poszukuje się typ o <paramref name="typeName" /> nazwie.</param>
        <param name="typeName">Nazwa preferowanego typu.</param>
        <summary>Tworzy wystąpienie typu, którego nazwa jest określona, przy użyciu nazwanego pliku zestawu i konstruktora bez parametrów.</summary>
        <returns>Dojście, które musi zostać rozpakowane, aby uzyskać dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Użyj metody, aby rozwinąć wartość zwracaną.  
  
 Aby uzyskać informacje o innych wyjątkach, które mogą być zgłaszane przez wywoływanych metod, zobacz sekcję <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> wyjątki <xref:System.Activator.CreateInstance%2A> metod i.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób wywołania <xref:System.Activator.CreateInstanceFrom%2A> metody. Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Activator> klasy.  
  
 [!code-cpp[ActivatorX#3](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#3)]
 [!code-csharp[ActivatorX#3](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#3)]
 [!code-vb[ActivatorX#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyFile" />w.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej lub ten element członkowski został wywołany przy użyciu mechanizmu późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, który został wywołany przez odbicie, wywołał wyjątek.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący ma wymagane <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" />nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2,0 lub nowszej jest obecnie załadowane i <paramref name="assemblyName" /> zostało skompilowane dla wersji środowiska CLR, która jest nowsza niż aktualnie załadowana wersja. Należy zauważyć, że .NET Framework wersje 2,0, 3,0 i 3,5 używają środowiska CLR w wersji 2,0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">możliwość wyszukiwania ścieżek katalogów i odczytywania ich zawartości. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">do uzyskiwania dostępu do typów niepublicznych niezależnie od ich zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (domain As AppDomain, assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyFile" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="domain">Domena zdalna, w której tworzony <paramref name="typeName" /> jest typ o nazwie.</param>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw, do którego poszukuje się typ o <paramref name="typeName" /> nazwie.</param>
        <param name="typeName">Nazwa preferowanego typu.</param>
        <summary>Tworzy wystąpienie typu, którego nazwa jest określona w określonej domenie zdalnej przy użyciu nazwanego pliku zestawu i konstruktora bez parametrów.</summary>
        <returns>Dojście, które musi zostać rozpakowane, aby uzyskać dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Activator.CreateInstanceFrom%2A> , gdy host musi wykonać kod w domenie aplikacji, która ma ograniczone uprawnienia zabezpieczeń.  
  
 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Użyj metody, aby rozwinąć wartość zwracaną.  
  
> [!NOTE]
>  Ta metoda używa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> do żądania bezpośredniego wywołującego do posiadania pełnego zaufania.  
  
 Aby uzyskać informacje o innych wyjątkach, które mogą być zgłaszane przez wywoływanych metod, zobacz sekcję <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> wyjątki <xref:System.Activator.CreateInstance%2A> metod i.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="domain" />lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyFile" />w.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej lub ten element członkowski został wywołany przy użyciu mechanizmu późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, który został wywołany przez odbicie, wywołał wyjątek.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący ma wymagane <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" />nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2,0 lub nowszej jest obecnie załadowane i <paramref name="assemblyName" /> zostało skompilowane dla wersji środowiska CLR, która jest nowsza niż aktualnie załadowana wersja. Należy zauważyć, że .NET Framework wersje 2,0, 3,0 i 3,5 używają środowiska CLR w wersji 2,0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">możliwość wyszukiwania ścieżek katalogów i odczytywania ich zawartości. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw, do którego poszukuje się typ o <paramref name="typeName" /> nazwie.</param>
        <param name="typeName">Nazwa preferowanego typu.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Jest to zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie typu, którego nazwa jest określona, przy użyciu nazwanego pliku zestawu i konstruktora bez parametrów.</summary>
        <returns>Dojście, które musi zostać rozpakowane, aby uzyskać dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Użyj metody, aby rozwinąć wartość zwracaną.  
  
 Aby uzyskać informacje o innych wyjątkach, które mogą być zgłaszane przez wywoływanych metod, zobacz sekcję <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> wyjątki <xref:System.Activator.CreateInstance%2A> metod i.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego publicznego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyFile" />w.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej lub ten element członkowski został wywołany przy użyciu mechanizmu późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, który został wywołany przez odbicie, wywołał wyjątek.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="activationAttributes" />nie jest pustą tablicą, a tworzony typ nie pochodzi od <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący ma wymagane <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" />nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2,0 lub nowszej jest obecnie załadowane i <paramref name="assemblyName" /> zostało skompilowane dla wersji środowiska CLR, która jest nowsza niż aktualnie załadowana wersja. Należy zauważyć, że .NET Framework wersje 2,0, 3,0 i 3,5 używają środowiska CLR w wersji 2,0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">możliwość wyszukiwania ścieżek katalogów i odczytywania ich zawartości. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">do uzyskiwania dostępu do typów niepublicznych niezależnie od ich zestawu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw, do którego poszukuje się typ o <paramref name="typeName" /> nazwie.</param>
        <param name="typeName">Nazwa preferowanego typu.</param>
        <param name="ignoreCase"><see langword="true" />Aby określić, czy w wyszukiwaniu <paramref name="typeName" /> nie jest rozróżniana wielkość liter; <see langword="false" /> aby określić, czy w wyszukiwaniu jest uwzględniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest równa zero, wykonywane jest wyszukiwanie dla konstruktorów publicznych z uwzględnieniem wielkości liter.</param>
        <param name="binder">Obiekt, który używa <paramref name="bindingAttr" /> i <paramref name="args" /> <paramref name="typeName" /> do wyszukiwania i identyfikowania konstruktora. Jeśli <paramref name="binder" /> jest<see langword="null" />, używany jest domyślny spinacz.</param>
        <param name="args">Tablica argumentów, które pasują do wartości Number, Order i Type parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest tablicą pustą <see langword="null" />lub, Konstruktor, który nie pobiera parametrów (Konstruktor bez parametrów) jest wywoływany.</param>
        <param name="culture">Informacje specyficzne <paramref name="args" /> <paramref name="typeName" /> dla kultury, które regulują rzutowanie na typy formalne zadeklarowane dla konstruktora. Jeśli <paramref name="culture" /> ma <see langword="null" />wartość ,<see cref="T:System.Globalization.CultureInfo" /> jest używany dla bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Jest to zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie typu, którego nazwa jest określona, przy użyciu nazwanego pliku zestawu i konstruktora, który najlepiej pasuje do określonych parametrów.</summary>
        <returns>Dojście, które musi zostać rozpakowane, aby uzyskać dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Użyj metody, aby rozwinąć wartość zwracaną.  
  
 Aby uzyskać informacje o innych wyjątkach, które mogą być zgłaszane przez wywoływanych metod, zobacz sekcję <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> wyjątki <xref:System.Activator.CreateInstance%2A> metod i.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyFile" />w.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej lub ten element członkowski został wywołany przy użyciu mechanizmu późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, który został wywołany przez odbicie, wywołał wyjątek.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganego <see cref="T:System.Security.Permissions.FileIOPermission" />elementu.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="activationAttributes" />nie jest pustą tablicą, a tworzony typ nie pochodzi od <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" />nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2,0 lub nowszej jest obecnie załadowane i <paramref name="assemblyName" /> zostało skompilowane dla wersji środowiska CLR, która jest nowsza niż aktualnie załadowana wersja. Należy zauważyć, że .NET Framework wersje 2,0, 3,0 i 3,5 używają środowiska CLR w wersji 2,0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">możliwość wyszukiwania ścieżek katalogów i odczytywania ich zawartości. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">do uzyskiwania dostępu do niepublicznych typów i członków, niezależnie od ich zestawu dotacji. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyFile" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="5" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="6" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="7" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="8" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="domain">Domena zdalna, w której tworzony <paramref name="typeName" /> jest typ o nazwie.</param>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw, do którego poszukuje się typ o <paramref name="typeName" /> nazwie.</param>
        <param name="typeName">Nazwa preferowanego typu.</param>
        <param name="ignoreCase"><see langword="true" />Aby określić, czy w wyszukiwaniu <paramref name="typeName" /> nie jest rozróżniana wielkość liter; <see langword="false" /> aby określić, czy w wyszukiwaniu jest uwzględniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest równa zero, wykonywane jest wyszukiwanie dla konstruktorów publicznych z uwzględnieniem wielkości liter.</param>
        <param name="binder">Obiekt, który używa <paramref name="bindingAttr" /> i <paramref name="args" /> <paramref name="typeName" /> do wyszukiwania i identyfikowania konstruktora. Jeśli <paramref name="binder" /> jest<see langword="null" />, używany jest domyślny spinacz.</param>
        <param name="args">Tablica argumentów, które pasują do wartości Number, Order i Type parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest tablicą pustą <see langword="null" />lub, Konstruktor, który nie pobiera parametrów (Konstruktor bez parametrów) jest wywoływany.</param>
        <param name="culture">Informacje specyficzne <paramref name="args" /> <paramref name="typeName" /> dla kultury, które regulują rzutowanie na typy formalne zadeklarowane dla konstruktora. Jeśli <paramref name="culture" /> ma <see langword="null" />wartość ,<see cref="T:System.Globalization.CultureInfo" /> jest używany dla bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Jest to zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <summary>Tworzy wystąpienie typu, którego nazwa jest określona w określonej domenie zdalnej przy użyciu nazwanego pliku zestawu i konstruktora, który najlepiej pasuje do określonych parametrów.</summary>
        <returns>Dojście, które musi zostać rozpakowane, aby uzyskać dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Activator.CreateInstanceFrom%2A> , gdy host musi wykonać kod w domenie aplikacji, która ma ograniczone uprawnienia zabezpieczeń.  
  
 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Użyj metody, aby rozwinąć wartość zwracaną.  
  
 Aby uzyskać informacje o innych wyjątkach, które mogą być zgłaszane przez wywoływanych metod, zobacz sekcję <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> wyjątki <xref:System.Activator.CreateInstance%2A> metod i.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="domain" />lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyFile" />w.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej lub ten element członkowski został wywołany przy użyciu mechanizmu późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, który został wywołany przez odbicie, wywołał wyjątek.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący ma wymagane <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="activationAttributes" />nie jest pustą tablicą, a tworzony typ nie pochodzi od <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" />nie jest prawidłowym zestawem.  
  
—lub— 
 <paramref name="assemblyName" />została skompilowana dla wersji środowiska uruchomieniowego języka wspólnego, która jest nowsza niż wersja, która jest aktualnie załadowana.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do dostarczania dowodów. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">możliwość wyszukiwania ścieżek katalogów i odczytywania ich zawartości. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">do uzyskiwania dostępu do niepublicznych typów i członków, niezależnie od ich zestawu dotacji. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw, do którego poszukuje się typ o <paramref name="typeName" /> nazwie.</param>
        <param name="typeName">Nazwa preferowanego typu.</param>
        <param name="ignoreCase"><see langword="true" />Aby określić, czy w wyszukiwaniu <paramref name="typeName" /> nie jest rozróżniana wielkość liter; <see langword="false" /> aby określić, czy w wyszukiwaniu jest uwzględniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest równa zero, wykonywane jest wyszukiwanie dla konstruktorów publicznych z uwzględnieniem wielkości liter.</param>
        <param name="binder">Obiekt, który używa <paramref name="bindingAttr" /> i <paramref name="args" /> <paramref name="typeName" /> do wyszukiwania i identyfikowania konstruktora. Jeśli <paramref name="binder" /> jest<see langword="null" />, używany jest domyślny spinacz.</param>
        <param name="args">Tablica argumentów, które pasują do wartości Number, Order i Type parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest tablicą pustą <see langword="null" />lub, Konstruktor, który nie pobiera parametrów (Konstruktor bez parametrów) jest wywoływany.</param>
        <param name="culture">Informacje specyficzne <paramref name="args" /> <paramref name="typeName" /> dla kultury, które regulują rzutowanie na typy formalne zadeklarowane dla konstruktora. Jeśli <paramref name="culture" /> ma <see langword="null" />wartość ,<see cref="T:System.Globalization.CultureInfo" /> jest używany dla bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Jest to zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <param name="securityInfo">Informacje używane do podejmowania decyzji dotyczących zasad zabezpieczeń i udzielania uprawnień kodu.</param>
        <summary>Tworzy wystąpienie typu, którego nazwa jest określona, przy użyciu nazwanego pliku zestawu i konstruktora, który najlepiej pasuje do określonych parametrów.</summary>
        <returns>Dojście, które musi zostać rozpakowane, aby uzyskać dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Użyj metody, aby rozwinąć wartość zwracaną.  
  
 Aby uzyskać informacje o innych wyjątkach, które mogą być zgłaszane przez wywoływanych metod, zobacz sekcję <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> wyjątki <xref:System.Activator.CreateInstance%2A> metod i.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyFile" />w.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej lub ten element członkowski został wywołany przy użyciu mechanizmu późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, który został wywołany przez odbicie, wywołał wyjątek.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganego <see cref="T:System.Security.Permissions.FileIOPermission" />elementu.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="activationAttributes" />nie jest pustą tablicą, a tworzony typ nie pochodzi od <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" />nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2,0 lub nowszej jest obecnie załadowane i <paramref name="assemblyName" /> zostało skompilowane dla wersji środowiska CLR, która jest nowsza niż aktualnie załadowana wersja. Należy zauważyć, że .NET Framework wersje 2,0, 3,0 i 3,5 używają środowiska CLR w wersji 2,0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu podczas tworzenia wystąpienia delegata. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">możliwość wyszukiwania ścieżek katalogów i odczytywania ich zawartości. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">do uzyskiwania dostępu do niepublicznych typów i członków, niezależnie od ich zestawu dotacji. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use Evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyFile" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="6" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="7" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="8" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="9" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="domain">Domena zdalna, w której tworzony <paramref name="typeName" /> jest typ o nazwie.</param>
        <param name="assemblyFile">Nazwa pliku, który zawiera zestaw, do którego poszukuje się typ o <paramref name="typeName" /> nazwie.</param>
        <param name="typeName">Nazwa preferowanego typu.</param>
        <param name="ignoreCase"><see langword="true" />Aby określić, czy w wyszukiwaniu <paramref name="typeName" /> nie jest rozróżniana wielkość liter; <see langword="false" /> aby określić, czy w wyszukiwaniu jest uwzględniana wielkość liter.</param>
        <param name="bindingAttr">Kombinacja zero lub więcej flag bitowych, które wpływają na wyszukiwanie <paramref name="typeName" /> konstruktora. Jeśli <paramref name="bindingAttr" /> jest równa zero, wykonywane jest wyszukiwanie dla konstruktorów publicznych z uwzględnieniem wielkości liter.</param>
        <param name="binder">Obiekt, który używa <paramref name="bindingAttr" /> i <paramref name="args" /> <paramref name="typeName" /> do wyszukiwania i identyfikowania konstruktora. Jeśli <paramref name="binder" /> jest<see langword="null" />, używany jest domyślny spinacz.</param>
        <param name="args">Tablica argumentów, które pasują do wartości Number, Order i Type parametrów konstruktora do wywołania. Jeśli <paramref name="args" /> jest tablicą pustą <see langword="null" />lub, Konstruktor, który nie pobiera parametrów (Konstruktor bez parametrów) jest wywoływany.</param>
        <param name="culture">Informacje specyficzne <paramref name="args" /> <paramref name="typeName" /> dla kultury, które regulują rzutowanie na typy formalne zadeklarowane dla konstruktora. Jeśli <paramref name="culture" /> ma <see langword="null" />wartość ,<see cref="T:System.Globalization.CultureInfo" /> jest używany dla bieżącego wątku.</param>
        <param name="activationAttributes">Tablica jednego lub więcej atrybutów, które mogą brać udział w aktywacji. Jest to zazwyczaj tablica zawierająca pojedynczy <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> obiekt, który określa adres URL, który jest wymagany do aktywowania obiektu zdalnego.  
  
Ten parametr jest powiązany z obiektami aktywowanymi przez klienta. Aktywacja klienta to Starsza technologia, która jest zachowywana w celu zapewnienia zgodności z poprzednimi wersjami, ale nie jest zalecana w przypadku nowych rozwiązań. Aplikacje rozproszone powinny zamiast tego używać Windows Communication Foundation.</param>
        <param name="securityAttributes">Informacje używane do podejmowania decyzji dotyczących zasad zabezpieczeń i udzielania uprawnień kodu.</param>
        <summary>Tworzy wystąpienie typu, którego nazwa jest określona w określonej domenie zdalnej przy użyciu nazwanego pliku zestawu i konstruktora, który najlepiej pasuje do określonych parametrów.</summary>
        <returns>Dojście, które musi zostać rozpakowane, aby uzyskać dostęp do nowo utworzonego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Activator.CreateInstanceFrom%2A> , gdy host musi wykonać kod w domenie aplikacji, która ma ograniczone uprawnienia zabezpieczeń.  
  
 <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Użyj metody, aby rozwinąć wartość zwracaną.  
  
> [!NOTE]
>  Ta metoda używa <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> do żądania bezpośredniego wywołującego do posiadania pełnego zaufania.  
  
 Aby uzyskać informacje o innych wyjątkach, które mogą być zgłaszane przez wywoływanych metod, zobacz sekcję <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> wyjątki <xref:System.Activator.CreateInstance%2A> metod i.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="domain" />lub <paramref name="typeName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nie znaleziono pasującego konstruktora.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typename" />nie została znaleziona <paramref name="assemblyFile" />w.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyFile" />nie znaleziono.</exception>
        <exception cref="T:System.MethodAccessException">Obiekt wywołujący nie ma uprawnień do wywoływania tego konstruktora.</exception>
        <exception cref="T:System.MemberAccessException">Nie można utworzyć wystąpienia klasy abstrakcyjnej lub ten element członkowski został wywołany przy użyciu mechanizmu późnego wiązania.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Konstruktor, który został wywołany przez odbicie, wywołał wyjątek.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący ma wymagane <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="activationAttributes" />nie jest pustą tablicą, a tworzony typ nie pochodzi od <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" />nie jest prawidłowym zestawem.  
  
—lub— 
Środowisko uruchomieniowe języka wspólnego (CLR) w wersji 2,0 lub nowszej jest obecnie załadowane i <paramref name="assemblyName" /> zostało skompilowane dla wersji środowiska CLR, która jest nowsza niż aktualnie załadowana wersja. Należy zauważyć, że .NET Framework wersje 2,0, 3,0 i 3,5 używają środowiska CLR w wersji 2,0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do dostarczania dowodów. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">możliwość wyszukiwania ścieżek katalogów i odczytywania ich zawartości. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> i<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">do uzyskiwania dostępu do niepublicznych typów i członków, niezależnie od ich zestawu dotacji. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy serwer proxy dla dobrze znanego obiektu lub usługi sieci Web XML.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member GetObject : Type * string -&gt; obj" Usage="System.Activator.GetObject (type, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="url" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Typ dobrze znanego obiektu, z którym chcesz nawiązać połączenie.</param>
        <param name="url">Adres URL dobrze znanego obiektu.</param>
        <summary>Tworzy serwer proxy dla dobrze znanego obiektu wskazywanego przez określony typ i adres URL.</summary>
        <returns>Serwer proxy, który wskazuje punkt końcowy obsługiwany przez żądany dobrze znany obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj serwer proxy, aby wysyłać komunikaty do zdalnego obiektu. Żadne komunikaty nie są wysyłane przez sieć do momentu wywołania metody na serwerze proxy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />lub <paramref name="url" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="type" />nie jest zorganizowany przez odwołanie i nie jest interfejsem.</exception>
        <exception cref="T:System.MemberAccessException">Ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member GetObject : Type * string * obj -&gt; obj" Usage="System.Activator.GetObject (type, url, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="url" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Typ dobrze znanego obiektu, z którym chcesz nawiązać połączenie.</param>
        <param name="url">Adres URL dobrze znanego obiektu.</param>
        <param name="state">Dane specyficzne dla kanału lub <see langword="null" />.</param>
        <summary>Tworzy serwer proxy dla dobrze znanego obiektu wskazywanego przez określony typ, adres URL i dane kanału.</summary>
        <returns>Serwer proxy, który wskazuje punkt końcowy obsługiwany przez żądany dobrze znany obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj serwer proxy, aby wysyłać komunikaty do zdalnego obiektu. Żadne komunikaty nie są wysyłane przez sieć do momentu wywołania metody na serwerze proxy.  
  
 Parametr przekazuje informacje do kanału i jest przekazywany <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> do metody. `state`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />lub <paramref name="url" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="type" />nie jest zorganizowany przez odwołanie i nie jest interfejsem.</exception>
        <exception cref="T:System.MemberAccessException">Ten element członkowski został wywołany z użyciem mechanizmu opóźnionego wiązania.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Activator.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Activator.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Activator::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="rgszNames">Przekazana Tablica nazw do mapowania.</param>
        <param name="cNames">Liczba nazw do mapowania.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować nazwy.</param>
        <param name="rgDispId">Tablica przypisana przez obiekt wywołujący, która odbiera identyfikatory odpowiadające nazwom.</param>
        <summary>Zestaw nazw jest mapowany na odpowiedni zestaw identyfikatorów wysyłania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do uzyskiwania dostępu do zarządzanych klas z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Więcej informacji o `IDispatch::GetIDsOfNames`programie znajduje się w bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Activator.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informacje o typie, który będzie zwracany.</param>
        <param name="lcid">Identyfikator regionalny dla informacji o typie.</param>
        <param name="ppTInfo">Obiekt, który odbiera wskaźnik do żądanego obiektu informacji o typie.</param>
        <summary>Pobiera informacje o typie dla obiektu, których następnie można użyć do uzyskania informacji o typie interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do uzyskiwania dostępu do zarządzanych klas z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Więcej informacji o `IDispatch::GetTypeInfo`programie znajduje się w bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Activator.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Gdy ta metoda zwraca, zawiera wskaźnik do lokalizacji, która otrzymuje liczbę interfejsów informacji o typie dostarczonych przez obiekt. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Pobiera informację o liczbie typów interfejsów, jakie zawiera obiekt (0 lub 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do uzyskiwania dostępu do zarządzanych klas z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Więcej informacji o `IDispatch::GetTypeInfoCount`programie znajduje się w bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.Invoke">
      <MemberSignature Language="C#" Value="void _Activator.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Activator.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Activator::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identyfikator wysyłania, który identyfikuje członka.</param>
        <param name="riid">Zarezerwowane do użytku w przyszłości. Musi być wartością IID_NULL.</param>
        <param name="lcid">Ustawienia regionalne kontekstu, w którym można interpretować argumenty.</param>
        <param name="wFlags">Flagi opisujące kontekst wywołania.</param>
        <param name="pDispParams">Wskaźnik do struktury zawierającej tablicę argumentów, tablicę identyfikatorów SPID argumentów dla nazwanych argumentów oraz liczbę elementów w tablicach.</param>
        <param name="pVarResult">Wskaźnik do lokalizacji, w której ma zostać zapisany wynik.</param>
        <param name="pExcepInfo">Wskaźnik do struktury zawierającej informacje o wyjątku.</param>
        <param name="puArgErr">Indeks pierwszego argumentu, który zawiera błąd.</param>
        <summary>Umożliwia dostęp do właściwości i metod udostępnianych przez obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do uzyskiwania dostępu do zarządzanych klas z niezarządzanego kodu i nie powinna być wywoływana z kodu zarządzanego. Więcej informacji o `IDispatch::Invoke`programie znajduje się w bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Dostęp z późnym wiązaniem przy użyciu interfejsu COM <c>IDispatch</c> nie jest obsługiwany.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
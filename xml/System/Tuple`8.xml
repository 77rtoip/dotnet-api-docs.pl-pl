<Type Name="Tuple&lt;T1,T2,T3,T4,T5,T6,T7,TRest&gt;" FullName="System.Tuple&lt;T1,T2,T3,T4,T5,T6,T7,TRest&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c4104fd3573b1019e77761503a22437044c8581f" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69404766" /></Metadata><TypeSignature Language="C#" Value="public class Tuple&lt;T1,T2,T3,T4,T5,T6,T7,TRest&gt; : IComparable, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Tuple`8&lt;T1, T2, T3, T4, T5, T6, T7, TRest&gt; extends System.Object implements class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.IComparable" />
  <TypeSignature Language="DocId" Value="T:System.Tuple`8" />
  <TypeSignature Language="VB.NET" Value="Public Class Tuple(Of T1, T2, T3, T4, T5, T6, T7, TRest)&#xA;Implements IComparable, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename TRest&gt;&#xA;public ref class Tuple : IComparable, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt; = class&#xA;    interface IStructuralEquatable&#xA;    interface IStructuralComparable&#xA;    interface IComparable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T1" />
    <TypeParameter Name="T2" />
    <TypeParameter Name="T3" />
    <TypeParameter Name="T4" />
    <TypeParameter Name="T5" />
    <TypeParameter Name="T6" />
    <TypeParameter Name="T7" />
    <TypeParameter Name="TRest" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T1">Typ pierwszego składnika spójnej kolekcji.</typeparam>
    <typeparam name="T2">Typ drugiego składnika spójnej kolekcji.</typeparam>
    <typeparam name="T3">Typ trzeciego składnika spójnej kolekcji.</typeparam>
    <typeparam name="T4">Typ czwartego składnika spójnej kolekcji.</typeparam>
    <typeparam name="T5">Typ piątego składnika spójnej kolekcji.</typeparam>
    <typeparam name="T6">Typ szóstego składnika krotki.</typeparam>
    <typeparam name="T7">Typ siódmego składnika spójnej kolekcji.</typeparam>
    <typeparam name="TRest">Dowolny obiekt <see langword="Tuple" /> generyczny, który definiuje typy pozostałych składników krotki.</typeparam>
    <summary>Reprezentuje krotkę *n*, gdzie *n* jest 8 lub większa.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spójna kolekcja to struktura danych, która ma określoną liczbę i kolejność wartości. Klasa reprezentuje krotkę n, która ma osiem lub więcej składników. ** <xref:System.Tuple%608>  
  
 Można utworzyć wystąpienie <xref:System.Tuple%608> obiektu z dokładnie ośmiu składnikami przez wywołanie metody statycznej <xref:System.Tuple.Create%2A?displayProperty=nameWithType> . Poniższy przykład tworzy 8-krotkę (Octuple), która zawiera liczby podstawowe, które są mniejsze niż 20. Należy zauważyć, że używa wnioskowania o typie do określenia typu każdego składnika.  
  
 [!code-csharp[System.Tuple.Create#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple.create/cs/createntuple.cs#17)]
 [!code-vb[System.Tuple.Create#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple.create/vb/createntuple.vb#17)]  
  
 Można również utworzyć wystąpienie dla obiektu krotki n z co najmniej ośmiu składnikami, wywołując <xref:System.Tuple%608.%23ctor%2A> Konstruktor. Poniższy przykład używa <xref:System.Tuple%608.%23ctor%2A> konstruktora do utworzenia 8-spójnej kolekcji, która jest równoważna spójnej kolekcji utworzonej w poprzednim przykładzie.  
  
 [!code-csharp[System.Tuple\`8.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.class/cs/octuple1.cs#1)]
 [!code-vb[System.Tuple\`8.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.class/vb/octuple1.vb#1)]  
  
> [!NOTE]
>  Aby utworzyć krotkę n z dziewięcioma lub większą liczbą składników, należy wywołać <xref:System.Tuple%608.%23ctor%2A> konstruktora. Statyczne metody <xref:System.Tuple> fabryki klasy nie obsługują `Tuple` tworzenia obiektów z więcej niż ośmiu składnikami.  
  
 Aby utworzyć wystąpienie n-spójnej kolekcji zawierającej osiem lub więcej składników <xref:System.Tuple%608.%23ctor%2A> z konstruktorem, należy podać `Tuple` obiekt generyczny `rest` jako parametr, aby zdefiniować osiem za pomocą *n*-tych składników spójnej kolekcji. Zagnieżdżając obiekty generyczne `Tuple` w ten sposób, można utworzyć krotkę, która nie ma praktycznego ograniczenia liczby jego składników.  
  
 Poniższy przykład obejmuje tworzenie spójnej kolekcji 17, która zawiera dane populacji dla miasta Detroit, Michigan, dla każdego krajowego spisu od 1860 do 2000. Pierwszym składnikiem krotki jest nazwa miasta. Drugi składnik jest datą początkową serii danych, a trzeci składnik jest populacją w dniu rozpoczęcia. Każdy kolejny składnik zawiera populację w odstępach czasowych. 17-Krotka jest tworzona przez zagnieżdżanie <xref:System.Tuple%603> obiektu <xref:System.Tuple%608> wewnątrz obiektu. (Oznacza to, <xref:System.Tuple%603> że obiekt jest dostarczany jako wartość `rest` parametru w <xref:System.Tuple%608> konstruktorze klasy). Ten <xref:System.Tuple%608> obiekt jest z kolei zagnieżdżony w obiekcie zewnętrznym <xref:System.Tuple%608> . (Oznacza to, <xref:System.Tuple%608> że obiekt jest dostarczany jako wartość `rest` parametru w konstruktorze klasy zewnętrznego <xref:System.Tuple%608> obiektu).  
  
 [!code-csharp[System.Tuple.Create#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple.create/cs/example.cs#19)]
 [!code-vb[System.Tuple.Create#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple.create/vb/example.vb#19)]  
  
 Można pobrać wartość pierwszych siedmiu składników krotki przy użyciu właściwości tylko <xref:System.Tuple%607.Item1%2A>do odczytu <xref:System.Tuple%607.Item3%2A>, <xref:System.Tuple%607.Item2%2A>,, <xref:System.Tuple%607.Item6%2A> <xref:System.Tuple%607.Item4%2A> <xref:System.Tuple%607.Item5%2A>, i <xref:System.Tuple%607.Item7%2A> wystąpienia. Wszystkie dodatkowe składniki są zagnieżdżane i można je pobrać z <xref:System.Tuple%608.Rest%2A> właściwości. W poprzednim przykładzie <xref:System.Tuple%608.Item1%2A> właściwości through <xref:System.Tuple%608.Item7%2A> pobierają pierwszy z siódmych składników spójnej kolekcji. Osiem przez czternaste składniki są zawarte w spójnej kolekcji, która jest zagnieżdżona na drugim poziomie i są reprezentowane przez `Rest.Item1` właściwości `Rest.Item7` przez. Elementy od 15 do siedemnastu są zawarte w spójnej kolekcji, która jest zagnieżdżona na trzecim poziomie i są reprezentowane `Rest.Rest.Item1` przez `Rest.Rest.Item3` właściwości.  
  
 Spójne kolekcje są powszechnie wykorzystywane na cztery różne sposoby:  
  
-   Reprezentowanie jednego zestawu danych. Na przykład spójna kolekcja może reprezentować rekord bazy danych, a jej składniki mogą reprezentować poszczególne pola rekordu.  
  
-   Zapewnienie łatwego dostępu do zestawu danych i możliwości wykonywania w nim różnych operacji.  
  
-   Aby zwrócić wiele wartości z metody bez użycia `out` parametrów (in C#) lub `ByRef` Parameters (w Visual Basic). Na przykład poprzedni przykład zwraca obliczone statystyki wraz z nazwą miasta w <xref:System.Tuple%607> obiekcie.  
  
-   Przekazywanie wielu wartości do metody za pomocą jednego parametru. Na przykład <xref:System.Threading.Thread.Start%28System.Object%29?displayProperty=nameWithType> Metoda ma jeden parametr, który umożliwia podawanie jednej wartości metodzie wykonywanej przez wątek przy uruchamianiu. W przypadku podania <xref:System.Tuple%607> obiektu jako argumentu metody można dostarczyć procedurę uruchamiania wątku z siedmiu elementami danych.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Tuple" />
    <altmember cref="T:System.Tuple`1" />
    <altmember cref="T:System.Tuple`2" />
    <altmember cref="T:System.Tuple`3" />
    <altmember cref="T:System.Tuple`4" />
    <altmember cref="T:System.Tuple`5" />
    <altmember cref="T:System.Tuple`6" />
    <altmember cref="T:System.Tuple`7" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Tuple (T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T1 item1, !T2 item2, !T3 item3, !T4 item4, !T5 item5, !T6 item6, !T7 item7, !TRest rest) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.#ctor(`0,`1,`2,`3,`4,`5,`6,`7)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (item1 As T1, item2 As T2, item3 As T3, item4 As T4, item5 As T5, item6 As T6, item7 As T7, rest As TRest)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);" />
      <MemberSignature Language="F#" Value="new Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt; : 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'Rest -&gt; Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;" Usage="new System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt; (item1, item2, item3, item4, item5, item6, item7, rest)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
        <Parameter Name="item2" Type="T2" />
        <Parameter Name="item3" Type="T3" />
        <Parameter Name="item4" Type="T4" />
        <Parameter Name="item5" Type="T5" />
        <Parameter Name="item6" Type="T6" />
        <Parameter Name="item7" Type="T7" />
        <Parameter Name="rest" Type="TRest" />
      </Parameters>
      <Docs>
        <param name="item1">Wartość pierwszego składnika spójnej kolekcji.</param>
        <param name="item2">Wartość drugiego składnika spójnej kolekcji.</param>
        <param name="item3">Wartość trzeciego składnika spójnej kolekcji.</param>
        <param name="item4">Wartość czwartego składnika spójnej kolekcji.</param>
        <param name="item5">Wartość piątego składnika spójnej kolekcji.</param>
        <param name="item6">Wartość szóstego składnika krotki.</param>
        <param name="item7">Wartość siódmego składnika krotki.</param>
        <param name="rest">Dowolny obiekt <see langword="Tuple" /> generyczny, który zawiera wartości pozostałych składników krotki.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Tuple`8" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można również użyć metody statycznej <xref:System.Tuple.Create%2A?displayProperty=nameWithType> , aby utworzyć wystąpienie obiektu z 8-krotką (Octuple) bez konieczności jawnego określania typów jego składników. Poniższy przykład używa <xref:System.Tuple.Create%2A?displayProperty=nameWithType> metody, aby utworzyć wystąpienie obiektu z 8-spoiny, który zawiera liczby podstawowe, które są mniejsze niż 20.  
  
 [!code-csharp[System.Tuple.Create#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple.create/cs/createntuple.cs#17)]
 [!code-vb[System.Tuple.Create#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple.create/vb/createntuple.vb#17)]  
  
 Jest to równoważne następującej wywołaniu <xref:System.Tuple%607.%23ctor%2A> konstruktora klasy.  
  
 [!code-csharp[System.Tuple\`8.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.class/cs/octuple1.cs#1)]
 [!code-vb[System.Tuple\`8.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.class/vb/octuple1.vb#1)]  
  
 Jednak metoda statyczna <xref:System.Tuple.Create%2A?displayProperty=nameWithType> nie może być używana do tworzenia obiektu krotki z więcej niż ośmiu składnikami.  
  
 Podczas używania <xref:System.Tuple%608.%23ctor%2A> konstruktora do tworzenia n-spoiny z co najmniej ośmiu składnikami, należy `rest` użyć parametru, aby utworzyć zagnieżdżoną krotkę n, która składa się z jednego do siedmiu składników. Korzystając z kolejnych poziomów zagnieżdżenia, można utworzyć n-krotkę, która ma praktycznie nieograniczoną liczbę składników. Na przykład, aby utworzyć 25-kolekcję, należy utworzyć wystąpienie <xref:System.Tuple%608> obiektu z trzema poziomami zagnieżdżenia w następujący sposób:  
  
-   Najbardziej zewnętrzny <xref:System.Tuple%608> obiekt zawiera pierwsze i siódme składniki. Jego <xref:System.Tuple%608.Rest%2A> Właściwość zapewnia dostęp <xref:System.Tuple%608> do obiektu na pierwszym poziomie zagnieżdżania.  
  
-   Najbardziej zewnętrzny obiekt <xref:System.Tuple%608> zagnieżdżony zawiera osiem przez czternaste składniki, a <xref:System.Tuple%608.Rest%2A> jego <xref:System.Tuple%608> Właściwość zapewnia dostęp do obiektu na drugim poziomie zagnieżdżania.  
  
-   Obiekt na drugim poziomie zagnieżdżania zawiera 15 do dwudziestu pierwszego składnika, a jego <xref:System.Tuple%608.Rest%2A> <xref:System.Tuple%604> Właściwość zapewnia dostęp do obiektu na trzecim poziomie zagnieżdżania. <xref:System.Tuple%608>  
  
-   Wewnętrzna Krotka jest <xref:System.Tuple%604> obiektem, który zawiera dwadzieścia sekund przez dwadzieścia piąte składniki.  
  
   
  
## Examples  
 W poniższym przykładzie jest tworzona krotka 17, która zawiera dane populacji dla miasta Detroit, Michigan, dla każdego spisu od 1860 do 2000. Pierwszym składnikiem krotki jest nazwa miasta. Drugi składnik jest datą początkową serii danych, a trzeci składnik jest populacją w dniu rozpoczęcia. Każdy kolejny składnik zawiera populację w odstępach czasowych. W przykładzie zastosowano dwie warstwy zagnieżdżania w celu utworzenia krotki 17: Definiuje 7-krotkę, z której trzecimi składnikami zawiera dane populacji dla 1860 do 1900, zagnieżdżoną krotkę 7, która zawiera dane populacji dla 1910 przez 1970, oraz wewnętrzną, zagnieżdżoną spójną krotkę, która zawiera dane populacji dla 1980 przez 2000.  
  
 [!code-csharp[System.Tuple.Create#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple.create/cs/example.cs#19)]
 [!code-vb[System.Tuple.Create#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple.create/vb/example.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rest" />nie jest obiektem <see langword="Tuple" /> ogólnym.</exception>
        <altmember cref="M:System.Tuple.Create``8(``0,``1,``2,``3,``4,``5,``6,``7)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="tuple.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, który ma zostać porównany z tym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy bieżący <see cref="T:System.Tuple`8" /> obiekt jest równy podanemu obiektowi.</summary>
        <returns><see langword="true" />Jeśli bieżące wystąpienie jest równe podanemu obiektowi; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `obj` Parametr jest traktowany jako równy bieżącemu wystąpieniu, jeśli spełnia wszystkie następujące warunki:  
  
-   Jest <xref:System.Tuple%608> to obiekt.  
  
-   Ma taką samą łączną liczbę składników, które są tego samego typu jak bieżące wystąpienie.  
  
-   Jego składniki (w tym składniki zagnieżdżone) są równe bieżącym wystąpieniu. Równość jest określana przez domyślną funkcję porównującą równość dla każdego składnika.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano <xref:System.Tuple%608> pięć obiektów, które zawierają liczby podstawowe. Następnie porównuje pierwszy obiekt z każdym z pozostałych obiektów. Jak widać na danych wyjściowych, tylko pierwszy i ostatni <xref:System.Tuple%608> obiekt są równe, ponieważ mają taką samą liczbę składników o identycznych wartościach.  
  
 [!code-csharp[System.Tuple\`8.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.equals/cs/equals1.cs#1)]
 [!code-vb[System.Tuple\`8.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="tuple.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Oblicza wartość skrótu dla bieżącego <see cref="T:System.Tuple`8" /> obiektu.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item1">
      <MemberSignature Language="C#" Value="public T1 Item1 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T1 Item1" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item1" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item1 As T1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T1 Item1 { T1 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item1 : 'T1" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T1</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość pierwszego składnika bieżącego <see cref="T:System.Tuple`8" /> obiektu.</summary>
        <value>Wartość pierwszego składnika bieżącego <see cref="T:System.Tuple`8" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ <xref:System.Tuple%608.Item1%2A> składnika można dynamicznie określić na jeden z dwóch sposobów:  
  
-   Przez wywołanie `GetType` metody na wartości zwracanej <xref:System.Tuple%608.Item1%2A> przez właściwość.  
  
-   Pobierając <xref:System.Type> obiekt, który <xref:System.Tuple%608> reprezentuje obiekt, i pobierając pierwszy element z tablicy, która jest zwracana przez jego <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metodę.  
  
   
  
## Examples  
 W poniższym przykładzie nastąpi utworzenie obiektu 17-elementowej spójnej kolekcji zawierającego dane o ludności miasta Detroit (stan Michigan) w latach 1860-2000. Pierwszym składnikiem 17-spoiny jest nazwa miasta. W przykładzie użyta <xref:System.Tuple%608.Item1%2A> jest właściwość w celu wyświetlenia nazwy miasta w nagłówku tabeli przed wyświetleniem danych populacji.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item2">
      <MemberSignature Language="C#" Value="public T2 Item2 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T2 Item2" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item2" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item2 As T2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T2 Item2 { T2 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item2 : 'T2" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item2" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T2</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość drugiego składnika bieżącego <see cref="T:System.Tuple`8" /> obiektu.</summary>
        <value>Wartość drugiego składnika bieżącego <see cref="T:System.Tuple`8" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ <xref:System.Tuple%608.Item2%2A> składnika można dynamicznie określić na jeden z dwóch sposobów:  
  
-   Przez wywołanie `GetType` metody na wartości zwracanej <xref:System.Tuple%608.Item2%2A> przez właściwość.  
  
-   Pobierając <xref:System.Type> obiekt, który <xref:System.Tuple%608> reprezentuje obiekt, i pobierając drugi element z tablicy, która jest zwracana przez jego <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metodę.  
  
   
  
## Examples  
 W poniższym przykładzie nastąpi utworzenie obiektu 17-elementowej spójnej kolekcji zawierającego dane o ludności miasta Detroit (stan Michigan) w latach 1860-2000. Drugim składnikiem 17-krotek jest pierwszy rok serii danych. Przykład przypisuje wartość <xref:System.Tuple%608.Item2%2A> właściwości do zmiennej, a następnie używa tej zmiennej do reprezentowania roku, którego dane są wyświetlane.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item3">
      <MemberSignature Language="C#" Value="public T3 Item3 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T3 Item3" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item3" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item3 As T3" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T3 Item3 { T3 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item3 : 'T3" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item3" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T3</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość trzeciego składnika bieżącego <see cref="T:System.Tuple`8" /> obiektu.</summary>
        <value>Wartość trzeciego składnika bieżącego <see cref="T:System.Tuple`8" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ <xref:System.Tuple%608.Item3%2A> składnika można dynamicznie określić na jeden z dwóch sposobów:  
  
-   Przez wywołanie `GetType` metody na wartości zwracanej <xref:System.Tuple%608.Item3%2A> przez właściwość.  
  
-   Pobierając <xref:System.Type> obiekt, który <xref:System.Tuple%608> reprezentuje obiekt, i pobierając trzeci element z tablicy, która jest zwracana przez jego <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metodę.  
  
   
  
## Examples  
 W poniższym przykładzie nastąpi utworzenie obiektu 17-elementowej spójnej kolekcji zawierającego dane o ludności miasta Detroit (stan Michigan) w latach 1860-2000. Trzeci składnik 17-spoiny jest populacją w 1860. W przykładzie używa <xref:System.Tuple%608.Item3%2A> się właściwości, aby wyświetlić wartość populacji i obliczyć roczną stawkę zmiany populacji z przedziału od 1860 do 1870.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item4">
      <MemberSignature Language="C#" Value="public T4 Item4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T4 Item4" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item4" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item4 As T4" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T4 Item4 { T4 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item4 : 'T4" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T4</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość czwartego składnika bieżącego <see cref="T:System.Tuple`8" /> obiektu.</summary>
        <value>Wartość czwartego składnika bieżącego <see cref="T:System.Tuple`8" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ <xref:System.Tuple%608.Item4%2A> składnika można dynamicznie określić na jeden z dwóch sposobów:  
  
-   Przez wywołanie `GetType` metody na wartości zwracanej <xref:System.Tuple%608.Item4%2A> przez właściwość.  
  
-   Pobierając <xref:System.Type> obiekt, który <xref:System.Tuple%608> reprezentuje obiekt, i pobierając czwarty element z tablicy, która jest zwracana przez jego <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metodę.  
  
   
  
## Examples  
 W poniższym przykładzie nastąpi utworzenie obiektu 17-elementowej spójnej kolekcji zawierającego dane o ludności miasta Detroit (stan Michigan) w latach 1860-2000. Czwarty składnik 17-spoiny jest populacją w 1870. W przykładzie używa <xref:System.Tuple%608.Item4%2A> się właściwości, aby wyświetlić wartość populacji i obliczyć roczną stawkę zmiany populacji z przedziału od 1870 do 1880.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item5">
      <MemberSignature Language="C#" Value="public T5 Item5 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T5 Item5" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item5" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item5 As T5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T5 Item5 { T5 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item5 : 'T5" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item5" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T5</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość piątego składnika bieżącego <see cref="T:System.Tuple`8" /> obiektu.</summary>
        <value>Wartość piątego składnika bieżącego <see cref="T:System.Tuple`8" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ <xref:System.Tuple%608.Item5%2A> składnika można dynamicznie określić na jeden z dwóch sposobów:  
  
-   Przez wywołanie `GetType` metody na wartości zwracanej <xref:System.Tuple%608.Item5%2A> przez właściwość.  
  
-   Pobierając <xref:System.Type> obiekt, który <xref:System.Tuple%608> reprezentuje obiekt, i pobierając piątego elementu z tablicy, która jest zwracana przez jego <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metodę.  
  
   
  
## Examples  
 W poniższym przykładzie nastąpi utworzenie obiektu 17-elementowej spójnej kolekcji zawierającego dane o ludności miasta Detroit (stan Michigan) w latach 1860-2000. Piątym składnikiem 17-krotek jest populacja w 1880. W przykładzie używa <xref:System.Tuple%608.Item5%2A> się właściwości, aby wyświetlić wartość populacji i obliczyć roczną stawkę zmiany populacji z przedziału od 1880 do 1890.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item6">
      <MemberSignature Language="C#" Value="public T6 Item6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T6 Item6" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item6" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item6 As T6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T6 Item6 { T6 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item6 : 'T6" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T6</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość szóstego składnika bieżącego <see cref="T:System.Tuple`8" /> obiektu.</summary>
        <value>Wartość szóstego składnika bieżącego <see cref="T:System.Tuple`8" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ <xref:System.Tuple%608.Item6%2A> składnika można dynamicznie określić na jeden z dwóch sposobów:  
  
-   Przez wywołanie `GetType` metody na wartości zwracanej <xref:System.Tuple%608.Item6%2A> przez właściwość.  
  
-   Pobierając <xref:System.Type> obiekt, który <xref:System.Tuple%608> reprezentuje obiekt, i pobierając szósty element z tablicy, która jest zwracana przez jego <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metodę.  
  
   
  
## Examples  
 W poniższym przykładzie nastąpi utworzenie obiektu 17-elementowej spójnej kolekcji zawierającego dane o ludności miasta Detroit (stan Michigan) w latach 1860-2000. Szósty składnik 17-spoiny jest populacją w 1890. W przykładzie używa <xref:System.Tuple%608.Item6%2A> się właściwości, aby wyświetlić wartość populacji i obliczyć roczną stawkę zmiany populacji z przedziału od 1890 do 1900.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item7">
      <MemberSignature Language="C#" Value="public T7 Item7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T7 Item7" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item7" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item7 As T7" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T7 Item7 { T7 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item7 : 'T7" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T7</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość siódmego składnika bieżącego <see cref="T:System.Tuple`8" /> obiektu.</summary>
        <value>Wartość siódmego składnika bieżącego <see cref="T:System.Tuple`8" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ <xref:System.Tuple%608.Item7%2A> składnika można dynamicznie określić na jeden z dwóch sposobów:  
  
-   Przez wywołanie `GetType` metody na wartości zwracanej <xref:System.Tuple%608.Item7%2A> przez właściwość.  
  
-   Pobierając <xref:System.Type> obiekt, który <xref:System.Tuple%608> reprezentuje obiekt, i pobierając siódmy element z tablicy, która jest zwracana przez jego <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metodę.  
  
   
  
## Examples  
 W poniższym przykładzie nastąpi utworzenie obiektu 17-elementowej spójnej kolekcji zawierającego dane o ludności miasta Detroit (stan Michigan) w latach 1860-2000. Siódmym składnikiem 17-krotek jest populacja w 1900. W przykładzie używa <xref:System.Tuple%608.Item7%2A> się właściwości, aby wyświetlić wartość populacji i obliczyć roczną stawkę zmiany populacji z przedziału od 1900 do 1910.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rest">
      <MemberSignature Language="C#" Value="public TRest Rest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TRest Rest" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Rest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rest As TRest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TRest Rest { TRest get(); };" />
      <MemberSignature Language="F#" Value="member this.Rest : 'Rest" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Rest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TRest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pozostałe składniki <see cref="T:System.Tuple`8" /> bieżącego obiektu.</summary>
        <value>Wartość pozostałych składników bieżącego <see cref="T:System.Tuple`8" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zwraca zagnieżdżony `Tuple` obiekt, który umożliwia dostęp do ośmiu, ale nie wszystkie składniki spójnej kolekcji. ** <xref:System.Tuple%608.Rest%2A> W zależności od łącznej liczby składników w spójnej części składowych można pobrać z `Tuple` <xref:System.Tuple%608.Item1%2A> obiektów <xref:System.Tuple%608.Item7%2A> zagnieżdżonych za pośrednictwem właściwości. Następnie można użyć <xref:System.Tuple%608.Rest%2A> właściwości obiektu zagnieżdżonego <xref:System.Tuple%608> , aby pobrać `Tuple` obiekt na następnym poziomie zagnieżdżania.  
  
 Można dynamicznie określić liczbę składników w obiekcie zagnieżdżonym `Tuple` zwracanym <xref:System.Tuple%608.Rest%2A> przez właściwość przez wyodrębnienie cyfry z nazwy typu. Poniższy przykład stanowi ilustrację.  
  
 [!code-vb[System.Tuple\`8.Item1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/rest.vb#2)]  
  
   
  
## Examples  
 W poniższym przykładzie nastąpi utworzenie obiektu 17-elementowej spójnej kolekcji zawierającego dane o ludności miasta Detroit (stan Michigan) w latach 1860-2000. Siódmym składnikiem 17-krotek jest populacja w 1900. W przykładzie używa <xref:System.Tuple%608.Rest%2A> się właściwości, aby pobrać wartości ósmej za pośrednictwem czternastych składników i <xref:System.Tuple%608.Rest%2A> używa właściwości obiektu zagnieżdżonego <xref:System.Tuple%608> do pobrania wartości pozostałych składników.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt, który ma zostać porównany z bieżącym wystąpieniem.</param>
        <param name="comparer">Obiekt dostarczający niestandardowe reguły na potrzeby porównania.</param>
        <summary>Porównuje bieżący <see cref="T:System.Tuple`8" /> obiekt z określonym obiektem przy użyciu określonej funkcji porównującej i zwraca liczbę całkowitą, która wskazuje, czy bieżący obiekt jest przed, po lub w tym samym położeniu, co określony obiekt w kolejności sortowania.</summary>
        <returns>Liczba całkowita ze znakiem, która wskazuje względną pozycję tego <paramref name="other" /> wystąpienia i w kolejności sortowania, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Opis 
 </description></listheader><item><term> Ujemna liczba całkowita 
 </term><description> To wystąpienie poprzedza <paramref name="other" />.  
  
 </description></item><item><term> Zero 
 </term><description> To wystąpienie i <paramref name="other" /> ma takie same położenie w kolejności sortowania.  
  
 </description></item><item><term> Dodatnia liczba całkowita 
 </term><description> To wystąpienie jest <paramref name="other" />następujące.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element członkowski jest jawną implementacją interfejsu. Może być używana tylko wtedy, <xref:System.Tuple%608> gdy wystąpienie jest rzutowane <xref:System.Collections.IStructuralComparable> do interfejsu.  
  
 Ta metoda pozwala definiować dostosowane porównania <xref:System.Tuple%608> obiektów. Na przykład można użyć tej metody do porządkowania <xref:System.Tuple%608> obiektów na podstawie wartości określonego składnika.  
  
 Chociaż ta metoda może być wywoływana bezpośrednio, jest najczęściej wywoływana przez metody sortowania kolekcji, które obejmują <xref:System.Collections.IComparer> parametry w celu uporządkowania elementów członkowskich kolekcji. Na przykład jest wywoływana <xref:System.Array.Sort%28System.Array%2CSystem.Collections.IComparer%29?displayProperty=nameWithType> przez metodę <xref:System.Collections.SortedList.Add%2A> i metodę <xref:System.Collections.SortedList> <xref:System.Collections.SortedList.%23ctor%28System.Collections.IComparer%29?displayProperty=nameWithType> obiektu, którego wystąpienie jest tworzone przy użyciu konstruktora.  
  
> [!CAUTION]
>  <xref:System.Tuple%608.System%23Collections%23IStructuralComparable%23CompareTo%2A> Metoda jest przeznaczona do użycia podczas sortowania operacji. Nie należy jej używać, gdy głównym celem porównania jest ustalenie, czy dwa obiekty są sobie równe. Aby określić, czy dwa obiekty są równe, wywołaj <xref:System.Tuple%608.System%23Collections%23IStructuralEquatable%23Equals%2A> metodę.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę <xref:System.Tuple%608> obiektów, która zawiera dane populacji dla czterech miast USA od 1940 do 2000. Pierwszy składnik Octuple jest nazwą miasta. Pozostałe sześć składników reprezentuje populację w odstępach 10-letnich od 1940 do 2000.  
  
 `PopulationComparer` Klasa<xref:System.Collections.IComparer> zawiera implementację, która umożliwia posortowanie tablicy octuples według jednego z jej składników. W Konstruktorze są podane `PopulationComparer` dwie wartości: Pozycja składnika, która definiuje porządek sortowania, oraz <xref:System.Boolean> wartość wskazującą, czy obiekty krotek mają być sortowane w kolejności rosnącej czy malejącej.  
  
 Przykład wyświetla elementy w tablicy w niesortowanej kolejności, sortuje je według trzeciego składnika (populacji w 1950) i wyświetla je, a następnie sortuje je według ósmego składnika (populacja w 2000) i wyświetla je.  
  
 [!code-csharp[System.Tuple\`8.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.compareto/cs/compareto2.cs#2)]
 [!code-vb[System.Tuple\`8.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.compareto/vb/compareto2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="other" />nie <see cref="T:System.Tuple`8" /> jest obiektem.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt, który ma zostać porównany z tym wystąpieniem.</param>
        <param name="comparer">Obiekt definiujący metodę służącą ocenie, czy dwa obiekty są sobie równe.</param>
        <summary>Zwraca wartość wskazującą, czy bieżący <see cref="T:System.Tuple`8" /> obiekt jest równy podanemu obiektowi w oparciu o określoną metodę porównania.</summary>
        <returns><see langword="true" />Jeśli bieżące wystąpienie jest równe podanemu obiektowi; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Tuple%608> gdy wystąpienie jest rzutowane <xref:System.Collections.IStructuralEquatable> do interfejsu.  
  
 C# <xref:System.Tuple%608> `null` `other` Implementacja jest wywoływana tylko wtedy, gdy nie jest, i jeśli można ją pomyślnie rzutować (w) lub skonwertować (w Visual Basic) do obiektu, który ma taką samą całkowitą liczbę składników (łącznie z tymi w <xref:System.Collections.IEqualityComparer.Equals%2A?displayProperty=nameWithType> obiekty `Tuple` zagnieżdżone) tego samego typu co bieżące wystąpienie. Metoda najpierw <xref:System.Collections.IEqualityComparer.Equals%2A?displayProperty=nameWithType> przekazuje wartości obiektów<xref:System.Tuple%608> do porównania z implementacją. <xref:System.Tuple%608.Item1%2A> <xref:System.Tuple%608.System%23Collections%23IStructuralEquatable%23Equals%28System.Object%2CSystem.Collections.IEqualityComparer%29> Jeśli wywołanie metody zwróci wartość `true`, Metoda zostanie wywołana ponownie i <xref:System.Tuple%608.Item2%2A> przekazała wartości dwóch <xref:System.Tuple%608> obiektów. Ten proces jest kontynuowany do momentu, `false` gdy porównuje określoną parę wartości z wywołaniem metody, lub dwie <xref:System.Tuple%608.Rest%2A> wartości są przenoszone do metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">Obiekt, którego <see cref="M:System.Collections.IEqualityComparer.GetHashCode(System.Object)" /> Metoda oblicza kod skrótu bieżącego <see cref="T:System.Tuple`8" /> obiektu.</param>
        <summary>Oblicza kod skrótu dla bieżącego <see cref="T:System.Tuple`8" /> obiektu za pomocą określonej metody obliczeniowej.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Tuple%608> gdy wystąpienie jest rzutowane <xref:System.Collections.IStructuralEquatable> do interfejsu.  
  
 Metoda po prostu zawija wywołanie do `comparer` <xref:System.Collections.IEqualityComparer.GetHashCode%2A?displayProperty=nameWithType> implementacji obiektu.  
  
 Algorytm używany do obliczania kodu skrótu powinien zwracać ten sam kod skrótu dla dwóch <xref:System.Tuple%608> obiektów, które są uważane za równe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, który ma zostać porównany z bieżącym wystąpieniem.</param>
        <summary>Porównuje bieżący <see cref="T:System.Tuple`8" /> obiekt z określonym obiektem i zwraca liczbę całkowitą, która wskazuje, czy bieżący obiekt jest przed, po lub w tym samym położeniu, co określony obiekt w kolejności sortowania.</summary>
        <returns>Liczba całkowita ze znakiem, która wskazuje względną pozycję tego <paramref name="obj" /> wystąpienia i w kolejności sortowania, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Opis 
 </description></listheader><item><term> Ujemna liczba całkowita 
 </term><description> To wystąpienie poprzedza <paramref name="obj" />.  
  
 </description></item><item><term> Zero 
 </term><description> To wystąpienie i <paramref name="obj" /> ma takie same położenie w kolejności sortowania.  
  
 </description></item><item><term> Dodatnia liczba całkowita 
 </term><description> To wystąpienie jest <paramref name="obj" />następujące.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Tuple%608> gdy wystąpienie jest rzutowane <xref:System.IComparable> do interfejsu.  
  
 Ta metoda zapewnia <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> implementację <xref:System.Tuple%608> klasy. Mimo że metoda może być wywoływana bezpośrednio, jest najczęściej wywoływana przez domyślne przeciążenia metod sortowania kolekcji, takich jak <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> i <xref:System.Collections.SortedList.Add%2A?displayProperty=nameWithType>, w celu uporządkowania elementów członkowskich kolekcji.  
  
> [!CAUTION]
>  <xref:System.Tuple%608.System%23IComparable%23CompareTo%2A> Metoda jest przeznaczona do użycia podczas sortowania operacji. Nie należy jej używać, gdy głównym celem porównania jest ustalenie, czy dwa obiekty są sobie równe. Aby określić, czy dwa obiekty są równe, wywołaj <xref:System.Tuple%608.Equals%28System.Object%29?displayProperty=nameWithType> metodę.  
  
 Ta metoda używa domyślnej metody porównującej obiektów do porównywania każdego składnika.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę octuples, której składniki są liczbami całkowitymi, które zawierają zakres liczb pierwszych. W przykładzie przedstawiono elementy tablicy w kolejności niesortowanej, Sortuje tablicę, a następnie wyświetla tablicę w sortowanej kolejności. Dane wyjściowe pokazują, że tablica została posortowana <xref:System.Tuple%608.Item1%2A>według lub pierwszego składnika spójnej kolekcji. Należy zauważyć, że przykład nie wywołuje <xref:System.Tuple%608.System%23IComparable%23CompareTo%28System.Object%29> bezpośrednio metody. Ta metoda jest wywoływana niejawnie przez <xref:System.Array.Sort%28System.Array%29> metodę dla każdego elementu w tablicy.  
  
 [!code-csharp[System.Tuple\`8.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.compareto/cs/compareto1.cs#1)]
 [!code-vb[System.Tuple\`8.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.compareto/vb/compareto1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="obj" />nie <see cref="T:System.Tuple`8" /> jest obiektem.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.CompilerServices.ITuple.Item">
      <MemberSignature Language="C#" Value="object System.Runtime.CompilerServices.ITuple.Item[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Runtime.CompilerServices.ITuple.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.System#Runtime#CompilerServices#ITuple#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Item(index As Integer) As Object Implements ITuple.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Runtime::CompilerServices::ITuple::Item[int] { System::Object ^ get(int index); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.CompilerServices.ITuple.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.CompilerServices.ITuple.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">Indeks określonego <see langword="Tuple" /> elementu. <paramref name="index" />zakres od 0 do <see langword="Item1" /> jeden jest mniejszy niż liczba elementów <see langword="Tuple" />w.</param>
        <summary>Pobiera wartość określonego <see langword="Tuple" /> elementu.</summary>
        <value>Wartość <see langword="Tuple" /> elementu w określonej pozycji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Tuple%608.System%23Runtime%23CompilerServices%23ITuple%23Item%2A?displayProperty=nameWithType> Właściwość jest jawną implementacją interfejsu. Aby wywołać tę metodę, należy rzutować lub przekonwertować <xref:System.Tuple%608> obiekt <xref:System.Runtime.CompilerServices.ITuple> na obiekt interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="index" />jest większe lub równe <see cref="P:System.Tuple`8.System#Runtime#CompilerServices#ITuple#Length" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.CompilerServices.ITuple.Length">
      <MemberSignature Language="C#" Value="int System.Runtime.CompilerServices.ITuple.Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Runtime.CompilerServices.ITuple.Length" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.System#Runtime#CompilerServices#ITuple#Length" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Length As Integer Implements ITuple.Length" />
      <MemberSignature Language="C++ CLI" Value="property int System::Runtime::CompilerServices::ITuple::Length { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.CompilerServices.ITuple.Length" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.CompilerServices.ITuple.Length</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów w <see langword="Tuple" />.</summary>
        <value>Liczba elementów w <see langword="Tuple" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Tuple%608.System%23Runtime%23CompilerServices%23ITuple%23Length%2A> Właściwość jest jawną implementacją interfejsu. Aby wywołać tę metodę, należy rzutować lub skonwertować <xref:System.Tuple%608> typ <xref:System.Runtime.CompilerServices.ITuple> do obiektu interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="tuple.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ciąg, który reprezentuje wartość tego <see cref="T:System.Tuple`8" /> wystąpienia.</summary>
        <returns>Ciąg reprezentujący ten <see cref="T:System.Tuple`8" /> obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciąg zwracany przez tę metodę przyjmuje postać (*Item1 —*, *Item2 —*, *Item3 —*, *Item4 —*, `Item5, Item6, Item7`, *Item8 —*...), gdzie *Item1 —*, *Item2 —*, *Item3 —*, *Item4 —*, *Item5 —*,  *Item6 —* i *Item7 —* <xref:System.Tuple%608.Item1%2A>reprezentują wartości właściwości <xref:System.Tuple%608.Item2%2A> ,<xref:System.Tuple%608.Item7%2A> , <xref:System.Tuple%608.Item3%2A>, <xref:System.Tuple%608.Item4%2A> <xref:System.Tuple%608.Item5%2A>, ,i.<xref:System.Tuple%608.Item6%2A> *Item8 —* reprezentuje wartość <xref:System.Tuple%608> `Next.Item1` właściwości obiektu. Wartość wszelkich dodatkowych zagnieżdżonych składników jest zgodna z *Item8 —*. Jeśli dowolna z wartości właściwości jest `null`, jest reprezentowana jako. <xref:System.String.Empty?displayProperty=nameWithType>  
  
   
  
## Examples  
 Poniższy przykład obejmuje tworzenie spójnej kolekcji 17, która zawiera dane populacji dla miasta Detroit, Michigan, od 1860 do 1900. Następnie używa <xref:System.Tuple%608.ToString%2A> metody do wyświetlania danych krotki.  
  
 [!code-csharp[System.Tuple\`8.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Tuple\`8.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

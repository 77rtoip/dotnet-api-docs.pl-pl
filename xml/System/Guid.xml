<Type Name="Guid" FullName="System.Guid">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4f579b3263d4c8f6a549a812ccf125e5c8bff7df" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30744347" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Guid : IComparable, IComparable&lt;Guid&gt;, IEquatable&lt;Guid&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Guid extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Guid&gt;, class System.IEquatable`1&lt;valuetype System.Guid&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Guid" />
  <TypeSignature Language="VB.NET" Value="Public Structure Guid&#xA;Implements IComparable, IComparable(Of Guid), IEquatable(Of Guid), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Guid : IComparable, IComparable&lt;Guid&gt;, IEquatable&lt;Guid&gt;, IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Guid&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Guid&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje unikatowy identyfikator globalny (GUID).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator GUID jest całkowitą 128-bitowego (16 bajtów) mogą być używane na wszystkich komputerów i sieci, wszędzie tam, gdzie jest wymagany unikatowy identyfikator. Taki identyfikator ma bardzo niskich prawdopodobieństwo jest zduplikowany.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Runtime.InteropServices.GuidAttribute?displayProperty=nameWithType> klasy można przypisać identyfikatora GUID interfejsu i klasy zdefiniowanej przez użytkownika. Go pobiera wartość identyfikatora GUID przez wywołanie metody <xref:System.Attribute.GetCustomAttribute%2A> metody i porównuje ją z dwóch innych identyfikatorów GUID do określenia, czy są one takie same.  
  
 [!code-cpp[Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Guid/CPP/Guids.cpp#1)]
 [!code-csharp[Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Guid/CS/Guids.cs#1)]
 [!code-vb[Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Guid/VB/Guids.vb#1)]  
  
 Należy pamiętać, że <xref:System.Runtime.InteropServices.GuidAttribute> atrybutu jest zwykle używany w aplikacji do udostępnienia typu do modelu COM. Jeśli kompilacja w tym przykładzie, możesz uruchomić [narzędzie do rejestrowania zestawów (Regasm.exe)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md) w wygenerowanym zestawie można utworzyć rejestru (reg) typu plików bibliotek (.tlb). Plik reg można zarejestrować klasy coclass w rejestrze, a pliku .tlb zapewnia metadanych dla modelu COM interop.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Guid" /> struktury.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Guid (byte[] b);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (b As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Guid(cli::array &lt;System::Byte&gt; ^ b);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="b" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="b">Tablica bajtów elementu 16 zawierająca wartości, z którą ma zostać zainicjować identyfikatora GUID.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Guid" /> struktury przy użyciu określonej tablicy bajtów.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="b" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="b" /> to nie 16 bajtów.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Guid (ReadOnlySpan&lt;byte&gt; b);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.#ctor(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (b As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Guid(ReadOnlySpan&lt;System::Byte&gt; b);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="b" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="b">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Guid (string g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (g As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Guid(System::String ^ g);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="g" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="g">Ciąg, który zawiera identyfikator GUID w jednym z następujących formatów ("d" reprezentuje szesnastkową wartością cyfrową, których wielkość liter jest ignorowana):  
  
 32 cyfr ciągły:  
  
 dddddddddddddddddddddddddddddddd  
  
 —lub—  
  
 Grupy 8, 4, 4, 4 i 12 cyfr i łączników między grupami. Cały identyfikator GUID opcjonalnie mogą być ujęte w odpowiadającym nawiasami:  
  
 dddddddd-dddd-dddd-dddd-dddddddddddd  
  
 —lub—  
  
 {dddddddd-dddd-dddd-dddd-dddddddddddd}  
  
 —lub—  
  
 (dddddddd-dddd-dddd-dddd-dddddddddddd)  
  
 —lub—  
  
 Grupy 8, 4 i 4 cyfry, podzestaw osiem grup 2 cyfr, z każdą grupą poprzedzona znakiem "0 x" lub "0 X" i oddzielonych przecinkami. Cały identyfikator GUID, a także podzestaw jest ujęta w pasujących nawiasów klamrowych:  
  
 {0xdddddddd, 0xdddd, 0xdddd,{0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd}}  
  
 Wymagane są wszystkie nawiasy klamrowe, przecinkami i prefiksy "0 x". Wszystkie spacje są ignorowane. Wszystkie zera wiodące w grupie są ignorowane.  
  
 Cyfr wyświetlane w grupie są maksymalną liczbę cyfr znaczenie, które mogą być wyświetlane w tej grupie. Można określić od 1 do liczby miejsc po przecinku wyświetlany dla grupy. Określony numer są rozpatrywane cyfr znaczącymi bitami grupy.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Guid" /> struktury przy użyciu wartości reprezentowany przez określonego ciągu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alfabetyczne cyfry szesnastkowe w `g` parametr może być wielkich i małych liter. Na przykład następujące ciągi reprezentują ten sam identyfikator GUID:  
  
 "ca761232ed4211cebacd00aa0057b223"  
  
 "CA761232-ED42-11CE-BACD-00AA0057B223"  
  
 "{CA761232-ED42-11CE-BACD-00AA0057B223}"  
  
 "(CA761232-ED42-11CE-BACD-00AA0057B223)"  
  
 "{0xCA761232, 0xED42, 0x11CE, {0xBA, 0xCD, 0x00, 0xAA, 0x00, 0x57, 0xB2, 0x23}}"  
  
   
  
## Examples  
 Poniższy przykład przekazuje każdy ciąg wymienione w sekcji uwag <xref:System.Guid.%23ctor%28System.String%29> konstruktora.  
  
 [!code-csharp[System.Guid.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Guid.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="g" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Format <paramref name="g" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.OverflowException">Format <paramref name="g" /> jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Guid (int a, short b, short c, byte[] d);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 a, int16 b, int16 c, unsigned int8[] d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.#ctor(System.Int32,System.Int16,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (a As Integer, b As Short, c As Short, d As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Guid(int a, short b, short c, cli::array &lt;System::Byte&gt; ^ d);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" />
        <Parameter Name="b" Type="System.Int16" />
        <Parameter Name="c" Type="System.Int16" />
        <Parameter Name="d" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="a">Pierwsze 4 bajty identyfikatora GUID.</param>
        <param name="b">Następne 2 bajty identyfikatora GUID.</param>
        <param name="c">Następne 2 bajty identyfikatora GUID.</param>
        <param name="d">Pozostała liczba 8 bajtów identyfikatora GUID.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Guid" /> struktury przy użyciu określonej liczby całkowite i tablicy bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 `Guid(1,2,3,new byte[]{0,1,2,3,4,5,6,7})` Tworzy <xref:System.Guid> odpowiadający "00000001-0002-0003-0001-020304050607".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="d" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="d" /> to nie 8 bajtów.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Guid (int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 a, int16 b, int16 c, unsigned int8 d, unsigned int8 e, unsigned int8 f, unsigned int8 g, unsigned int8 h, unsigned int8 i, unsigned int8 j, unsigned int8 k) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.#ctor(System.Int32,System.Int16,System.Int16,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (a As Integer, b As Short, c As Short, d As Byte, e As Byte, f As Byte, g As Byte, h As Byte, i As Byte, j As Byte, k As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Guid(int a, short b, short c, System::Byte d, System::Byte e, System::Byte f, System::Byte g, System::Byte h, System::Byte i, System::Byte j, System::Byte k);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" />
        <Parameter Name="b" Type="System.Int16" />
        <Parameter Name="c" Type="System.Int16" />
        <Parameter Name="d" Type="System.Byte" />
        <Parameter Name="e" Type="System.Byte" />
        <Parameter Name="f" Type="System.Byte" />
        <Parameter Name="g" Type="System.Byte" />
        <Parameter Name="h" Type="System.Byte" />
        <Parameter Name="i" Type="System.Byte" />
        <Parameter Name="j" Type="System.Byte" />
        <Parameter Name="k" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="a">Pierwsze 4 bajty identyfikatora GUID.</param>
        <param name="b">Następne 2 bajty identyfikatora GUID.</param>
        <param name="c">Następne 2 bajty identyfikatora GUID.</param>
        <param name="d">Następny bajt identyfikatora GUID.</param>
        <param name="e">Następny bajt identyfikatora GUID.</param>
        <param name="f">Następny bajt identyfikatora GUID.</param>
        <param name="g">Następny bajt identyfikatora GUID.</param>
        <param name="h">Następny bajt identyfikatora GUID.</param>
        <param name="i">Następny bajt identyfikatora GUID.</param>
        <param name="j">Następny bajt identyfikatora GUID.</param>
        <param name="k">Następny bajt identyfikatora GUID.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Guid" /> struktury przy użyciu określonej liczby całkowite i bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określenie poszczególnych bajtów w ten sposób może służyć do obchodzenia ograniczenia kolejności bajtów (kolejności bajtów big endian lub little endian) rodzajów komputerów.  
  
   
  
## Examples  
 Poniższy przykład tworzy identyfikator GUID, których ciąg reprezentujący jest "0000000a-000b-000c-0001-020304050607".  
  
 [!code-csharp[System.Guid.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.ctor/cs/ctor2.cs#2)]
 [!code-vb[System.Guid.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.ctor/vb/ctor2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Guid (uint a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 a, unsigned int16 b, unsigned int16 c, unsigned int8 d, unsigned int8 e, unsigned int8 f, unsigned int8 g, unsigned int8 h, unsigned int8 i, unsigned int8 j, unsigned int8 k) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.#ctor(System.UInt32,System.UInt16,System.UInt16,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (a As UInteger, b As UShort, c As UShort, d As Byte, e As Byte, f As Byte, g As Byte, h As Byte, i As Byte, j As Byte, k As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Guid(System::UInt32 a, System::UInt16 b, System::UInt16 c, System::Byte d, System::Byte e, System::Byte f, System::Byte g, System::Byte h, System::Byte i, System::Byte j, System::Byte k);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="a" Type="System.UInt32" />
        <Parameter Name="b" Type="System.UInt16" />
        <Parameter Name="c" Type="System.UInt16" />
        <Parameter Name="d" Type="System.Byte" />
        <Parameter Name="e" Type="System.Byte" />
        <Parameter Name="f" Type="System.Byte" />
        <Parameter Name="g" Type="System.Byte" />
        <Parameter Name="h" Type="System.Byte" />
        <Parameter Name="i" Type="System.Byte" />
        <Parameter Name="j" Type="System.Byte" />
        <Parameter Name="k" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="a">Pierwsze 4 bajty identyfikatora GUID.</param>
        <param name="b">Następne 2 bajty identyfikatora GUID.</param>
        <param name="c">Następne 2 bajty identyfikatora GUID.</param>
        <param name="d">Następny bajt identyfikatora GUID.</param>
        <param name="e">Następny bajt identyfikatora GUID.</param>
        <param name="f">Następny bajt identyfikatora GUID.</param>
        <param name="g">Następny bajt identyfikatora GUID.</param>
        <param name="h">Następny bajt identyfikatora GUID.</param>
        <param name="i">Następny bajt identyfikatora GUID.</param>
        <param name="j">Następny bajt identyfikatora GUID.</param>
        <param name="k">Następny bajt identyfikatora GUID.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Guid" /> struktury przy użyciu określonego podpisane liczby całkowite i bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określenie liczby bajtów w ten sposób pozwala uniknąć problemów kolejności bajtów.  
  
   
  
## Examples  
 Tworzy GUID(0xA,0xb,0xC,0,1,2,3,4,5,6,7) <xref:System.Guid> odpowiadający "0000000a-000b-000c-0001-020304050607".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Porównuje tego wystąpienia określonego obiektu lub <see cref="T:System.Guid" /> i zwraca dane dotyczące ich względne wartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (Guid value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Guid value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.CompareTo(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Guid) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(Guid value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt, który ma zostać porównany z tym wystąpieniem.</param>
        <summary>Porównuje tego wystąpienia określonej <see cref="T:System.Guid" /> obiektu i zwraca dane dotyczące ich względne wartości.</summary>
        <returns>Podpisem liczbę określającą względne wartości tego wystąpienia i <paramref name="value" />.  
  
 <list type="table"><listheader><term> Wartość zwracana  
  
 </term><description> Opis elementu  
  
 </description></listheader><item><term> Ujemna liczba całkowita  
  
 </term><description> To wystąpienie jest mniejsza niż <paramref name="value" />.  
  
 </description></item><item><term> Zero  
  
 </term><description> To wystąpienie jest równe <paramref name="value" />.  
  
 </description></item><item><term> Dodatnia liczba całkowita  
  
 </term><description> To wystąpienie jest większa niż <paramref name="value" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Guid.CompareTo%2A> Metoda porównuje identyfikatory GUID, tak jakby były to wartości przekazywane do <xref:System.Guid.%23ctor%28System.Int32%2CSystem.Int16%2CSystem.Int16%2CSystem.Byte%5B%5D%29> konstruktora w następujący sposób:  
  
-   Porównuje <xref:System.UInt32> wartości i zwraca wynik, jeśli ich nie są równe. Czy są równe, wykonuje następnego porównania.  
  
-   Porównuje pierwszy <xref:System.UInt16> wartości i zwraca wynik, jeśli ich nie są równe. Czy są równe, wykonuje następnego porównania.  
  
-   Porównuje drugi <xref:System.UInt16> wartości i zwraca wynik, jeśli ich nie są równe. Czy są równe, wykonuje następnego porównania.  
  
-   Jeśli przeprowadza porównanie po bicie dalej ośmiu <xref:System.Byte> wartości. Po napotkaniu pierwszego pary nierówne zwraca wynik. W przeciwnym razie zwraca wartość 0, aby wskazać, że dwa <xref:System.Guid> wartości są równe.  
  
 Należy pamiętać, że końcowy ośmiu bajtów są wyświetlane w reprezentację ciągu <xref:System.Guid> w odwrotnej kolejności z niskim bajtu na bajt. Na przykład w reprezentację ciągu <xref:System.Guid> wartość "01e75c83-c6f5-4192-b57e-7427cec5560d" końcowego ośmiu bajtów to "b57e 7427cec5560d." Innymi słowy końcowego ośmiu bajtów są porównywane na podstawie po bicie od lewej do prawej, począwszy 0xb5.  
  
 Jeśli dwa identyfikatory GUID mają takie same wartości dla składnika, metoda porównuje następny składnik. Po znalezieniu składników, których wartości są równe, zwraca wynik.  
  
 Ta metoda implementuje <xref:System.IComparable%601?displayProperty=nameWithType> interfejsu i wykonuje nieco większą niż <xref:System.Guid.CompareTo%2A?displayProperty=nameWithType> — metoda, ponieważ nie muszą być konwertowane `value` parametr <xref:System.Guid> wartość.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Guid.CompareTo%28System.Guid%29> metody do porównywania wartości identyfikatora GUID z dwóch podobnych wartości identyfikatora GUID.  
  
 [!code-csharp[System.Guid.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Guid.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.compareto/vb/compareto2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do porównania, lub <see langword="null" />.</param>
        <summary>Porównuje to wystąpienie z określonym obiektem i zwraca wskazanie ich względnych wartości.</summary>
        <returns>Podpisem liczbę określającą względne wartości tego wystąpienia i <paramref name="value" />.  
  
 <list type="table"><listheader><term> Wartość zwracana  
  
 </term><description> Opis elementu  
  
 </description></listheader><item><term> Ujemna liczba całkowita  
  
 </term><description> To wystąpienie jest mniejsza niż <paramref name="value" />.  
  
 </description></item><item><term> Zero  
  
 </term><description> To wystąpienie jest równe <paramref name="value" />.  
  
 </description></item><item><term> Dodatnia liczba całkowita  
  
 </term><description> To wystąpienie jest większa niż <paramref name="value" />, lub <paramref name="value" /> jest <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Parametr musi być `null` lub wystąpienie <xref:System.Guid>; w przeciwnym razie jest zwracany wyjątek. Wszystkie wystąpienia <xref:System.Guid>, niezależnie od jego wartość jest uznawany za większy niż `null`.  
  
 <xref:System.Guid.CompareTo%2A> Metoda porównuje identyfikatory GUID, tak jakby były to wartości przekazywane do <xref:System.Guid.%23ctor%2A> konstruktora w następujący sposób:  
  
-   Porównuje <xref:System.Int32> wartości i zwraca wynik, jeśli ich nie są równe. Czy są równe, wykonuje następnego porównania.  
  
-   Porównuje pierwszy <xref:System.Int16> wartości i zwraca wynik, jeśli ich nie są równe. Czy są równe, wykonuje następnego porównania.  
  
-   Porównuje drugi <xref:System.Int16> wartości i zwraca wynik, jeśli ich nie są równe. Czy są równe, wykonuje następnego porównania.  
  
-   Jeśli przeprowadza porównanie po bicie dalej ośmiu <xref:System.Byte> wartości. Po napotkaniu pierwszego pary nierówne zwraca wynik. W przeciwnym razie zwraca wartość 0, aby wskazać, że dwa <xref:System.Guid> wartości są równe.  
  
 Jeśli dwa identyfikatory GUID mają takie same wartości dla składnika, metoda porównuje następny składnik. Po znalezieniu składników, których wartości są równe, zwraca wynik.  
  
 Należy pamiętać, że końcowy ośmiu bajtów są wyświetlane w reprezentację ciągu <xref:System.Guid> w odwrotnej kolejności z niskim bajtu na bajt. Na przykład w reprezentację ciągu <xref:System.Guid> wartość "01e75c83-c6f5-4192-b57e-7427cec5560d" końcowego ośmiu bajtów to "b57e 7427cec5560d."  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Runtime.InteropServices.GuidAttribute> atrybut można przypisać do klasy identyfikatora GUID. Wywołując go pobiera wartość tego identyfikatora GUID <xref:System.Attribute.GetCustomAttribute%2A?displayProperty=nameWithType> — metoda i przekazywanie <xref:System.Runtime.InteropServices.GuidAttribute.Value%2A> właściwości zwracana <xref:System.Runtime.InteropServices.GuidAttribute> do obiektu <xref:System.Guid.Parse%2A> — metoda. Następnie porównuje tego identyfikatora GUID z tablicy wartości.  
  
 [!code-csharp[System.Guid.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.compareto/cs/compareto1.cs#2)]
 [!code-vb[System.Guid.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.compareto/vb/compareto1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> nie jest <see cref="T:System.Guid" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly Guid Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Guid Empty" />
      <MemberSignature Language="DocId" Value="F:System.Guid.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As Guid " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Guid Empty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Jest tylko do odczytu wystąpienie <see cref="T:System.Guid" /> struktury, którego wartość jest same zera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz porównać identyfikatora GUID z wartością <xref:System.Guid.Empty?displayProperty=nameWithType> pole, aby określić, czy identyfikator GUID jest różna od zera. W poniższym przykładzie użyto <xref:System.Guid.op_Equality%2A> operator do porównywania dwóch wartości identyfikatora GUID z <xref:System.Guid.Empty?displayProperty=nameWithType> ustalenie, czy składać się wyłącznie z zer.  
  
 [!code-csharp[System.Guid.Empty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.empty/cs/empty.cs#1)]
 [!code-vb[System.Guid.Empty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.empty/vb/empty.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy dwa wystąpienia elementu <see cref="T:System.Guid" /> reprezentują tę samą wartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (Guid g);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Guid g) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.Equals(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (g As Guid) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Guid g);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="g">Obiekt, który ma zostać porównany z tym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą czy to wystąpienie i określonej <see cref="T:System.Guid" /> obiektu reprezentują tę samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="g" /> jest taki sam, jak to wystąpienie w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa <xref:System.Guid> obiekty są takie same, jeśli mają identyczne wartości.  
  
 Ta metoda wykonuje nieco lepszym rozwiązaniem niż <xref:System.Guid.Equals%2A> metody, ponieważ nie ma do pola `g` parametru.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Guid.Equals(System.Object)" />
        <altmember cref="Overload:System.Guid.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Obiekt, który ma zostać porównany z tym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="o" /> jest <see cref="T:System.Guid" /> mający taką samą wartość jak to wystąpienie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa <xref:System.Guid> obiekty są takie same, jeśli mają identyczne wartości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego wystąpienia.</summary>
        <returns>Kod skrótu dla tego wystąpienia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewGuid">
      <MemberSignature Language="C#" Value="public static Guid NewGuid ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid NewGuid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.NewGuid" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NewGuid () As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid NewGuid();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Guid" /> struktury.</summary>
        <returns>Identyfikator GUID nowego obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wygodny sposób `static` metodę można wywołać w celu pobrania nowego tokenu <xref:System.Guid>. Metoda opakowuje wywołanie systemu Windows [funkcji CoCreateGuid](http://msdn.microsoft.com/library/windows/desktop/ms688568.aspx) funkcji. Zwrócona <xref:System.Guid> może nie być równa <xref:System.Guid.Empty?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy i wyświetla wartości dwu <xref:System.Guid> obiektów.  
  
 [!code-csharp[system.guid.newguid#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.newguid/cs/ng.cs#1)]
 [!code-vb[system.guid.newguid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.newguid/vb/ng.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Guid a, Guid b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Guid a, valuetype System.Guid b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.op_Equality(System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As Guid, b As Guid) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Guid a, Guid b);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Guid" />
        <Parameter Name="b" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="a">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="b">Drugi obiekt, który będzie porównywany.</param>
        <summary>Wskazuje, czy określone wartości dwu <see cref="T:System.Guid" /> obiekty są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="a" /> i <paramref name="b" /> są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Jest równoważne metodę dla tego operatora <xref:System.Guid.Equals%28System.Object%29?displayProperty=nameWithType>  
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Guid.op_Equality%2A> operator do porównywania dwóch wartości identyfikatora GUID z <xref:System.Guid.Empty?displayProperty=nameWithType> ustalenie, czy składać się wyłącznie z zer.  
  
 [!code-csharp[System.Guid.Empty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.empty/cs/empty.cs#1)]
 [!code-vb[System.Guid.Empty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.empty/vb/empty.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Guid a, Guid b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Guid a, valuetype System.Guid b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.op_Inequality(System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As Guid, b As Guid) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Guid a, Guid b);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Guid" />
        <Parameter Name="b" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="a">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="b">Drugi obiekt, który będzie porównywany.</param>
        <summary>Wskazuje, czy określone wartości dwu <see cref="T:System.Guid" /> obiekty nie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="a" /> i <paramref name="b" /> nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Jest równoważne metodę dla tego operatora <xref:System.Guid.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static Guid Parse (ReadOnlySpan&lt;char&gt; input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.Parse(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (input As ReadOnlySpan(Of Char)) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid Parse(ReadOnlySpan&lt;char&gt; input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static Guid Parse (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid Parse(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (input As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid Parse(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg do konwersji.</param>
        <summary>Konwertuje reprezentację ciągu identyfikatora GUID odpowiednikiem <see cref="T:System.Guid" /> struktury.</summary>
        <returns>Struktura, która zawiera wartość, która zostanie przeanalizowany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Guid.Parse%2A> Metody przycina żadnego odstępu wiodących i końcowych z `input` i konwertuje reprezentację ciągu identyfikator GUID <xref:System.Guid> wartość. Ta metoda Konwertowanie ciągów znaków w jednym z pięciu formatów utworzonego przez <xref:System.Guid.ToString%28System.String%29> i <xref:System.Guid.ToString%28System.String%2CSystem.IFormatProvider%29> metody, jak pokazano w poniższej tabeli.  
  
|Specyfikator|Opis|Format|  
|---------------|-----------------|------------|  
|`N`|32 cyfr|00000000000000000000000000000000|  
|`D`|32 cyfry szesnastkowe rozdzielone myślnikami|00000000-0000-0000-0000-000000000000|  
|`B`|32 cyfry szesnastkowe rozdzielone myślnikami, ujęta w nawiasy klamrowe|{00000000-0000-0000-0000-000000000000}|  
|`P`|32 cyfry szesnastkowe rozdzielone myślnikami, ujęte w nawiasy|(00000000-0000-0000-0000-000000000000)|  
|`X`|Cztery wartości szesnastkowe ujęta w nawiasy klamrowe, gdzie czwarta wartość jest podzbiór osiem wartości szesnastkowe również ujęty w nawiasy klamrowe|{0x00000000, 0x0000, 0x0000, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}|  
  
 Metoda zgłasza <xref:System.FormatException> Jeśli nie można pomyślnie przeanalizować składni ciągu. Poniżej przedstawiono przyczyny, może to mieć miejsce między innymi:  
  
-   `input` zawiera znaki, które nie są częścią zestawu znaków szesnastkowych.  
  
-   `input` ma zbyt wiele lub zbyt mało znaków liczbowych.  
  
-   `input` ma zbyt wiele lub zbyt mało znaków nienumerycznych odpowiednie dla określonego formatu.  
  
-   `input` nie znajduje się w jednym z formatów rozpoznał <xref:System.Guid.ToString%2A> — metoda i wymienione w powyższej tabeli.  
  
 Użyj <xref:System.Guid.TryParse%2A> metodę, aby przechwycić wszystkie operacje analizy nie powiodło się bez konieczności obsługi wyjątku.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy identyfikator GUID, konwertuje go oświadczenia w trzech oddzielnych ciąg przez wywołanie metody <xref:System.Guid.ToString%28System.String%29> metody na "B", "D" i "X" specyfikatory formatu, a następnie wywołania <xref:System.Guid.Parse%2A> metodę, aby przekonwertować ciągi z powrotem do <xref:System.Guid> wartości.  
  
 [!code-csharp[System.Guid.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.parse/cs/parseex1.cs#3)]
 [!code-vb[System.Guid.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.parse/vb/parseex1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="input" /> nie jest w rozpoznawanym formacie.</exception>
        <altmember cref="M:System.Guid.TryParse(System.String,System.Guid@)" />
        <altmember cref="M:System.Guid.ToString" />
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static Guid ParseExact (ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; format);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid ParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; input, valuetype System.ReadOnlySpan`1&lt;char&gt; format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.ParseExact(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (input As ReadOnlySpan(Of Char), format As ReadOnlySpan(Of Char)) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid ParseExact(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="input">To be added.</param>
        <param name="format">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static Guid ParseExact (string input, string format);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid ParseExact(string input, string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.ParseExact(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (input As String, format As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid ParseExact(System::String ^ input, System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Identyfikator GUID, który ma zostać przekształcony.</param>
        <param name="format">Jedną z następujących Specyfikatory, które wskazuje dokładnego formatu do użycia podczas interpretacji <c>wejściowych</c>: "N", "D", "B", "P" lub "X".</param>
        <summary>Konwertuje reprezentację ciągu identyfikatora GUID odpowiednikiem <see cref="T:System.Guid" /> struktury, pod warunkiem, że ten ciąg jest w określonym formacie.</summary>
        <returns>Struktura, która zawiera wartość, która zostanie przeanalizowany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Guid.ParseExact%2A> Metoda wymaga ciąg do przekonwertowania dokładnie w formacie określonym przez `format` parametru, po usunięciu spacji wiodących i końcowych znaków odstępu. W poniższej tabeli przedstawiono specyfikatory zaakceptowanym formacie dla `format` parametru. Znak „0” reprezentuje cyfrę. Łączniki („-”), nawiasy klamrowe („{”, „}”) i nawiasy („(”, „)”) są wyświetlane jak pokazano.  
  
|Specyfikator|Format elementu `input` parametru|  
|---------------|-------------------------------------|  
|N|32 cyfry:<br /><br /> 00000000000000000000000000000000|  
|D|32 cyfry rozdzielone łącznikami:<br /><br /> 00000000-0000-0000-0000-000000000000|  
|B|32 cyfry rozdzielone łącznikami, ujęte w nawiasach klamrowych:<br /><br /> {00000000-0000-0000-0000-000000000000}|  
|P|32 cyfry rozdzielone łącznikami, ujęte w nawiasach:<br /><br /> (00000000-0000-0000-0000-000000000000)|  
|X|Cztery wartości szesnastkowe zawarte w nawiasach klamrowych, gdzie czwarta wartość jest podzbiorem ośmiu wartości szesnastkowych również ujętych w nawiasy klamrowe:<br /><br /> {0x00000000, 0x0000, 0x0000, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}|  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Guid.ToString%28System.String%29> metody z każdym specyfikatory obsługiwanego formatu do wygenerowania na tablicę ciągów reprezentujących jednego identyfikatora GUID. Te są następnie przekazywane do <xref:System.Guid.ParseExact%2A> metodę, która analizuje pomyślnie tylko ciąg, który odpowiada specyfikator formatu "B".  
  
 [!code-csharp[System.Guid.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.parse/cs/parseexactex1.cs#4)]
 [!code-vb[System.Guid.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.parse/vb/parseexactex1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> lub <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="input" /> nie jest w formacie określonym przez <paramref name="format" />.</exception>
        <altmember cref="M:System.Guid.TryParseExact(System.String,System.String,System.Guid@)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IFormattable.ToString">
      <MemberSignature Language="C#" Value="string IFormattable.ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IFormattable.ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.System#IFormattable#ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (format As String, provider As IFormatProvider) As String Implements IFormattable.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IFormattable.ToString(System::String ^ format, IFormatProvider ^ provider) = IFormattable::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.ToByteArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ToByteArray();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę 16 element bajtów, który zawiera wartość tego wystąpienia.</summary>
        <returns>Tablica bajtów elementu 16.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica bajtów zwrócona przez tę metodę przesyłania danych można użyć <xref:System.Guid> wartość wywołując <xref:System.Guid.%23ctor%28System.Byte%5B%5D%29> konstruktora.  
  
 Należy pamiętać, że kolejność bajtów w tablicy bajtów zwróconych inny niż reprezentację ciągu <xref:System.Guid> wartość. Kolejność początku grupy 4 bajtowych oraz kolejnych dwóch grup dwubajtowego została odwrócona kolejność ostatniego grupy dwubajtowego i 6 bajtowy zamknięcia jest taka sama. Przykład stanowi ilustrację.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Guid.NewGuid%2A> metodę w celu utworzenia <xref:System.Guid> wartość, a następnie wywołania <xref:System.Guid.ToByteArray%2A> metody do reprezentowania <xref:System.Guid> wartości w postaci tablicy bajtów. Następnie wyświetla obie wartości do konsoli. Na koniec, tworzy nową <xref:System.Guid> wartości z tablicy bajtów i wywołania jego <xref:System.Guid.Equals%28System.Guid%29> metodę pokazują, że dwa <xref:System.Guid> wartości są identyczne.  
  
 [!code-csharp[System.Guid.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.tobytearray/cs/tobytearray3.cs#1)]
 [!code-vb[System.Guid.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.tobytearray/vb/tobytearray3.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca reprezentację ciągu wartość tego wystąpienia <see cref="T:System.Guid" /> struktury.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca reprezentację ciągu tego wystąpienia wartości w formacie rejestru.</summary>
        <returns>Wartość tego <see cref="T:System.Guid" />, sformatowany przy użyciu specyfikatora formatu "D" w następujący sposób:  
  
 <c>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</c>  
  
 gdy wartość identyfikatora GUID jest reprezentowany jako serię małe cyfry szesnastkowe w grupach, 8, 4, 4, 4, a 12 cyfr i rozdzielone myślnikami. Przykład zwracanej wartości to "382c74c3-721d-4f34-80e5-57657b6cbc27". Aby przekonwertować cyfr szesnastkowych od do f na wielkie litery, należy wywołać <see cref="M:System.String.ToUpper" /> metoda zwracany ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapewnia domyślny format identyfikatora GUID, który wystarcza w typowy sposób użycia; jednak inne wersje tej metody, które wymagają `format` parametru podać kilka wspólnych zmiany formatu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Specyfikator formatu pojedynczego wskazującą sposób formatowania wartości to <see cref="T:System.Guid" />. <c>Format</c> parametr może być "N", "D", "B", "P" lub "X". Jeśli <c>format</c> jest <see langword="null" /> lub ciąg pusty (""), "D" jest używany.</param>
        <summary>Zwraca reprezentację ciągu wartości to <see cref="T:System.Guid" /> wystąpienia, zgodnie z specyfikator formatu podany.</summary>
        <returns>Wartość tego <see cref="T:System.Guid" />, reprezentowana jako serię małe cyfry szesnastkowe w określonym formacie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono specyfikatory zaakceptowanym formacie dla `format` parametru. Znak „0” reprezentuje cyfrę. Łączniki („-”), nawiasy klamrowe („{”, „}”) i nawiasy („(”, „)”) są wyświetlane jak pokazano.  
  
|Specyfikator|Format wartości zwracanej|  
|---------------|----------------------------|  
|`N`|32 cyfry:<br /><br /> 00000000000000000000000000000000|  
|`D`|32 cyfry rozdzielone łącznikami:<br /><br /> 00000000-0000-0000-0000-000000000000|  
|`B`|32 cyfry rozdzielone łącznikami, ujęte w nawiasach klamrowych:<br /><br /> {00000000-0000-0000-0000-000000000000}|  
|`P`|32 cyfry rozdzielone łącznikami, ujęte w nawiasach:<br /><br /> (00000000-0000-0000-0000-000000000000)|  
|`X`|Cztery wartości szesnastkowe zawarte w nawiasach klamrowych, gdzie czwarta wartość jest podzbiorem ośmiu wartości szesnastkowych również ujętych w nawiasy klamrowe:<br /><br /> {0x00000000, 0x0000, 0x0000, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}|  
  
 Małe litery w ciągu zwracane są cyfr szesnastkowych do f. Aby przekonwertować je na wielkie litery, należy wywołać <xref:System.String.ToUpper%2A?displayProperty=nameWithType> metoda zwracany ciąg.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Wartość <paramref name="format" /> nie jest <see langword="null" />, ciąg pusty (""), "N", "D", "B", "P" lub "X".</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Specyfikator formatu pojedynczego wskazującą sposób formatowania wartości to <see cref="T:System.Guid" />. <c>Format</c> parametr może być "N", "D", "B", "P" lub "X". Jeśli <c>format</c> jest <see langword="null" /> lub ciąg pusty (""), "D" jest używany.</param>
        <param name="provider">(Parametr zarezerwowany) Obiekt dostarczający informacji o formatowaniu specyficznych dla kultury.</param>
        <summary>Zwraca reprezentację ciągu wartość tego wystąpienia <see cref="T:System.Guid" /> klasy, zgodnie z specyfikator formatu podany i informacji o formacie specyficzne dla kultury.</summary>
        <returns>Wartość tego <see cref="T:System.Guid" />, reprezentowana jako serię małe cyfry szesnastkowe w określonym formacie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` Parametr jest zarezerwowany do użytku w przyszłości i nie wpływa na wykonanie tej metody. Można przekazać `null` w wywołaniu metody.  
  
 W poniższej tabeli przedstawiono specyfikatory zaakceptowanym formacie dla `format` parametru. Znak „0” reprezentuje cyfrę. Łączniki („-”), nawiasy klamrowe („{”, „}”) i nawiasy („(”, „)”) są wyświetlane jak pokazano.  
  
|Specyfikator|Format wartości zwracanej|  
|---------------|----------------------------|  
|`N`|32 cyfry:<br /><br /> 00000000000000000000000000000000|  
|`D`|32 cyfry rozdzielone łącznikami:<br /><br /> 00000000-0000-0000-0000-000000000000|  
|`B`|32 cyfry rozdzielone łącznikami, ujęte w nawiasach klamrowych:<br /><br /> {00000000-0000-0000-0000-000000000000}|  
|`P`|32 cyfry rozdzielone łącznikami, ujęte w nawiasach:<br /><br /> (00000000-0000-0000-0000-000000000000)|  
|`X`|Cztery wartości szesnastkowe zawarte w nawiasach klamrowych, gdzie czwarta wartość jest podzbiorem ośmiu wartości szesnastkowych również ujętych w nawiasy klamrowe:<br /><br /> {0x00000000, 0x0000, 0x0000, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}|  
  
 Małe litery w ciągu zwracane są cyfr szesnastkowych do f. Aby przekonwertować je na wielkie litery, należy wywołać <xref:System.String.ToUpper%2A?displayProperty=nameWithType> metoda zwracany ciąg.  
  
 Ponieważ `provider` parametru jest ignorowana, nie można go użyć niestandardowe rozwiązanie formatowania. Do reprezentowania <xref:System.Guid> wartość jako ciąg w formacie, który nie jest obsługiwany przez standardowe ciągi formatujące identyfikatora GUID, wywołanie <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> metody z `provider` obiekt, który implementuje zarówno <xref:System.ICustomFormatter> i <xref:System.IFormatProvider> interfejsów. Aby uzyskać więcej informacji, zobacz sekcję "Niestandardowe formatowanie z ICustomFormatter" w [typy formatowania](~/docs/standard/base-types/formatting-types.md) artykułu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Wartość <paramref name="format" /> nie jest <see langword="null" />, ciąg pusty (""), "N", "D", "B", "P" lub "X".</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null) As Boolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; input, out Guid result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; input, [out] valuetype System.Guid&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.TryParse(System.ReadOnlySpan{System.Char},System.Guid@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (input As ReadOnlySpan(Of Char), ByRef result As Guid) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; input, [Runtime::InteropServices::Out] Guid % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Guid&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string input, out Guid result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string input, [out] valuetype System.Guid&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.TryParse(System.String,System.Guid@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (input As String, ByRef result As Guid) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ input, [Runtime::InteropServices::Out] Guid % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="result" Type="System.Guid&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Identyfikator GUID, który ma zostać przekształcony.</param>
        <param name="result">Struktura, która będzie zawierać przeanalizowana wartość. Jeśli metoda zwraca <see langword="true" />, <c>wynik</c> zawiera prawidłowy <see cref="T:System.Guid" />. Jeśli metoda zwraca <see langword="false" />, <c>wynik</c> jest równe <see cref="F:System.Guid.Empty" />.</param>
        <summary>Konwertuje reprezentację ciągu identyfikatora GUID odpowiednikiem <see cref="T:System.Guid" /> struktury.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja analizy zakończyło się pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest podobna <xref:System.Guid.Parse%2A> metody, z wyjątkiem zamiast zwracać przeanalizowany identyfikator GUID, zwraca `false` Jeśli `input` jest `null` lub nie jest w rozpoznawanym formacie i nie zgłosić wyjątek. Przycina ona żadnego odstępu wiodących i końcowych z `input` i konwertuje ciągów w jednym z pięciu formatów rozpoznawany przez <xref:System.Guid.ToString%28System.String%29> i <xref:System.Guid.ToString%28System.String%2CSystem.IFormatProvider%29> metody, jak pokazano w poniższej tabeli.  
  
|Specyfikator|Opis|Format|  
|---------------|-----------------|------------|  
|`N`|32 cyfr|00000000000000000000000000000000|  
|`D`|32 cyfry szesnastkowe rozdzielone myślnikami|00000000-0000-0000-0000-000000000000|  
|`B`|32 cyfry szesnastkowe rozdzielone myślnikami, ujęta w nawiasy klamrowe|{00000000-0000-0000-0000-000000000000}|  
|`P`|32 cyfry szesnastkowe rozdzielone myślnikami, ujęte w nawiasy|(00000000-0000-0000-0000-000000000000)|  
|`X`|Cztery wartości szesnastkowe ujęta w nawiasy klamrowe, gdzie czwarta wartość jest podzbiór osiem wartości szesnastkowe również ujęty w nawiasy klamrowe|{0x00000000, 0x0000, 0x0000, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}|  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy identyfikator GUID, konwertuje go oświadczenia w trzech oddzielnych ciąg przez wywołanie metody <xref:System.Guid.ToString%28System.String%29> metody na "B", "D" i "X" specyfikatory formatu, a następnie wywołania <xref:System.Guid.TryParse%2A> metodę, aby przekonwertować ciągi z powrotem do <xref:System.Guid> wartości.  
  
 [!code-csharp[System.Guid.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.parse/cs/tryparseex1.cs#2)]
 [!code-vb[System.Guid.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.parse/vb/tryparseex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Guid.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; format, out Guid result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; input, valuetype System.ReadOnlySpan`1&lt;char&gt; format, [out] valuetype System.Guid&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.TryParseExact(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Guid@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (input As ReadOnlySpan(Of Char), format As ReadOnlySpan(Of Char), ByRef result As Guid) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; format, [Runtime::InteropServices::Out] Guid % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Guid&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">To be added.</param>
        <param name="format">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (string input, string format, out Guid result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(string input, string format, [out] valuetype System.Guid&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.TryParseExact(System.String,System.String,System.Guid@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (input As String, format As String, ByRef result As Guid) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(System::String ^ input, System::String ^ format, [Runtime::InteropServices::Out] Guid % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="result" Type="System.Guid&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Identyfikator GUID, który ma zostać przekształcony.</param>
        <param name="format">Jedną z następujących Specyfikatory, które wskazuje dokładnego formatu do użycia podczas interpretacji <c>wejściowych</c>: "N", "D", "B", "P" lub "X".</param>
        <param name="result">Struktura, która będzie zawierać przeanalizowana wartość. Jeśli metoda zwraca <see langword="true" />, <c>wynik</c> zawiera prawidłowy <see cref="T:System.Guid" />. Jeśli metoda zwraca <see langword="false" />, <c>wynik</c> jest równe <see cref="F:System.Guid.Empty" />.</param>
        <summary>Konwertuje reprezentację ciągu identyfikatora GUID odpowiednikiem <see cref="T:System.Guid" /> struktury, pod warunkiem, że ten ciąg jest w określonym formacie.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja analizy zakończyło się pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wymaga ciąg do przekonwertowania dokładnie w formacie określonym przez `format` parametru, po usunięciu spacji wiodących i końcowych znaków odstępu. Zwraca `false` Jeśli `input` jest `null` lub nie jest w formacie określonym przez `format`i nie zgłosić wyjątek.  
  
 W poniższej tabeli przedstawiono specyfikatory zaakceptowanym formacie dla `format` parametru. Znak „0” reprezentuje cyfrę. Łączniki („-”), nawiasy klamrowe („{”, „}”) i nawiasy („(”, „)”) są wyświetlane jak pokazano.  
  
|Specyfikator|Format elementu `input` parametru|  
|---------------|-------------------------------------|  
|N|32 cyfry:<br /><br /> 00000000000000000000000000000000|  
|D|32 cyfry rozdzielone łącznikami:<br /><br /> 00000000-0000-0000-0000-000000000000|  
|B|32 cyfry rozdzielone łącznikami, ujęte w nawiasach klamrowych:<br /><br /> {00000000-0000-0000-0000-000000000000}|  
|P|32 cyfry rozdzielone łącznikami, ujęte w nawiasach:<br /><br /> (00000000-0000-0000-0000-000000000000)|  
|X|Cztery wartości szesnastkowe zawarte w nawiasach klamrowych, gdzie czwarta wartość jest podzbiorem ośmiu wartości szesnastkowych również ujętych w nawiasy klamrowe:<br /><br /> {0x00000000, 0x0000, 0x0000, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}|  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Guid.ToString%28System.String%29> metody z każdym specyfikatory obsługiwanego formatu do wygenerowania na tablicę ciągów reprezentujących jednego identyfikatora GUID. Te są następnie przekazywane do <xref:System.Guid.TryParseExact%2A> metodę, która analizuje pomyślnie ciąg, który odpowiada specyfikator formatu "B".  
  
 [!code-csharp[System.Guid.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.guid.parse/cs/tryparseexactex1.cs#5)]
 [!code-vb[System.Guid.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.guid.parse/vb/tryparseexactex1.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Guid.ParseExact(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Guid.TryWriteBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryWriteBytes(Span&lt;System::Byte&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
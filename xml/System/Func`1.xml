<Type Name="Func&lt;TResult&gt;" FullName="System.Func&lt;TResult&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="32bfd87c717460eeca143861ae42f3f64042f133" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30744374" />
  </Metadata>
  <TypeSignature Language="C#" Value="public delegate TResult Func&lt;out TResult&gt;();" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed Func`1&lt;+ TResult&gt; extends System.MulticastDelegate" />
  <TypeSignature Language="DocId" Value="T:System.Func`1" />
  <TypeSignature Language="VB.NET" Value="Public Delegate Function Func(Of Out TResult)() As TResult " />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TResult&gt;&#xA;public delegate TResult Func();" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TResult">
      <Constraints>
        <ParameterAttribute>Covariant</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")</AttributeName>
    </Attribute>
  </Attributes>
  <Parameters />
  <ReturnValue>
    <ReturnType>TResult</ReturnType>
  </ReturnValue>
  <Docs>
    <typeparam name="TResult">Typ zwracanej wartości metody, która hermetyzuje tego delegata.</typeparam>
    <summary>Hermetyzuje metodę, która nie ma parametrów i zwraca wartość typu określonego przez <typeparamref name="TResult" /> parametru.</summary>
    <returns>Wartość zwracaną metody, która hermetyzuje tego delegata.</returns>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten delegat umożliwia reprezentuje metodę, która można przekazać jako parametru bez jawnie deklarowanie niestandardowego obiektu delegowanego. Metoda hermetyzowany musi odpowiadać podpis metody jest definiowana za pomocą tego delegata. Oznacza to, że hermetyzowany metody musi nie może mieć parametrów i musi zwracać wartość.  
  
> [!NOTE]
>  Metoda, która nie ma parametrów i zwraca odwołanie do `void` (lub w języku Visual Basic, który jest zadeklarowany jako `Sub` , a nie jako `Function`), użyj <xref:System.Action> zamiast tego delegata.  
  
 Jeśli używasz <xref:System.Func%601> delegata, nie trzeba jawnie definiować delegata, który hermetyzuje metody bez parametrów. Na przykład następujący kod jawnie deklaruje delegata o nazwie `WriteMethod` i odwołanie do `OutputTarget.SendToFile` metody do jego wystąpienia delegata wystąpienia.  
  
 [!code-csharp[System.Func~1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Func~1/cs/Delegate.cs#1)]
 [!code-vb[System.Func~1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Func~1/vb/Delegate.vb#1)]  
  
 Poniższy przykład ułatwiają ten kod przy uruchamianiu <xref:System.Func%601> delegata zamiast jawnie nowe delegowanie definiowanie i przypisywanie metodę o nazwie.  
  
 [!code-csharp[System.Func~1#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Func~1/cs/Func1.cs#2)]
 [!code-vb[System.Func~1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Func~1/vb/Func1.vb#2)]  
  
 Można użyć <xref:System.Func%601> delegata z metody anonimowe w języku C#, jak pokazano w poniższym przykładzie. (Wprowadzenie do metod anonimowych, zobacz [metod anonimowych](~/docs/csharp/programming-guide/statements-expressions-operators/anonymous-methods.md).)  
  
 [!code-csharp[System.Func~1#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Func~1/cs/Anon.cs#3)]  
  
 Można także przypisać wyrażenia lambda do <xref:System.Func%602> delegować, jak pokazano w poniższym przykładzie. (Wprowadzenie do wyrażenia lambda, zobacz [wyrażenia Lambda](~/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md) i [wyrażenia Lambda](~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).)  
  
 [!code-csharp[System.Func~1#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Func~1/cs/Lambda.cs#4)]
 [!code-vb[System.Func~1#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Func~1/vb/Lambda.vb#4)]  
  
 Podstawowy typ wyrażenia lambda jest jednym z ogólnego `Func` delegatów. Dzięki temu można przekazać wyrażenia lambda jako parametr bez jawnie przypisywania go do delegata. W szczególności ponieważ wiele metod typów w <xref:System.Linq> ma przestrzeń nazw `Func` parametry, można przekazać te metody wyrażenia lambda bez jawnego tworzenia wystąpienia `Func` delegowanie.  
  
 Jeśli masz kosztowne obliczeń, który chcesz wykonać tylko wtedy, gdy wynik będzie to wymagane, można przypisać kosztowne funkcji <xref:System.Func%601> delegowanie. Następnie można opóźnić wykonanie funkcji, dopóki właściwość, która uzyskuje dostęp do wartości jest używany w wyrażeniu. Przykład w następnej sekcji pokazano, jak to zrobić.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia delegata, który nie przyjmuje żadnych parametrów. Ten kod tworzy ogólny klasy o nazwie `LazyValue` mający pola typu <xref:System.Func%601>. To pole Delegat może przechowywać odwołanie do dowolnej funkcji, która zwraca wartość typu, który odpowiada na parametr typu `LazyValue` obiektu. `LazyValue` Ma także typ `Value` właściwość, która wykonuje funkcji (jeśli go nie już zostało wykonane) i zwraca wartość wynikową.  
  
 W przykładzie tworzy dwie metody i tworzy dwa `LazyValue` obiektów z wyrażenia lambda, które wywołują te metody. Wyrażenia lambda nie mają parametrów, ponieważ właśnie należy wywołać metodę. Jak pokazano na dane wyjściowe, te dwie metody są wykonywane tylko wtedy, gdy wartość każdego `LazyValue` pobrać obiektu.  
  
 [!code-csharp[System.Func~1#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Func~1/cs/Example.cs#5)]
 [!code-vb[System.Func~1#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Func~1/vb/Example.vb#5)]  
  
 ]]></format>
    </remarks>
  </Docs>
</Type>
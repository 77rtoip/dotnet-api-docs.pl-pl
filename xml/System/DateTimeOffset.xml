<Type Name="DateTimeOffset" FullName="System.DateTimeOffset">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0121851dad511751c9beb499045b55b619cc57c7" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36433727" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct DateTimeOffset : IComparable, IComparable&lt;DateTimeOffset&gt;, IEquatable&lt;DateTimeOffset&gt;, IFormattable, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit DateTimeOffset extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.DateTimeOffset&gt;, class System.IEquatable`1&lt;valuetype System.DateTimeOffset&gt;, class System.IFormattable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.DateTimeOffset" />
  <TypeSignature Language="VB.NET" Value="Public Structure DateTimeOffset&#xA;Implements IComparable, IComparable(Of DateTimeOffset), IDeserializationCallback, IEquatable(Of DateTimeOffset), IFormattable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public value class DateTimeOffset : IComparable, IComparable&lt;DateTimeOffset&gt;, IEquatable&lt;DateTimeOffset&gt;, IFormattable, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type DateTimeOffset = struct&#xA;    interface IFormattable&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.DateTimeOffset&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.DateTimeOffset&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Reprezentuje punkt w czasie, zwykle wyrażonej w postaci daty i godziny, dnia, względem uniwersalny czas koordynowany (UTC).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset> Struktura zawiera <xref:System.DateTime> wartość wraz z <xref:System.DateTimeOffset.Offset%2A> właściwość, która określa różnicę między bieżącą <xref:System.DateTimeOffset> wystąpienia daty i godziny oraz uniwersalny czas koordynowany (UTC). Ponieważ dokładnie określa datę i godzinę względem czasu UTC, <xref:System.DateTimeOffset> nie ma struktury `Kind` elementu członkowskiego, jako <xref:System.DateTime> jest struktura. Reprezentuje daty i godziny z wartości, których UTC zakresu od północy 12:00:00, 1 stycznia 0001 Anno Domini (typowe Era), do 11:59:59 PM, 31 grudnia 9999 r. (C.E.).  
  
 Składnik godziny <xref:System.DateTimeOffset> wartość jest podawana w 100-nanosekundowych jednostek nazywanych znaczniki i określonej daty to liczbę taktów od momentu 12:00, a 1 stycznia, 0001 r. N.E. (R) w <xref:System.Globalization.GregorianCalendar> kalendarza. A <xref:System.DateTimeOffset> wartość jest zawsze wyrażona w kontekście jawnego lub domyślna kalendarz. Znaczniki, które są przypisane do leap sekund nie znajdują się w łączną liczbę taktów.  
  
> [!NOTE]
>  Jeśli pracujesz z wartość impulsów, że ma zostać przekonwertowany na niektóre inne interwał czasu, takich jak minut i sekund, należy użyć <xref:System.TimeSpan.TicksPerDay?displayProperty=nameWithType>, <xref:System.TimeSpan.TicksPerHour?displayProperty=nameWithType>, <xref:System.TimeSpan.TicksPerMinute?displayProperty=nameWithType>, <xref:System.TimeSpan.TicksPerSecond?displayProperty=nameWithType>, lub <xref:System.TimeSpan.TicksPerMillisecond?displayProperty=nameWithType> stała, aby dokonać konwersji. Na przykład, aby dodać liczbę sekund reprezentowany przez określoną liczbę znaczniki osi <xref:System.DateTimeOffset.Second%2A> składnika <xref:System.DateTimeOffset> wartości, można użyć wyrażenia `dateValue.Second + nTicks/Timespan.TicksPerSecond`.  
  
 Mimo że <xref:System.DateTimeOffset> wartość obejmuje przesunięcie, nie jest to struktura danych pełni strefy czasowej obsługujący. Przesunięcie od czasu UTC jest pojedynczy parametr strefy czasowej, go nie jednoznacznie identyfikuje strefę czasową. Nie tylko w wielu strefach czasowych korzystają z tej samej przesunięcie od czasu UTC, ale przesunięcie jednej strefie czasowej zmian on obowiązuje czas letni. Oznacza to, że, jak najszybciej <xref:System.DateTimeOffset> wartości są oddzielone od strefy czasowej, ona już nie można jednoznacznie połączyć do jego oryginalnej strefy czasowej.  
  
 Ponieważ <xref:System.DateTimeOffset> jest strukturą, <xref:System.DateTimeOffset> obiekt, który został zadeklarowany, ale nie został zainicjowany zawiera wartości domyślne dla każdego z jego pól elementu członkowskiego. Oznacza to, że jego <xref:System.DateTimeOffset.DateTime%2A> właściwość jest ustawiona na <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType> i jego <xref:System.DateTimeOffset.Offset%2A> właściwość jest ustawiona na <xref:System.TimeSpan.Zero?displayProperty=nameWithType>.  
  
 Można utworzyć nowy <xref:System.DateTimeOffset> wartość wywołując żadnego przeciążenia jego konstruktora, które są podobne do przeciążone konstruktory <xref:System.DateTime> struktury. Można również utworzyć nowy <xref:System.DateTimeOffset> wartości przez przypisanie <xref:System.DateTime> wartość. Jest to niejawna konwersja; nie wymagają operator rzutowania (w języku C#) lub wywołanie metody konwersji (w języku Visual Basic). Można również zainicjować <xref:System.DateTimeOffset> wartość z reprezentacji ciągu daty i czasu, przez wywołanie metody liczba statyczny ciąg analizowania metody, które obejmują <xref:System.DateTimeOffset.Parse%2A>, <xref:System.DateTimeOffset.ParseExact%2A>, <xref:System.DateTimeOffset.TryParse%2A>, i <xref:System.DateTimeOffset.TryParseExact%2A>.  
  
 Elementy członkowskie <xref:System.DateTimeOffset> struktury zapewniać funkcje w następujących obszarach:  
  
-   Data i godzina arytmetyczne.  
  
     Można dodawać lub odjęcia daty lub przedziały czasu, w szczególności <xref:System.DateTimeOffset> wartość. Operacje arytmetyczne z <xref:System.DateTimeOffset> wartości, w przeciwieństwie do tych, których <xref:System.DateTime> wartości, Dostosuj różnic w przesunięcia czasowego, zwracając wynik. Na przykład poniższy kod używa <xref:System.DateTime> zmienne do odjęcia bieżącym czasem lokalnym od bieżącego czasu UTC. Następnie używa kod <xref:System.DateTimeOffset> zmienne, aby wykonać operację. Odejmowanie z <xref:System.DateTime> wartości zwraca różnicy lokalnej strefy czasowej z formatem UTC, podczas odejmowania z <xref:System.DateTimeOffset> wartości zwraca <xref:System.TimeSpan.Zero?displayProperty=nameWithType>.  
  
     [!code-csharp[System.DateTimeOffset.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Type/cs/Type.cs#1)]
     [!code-vb[System.DateTimeOffset.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Type/vb/Type.vb#1)]  
  
-   Typ operacji konwersji.  
  
     Możesz przekształcić <xref:System.DateTimeOffset> wartości do <xref:System.DateTimeOffset.DateTime%2A> wartości i na odwrót.  
  
-   Czas operacji manipulacji i wyodrębniania.  
  
     Można wyodrębnić data lub godzina <xref:System.DateTimeOffset> wartość. Można również pobrać wartość określonego <xref:System.DateTimeOffset> składnika, np. rok lub jego miesiąca.  
  
-   Data i godzina konwersji.  
  
     Możesz przekształcić żadnego <xref:System.DateTimeOffset> wartość do innego <xref:System.DateTimeOffset> wartość, która reprezentuje tego samego punktu w czasie w innej strefie czasowej. Jednak strefę czasową korekty reguły są stosowane tylko w odniesieniu <xref:System.DateTimeOffset.ToLocalTime%2A> metodę, która konwertuje <xref:System.DateTimeOffset> wartość daty i godziny w strefie systemu lokalnego.  
  
-   Data i godzina porównania.  
  
     Można określić, czy którekolwiek określonego <xref:System.DateTimeOffset> wartość jest wcześniejsza niż takie same jak lub nowszej niż inna <xref:System.DateTimeOffset> wartość. Przed wykonaniem porównanie, wszystkie wartości są konwertowane na czas UTC.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTimeOffset" /> struktury.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTimeOffset (DateTime dateTime);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.DateTime dateTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.#ctor(System.DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset(DateTime dateTime);" />
      <MemberSignature Language="F#" Value="new DateTimeOffset : DateTime -&gt; DateTimeOffset" Usage="new System.DateTimeOffset dateTime" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dateTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="dateTime">Data i godzina.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTimeOffset" /> struktury przy użyciu określonego <see cref="T:System.DateTime" /> wartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor zachowanie zależy od wartości <xref:System.DateTime.Kind%2A?displayProperty=nameWithType> właściwość `dateTime` parametru:  
  
-   Jeśli wartość <xref:System.DateTime.Kind%2A?displayProperty=nameWithType> jest <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, <xref:System.DateTimeOffset.DateTime%2A> właściwości nowe wystąpienie jest równe `dateTime`i <xref:System.DateTimeOffset.Offset%2A> właściwość ma wartość równą <xref:System.TimeSpan.Zero>.  
  
-   Jeśli wartość <xref:System.DateTime.Kind%2A?displayProperty=nameWithType> jest <xref:System.DateTimeKind.Local?displayProperty=nameWithType> lub <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>, <xref:System.DateTimeOffset.DateTime%2A> właściwości nowe wystąpienie jest równe `dateTime`i <xref:System.DateTimeOffset.Offset%2A> właściwość ma wartość równą przesunięcie bieżącej strefy czasowej systemu lokalnego.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wartość <xref:System.DateTime.Kind%2A?displayProperty=nameWithType> właściwość `dateTime` parametr ma wpływ na wartość daty i godziny, która jest zwracana w wyniku tego konstruktora.  
  
 [!code-csharp[System.DateTimeOffset.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Constructors/cs/Constructors.cs#1)]
 [!code-vb[System.DateTimeOffset.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Constructors/vb/Constructors.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Uniwersalny czas koordynowany (UTC), datę i godzinę, będącą wynikiem zastosowania przesunięcie jest starsza niż <see cref="F:System.DateTimeOffset.MinValue" />.  - lub - jest późniejsza niż data i godzina, będącą wynikiem zastosowania przesunięcie UTC <see cref="F:System.DateTimeOffset.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTimeOffset (DateTime dateTime, TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.DateTime dateTime, valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.#ctor(System.DateTime,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset(DateTime dateTime, TimeSpan offset);" />
      <MemberSignature Language="F#" Value="new DateTimeOffset : DateTime * TimeSpan -&gt; DateTimeOffset" Usage="new System.DateTimeOffset (dateTime, offset)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dateTime" Type="System.DateTime" />
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="dateTime">Data i godzina.</param>
        <param name="offset">Przesunięcie czasu od skoordynowanego czasu uniwersalnego (UTC).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTimeOffset" /> struktury przy użyciu określonego <see cref="T:System.DateTime" /> wartość i przesunięcie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor zachowanie zależy od częściowo wartość <xref:System.DateTime.Kind%2A> właściwość `dateTime` parametru:  
  
-   Jeśli wartość <xref:System.DateTime.Kind%2A> jest <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, wartość `offset` parametru musi być równa 0 lub <xref:System.ArgumentException> jest generowany.  
  
-   Jeśli wartość <xref:System.DateTime.Kind%2A> jest <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, wartość `offset` parametru musi być równa przesunięcia lokalnej strefy czasowej z uniwersalnego czasu koordynowanego (UTC) na określonym dniu lub <xref:System.ArgumentException> jest generowany.  
  
-   Jeśli wartość <xref:System.DateTime.Kind%2A> jest <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>, `offset` parametr może mieć dowolną prawidłową wartość.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak zainicjować <xref:System.DateTimeOffset> obiektu z datą i godziną i przesunięcie w lokalnej strefie czasowej podczas tej strefy czasowej nie jest znany wcześniej.  
  
 [!code-csharp[System.DateTimeOffset.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Constructors/cs/Constructors.cs#3)]
 [!code-vb[System.DateTimeOffset.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Constructors/vb/Constructors.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="dateTime.Kind" /> Equals <see cref="F:System.DateTimeKind.Utc" /> i <paramref name="offset" /> nie jest równa zero.  - lub - <paramref name="dateTime.Kind" /> jest równe <see cref="F:System.DateTimeKind.Local" /> i <paramref name="offset" /> nie jest równa przesunięcie systemu lokalnej strefy czasowej.  - lub - <paramref name="offset" /> nie jest określone w pełnych minutach.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż-14 godzin lub większa niż 14 godzin.  - lub - <see cref="P:System.DateTimeOffset.UtcDateTime" /> jest mniejsza niż <see cref="F:System.DateTimeOffset.MinValue" /> lub większa niż <see cref="F:System.DateTimeOffset.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTimeOffset (long ticks, TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 ticks, valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.#ctor(System.Int64,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ticks As Long, offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset(long ticks, TimeSpan offset);" />
      <MemberSignature Language="F#" Value="new DateTimeOffset : int64 * TimeSpan -&gt; DateTimeOffset" Usage="new System.DateTimeOffset (ticks, offset)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ticks" Type="System.Int64" />
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="ticks">Data i godzina wyrażone jako liczba 100-nanosekundowych interwałów, które upłynęły od północy 12:00:00 w dniu 1 stycznia 0001.</param>
        <param name="offset">Przesunięcie czasu od skoordynowanego czasu uniwersalnego (UTC).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTimeOffset" /> struktury przy użyciu określonej liczby znaczników i przesunięcie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle próby wywołania <xref:System.DateTimeOffset.%23ctor%2A> Konstruktor do tworzenia wystąpienia <xref:System.DateTimeOffset> wartości z czasem lokalnym i przesunięcia innych niż że z czasem lokalnym strefy zgłasza <xref:System.ArgumentException>. Można użyć tego przeciążenia <xref:System.DateTimeOffset> konstruktora w celu obejścia tego ograniczenia. W poniższym przykładzie użyto czasu lokalnego liczbę znaczników do utworzenia wystąpienia <xref:System.DateTimeOffset> wartości, których przesunięcie nie musi to oznaczać który czas lokalny:  
  
 [!code-csharp[System.DateTimeOffset.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Constructors/cs/Constructors.cs#4)]
 [!code-vb[System.DateTimeOffset.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Constructors/vb/Constructors.vb#4)]  
  
   
  
## Examples  
 W poniższym przykładzie inicjowane <xref:System.DateTimeOffset> obiektu za pomocą dowolnego datę (w tym przypadku 16 lipca 2007 godzinie 1:32) z przesunięciem równym -5 liczbę znaczników.  
  
 [!code-csharp[System.DateTimeOffset.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Constructors/cs/Constructors.cs#2)]
 [!code-vb[System.DateTimeOffset.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Constructors/vb/Constructors.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> nie określono w pełnych minutach.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.DateTimeOffset.UtcDateTime" /> Właściwości jest starsza niż <see cref="F:System.DateTimeOffset.MinValue" /> lub nowszej niż <see cref="F:System.DateTimeOffset.MaxValue" />.  - lub - <paramref name="ticks" /> jest mniejsza niż <see langword="DateTimeOffset.MinValue.Ticks" /> lub większa niż <see langword="DateTimeOffset.MaxValue.Ticks" />.  - lub - <paramref name="Offset" /> s mniejszy niż-14 godzin lub większa niż 14 godzin.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTimeOffset (int year, int month, int day, int hour, int minute, int second, TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer, offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset(int year, int month, int day, int hour, int minute, int second, TimeSpan offset);" />
      <MemberSignature Language="F#" Value="new DateTimeOffset : int * int * int * int * int * int * TimeSpan -&gt; DateTimeOffset" Usage="new System.DateTimeOffset (year, month, day, hour, minute, second, offset)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="year">Rok (od 1 do 9999).</param>
        <param name="month">Miesiąc (od 1 do 12).</param>
        <param name="day">Dzień (1 przez liczbę dni w <c>miesiąca</c>).</param>
        <param name="hour">Godziny (od 0 do 23).</param>
        <param name="minute">Minuty (od 0 do 59).</param>
        <param name="second">Liczba sekund (od 0 do 59).</param>
        <param name="offset">Przesunięcie czasu od skoordynowanego czasu uniwersalnego (UTC).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTimeOffset" /> struktury przy użyciu określony rok, miesiąc, dzień, godzinę, minutę, sekundę i przesunięcie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor interpretuje `year`, `month`, i `day` jako rok, miesiąc i dzień kalendarza gregoriańskiego. Można utworzyć wystąpienia <xref:System.DateTimeOffset> wartość przy użyciu rok, miesiąc i dzień w kalendarzu innego wywołania <xref:System.DateTimeOffset.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%2CSystem.TimeSpan%29> konstruktora.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.DateTimeOffset> obiektu przy użyciu <xref:System.DateTimeOffset.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.TimeSpan%29?displayProperty=nameWithType> przeładowania konstruktora.  
  
 [!code-csharp[System.DateTimeOffset.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Constructors/cs/Constructors.cs#5)]
 [!code-vb[System.DateTimeOffset.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Constructors/vb/Constructors.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> reprezentuje pełnych minutach.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> jest mniejsza niż jeden lub większa niż 9999.  - lub - <paramref name="month" /> jest mniejsza niż jeden lub większa niż 12.  - lub - <paramref name="day" /> jest mniejsza niż jeden lub większa niż liczba dni w <paramref name="month" />.  - lub - <paramref name="hour" /> jest mniejsza niż zero lub większą niż 23.  - lub - <paramref name="minute" /> jest mniejsza niż 0 lub większą niż 59.  - lub - <paramref name="second" /> jest mniejsza niż 0 lub większą niż 59.  - lub - <paramref name="offset" /> jest mniejsza niż-14 godzin lub większa niż 14 godzin.  - lub - <see cref="P:System.DateTimeOffset.UtcDateTime" /> właściwości jest starsza niż <see cref="F:System.DateTimeOffset.MinValue" /> lub nowszej niż <see cref="F:System.DateTimeOffset.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTimeOffset (int year, int month, int day, int hour, int minute, int second, int millisecond, TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, int32 millisecond, valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (year As Integer, month As Integer, day As Integer, hour As Integer, minute As Integer, second As Integer, millisecond As Integer, offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, TimeSpan offset);" />
      <MemberSignature Language="F#" Value="new DateTimeOffset : int * int * int * int * int * int * int * TimeSpan -&gt; DateTimeOffset" Usage="new System.DateTimeOffset (year, month, day, hour, minute, second, millisecond, offset)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="millisecond" Type="System.Int32" />
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="year">Rok (od 1 do 9999).</param>
        <param name="month">Miesiąc (od 1 do 12).</param>
        <param name="day">Dzień (1 przez liczbę dni w <c>miesiąca</c>).</param>
        <param name="hour">Godziny (od 0 do 23).</param>
        <param name="minute">Minuty (od 0 do 59).</param>
        <param name="second">Liczba sekund (od 0 do 59).</param>
        <param name="millisecond">Milisekundy (od 0 do 999).</param>
        <param name="offset">Przesunięcie czasu od skoordynowanego czasu uniwersalnego (UTC).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTimeOffset" /> struktury przy użyciu określony rok, miesiąc, dzień, godzinę, minutę, sekundę, milisekundy i przesunięcie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor interpretuje `year`, `month`, i `day` jako rok, miesiąc i dzień kalendarza gregoriańskiego. Można utworzyć wystąpienia <xref:System.DateTimeOffset> wartość przy użyciu rok, miesiąc i dzień w kalendarzu innego wywołania <xref:System.DateTimeOffset.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.Calendar%2CSystem.TimeSpan%29> konstruktora.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.DateTimeOffset> obiektu przy użyciu <xref:System.DateTimeOffset.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.TimeSpan%29?displayProperty=nameWithType> przeładowania konstruktora.  
  
 [!code-csharp[System.DateTimeOffset.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Constructors/cs/Constructors.cs#7)]
 [!code-vb[System.DateTimeOffset.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Constructors/vb/Constructors.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> reprezentuje pełnych minutach.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> jest mniejsza niż jeden lub większa niż 9999.  - lub - <paramref name="month" /> jest mniejsza niż jeden lub większa niż 12.  - lub - <paramref name="day" /> jest mniejsza niż jeden lub większa niż liczba dni w <paramref name="month" />.  - lub - <paramref name="hour" /> jest mniejsza niż zero lub większą niż 23.  - lub - <paramref name="minute" /> jest mniejsza niż 0 lub większą niż 59.  - lub - <paramref name="second" /> jest mniejsza niż 0 lub większą niż 59.  - lub - <paramref name="millisecond" /> jest mniejsza niż 0 lub większą niż 999.  - lub - <paramref name="offset" /> jest mniejsza niż -14 lub większa niż 14.  - lub - <see cref="P:System.DateTimeOffset.UtcDateTime" /> właściwości jest starsza niż <see cref="F:System.DateTimeOffset.MinValue" /> lub nowszej niż <see cref="F:System.DateTimeOffset.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DateTimeOffset (int year, int month, int day, int hour, int minute, int second, int millisecond, System.Globalization.Calendar calendar, TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, int32 millisecond, class System.Globalization.Calendar calendar, valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Globalization.Calendar,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, System::Globalization::Calendar ^ calendar, TimeSpan offset);" />
      <MemberSignature Language="F#" Value="new DateTimeOffset : int * int * int * int * int * int * int * System.Globalization.Calendar * TimeSpan -&gt; DateTimeOffset" Usage="new System.DateTimeOffset (year, month, day, hour, minute, second, millisecond, calendar, offset)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="year" Type="System.Int32" />
        <Parameter Name="month" Type="System.Int32" />
        <Parameter Name="day" Type="System.Int32" />
        <Parameter Name="hour" Type="System.Int32" />
        <Parameter Name="minute" Type="System.Int32" />
        <Parameter Name="second" Type="System.Int32" />
        <Parameter Name="millisecond" Type="System.Int32" />
        <Parameter Name="calendar" Type="System.Globalization.Calendar" />
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="year">Rok.</param>
        <param name="month">Miesiąc (od 1 do 12).</param>
        <param name="day">Dzień (1 przez liczbę dni w <c>miesiąca</c>).</param>
        <param name="hour">Godziny (od 0 do 23).</param>
        <param name="minute">Minuty (od 0 do 59).</param>
        <param name="second">Liczba sekund (od 0 do 59).</param>
        <param name="millisecond">Milisekundy (od 0 do 999).</param>
        <param name="calendar">Kalendarz, który służy do interpretowania <c>roku</c>, <c>miesiąca</c>, i <c>dzień</c>.</param>
        <param name="offset">Przesunięcie czasu od skoordynowanego czasu uniwersalnego (UTC).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.DateTimeOffset" /> struktury przy użyciu określony rok, miesiąc, dzień, godzinę, minutę, sekundę, milisekund i przesunięcie określony kalendarz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `year`, `month`, `day`, `hour`, `minute`, `second`, I `millisecond` wszystkie parametry odzwierciedlają wartości wyrażone w kalendarzu określony przez `calendar` parametru. Jeśli te wartości formularza datę i godzinę, których nie można wyrazić za pomocą tego kalendarza, jest zgłaszany wyjątek.  
  
   
  
## Examples  
 W poniższym przykładzie użyto wystąpienia obu <xref:System.Globalization.HebrewCalendar> klasy i <xref:System.Globalization.HijriCalendar> klasa do tworzenia wystąpienia <xref:System.DateTimeOffset> wartość. Data następnie zostanie wyświetlony w konsoli przy użyciu odpowiednich kalendarzy i kalendarza gregoriańskiego.  
  
 [!code-csharp[System.DateTimeOffset.Constructors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Constructors/cs/Constructors.cs#8)]
 [!code-vb[System.DateTimeOffset.Constructors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Constructors/vb/Constructors.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> reprezentuje pełnych minutach.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="calendar" /> nie może być <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="year" /> jest mniejsza niż <paramref name="calendar" /> parametru <see langword="MinSupportedDateTime.Year" /> lub większa niż <see langword="MaxSupportedDateTime.Year" />.  - lub - <paramref name="month" /> jest albo mniejsza lub większa niż liczba miesięcy w <paramref name="year" /> w <paramref name="calendar" />.  - lub - <paramref name="day" /> jest mniejsza niż jeden lub większa niż liczba dni w <paramref name="month" />.  - lub - <paramref name="hour" /> jest mniejsza niż zero lub większą niż 23.  - lub - <paramref name="minute" /> jest mniejsza niż 0 lub większą niż 59.  - lub - <paramref name="second" /> jest mniejsza niż 0 lub większą niż 59.  - lub - <paramref name="millisecond" /> jest mniejsza niż 0 lub większą niż 999.  - lub - <paramref name="offset" /> jest mniejsza niż-14 godzin lub większa niż 14 godzin.  - lub - <paramref name="year" />, <paramref name="month" />, i <paramref name="day" /> parametrów nie może być reprezentowany jako wartość daty i godziny.  - lub - <see cref="P:System.DateTimeOffset.UtcDateTime" /> właściwości jest starsza niż <see cref="F:System.DateTimeOffset.MinValue" /> lub nowszej niż <see cref="F:System.DateTimeOffset.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public DateTimeOffset Add (TimeSpan timeSpan);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset Add(valuetype System.TimeSpan timeSpan) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.Add(System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset Add(TimeSpan timeSpan);" />
      <MemberSignature Language="F#" Value="member this.Add : TimeSpan -&gt; DateTimeOffset" Usage="dateTimeOffset.Add timeSpan" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeSpan" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeSpan">A <see cref="T:System.TimeSpan" /> obiekt, który reprezentuje dodatnią lub ujemną interwału.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTimeOffset" /> obiekt, który dodaje określony interwał wartość tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest równa sumie Data i czas reprezentowany przez bieżący <see cref="T:System.DateTimeOffset" /> obiekt i czas reprezentowany przez <paramref name="timeSpan" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć <xref:System.DateTimeOffset.Add%2A> metodę, aby dodać więcej niż jednego rodzaju interwału czasu (dni, godziny, minuty, sekundy lub milisekund) w ramach jednej operacji. Ta metoda zachowanie jest takie same jak operator dodawania. <xref:System.DateTimeOffset> Struktury obsługuje również metody dodawania specjalne (takie jak <xref:System.DateTimeOffset.AddDays%2A>, <xref:System.DateTimeOffset.AddHours%2A>, i <xref:System.DateTimeOffset.AddMinutes%2A>) dla każdego interwału czasu.  
  
> [!NOTE]
>  Ta metoda zwraca nową <xref:System.DateTimeOffset> obiektu. Nie modyfikuje wartość bieżącego obiektu przez dodanie `timeSpan` do jego daty i godziny.  
  
 <xref:System.DateTimeOffset.Add%2A> — Metoda nie ma wpływu na wartość bieżącej klasy <xref:System.DateTimeOffset> obiektu <xref:System.DateTimeOffset.Offset%2A> właściwości.  
  
 Ponieważ <xref:System.DateTimeOffset> obiekt nie reprezentuje datę i godzinę w określonej strefy czasowej, <xref:System.DateTimeOffset.Add%2A> — metoda nie należy wziąć pod uwagę daną strefę czasową dostosowania reguł podczas wykonywania arytmetyczne daty i czasu.  
  
 Jeśli `timeSpan` parametr jest `null`, ta metoda zwraca wartość oryginalna <xref:System.DateTimeOffset> obiektu bez zmian.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę <xref:System.TimeSpan> obiekty reprezentujące czasu przesyłane między miejsc docelowych. <xref:System.DateTimeOffset.Add%2A> Metoda następnie dodaje te czasy <xref:System.DateTimeOffset> obiekt, który reprezentuje przesyłane początkowego startowania czasu. Wynik odzwierciedla Godzina nadejścia zaplanowane w każdej lokalizacji docelowej.  
  
 [!code-csharp[System.DateTimeOffset.Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/cs/Methods.cs#1)]
 [!code-vb[System.DateTimeOffset.Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/vb/Methods.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest mniejsza niż <see cref="F:System.DateTimeOffset.MinValue" />.  - lub - powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest większa niż <see cref="F:System.DateTimeOffset.MaxValue" />.</exception>
        <altmember cref="M:System.DateTimeOffset.op_Addition(System.DateTimeOffset,System.TimeSpan)" />
      </Docs>
    </Member>
    <Member MemberName="AddDays">
      <MemberSignature Language="C#" Value="public DateTimeOffset AddDays (double days);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset AddDays(float64 days) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.AddDays(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddDays (days As Double) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset AddDays(double days);" />
      <MemberSignature Language="F#" Value="member this.AddDays : double -&gt; DateTimeOffset" Usage="dateTimeOffset.AddDays days" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="days" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="days">Liczba całych i ułamkowych dni. Liczba może być dodatnia lub ujemna.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTimeOffset" /> obiekt, który dodaje określoną liczbę dni całość lub część wartość tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest równa sumie Data i czas reprezentowany przez bieżący <see cref="T:System.DateTimeOffset" /> obiekt i liczbę dni reprezentowany przez <paramref name="days" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Części ułamkowej `days` parametr jest ułamkową część dnia. Na przykład 4.5 jest odpowiednikiem 4 dni, 12 godzin, 0 minut, 0 sekund, 0 milisekund. `days` Parametr jest zaokrąglana do najbliższego milisekund.  
  
> [!NOTE]
>  Ta metoda zwraca nową <xref:System.DateTimeOffset> obiektu. Nie modyfikuje wartość bieżącego obiektu przez dodanie `days` do jego daty i godziny.  
  
 Ponieważ <xref:System.DateTimeOffset> obiekt nie reprezentuje datę i godzinę w określonej strefy czasowej, <xref:System.DateTimeOffset.AddDays%2A> — metoda nie należy wziąć pod uwagę daną strefę czasową dostosowania reguł podczas wykonywania arytmetyczne daty i czasu.  
  
 Konwertowanie przedziały czasu mniejsze niż dnia ułamka może obejmować utratę dokładności. Jeśli jest to problem, możesz użyć <xref:System.DateTimeOffset.Add%2A> metodę, która można określić więcej niż jednego rodzaju interwał czasu w wywołaniu metody pojedynczego i eliminuje potrzebę przekonwertować przedziały czasu ułamkowych części dnia.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTimeOffset.AddDays%2A> metodę do listy daty, które wchodzą w poniedziałek, początek tygodnia pracy marca 2008.  
  
 [!code-csharp[System.DateTimeOffset.Methods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/cs/Methods.cs#2)]
 [!code-vb[System.DateTimeOffset.Methods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/vb/Methods.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest mniejsza niż <see cref="F:System.DateTimeOffset.MinValue" />.  - lub - powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest większa niż <see cref="F:System.DateTimeOffset.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddHours">
      <MemberSignature Language="C#" Value="public DateTimeOffset AddHours (double hours);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset AddHours(float64 hours) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.AddHours(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddHours (hours As Double) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset AddHours(double hours);" />
      <MemberSignature Language="F#" Value="member this.AddHours : double -&gt; DateTimeOffset" Usage="dateTimeOffset.AddHours hours" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hours" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="hours">Liczba godzin całość lub część. Liczba może być dodatnia lub ujemna.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTimeOffset" /> obiekt, który dodaje określoną liczbę godzin całość lub część wartość tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest równa sumie Data i czas reprezentowany przez bieżący <see cref="T:System.DateTimeOffset" /> obiekt i liczbę godzin reprezentowany przez <paramref name="hours" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Części ułamkowej `hours` parametr jest część ułamkowa godziny. Na przykład 4.5 jest odpowiednikiem 4 godzin, 30 minut, 0 sekund, 0 milisekund. `hours` Parametr jest zaokrąglana do najbliższego milisekund.  
  
> [!NOTE]
>  Ta metoda zwraca nową <xref:System.DateTimeOffset> obiektu. Nie modyfikuje wartość bieżącego obiektu przez dodanie `hours` do jego daty i godziny.  
  
 Ponieważ <xref:System.DateTimeOffset> obiekt nie reprezentuje datę i godzinę w określonej strefy czasowej, <xref:System.DateTimeOffset.AddHours%2A> — metoda nie należy wziąć pod uwagę daną strefę czasową dostosowania reguł podczas wykonywania arytmetyczne daty i czasu.  
  
 Konwertowanie przedziały czasu niecałej godziny ułamka może obejmować utratę dokładności. (Na przykład jedna minuta jest 0.01666 godzinę). Jeśli jest to problem, możesz użyć <xref:System.DateTimeOffset.Add%2A> metodę, która można określić więcej niż jednego rodzaju interwał czasu w wywołaniu metody pojedynczego i eliminuje potrzebę przekonwertować przedziały czasu ułamkowych części godzinę.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTimeOffset.AddHours%2A> metody, aby wyświetlić listę godzin rozpoczęcia pracy przewiduje się na dany tydzień urzędzie, który ma dwie zmiany ośmiu godzin na dzień.  
  
 [!code-csharp[System.DateTimeOffset.Methods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/cs/Methods.cs#3)]
 [!code-vb[System.DateTimeOffset.Methods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/vb/Methods.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest mniejsza niż <see cref="F:System.DateTimeOffset.MinValue" />.  - lub - powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest większa niż <see cref="F:System.DateTimeOffset.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddMilliseconds">
      <MemberSignature Language="C#" Value="public DateTimeOffset AddMilliseconds (double milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset AddMilliseconds(float64 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.AddMilliseconds(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddMilliseconds (milliseconds As Double) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset AddMilliseconds(double milliseconds);" />
      <MemberSignature Language="F#" Value="member this.AddMilliseconds : double -&gt; DateTimeOffset" Usage="dateTimeOffset.AddMilliseconds milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Liczba milisekund całość lub część. Liczba może być dodatnia lub ujemna.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTimeOffset" /> obiekt, który dodaje określoną liczbę milisekund do wartość tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest równa sumie Data i czas reprezentowany przez bieżący <see cref="T:System.DateTimeOffset" /> obiektu i liczby pełnych milisekund reprezentowany przez <paramref name="milliseconds" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Części ułamkowej `milliseconds` parametr jest część ułamkowa milisekundy. Na przykład jest odpowiednikiem 4 milisekundy i 5000 znaczników, gdzie jednej milisekundy równa 10 000 impulsów 4.5. Jednak `milliseconds` jest zaokrąglana do najbliższego milisekund; wszystkie wartości.5 lub większa są zaokrąglane w górę.  
  
> [!NOTE]
>  Ta metoda zwraca nową <xref:System.DateTimeOffset> obiektu. Nie modyfikuje wartość bieżącego obiektu przez dodanie `milliseconds` do jego daty i godziny.  
  
 Ponieważ <xref:System.DateTimeOffset> obiekt nie reprezentuje datę i godzinę w określonej strefy czasowej, <xref:System.DateTimeOffset.AddMilliseconds%2A> — metoda nie należy wziąć pod uwagę daną strefę czasową dostosowania reguł podczas wykonywania arytmetyczne daty i czasu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest mniejsza niż <see cref="F:System.DateTimeOffset.MinValue" />.  - lub - powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest większa niż <see cref="F:System.DateTimeOffset.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddMinutes">
      <MemberSignature Language="C#" Value="public DateTimeOffset AddMinutes (double minutes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset AddMinutes(float64 minutes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.AddMinutes(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddMinutes (minutes As Double) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset AddMinutes(double minutes);" />
      <MemberSignature Language="F#" Value="member this.AddMinutes : double -&gt; DateTimeOffset" Usage="dateTimeOffset.AddMinutes minutes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minutes" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="minutes">Liczba minut całość lub część. Liczba może być dodatnia lub ujemna.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTimeOffset" /> obiekt, który dodaje określoną liczbę minut całość lub część wartość tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest równa sumie Data i czas reprezentowany przez bieżący <see cref="T:System.DateTimeOffset" /> obiekt i liczbę minut reprezentowany przez <paramref name="minutes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Części ułamkowej `minutes` parametr jest części ułamkowej minutę. Na przykład 4.5 jest odpowiednikiem 4 minut, 30 sekund, 0 milisekund. `minutes` Parametr jest zaokrąglana do najbliższego milisekund.  
  
> [!NOTE]
>  Ta metoda zwraca nową <xref:System.DateTimeOffset> obiektu. Nie modyfikuje wartość bieżącego obiektu przez dodanie `minutes` do jego daty i godziny.  
  
 Ponieważ <xref:System.DateTimeOffset> obiekt nie reprezentuje datę i godzinę w określonej strefy czasowej, <xref:System.DateTimeOffset.AddMinutes%2A> — metoda nie należy wziąć pod uwagę daną strefę czasową dostosowania reguł podczas wykonywania arytmetyczne daty i czasu.  
  
 Konwertowanie przedziały czasu z mniej niż minutę ułamka może obejmować utratę dokładności. (Na przykład jednej sekundzie jest 0.01666 minutę). Jeśli jest to problem, możesz użyć <xref:System.DateTimeOffset.Add%2A> metodę, która można określić więcej niż jednego rodzaju interwał czasu w wywołaniu metody pojedynczego i eliminuje potrzebę przekonwertować przedziały czasu ułamkowych części minutę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest mniejsza niż <see cref="F:System.DateTimeOffset.MinValue" />.  - lub - powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest większa niż <see cref="F:System.DateTimeOffset.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddMonths">
      <MemberSignature Language="C#" Value="public DateTimeOffset AddMonths (int months);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset AddMonths(int32 months) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.AddMonths(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddMonths (months As Integer) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset AddMonths(int months);" />
      <MemberSignature Language="F#" Value="member this.AddMonths : int -&gt; DateTimeOffset" Usage="dateTimeOffset.AddMonths months" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="months" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="months">Liczby całkowitej. Liczba może być dodatnia lub ujemna.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTimeOffset" /> obiekt, który dodaje określoną liczbę miesięcy do wartości tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest równa sumie Data i czas reprezentowany przez bieżący <see cref="T:System.DateTimeOffset" /> obiekt i liczba miesięcy reprezentowany przez <paramref name="months" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości innych metod, które dodać jeden raz jednostkę interwału (na przykład minut lub dni) na wartość daty i godziny <xref:System.DateTimeOffset.AddMonths%2A> nie umożliwiają dodawanie ułamkowych części miesiąca. Aby dodać czas, który składa się z innymi jednostki czasu oprócz miesięcy do <xref:System.DateTimeOffset> obiektów, użyj <xref:System.DateTimeOffset.Add%2A> metody.  
  
> [!NOTE]
>  Ta metoda zwraca nową <xref:System.DateTimeOffset> obiektu. Nie modyfikuje wartość bieżącego obiektu przez dodanie `months` do jego daty i godziny.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTimeOffset.AddMonths%2A> metodę, aby wyświetlić datę rozpoczęcia każdego kwartału roku 2007.  
  
 [!code-csharp[System.DateTimeOffset.Methods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/cs/Methods.cs#4)]
 [!code-vb[System.DateTimeOffset.Methods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/vb/Methods.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest mniejsza niż <see cref="F:System.DateTimeOffset.MinValue" />.  - lub - powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest większa niż <see cref="F:System.DateTimeOffset.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddSeconds">
      <MemberSignature Language="C#" Value="public DateTimeOffset AddSeconds (double seconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset AddSeconds(float64 seconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.AddSeconds(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddSeconds (seconds As Double) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset AddSeconds(double seconds);" />
      <MemberSignature Language="F#" Value="member this.AddSeconds : double -&gt; DateTimeOffset" Usage="dateTimeOffset.AddSeconds seconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="seconds" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="seconds">Liczba całych i ułamkowych części sekundy. Liczba może być dodatnia lub ujemna.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTimeOffset" /> obiekt, który dodaje określoną liczbę sekund całość lub część wartość tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest równa sumie Data i czas reprezentowany przez bieżący <see cref="T:System.DateTimeOffset" /> obiekt i liczbę sekund reprezentowany przez <paramref name="seconds" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Części ułamkowej `seconds` parametr jest ułamkowych części sekundy. W poniższej tabeli przedstawiono wartości ułamkowych części sekundy.  
  
|Druga wartość|Odpowiednik|  
|------------------|----------------|  
|drugie.1|100 milisekund|  
|.01 sekundę|10 MS|  
|.001 sekundę|1 milisekundy|  
  
 `seconds` Parametr jest zaokrąglana do najbliższego milisekund.  
  
> [!NOTE]
>  Ta metoda zwraca nową <xref:System.DateTimeOffset> obiektu. Nie modyfikuje wartość bieżącego obiektu przez dodanie `minutes` do jego daty i godziny.  
  
 Ponieważ <xref:System.DateTimeOffset> obiekt nie reprezentuje datę i godzinę w określonej strefy czasowej, <xref:System.DateTimeOffset.AddSeconds%2A> — metoda nie należy wziąć pod uwagę daną strefę czasową dostosowania reguł podczas wykonywania arytmetyczne daty i czasu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest mniejsza niż <see cref="F:System.DateTimeOffset.MinValue" />.  - lub - powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest większa niż <see cref="F:System.DateTimeOffset.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddTicks">
      <MemberSignature Language="C#" Value="public DateTimeOffset AddTicks (long ticks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset AddTicks(int64 ticks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.AddTicks(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddTicks (ticks As Long) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset AddTicks(long ticks);" />
      <MemberSignature Language="F#" Value="member this.AddTicks : int64 -&gt; DateTimeOffset" Usage="dateTimeOffset.AddTicks ticks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ticks" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ticks">Liczba 100-nanosekundowych znaczniki osi. Liczba może być dodatnia lub ujemna.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTimeOffset" /> obiekt, który dodaje określoną liczbę znaczników do wartość tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest równa sumie Data i czas reprezentowany przez bieżący <see cref="T:System.DateTimeOffset" /> obiektów i ich liczba reprezentowany przez <paramref name="ticks" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znaczników reprezentuje 100 nanosekundach lub milionowych co 10 sekund. Ponieważ znaczników jest bardzo małe i dokładne interwał, żadnych większych jednostkę czasu może być wyrażona jako liczbę taktów bez utraty dokładności.  
  
> [!NOTE]
>  Ta metoda zwraca nową <xref:System.DateTimeOffset> obiektu. Nie modyfikuje wartość bieżącego obiektu przez dodanie `minutes` do jego daty i godziny.  
  
 W poniższej tabeli wymieniono liczbę znaczników w określonym interwale.  
  
|Interwał czasu|Liczbę znaczników|  
|-------------------|---------------------|  
|Sekunda|10 000 000|  
|Minuta|600,000,000|  
|Godzina|36,000,000,000|  
|Dzień|864,000,000,000|  
|tydzień|6,048,000,000,000|  
|miesiąc|Zależy od liczby dni w miesiącu.|  
|Roku przestępnego inne niż|315,360,000,000,000|  
|Roku przestępnego|316,224,000,000,000|  
  
 Ponieważ <xref:System.DateTimeOffset> obiekt nie reprezentuje datę i godzinę w określonej strefy czasowej, <xref:System.DateTimeOffset.AddTicks%2A> — metoda nie należy wziąć pod uwagę daną strefę czasową dostosowania reguł podczas wykonywania arytmetyczne daty i czasu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest mniejsza niż <see cref="F:System.DateTimeOffset.MinValue" />.  - lub - powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest większa niż <see cref="F:System.DateTimeOffset.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddYears">
      <MemberSignature Language="C#" Value="public DateTimeOffset AddYears (int years);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset AddYears(int32 years) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.AddYears(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddYears (years As Integer) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset AddYears(int years);" />
      <MemberSignature Language="F#" Value="member this.AddYears : int -&gt; DateTimeOffset" Usage="dateTimeOffset.AddYears years" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="years" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="years">Kilka lat temu. Liczba może być dodatnia lub ujemna.</param>
        <summary>Zwraca nowy <see cref="T:System.DateTimeOffset" /> obiekt, który dodaje określoną liczbę lat do wartości tego wystąpienia.</summary>
        <returns>Obiekt, którego wartość jest równa sumie Data i czas reprezentowany przez bieżący <see cref="T:System.DateTimeOffset" /> obiekt i liczbę lat reprezentowany przez <paramref name="years" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości innych metod, które dodać jeden raz jednostkę interwału (na przykład minut lub dni) na wartość daty i godziny <xref:System.DateTimeOffset.AddYears%2A> nie umożliwiają dodawanie ułamkowych części roku. Aby dodać czas, który składa się z innymi jednostki czasu oprócz lat do <xref:System.DateTimeOffset> obiektów, użyj <xref:System.DateTimeOffset.Add%2A> metody.  
  
> [!NOTE]
>  Ta metoda zwraca nową <xref:System.DateTimeOffset> obiektu. Nie modyfikuje wartość bieżącego obiektu przez dodanie `months` do jego daty i godziny.  
  
   
  
## Examples  
 W Stanach Zjednoczonych licencji sterownika nie można wystawić osobom 16 lat. W poniższym przykładzie przedstawiono możliwe datę, na którym osoby muszą być urodzone celu legalnie wydawane prawa jazdy.  
  
 [!code-csharp[System.DateTimeOffset.Methods#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/cs/Methods.cs#6)]
 [!code-vb[System.DateTimeOffset.Methods#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/vb/Methods.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest mniejsza niż <see cref="F:System.DateTimeOffset.MinValue" />.  - lub - powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest większa niż <see cref="F:System.DateTimeOffset.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (DateTimeOffset first, DateTimeOffset second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.DateTimeOffset first, valuetype System.DateTimeOffset second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.Compare(System.DateTimeOffset,System.DateTimeOffset)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (first As DateTimeOffset, second As DateTimeOffset) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(DateTimeOffset first, DateTimeOffset second);" />
      <MemberSignature Language="F#" Value="static member Compare : DateTimeOffset * DateTimeOffset -&gt; int" Usage="System.DateTimeOffset.Compare (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="first" Type="System.DateTimeOffset" />
        <Parameter Name="second" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="first">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="second">Drugi obiekt, który będzie porównywany.</param>
        <summary>Porównuje dwa <see cref="T:System.DateTimeOffset" /> obiekty i wskazuje, czy pierwszy jest wcześniejsza niż drugi, równe drugiemu lub nowsze od drugiego.</summary>
        <returns>Całkowita, która wskazuje, czy wartość <paramref name="first" /> parametr jest wcześniejsza niż późniejsza niż, lub w tym samym czasie jako wartość <paramref name="second" /> parametru, jak to pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana </term><description> znaczenie </description></listheader><item><term> mniejsza od zera </term><description><paramref name="first" /> jest starsza niż <paramref name="second" />.  </description></item><item><term> Zero </term><description><paramref name="first" /> jest równa <paramref name="second" />.  </description></item><item><term> Większa od zera </term><description><paramref name="first" /> jest nowsza niż <paramref name="second" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wykonywanie porównanie, metoda konwertuje zarówno `first` i `second` parametrów do uniwersalnego czasu koordynowanego (UTC) przed przesłaniem porównania. Metoda ta jest równoważna dla następujących czynności:  
  
 [!code-csharp[System.DateTimeOffset.Syntax#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Syntax/cs/Syntax.cs#1)]
 [!code-vb[System.DateTimeOffset.Syntax#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Syntax/vb/Syntax.vb#1)]  
  
 Innymi słowy <xref:System.DateTimeOffset.Compare%2A> Metoda określa, czy dwa <xref:System.DateTimeOffset> obiekty reprezentują pojedynczy punkt w czasie. Porównuje bezpośrednio daty i godziny, a nie przesunięcia.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywołań <xref:System.DateTimeOffset.Compare%2A> metody do porównania <xref:System.DateTimeOffset> obiektów.  
  
 [!code-csharp[System.DateTimeOffset.Methods#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/cs/Methods2.cs#7)]
 [!code-vb[System.DateTimeOffset.Methods#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/vb/Methods2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (DateTimeOffset other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.DateTimeOffset other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.CompareTo(System.DateTimeOffset)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As DateTimeOffset) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(DateTimeOffset other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : DateTimeOffset -&gt; int&#xA;override this.CompareTo : DateTimeOffset -&gt; int" Usage="dateTimeOffset.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania z bieżącym <see cref="T:System.DateTimeOffset" /> obiektu.</param>
        <summary>Porównuje bieżący <see cref="T:System.DateTimeOffset" /> obiekt do określonej <see cref="T:System.DateTimeOffset" /> obiektu i wskazuje, czy bieżący obiekt jest wcześniejsza niż takie same jak lub nowszy od drugiego <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <returns>Liczby całkowite ze znakiem wskazuje relację między bieżącą <see cref="T:System.DateTimeOffset" /> obiektu i <paramref name="other" />, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana </term><description> opis </description></listheader><item><term> mniejsza od zera </term><description> bieżącego <see cref="T:System.DateTimeOffset" /> obiektu jest starsza niż <paramref name="other" />.  </description></item><item><term> Zero </term><description> bieżącego <see cref="T:System.DateTimeOffset" /> obiekt jest taki sam jak <paramref name="other" />.  </description></item><item><term> Większa niż zero.  </term><description> Bieżący <see cref="T:System.DateTimeOffset" /> obiektu jest nowsza niż <paramref name="other" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda porównuje <xref:System.DateTimeOffset> obiektów na podstawie porównania ilości ich <xref:System.DateTimeOffset.UtcDateTime%2A> wartości, oznacza to, określa czy dwa obiekty reprezentują pojedynczy punkt w czasie i wskazuje, czy bieżący obiekt jest wcześniejsza niż, późniejsza niż, lub taka sama jak `other`parametru.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywołań <xref:System.DateTimeOffset.CompareTo%2A> metody do porównania <xref:System.DateTimeOffset> obiektów.  
  
 [!code-csharp[System.DateTimeOffset.Methods#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/cs/Methods3.cs#8)]
 [!code-vb[System.DateTimeOffset.Methods#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/vb/Methods3.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.DateTimeOffset.Date" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Date : DateTime" Usage="System.DateTimeOffset.Date" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.DateTime" /> wartość, która reprezentuje składnik daty bieżącej <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <value>A <see cref="T:System.DateTime" /> wartość, która reprezentuje składnik daty bieżącej <see cref="T:System.DateTimeOffset" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej właściwości spowoduje usunięcie wszelkich znaczną część składnik godziny z <xref:System.DateTimeOffset> obiektu i zwraca jego składnik znaczących daty. Na przykład jeśli <xref:System.DateTimeOffset> obiektu ma wartość daty i godziny "07-1/12 16:01:00 + 7:30", zwraca właściwość <xref:System.DateTime> wartość "1/12/07 00:00:00: 00". <xref:System.DateTime> Wartość mogą być następnie wyświetlane przy użyciu dowolnej z specyfikatory formatu standardowych lub niestandardowych, zawierających tylko daty. (Zobacz sekcję przykład ilustracja).  
  
 Wartość <xref:System.DateTime.Kind%2A?displayProperty=nameWithType> właściwości zwracana <xref:System.DateTime> obiektu jest zawsze <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Nie ma wpływu na wartość <xref:System.DateTimeOffset.Offset%2A> właściwości.  
  
 Aby wyświetlić datę bez jego składnik czasu, umożliwia także "D" lub "d" sformatuj specyfikatory; Ilustracja zobacz sekcję przykład.  
  
   
  
## Examples  
 Poniższy przykład pobiera wartość <xref:System.DateTimeOffset.Date%2A> właściwości dla określonej daty. Następnie wyświetla tej wartości w konsoli przy użyciu specyfikatory niektóre standardowe i niestandardowe formatu daty.  
  
 [!code-csharp[System.DateTimeOffset.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/cs/Properties.cs#1)]
 [!code-vb[System.DateTimeOffset.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/vb/Properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DateTime">
      <MemberSignature Language="C#" Value="public DateTime DateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime DateTime" />
      <MemberSignature Language="DocId" Value="P:System.DateTimeOffset.DateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime DateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.DateTime : DateTime" Usage="System.DateTimeOffset.DateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.DateTime" /> wartość, która reprezentuje datę i godzinę bieżącego <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <value>Data i godzina bieżącego <see cref="T:System.DateTimeOffset" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.DateTime%2A> Właściwość nie ma wpływu na wartość <xref:System.DateTimeOffset.Offset%2A> właściwości.  
  
 Ta właściwość zwraca zarówno data, jak i składnik godziny <xref:System.DateTimeOffset> obiektu, który ułatwia przydatne w przypadku wykonywania <xref:System.DateTimeOffset> do <xref:System.DateTime> konwersji. Na przykład jeśli <xref:System.DateTimeOffset> obiektu ma wartość daty i godziny "07-1/12 16:01:00 + 7:30", właściwość zwraca daty "07-1/12 16:01:00".  
  
 Wartość <xref:System.DateTime.Kind%2A?displayProperty=nameWithType> właściwości zwracana <xref:System.DateTime> obiekt jest <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.DateTimeOffset.DateTime%2A> właściwości można skonwertować godzinę zwrócony przez <xref:System.DateTimeOffset.Now%2A> i <xref:System.DateTimeOffset.UtcNow%2A> właściwości <xref:System.DateTime> wartości.  
  
 [!code-csharp[System.DateTimeOffset.Properties#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/cs/Properties.cs#2)]
 [!code-vb[System.DateTimeOffset.Properties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/vb/Properties.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.DateTimeOffset.LocalDateTime" />
      </Docs>
    </Member>
    <Member MemberName="Day">
      <MemberSignature Language="C#" Value="public int Day { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Day" />
      <MemberSignature Language="DocId" Value="P:System.DateTimeOffset.Day" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Day As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Day { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Day : int" Usage="System.DateTimeOffset.Day" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dzień miesiąca reprezentowany przez bieżący <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <value>Składnik dni bieżącego <see cref="T:System.DateTimeOffset" /> obiektu, wyrażony jako wartość z zakresu od 1 do 31.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.Day%2A> Właściwość nie ma wpływu na wartość <xref:System.DateTimeOffset.Offset%2A> właściwości.  
  
 Można również utworzyć reprezentację ciągu <xref:System.DateTimeOffset> obiektu składnik dni, przez wywołanie metody <xref:System.DateTimeOffset.ToString%2A> metody z specyfikatorów formatu niestandardowego "d" lub "dd".  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono składnik dni z wartości <xref:System.DateTimeOffset> obiektu na trzy sposoby:  
  
-   Pobierając zaletą <xref:System.DateTimeOffset.Day%2A> właściwości.  
  
-   Wywołując <xref:System.DateTimeOffset.ToString%28System.String%29> metody z specyfikator formatu "d".  
  
-   Wywołując <xref:System.DateTimeOffset.ToString%28System.String%29> metody z specyfikator formatu "dd".  
  
 [!code-csharp[System.DateTimeOffset.Properties#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/cs/Properties.cs#10)]
 [!code-vb[System.DateTimeOffset.Properties#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/vb/Properties.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DayOfWeek">
      <MemberSignature Language="C#" Value="public DayOfWeek DayOfWeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DayOfWeek DayOfWeek" />
      <MemberSignature Language="DocId" Value="P:System.DateTimeOffset.DayOfWeek" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DayOfWeek As DayOfWeek" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DayOfWeek DayOfWeek { DayOfWeek get(); };" />
      <MemberSignature Language="F#" Value="member this.DayOfWeek : DayOfWeek" Usage="System.DateTimeOffset.DayOfWeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DayOfWeek</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dnia tygodnia reprezentowany przez bieżący <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <value>Jedną z wartości wyliczenia, które wskazuje dzień tygodnia bieżącego <see cref="T:System.DateTimeOffset" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartości stałe w <xref:System.DayOfWeek> wyliczenie zakresów z <xref:System.DayOfWeek.Sunday?displayProperty=nameWithType> do <xref:System.DayOfWeek.Saturday?displayProperty=nameWithType>. Jeśli rzutowania na liczbę całkowitą, jego wartość należy do zakresu od 0 (co oznacza <xref:System.DayOfWeek.Sunday?displayProperty=nameWithType>) na sześć (co oznacza <xref:System.DayOfWeek.Saturday?displayProperty=nameWithType>).  
  
 Nazwa dnia tygodnia z określonej daty można również wyświetlić przy użyciu specyfikatora formatu "D" lub "dddd" specyfikator formatu niestandardowego. Na przykład:  
  
 [!code-csharp[System.DateTimeOffset.Properties#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/cs/Properties.cs#4)]
 [!code-vb[System.DateTimeOffset.Properties#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/vb/Properties.vb#4)]  
  
 Należy pamiętać, że zwrócony ciąg przez wywołanie metody `ToString` metody <xref:System.DayOfWeek> element członkowski wyliczenia, która jest zwracana przez tę właściwość nie jest lokalizowany. Aby wyodrębnić ciąg znaków zawierający nazwę dzień tygodnia dla bieżącej kultury lub określoną kulturę, należy wywołać <xref:System.DateTimeOffset.ToString%2A> metoda ze specyfikatorem formatu niestandardowego "dddd". Na przykład poniższy kod wyświetla nazwę dzień tygodnia dla daty przy użyciu `fr-fr` kultury.  
  
 [!code-csharp[System.DateTimeOffset.Properties#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/cs/Properties.cs#5)]
 [!code-vb[System.DateTimeOffset.Properties#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/vb/Properties.vb#5)]  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono nazwy dni tygodnia pierwszego dnia każdego miesiąca 2008 roku.  
  
 [!code-csharp[System.DateTimeOffset.Properties#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/cs/Properties.cs#3)]
 [!code-vb[System.DateTimeOffset.Properties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/vb/Properties.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DayOfYear">
      <MemberSignature Language="C#" Value="public int DayOfYear { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DayOfYear" />
      <MemberSignature Language="DocId" Value="P:System.DateTimeOffset.DayOfYear" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DayOfYear As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DayOfYear { int get(); };" />
      <MemberSignature Language="F#" Value="member this.DayOfYear : int" Usage="System.DateTimeOffset.DayOfYear" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dzień roku, reprezentowany przez bieżący <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <value>Dzień roku bieżącego <see cref="T:System.DateTimeOffset" /> obiektu, wyrażony jako wartość z zakresu od 1 do 366.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy dwa <see cref="T:System.DateTimeOffset" /> obiekty są takie same, lub <see cref="T:System.DateTimeOffset" /> obiekt jest taki sam jak określony obiekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (DateTimeOffset other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.DateTimeOffset other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.Equals(System.DateTimeOffset)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(DateTimeOffset other);" />
      <MemberSignature Language="F#" Value="override this.Equals : DateTimeOffset -&gt; bool" Usage="dateTimeOffset.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania z bieżącą <see cref="T:System.DateTimeOffset" /> obiektu.</param>
        <summary>Określa, czy bieżący <see cref="T:System.DateTimeOffset" /> obiekt reprezentuje tego samego punktu w czasie określonym <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <returns>
          <see langword="true" /> Jeśli oba <see cref="T:System.DateTimeOffset" /> obiekty mają takie same <see cref="P:System.DateTimeOffset.UtcDateTime" /> wartości; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed rozpoczęciem porównanie, ta metoda konwertuje wartości obu <xref:System.DateTimeOffset> obiektów uniwersalny czas koordynowany (UTC). Metoda ta jest równoważna dla następujących czynności:  
  
 [!code-csharp[System.DateTimeOffset.Syntax#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Syntax/cs/Syntax.cs#2)]
 [!code-vb[System.DateTimeOffset.Syntax#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Syntax/vb/Syntax.vb#2)]  
  
 Innymi słowy <xref:System.DateTimeOffset.Equals%28System.DateTimeOffset%29> Metoda określa, czy dwa <xref:System.DateTimeOffset> obiekty reprezentują pojedynczy punkt w czasie. Porównuje bezpośrednio daty i godziny, a nie przesunięcia. Aby określić, czy dwa <xref:System.DateTimeOffset> obiekty reprezentują tym samym czasie i mają taką samą wartość przesunięcia, użyj <xref:System.DateTimeOffset.EqualsExact%2A> metody.  
  
 A <xref:System.DateTimeOffset> obiektu, który nie jest `null` jest traktowany jako nowszej (lub nowszego) niż jest `null`.  
  
 To przeciążenie metody <xref:System.DateTimeOffset.Equals%28System.DateTimeOffset%29> implementuje metody <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> metody. Zapewnia nieco większą wydajność niż <xref:System.DateTimeOffset.Equals%28System.Object%29?displayProperty=nameWithType> przeciążać, ponieważ `other` parametru nie ma do skonwertowania obiektu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywołań <xref:System.DateTimeOffset.Equals%28System.DateTimeOffset%29> metody do testowania <xref:System.DateTimeOffset> obiekty do porównania z bieżącym <xref:System.DateTimeOffset> obiektu.  
  
 [!code-csharp[System.DateTimeOffset.Methods#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/cs/Methods.cs#9)]
 [!code-vb[System.DateTimeOffset.Methods#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/vb/Methods.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTimeOffset.EqualsExact(System.DateTimeOffset)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dateTimeOffset.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z bieżącą <see cref="T:System.DateTimeOffset" /> obiektu.</param>
        <summary>Określa, czy <see cref="T:System.DateTimeOffset" /> obiekt reprezentuje tego samego punktu w czasie, gdy określony obiekt.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> parametr jest <see cref="T:System.DateTimeOffset" /> obiektu i reprezentuje tego samego punktu w czasie, gdy bieżący <see cref="T:System.DateTimeOffset" /> obiektu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed rozpoczęciem porównanie, ta metoda konwertuje wartości obu bieżącego <xref:System.DateTimeOffset> obiektu i `obj` parametru uniwersalny czas koordynowany (UTC). Metoda ta jest równoważna dla następujących czynności:  
  
 [!code-csharp[System.DateTimeOffset.Syntax#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Syntax/cs/Syntax.cs#3)]
 [!code-vb[System.DateTimeOffset.Syntax#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Syntax/vb/Syntax.vb#3)]  
  
 Innymi słowy <xref:System.DateTimeOffset.Equals%28System.Object%29?displayProperty=nameWithType> Metoda określa, czy bieżący <xref:System.DateTimeOffset> obiekt i określonego obiektu reprezentują pojedynczy punkt w czasie. Porównuje bezpośrednio daty i godziny, a nie przesunięcia. Aby określić, czy dwa <xref:System.DateTimeOffset> obiekty reprezentują tym samym czasie i mają taką samą wartość przesunięcia, użyj <xref:System.DateTimeOffset.EqualsExact%2A> metody.  
  
 Jeśli `obj` jest `null`, lub jeśli typ środowiska wykonawczego `obj` nie jest <xref:System.DateTimeOffset>, metoda zwraca `false`.  
  
   
  
## Examples  
 Poniższy przykład wskazuje, czy bieżącego <xref:System.DateTimeOffset> obiekt jest taki sam kilka innych <xref:System.DateTimeOffset> obiekty, jak również jako odwołanie o wartości null i a <xref:System.DateTime> obiektu.  
  
 [!code-csharp[System.DateTimeOffset.Methods#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/cs/Methods.cs#10)]
 [!code-vb[System.DateTimeOffset.Methods#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/vb/Methods.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTimeOffset.EqualsExact(System.DateTimeOffset)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (DateTimeOffset first, DateTimeOffset second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(valuetype System.DateTimeOffset first, valuetype System.DateTimeOffset second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.Equals(System.DateTimeOffset,System.DateTimeOffset)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (first As DateTimeOffset, second As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(DateTimeOffset first, DateTimeOffset second);" />
      <MemberSignature Language="F#" Value="static member Equals : DateTimeOffset * DateTimeOffset -&gt; bool" Usage="System.DateTimeOffset.Equals (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="first" Type="System.DateTimeOffset" />
        <Parameter Name="second" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="first">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="second">Drugi obiekt, który będzie porównywany.</param>
        <summary>Określa, czy dwa określone <see cref="T:System.DateTimeOffset" /> obiekty reprezentują tego samego punktu w czasie.</summary>
        <returns>
          <see langword="true" /> Jeśli dwa <see cref="T:System.DateTimeOffset" /> obiekty mają takie same <see cref="P:System.DateTimeOffset.UtcDateTime" /> wartości; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed rozpoczęciem porównanie, ta metoda konwertuje zarówno <xref:System.DateTimeOffset> obiektów uniwersalny czas koordynowany (UTC). Metoda ta jest równoważna dla następujących czynności:  
  
 [!code-csharp[System.DateTimeOffset.Syntax#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Syntax/cs/Syntax.cs#4)]
 [!code-vb[System.DateTimeOffset.Syntax#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Syntax/vb/Syntax.vb#4)]  
  
 Innymi słowy <xref:System.DateTimeOffset.Equals%28System.DateTimeOffset%2CSystem.DateTimeOffset%29> Metoda określa, czy dwa <xref:System.DateTimeOffset> obiekty reprezentują pojedynczy punkt w czasie. Porównuje bezpośrednio daty i godziny, a nie przesunięcia. Aby określić, czy dwa <xref:System.DateTimeOffset> obiekty reprezentują tym samym czasie i mają taką samą wartość przesunięcia, użyj <xref:System.DateTimeOffset.EqualsExact%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywołań <xref:System.DateTimeOffset.Equals%28System.DateTimeOffset%2CSystem.DateTimeOffset%29> metody do testowania różnych par <xref:System.DateTimeOffset> obiekty pod kątem równości.  
  
 [!code-csharp[System.DateTimeOffset.Methods#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/cs/Methods.cs#11)]
 [!code-vb[System.DateTimeOffset.Methods#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/vb/Methods.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTimeOffset.EqualsExact(System.DateTimeOffset)" />
      </Docs>
    </Member>
    <Member MemberName="EqualsExact">
      <MemberSignature Language="C#" Value="public bool EqualsExact (DateTimeOffset other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EqualsExact(valuetype System.DateTimeOffset other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.EqualsExact(System.DateTimeOffset)" />
      <MemberSignature Language="VB.NET" Value="Public Function EqualsExact (other As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EqualsExact(DateTimeOffset other);" />
      <MemberSignature Language="F#" Value="member this.EqualsExact : DateTimeOffset -&gt; bool" Usage="dateTimeOffset.EqualsExact other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania z bieżącą <see cref="T:System.DateTimeOffset" /> obiektu.</param>
        <summary>Określa, czy bieżący <see cref="T:System.DateTimeOffset" /> obiekt reprezentuje tym samym czasie i ma takie same przesunięcie określone <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący <see cref="T:System.DateTimeOffset" /> obiektu i <paramref name="other" /> ma taką samą wartość daty i godziny i tym samym <see cref="P:System.DateTimeOffset.Offset" /> wartości; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ wielu strefach czasowych udział pojedynczego przesunięcie, zwracana wartość `true` nie gwarantuje, że bieżący i `other` obiekt reprezentuje razy w tej samej strefie czasowej.  
  
 W odróżnieniu od <xref:System.DateTimeOffset.EqualsExact%2A> metoda, przeciążeń <xref:System.DateTimeOffset.Equals%2A> metody ustalić, czy dwa <xref:System.DateTimeOffset> wartości reprezentują pojedynczy punkt w czasie. Nie wskazuje, czy dwie wartości mają tę samą datę i czas, a także samej przesunięcie.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.DateTimeOffset.EqualsExact%2A> metody do porównania podobne <xref:System.DateTimeOffset> obiektów.  
  
 [!code-csharp[System.DateTimeOffset.Methods#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/cs/Methods.cs#12)]
 [!code-vb[System.DateTimeOffset.Methods#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/vb/Methods.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.DateTimeOffset.Equals" />
      </Docs>
    </Member>
    <Member MemberName="FromFileTime">
      <MemberSignature Language="C#" Value="public static DateTimeOffset FromFileTime (long fileTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTimeOffset FromFileTime(int64 fileTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.FromFileTime(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromFileTime (fileTime As Long) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTimeOffset FromFileTime(long fileTime);" />
      <MemberSignature Language="F#" Value="static member FromFileTime : int64 -&gt; DateTimeOffset" Usage="System.DateTimeOffset.FromFileTime fileTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileTime" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileTime">Czas systemu Windows plik, wyrażone w znaczniki osi.</param>
        <summary>Konwertuje określony czas systemu Windows w pliku odpowiedni czas lokalny.</summary>
        <returns>Obiekt reprezentujący datę i godzinę <paramref name="fileTime" /> z przesunięciem ustawioną przesunięcie czasu lokalnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czas pliku systemu Windows ma wartość 64-bitową. Reprezentuje ona liczbę 100-nanosekundowych przedziałów czasu, które upłynęły od północy 1 stycznia 1601 roku n.e. (C.E.) Uniwersalny czas koordynowany (UTC). System Windows wykorzystuje czas pliku do rejestrowania informacji o tym, kiedy aplikacja tworzy, uzyskuje dostęp do zapisuje do pliku.  
  
 Czas plików systemu Windows jest dostępny bezpośrednio za pomocą interfejsu API systemu Windows przez wywołanie metody `GetFileTime` funkcji, która zwraca `FILETIME` struktury. Parametr jednej funkcji jest dojście plik, którego informacje o czasie pliku do pobrania. Dojście do pliku są pobierane przez wywołanie metody `CreateFile` funkcji. `FILETIME` Struktury `dwHighDateTime` elementu członkowskiego zawiera cztery bajty znaczących czasu pliku i jego `dwLowDateTime` elementu członkowskiego zawiera cztery bajty znaczącymi bitami. Jak pobrać wartości godziny pliku systemu Windows i przekonwertować je na pokazano w przykładzie poniżej <xref:System.DateTimeOffset> wartości.  
  
 Wartości godziny pliku systemu Windows można także utworzyć z <xref:System.DateTime> wartości przez wywołanie metody <xref:System.DateTime.ToFileTime%2A?displayProperty=nameWithType> i <xref:System.DateTime.ToFileTimeUtc%2A?displayProperty=nameWithType> metod i z <xref:System.DateTimeOffset> wartości przez wywołanie metody <xref:System.DateTimeOffset.ToFileTime%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto interfejsu API systemu Windows można pobrać czasy plików systemu Windows dla pliku wykonywalnego WordPad.  
  
 [!code-csharp[System.DateTimeOffset.FromFileTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.FromFileTime/cs/FileTime.cs#1)]
 [!code-vb[System.DateTimeOffset.FromFileTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.FromFileTime/vb/FileTime.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="filetime" /> jest mniejsza od zera.  - lub - <paramref name="filetime" /> jest większa niż <see langword="DateTimeOffset.MaxValue.Ticks" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromUnixTimeMilliseconds">
      <MemberSignature Language="C#" Value="public static DateTimeOffset FromUnixTimeMilliseconds (long milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTimeOffset FromUnixTimeMilliseconds(int64 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.FromUnixTimeMilliseconds(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromUnixTimeMilliseconds (milliseconds As Long) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTimeOffset FromUnixTimeMilliseconds(long milliseconds);" />
      <MemberSignature Language="F#" Value="static member FromUnixTimeMilliseconds : int64 -&gt; DateTimeOffset" Usage="System.DateTimeOffset.FromUnixTimeMilliseconds milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Unix czasowy jako liczbę milisekund, które upłynęły od 1970-01-01T00:00:00Z (1 stycznia 1970 roku w UTC 00:00:00). Dla systemu Unix godzin przed tą datą jego wartość jest ujemna.</param>
        <summary>Konwertuje godzinę Unix wyrażone jako liczba milisekund, które upłynęły od 1970-01-01T00:00:00Z do <see cref="T:System.DateTimeOffset" /> wartości.</summary>
        <returns>Wartość daty i godziny, która reprezentuje tym momencie w czasie, gdy czas systemu Unix.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.Offset%2A> Zwracana wartość właściwości <xref:System.DateTimeOffset> wystąpienie jest <xref:System.TimeSpan.Zero?displayProperty=nameWithType>, który reprezentuje uniwersalny czas koordynowany. Konwertuj na czas w strefie czasowej określonej przez wywołanie metody <xref:System.TimeZoneInfo.ConvertTime%28System.DateTimeOffset%2CSystem.TimeZoneInfo%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="milliseconds" /> jest mniejsza niż-62,135,596,800,000.  - lub - <paramref name="milliseconds" /> jest większa niż 253,402,300,799,999.</exception>
        <altmember cref="M:System.DateTimeOffset.FromUnixTimeSeconds(System.Int64)" />
        <altmember cref="M:System.DateTimeOffset.ToUnixTimeMilliseconds" />
      </Docs>
    </Member>
    <Member MemberName="FromUnixTimeSeconds">
      <MemberSignature Language="C#" Value="public static DateTimeOffset FromUnixTimeSeconds (long seconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTimeOffset FromUnixTimeSeconds(int64 seconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.FromUnixTimeSeconds(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromUnixTimeSeconds (seconds As Long) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTimeOffset FromUnixTimeSeconds(long seconds);" />
      <MemberSignature Language="F#" Value="static member FromUnixTimeSeconds : int64 -&gt; DateTimeOffset" Usage="System.DateTimeOffset.FromUnixTimeSeconds seconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="seconds" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="seconds">Unix czasowy jako liczbę sekund, które upłynęły od 1970-01-01T00:00:00Z (1 stycznia 1970 roku w UTC 00:00:00). Dla systemu Unix godzin przed tą datą jego wartość jest ujemna.</param>
        <summary>Konwertuje godzinę Unix wyrażone jako liczba sekund, które upłynęły od 1970-01-01T00:00:00Z do <see cref="T:System.DateTimeOffset" /> wartości.</summary>
        <returns>Wartość daty i godziny, która reprezentuje tym momencie w czasie, gdy czas systemu Unix.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.Offset%2A> Zwracana wartość właściwości <xref:System.DateTimeOffset> wystąpienie jest <xref:System.TimeSpan.Zero?displayProperty=nameWithType>, który reprezentuje uniwersalny czas koordynowany. Konwertuj na czas w strefie czasowej określonej przez wywołanie metody <xref:System.TimeZoneInfo.ConvertTime%28System.DateTimeOffset%2CSystem.TimeZoneInfo%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="seconds" /> jest mniejsza niż-62,135,596,800.  - lub - <paramref name="seconds" /> jest większa niż 253,402,300,799.</exception>
        <altmember cref="M:System.DateTimeOffset.FromUnixTimeMilliseconds(System.Int64)" />
        <altmember cref="M:System.DateTimeOffset.ToUnixTimeSeconds" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dateTimeOffset.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla bieżącego <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Hour">
      <MemberSignature Language="C#" Value="public int Hour { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Hour" />
      <MemberSignature Language="DocId" Value="P:System.DateTimeOffset.Hour" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Hour As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Hour { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Hour : int" Usage="System.DateTimeOffset.Hour" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik godziny czas reprezentowany przez bieżący <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <value>Składnik godziny z wartości bieżącego <see cref="T:System.DateTimeOffset" /> obiektu. Ta właściwość używa zegarze 24-godzinnym; zakresy wartości z zakresu od 0 do 23.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.Hour%2A> Właściwość nie ma wpływu na wartość <xref:System.DateTimeOffset.Offset%2A> właściwości.  
  
 Można również utworzyć reprezentację ciągu <xref:System.DateTimeOffset> składnik godziny obiektu przez wywołanie metody <xref:System.DateTimeOffset.ToString%2A> metody za pomocą "H" lub "HH" specyfikatorów formatu niestandardowego.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono składnik godziny z <xref:System.DateTimeOffset> obiektu na trzy sposoby:  
  
-   Pobierając zaletą <xref:System.DateTimeOffset.Hour%2A> właściwości.  
  
-   Wywołując <xref:System.DateTimeOffset.ToString%28System.String%29> metody z specyfikator formatu "H".  
  
-   Wywołując <xref:System.DateTimeOffset.ToString%28System.String%29> specyfikatorze formatu metody za pomocą "HH".  
  
 [!code-csharp[System.DateTimeOffset.Properties#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/cs/Properties.cs#6)]
 [!code-vb[System.DateTimeOffset.Properties#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/vb/Properties.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalDateTime">
      <MemberSignature Language="C#" Value="public DateTime LocalDateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LocalDateTime" />
      <MemberSignature Language="DocId" Value="P:System.DateTimeOffset.LocalDateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalDateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LocalDateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalDateTime : DateTime" Usage="System.DateTimeOffset.LocalDateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.DateTime" /> wartość, która reprezentuje lokalnego datę i godzinę bieżącego <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <value>Lokalne datę i godzinę bieżącego <see cref="T:System.DateTimeOffset" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W razie potrzeby <xref:System.DateTimeOffset.LocalDateTime%2A> właściwości Konwertuje bieżący <xref:System.DateTimeOffset> Data i godzina do daty i godziny w systemie lokalnym obiektu. Konwersja jest operacją dwuetapową:  
  
1.  Właściwość Konwertuje bieżący <xref:System.DateTimeOffset> obiektu czas uniwersalny czas koordynowany (UTC).  
  
2.  Właściwość następnie konwertuje UTC na czas lokalny.  
  
 Nie nie razy nieprawidłowe i niejednoznacznych wartości czasu są mapowane do lokalnej strefy (czas standardowy). (Jednak utworzyć konwersji anomalii: Jeśli <xref:System.DateTimeOffset> wartość, która pochodzi z komputera lokalnego odzwierciedla niejednoznaczne daty i czasu, która wartość mogą być konwertowane na czas UTC, a następnie z powrotem do czasu lokalnego, która różni się od oryginalnej czasu.)  Właściwość ma zastosowanie żadnych reguł korygowania w lokalnej strefie czasowej podczas wykonywania konwersji.  
  
 Ta właściwość zwraca zarówno data, jak i składnik godziny <xref:System.DateTimeOffset> obiektu, co jest użyteczne dla <xref:System.DateTimeOffset> do <xref:System.DateTime> konwersji. Oprócz wykonywania konwersji wszelkie niezbędne czasu, właściwość ta różni się od <xref:System.DateTimeOffset.DateTime%2A> właściwości, ustawiając wartość <xref:System.DateTime.Kind%2A> właściwości zwracana <xref:System.DateTime> do obiektu <xref:System.DateTimeKind.Local?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia kilka konwersje <xref:System.DateTimeOffset> wartości godzin czasu lokalnego w Stanach Zjednoczonych Pacyficzny standardowa strefy czasowej. Należy zauważyć, że ostatni trzy razy wszystkie niejednoznaczne; właściwości wszystkich z nich jest mapowany na pojedyncza Data i czas w strefie czasowej pacyficzny standardowa.  
  
 [!code-csharp[System.DateTimeOffset.Properties#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/cs/Properties.cs#7)]
 [!code-vb[System.DateTimeOffset.Properties#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/vb/Properties.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.DateTimeOffset.DateTime" />
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public static readonly DateTimeOffset MaxValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTimeOffset MaxValue" />
      <MemberSignature Language="DocId" Value="F:System.DateTimeOffset.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxValue As DateTimeOffset " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTimeOffset MaxValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxValue : DateTimeOffset" Usage="System.DateTimeOffset.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje największa możliwa wartość z <see cref="T:System.DateTimeOffset" />. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej stałej jest 12/31/9999 11:59:59 PM + 00:00.  
  
 <xref:System.DateTimeOffset.MaxValue> Właściwość jest używana do określenia czy wartość nowej <xref:System.DateTimeOffset> obiektu lub <xref:System.DateTimeOffset> wartość zwrócona przez operacji arytmetycznej jest taka sama jak lub starszy niż ta wartość maksymalną wielkość zakresu. Jeśli nie, metoda wygeneruje <xref:System.ArgumentOutOfRangeException>. Wszelkie <xref:System.DateTimeOffset> wartość jest konwertowana uniwersalny czas koordynowany (UTC), zanim metoda porównuje ją z <xref:System.DateTimeOffset.MaxValue>.  Oznacza to, że <xref:System.DateTimeOffset> wartości, których data i godzina są blisko maksymalną wielkość zakresu, ale których przesunięcie jest ujemna, może zgłosić wyjątek. Na przykład wartość 12/31/9999 11:00 PM-02: 00 jest poza zakresem, ponieważ jest on godzinę później niż <xref:System.DateTimeOffset.MaxValue> po jest konwertowana na czas UTC.  
  
 Niektóre kalendarzy, takich jak <xref:System.Globalization.UmAlQuraCalendar>, obsługuje górnego zakresu, starszej niż <xref:System.DateTime.MaxValue>. W takich przypadkach próby uzyskania dostępu do <xref:System.DateTime.MaxValue> w przypisań zmiennych lub formatowania ani do analizowania operacje może zgłosić <xref:System.ArgumentOutOfRangeException>. Zamiast pobierania wartości <xref:System.DateTime.MaxValue?displayProperty=nameWithType>, można pobrać wartość określonej kultury najnowsze prawidłowej wartości daty z <xref:System.Globalization.Calendar.MaxSupportedDateTime%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="F:System.DateTime.MaxValue" /> znajduje się poza zakresem kalendarza domyślna kultura bieżącego lub został określony.</exception>
      </Docs>
    </Member>
    <Member MemberName="Millisecond">
      <MemberSignature Language="C#" Value="public int Millisecond { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Millisecond" />
      <MemberSignature Language="DocId" Value="P:System.DateTimeOffset.Millisecond" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Millisecond As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Millisecond { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Millisecond : int" Usage="System.DateTimeOffset.Millisecond" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik milisekund czas reprezentowany przez bieżący <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <value>Składnik milisekund bieżącego <see cref="T:System.DateTimeOffset" /> obiektu, wyrażone jako liczba całkowita z zakresu od 0 do 999.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można również utworzyć reprezentację ciągu <xref:System.DateTimeOffset> składnika milisekund obiektu przez wywołanie metody <xref:System.DateTimeOffset.ToString%2A> metoda ze specyfikatorem formatu niestandardowego "fff".  
  
 Jeśli użytkownik korzysta z właściwości takich jak <xref:System.DateTimeOffset.Now%2A> lub <xref:System.DateTimeOffset.UtcNow%2A> dokładnie śledzić liczbę milisekund, który upłynął, dokładność składnik milisekund czasu zależy od rozdzielczości zegara systemowego. Systemu Windows NT w wersji 3.5 lub nowszej i systemów operacyjnych Windows Vista rozdzielczość zegara to około 10 – 15 milisekund.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono liczbę milisekund <xref:System.DateTimeOffset> przy użyciu specyfikatora formatu niestandardowego i uzyskując bezpośrednio dostęp do obiektów <xref:System.DateTimeOffset.Millisecond%2A> właściwości.  
  
 [!code-csharp[System.DateTimeOffset.Properties#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/cs/Properties.cs#12)]
 [!code-vb[System.DateTimeOffset.Properties#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/vb/Properties.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Minute">
      <MemberSignature Language="C#" Value="public int Minute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Minute" />
      <MemberSignature Language="DocId" Value="P:System.DateTimeOffset.Minute" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Minute As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Minute { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Minute : int" Usage="System.DateTimeOffset.Minute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik minuty czas reprezentowany przez bieżący <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <value>Składnik minuty bieżącego <see cref="T:System.DateTimeOffset" /> obiektu, wyrażone jako liczba całkowita z zakresu od 0 do 59.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.Minute%2A> Właściwość nie ma wpływu na wartość <xref:System.DateTimeOffset.Offset%2A> właściwości.  
  
 Można również utworzyć reprezentację ciągu <xref:System.DateTimeOffset> składnik minuty obiektu przez wywołanie metody <xref:System.DateTimeOffset.ToString%2A> metody "m" lub "mm" specyfikatorów formatu niestandardowego.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono składnik minuty z <xref:System.DateTimeOffset> obiektu na trzy sposoby:  
  
-   Pobierając zaletą <xref:System.DateTimeOffset.Minute%2A> właściwości.  
  
-   Wywołując <xref:System.DateTimeOffset.ToString%28System.String%29> metody z specyfikator formatu "m".  
  
-   Wywołując <xref:System.DateTimeOffset.ToString%28System.String%29> metody z specyfikator formatu "mm".  
  
 [!code-csharp[System.DateTimeOffset.Properties#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/cs/Properties.cs#8)]
 [!code-vb[System.DateTimeOffset.Properties#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/vb/Properties.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public static readonly DateTimeOffset MinValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTimeOffset MinValue" />
      <MemberSignature Language="DocId" Value="F:System.DateTimeOffset.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinValue As DateTimeOffset " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTimeOffset MinValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinValue : DateTimeOffset" Usage="System.DateTimeOffset.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje najwcześniejszym możliwym <see cref="T:System.DateTimeOffset" /> wartość. To pole jest tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej stałej jest 1/1/0001 12:00:00 AM + 00:00.  
  
 <xref:System.DateTimeOffset.MinValue> Właściwość jest używana do określenia czy wartość nowej <xref:System.DateTimeOffset> obiektu lub <xref:System.DateTimeOffset> wartość zwrócona przez operacji arytmetycznej jest taka sama jak lub nowszej niż ta minimalną wartość zakresu. Jeśli nie, metoda wygeneruje <xref:System.ArgumentOutOfRangeException>. Wszelkie <xref:System.DateTimeOffset> wartość jest konwertowana na uniwersalny czas koordynowany (UTC), przed metoda przeprowadza porównanie z <xref:System.DateTimeOffset.MinValue>.  Oznacza to, że <xref:System.DateTimeOffset> wartości, których data i godzina są blisko zakresu minimalnego, ale których przesunięcie jest dodatnia, może zgłosić wyjątek. Na przykład, wartość 1/1/0001 1:00:00 AM + 02:00 jest poza zakresem, ponieważ to jedna godzina wcześniejszy niż <xref:System.DateTimeOffset.MinValue> po jest konwertowana na czas UTC.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.DateTimeOffset.ParseExact" />
      </Docs>
    </Member>
    <Member MemberName="Month">
      <MemberSignature Language="C#" Value="public int Month { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Month" />
      <MemberSignature Language="DocId" Value="P:System.DateTimeOffset.Month" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Month As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Month { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Month : int" Usage="System.DateTimeOffset.Month" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik miesiąca daty reprezentowany przez bieżący <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <value>Składnik miesiąca bieżącego <see cref="T:System.DateTimeOffset" /> obiektu, wyrażone jako liczba całkowita z przedziału od 1 do 12.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.Month%2A> Właściwość nie ma wpływu na wartość <xref:System.DateTimeOffset.Offset%2A> właściwości.  
  
 Można również utworzyć reprezentację ciągu <xref:System.DateTimeOffset> składnik miesiąca obiektu przez wywołanie metody <xref:System.DateTimeOffset.ToString%2A> metody z specyfikatorów formatu niestandardowego "M" lub "MM".  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono składnik miesiąca z <xref:System.DateTimeOffset> wartość na trzy sposoby:  
  
-   Pobierając zaletą <xref:System.DateTimeOffset.Month%2A> właściwości.  
  
-   Wywołując <xref:System.DateTimeOffset.ToString%28System.String%29> metody z specyfikator formatu "M".  
  
-   Wywołując <xref:System.DateTimeOffset.ToString%28System.String%29> metody z specyfikator formatu "MM".  
  
 [!code-csharp[System.DateTimeOffset.Properties#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/cs/Properties.cs#9)]
 [!code-vb[System.DateTimeOffset.Properties#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/vb/Properties.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Now">
      <MemberSignature Language="C#" Value="public static DateTimeOffset Now { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.DateTimeOffset Now" />
      <MemberSignature Language="DocId" Value="P:System.DateTimeOffset.Now" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Now As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property DateTimeOffset Now { DateTimeOffset get(); };" />
      <MemberSignature Language="F#" Value="member this.Now : DateTimeOffset" Usage="System.DateTimeOffset.Now" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.DateTimeOffset" /> obiekt, który jest ustawiona na bieżącą datę i godzinę na bieżącym komputerze z przesunięciem ustawioną przesunięcie czasu lokalnego z uniwersalnego czasu koordynowanego (UTC).</summary>
        <value>A <see cref="T:System.DateTimeOffset" /> obiekt, którego daty i godziny jest bieżącym czasem lokalnym i którego przesunięcie przesunięcia lokalnej strefy czasowej z uniwersalnego czasu koordynowanego (UTC).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dokładność składnika milisekund bieżącym czasem lokalnym zależy od rozdzielczości zegara systemowego. Systemu Windows NT w wersji 3.5 lub nowszej i systemów operacyjnych Windows Vista rozdzielczość zegara to około 10 – 15 milisekund.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTimeOffset.Now%2A> właściwości w celu pobrania aktualnej daty i godziny i wyświetla je przy użyciu każdego z [standardowa Data i godzina ciągi formatujące](~/docs/standard/base-types/standard-date-and-time-format-strings.md) obsługiwane przez <xref:System.DateTimeOffset> typu.  
  
 [!code-csharp[System.DateTimeOffset.Now#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetimeoffset.now/cs/now1.cs#1)]
 [!code-vb[System.DateTimeOffset.Now#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetimeoffset.now/vb/now1.vb#1)]  
  
 W poniższym przykładzie użyto <xref:System.DateTimeOffset.Now%2A> i <xref:System.DateTimeOffset.Millisecond%2A> właściwości, aby ustalić rozwiązanie zegara systemowego. Wyświetla czas tylko gdy zmieniono wartość jego składnika milisekund.  
  
 [!code-csharp[System.DateTimeOffset.Properties#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/cs/Properties.cs#11)]
 [!code-vb[System.DateTimeOffset.Properties#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/vb/Properties.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.DateTimeOffset.UtcNow" />
      </Docs>
    </Member>
    <Member MemberName="Offset">
      <MemberSignature Language="C#" Value="public TimeSpan Offset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan Offset" />
      <MemberSignature Language="DocId" Value="P:System.DateTimeOffset.Offset" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Offset As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan Offset { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.Offset : TimeSpan" Usage="System.DateTimeOffset.Offset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera przesunięcie czasu z uniwersalnego czasu koordynowanego (UTC).</summary>
        <value>Różnica między bieżącą <see cref="T:System.DateTimeOffset" /> obiektu wartość czasu i uniwersalny czas koordynowany (UTC).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.TimeSpan.Hours%2A> właściwości zwracana <xref:System.TimeSpan> obiektu mogą należeć do zakresu od-14 godzin do 14 godzin.  
  
 Wartość <xref:System.DateTimeOffset.Offset%2A> właściwość jest dokładne na minutę.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTimeOffset.Offset%2A> właściwości do wyświetlenia różnicy czasu lokalnego z uniwersalnego czasu koordynowanego (UTC).  
  
 [!code-csharp[System.DateTimeOffset.Properties#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/cs/Properties.cs#13)]
 [!code-vb[System.DateTimeOffset.Properties#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/vb/Properties.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static DateTimeOffset operator + (DateTimeOffset dateTimeOffset, TimeSpan timeSpan);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.DateTimeOffset op_Addition(valuetype System.DateTimeOffset dateTimeOffset, valuetype System.TimeSpan timeSpan) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.op_Addition(System.DateTimeOffset,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTimeOffset operator +(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);" />
      <MemberSignature Language="F#" Value="static member ( + ) : DateTimeOffset * TimeSpan -&gt; DateTimeOffset" Usage="dateTimeOffset + timeSpan" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateTimeOffset" Type="System.DateTimeOffset" />
        <Parameter Name="timeSpan" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="dateTimeOffset">Obiekt do dodania przedział czasu.</param>
        <param name="timeSpan">Przedział czasu, aby dodać.</param>
        <summary>Dodaje określony interwał do <see cref="T:System.DateTimeOffset" /> obiekt, który ma określoną datą i godziną i zwraca <see cref="T:System.DateTimeOffset" /> obiektu, który ma nowych datę i godzinę.</summary>
        <returns>Obiekt, którego wartość jest sumą wartości z <paramref name="dateTimeTz" /> i <paramref name="timeSpan" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.op_Addition%2A> Metoda definiuje operacji dodawania dla <xref:System.DateTimeOffset> wartości. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.DateTimeOffset.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/cs/Operators.cs#1)]
 [!code-vb[System.DateTimeOffset.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/vb/Operators.vb#1)]  
  
 Języki, które nie obsługują niestandardowych operatory i przeładowania operatora można wywołać <xref:System.DateTimeOffset.Add%2A> metody zamiast tego.  
  
 Metoda równoważne tego operatora jest <xref:System.DateTimeOffset.Add%28System.TimeSpan%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest mniejsza niż <see cref="F:System.DateTimeOffset.MinValue" />.  - lub - powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest większa niż <see cref="F:System.DateTimeOffset.MaxValue" />.</exception>
        <altmember cref="M:System.DateTimeOffset.Add(System.TimeSpan)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (DateTimeOffset left, DateTimeOffset right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.DateTimeOffset left, valuetype System.DateTimeOffset right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.op_Equality(System.DateTimeOffset,System.DateTimeOffset)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As DateTimeOffset, right As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(DateTimeOffset left, DateTimeOffset right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : DateTimeOffset * DateTimeOffset -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.DateTimeOffset" />
        <Parameter Name="right" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="right">Drugi obiekt, który będzie porównywany.</param>
        <summary>Określa, czy dwa określone <see cref="T:System.DateTimeOffset" /> obiekty reprezentują tego samego punktu w czasie.</summary>
        <returns>
          <see langword="true" /> Jeśli oba <see cref="T:System.DateTimeOffset" /> obiekty mają takie same <see cref="P:System.DateTimeOffset.UtcDateTime" /> wartości; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.op_Equality%2A> Metoda definiuje operacji operatora równości dla <xref:System.DateTimeOffset> obiektów. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.DateTimeOffset.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/cs/Operators.cs#2)]
 [!code-vb[System.DateTimeOffset.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/vb/Operators.vb#2)]  
  
 Przed obliczeniem `left` i `right` operandy pod kątem równości, operator konwertuje obie wartości uniwersalny czas koordynowany (UTC). Operacja ta jest równoważna z wykonaniem następujących czynności:  
  
 [!code-csharp[System.DateTimeOffset.Syntax#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Syntax/cs/Syntax.cs#4)]
 [!code-vb[System.DateTimeOffset.Syntax#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Syntax/vb/Syntax.vb#4)]  
  
 Innymi słowy <xref:System.DateTimeOffset.op_Equality%2A> Metoda określa, czy dwa <xref:System.DateTimeOffset> obiekty reprezentują pojedynczy punkt w czasie. Porównuje bezpośrednio daty i godziny, a nie przesunięcia. Aby określić, czy dwa <xref:System.DateTimeOffset> obiekty reprezentują tym samym czasie i mają taką samą wartość przesunięcia, użyj <xref:System.DateTimeOffset.EqualsExact%2A> metody.  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTimeOffset.Equals%28System.DateTimeOffset%2CSystem.DateTimeOffset%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="Overload:System.DateTimeOffset.Equals" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (DateTimeOffset left, DateTimeOffset right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.DateTimeOffset left, valuetype System.DateTimeOffset right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.op_GreaterThan(System.DateTimeOffset,System.DateTimeOffset)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As DateTimeOffset, right As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(DateTimeOffset left, DateTimeOffset right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : DateTimeOffset * DateTimeOffset -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.DateTimeOffset" />
        <Parameter Name="right" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="right">Drugi obiekt, który będzie porównywany.</param>
        <summary>Określa, czy określone jedną <see cref="T:System.DateTimeOffset" /> obiekt jest większy niż (lub późniejszy niż) określić drugi <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="P:System.DateTimeOffset.UtcDateTime" /> wartość <paramref name="left" /> jest nowsza niż <see cref="P:System.DateTimeOffset.UtcDateTime" /> wartość <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.op_GreaterThan%2A> Metoda definiuje operację większym niż operator <xref:System.DateTimeOffset> obiektów. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.DateTimeOffset.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/cs/Operators.cs#3)]
 [!code-vb[System.DateTimeOffset.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/vb/Operators.vb#3)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.DateTimeOffset.Compare%2A> metody zamiast tego. Można również wywołać <xref:System.DateTimeOffset.op_GreaterThan%2A> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.DateTimeOffset.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/vb/Operators.vb#4)]  
  
 Przed obliczeniem `left` i `right` argumentów operacji, operator konwertuje obie wartości uniwersalny czas koordynowany (UTC). Operacja ta jest równoważna z wykonaniem następujących czynności:  
  
 [!code-csharp[System.DateTimeOffset.Syntax#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Syntax/cs/Syntax.cs#5)]
 [!code-vb[System.DateTimeOffset.Syntax#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Syntax/vb/Syntax.vb#5)]  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTimeOffset.Compare%28System.DateTimeOffset%2CSystem.DateTimeOffset%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (DateTimeOffset left, DateTimeOffset right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.DateTimeOffset left, valuetype System.DateTimeOffset right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.op_GreaterThanOrEqual(System.DateTimeOffset,System.DateTimeOffset)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As DateTimeOffset, right As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(DateTimeOffset left, DateTimeOffset right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : DateTimeOffset * DateTimeOffset -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.DateTimeOffset" />
        <Parameter Name="right" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="right">Drugi obiekt, który będzie porównywany.</param>
        <summary>Określa, czy określone jedną <see cref="T:System.DateTimeOffset" /> obiektu jest większa lub równa 1 sekunda określony <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="P:System.DateTimeOffset.UtcDateTime" /> wartość <paramref name="left" /> jest taka sama jak lub późniejsza niż <see cref="P:System.DateTimeOffset.UtcDateTime" /> wartość <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.op_GreaterThan%2A> Metoda definiuje operację większa niż lub równa operatora dla <xref:System.DateTimeOffset> obiektów. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.DateTimeOffset.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/cs/Operators.cs#5)]
 [!code-vb[System.DateTimeOffset.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/vb/Operators.vb#5)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.DateTimeOffset.Compare%2A> metody zamiast tego. W przypadku niektórych języków może także wywołać <xref:System.DateTimeOffset.op_GreaterThanOrEqual%2A> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.DateTimeOffset.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/vb/Operators.vb#6)]  
  
 Przed obliczeniem `left` i `right` argumentów operacji, operator konwertuje obie wartości uniwersalny czas koordynowany (UTC). Operacja ta jest równoważna z wykonaniem następujących czynności:  
  
 [!code-csharp[System.DateTimeOffset.Syntax#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Syntax/cs/Syntax.cs#6)]
 [!code-vb[System.DateTimeOffset.Syntax#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Syntax/vb/Syntax.vb#6)]  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTimeOffset.Compare%28System.DateTimeOffset%2CSystem.DateTimeOffset%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator DateTimeOffset (DateTime dateTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.DateTimeOffset op_Implicit(valuetype System.DateTime dateTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.op_Implicit(System.DateTime)~System.DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator DateTimeOffset(DateTime dateTime);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : DateTime -&gt; DateTimeOffset" Usage="System.DateTimeOffset.op_Implicit dateTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="dateTime">Obiekt do przekonwertowania.</param>
        <summary>Definiuje niejawnej konwersji wartości <see cref="T:System.DateTime" /> do obiektu <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <returns>Przekonwertowany obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.op_Implicit%2A> Metoda włącza kompilator, aby dokonać automatycznej konwersji <xref:System.DateTime> do obiektu <xref:System.DateTimeOffset> obiektu bez jawnego rzutowania operator (C#) lub wywołanie funkcji konwersji (w języku Visual Basic). Definiuje konwersję rozszerzającą nie wiąże się z utraty danych, która nie zgłasza <xref:System.OverflowException>. <xref:System.DateTimeOffset.op_Implicit%2A> Metoda pozwala kodu, takie jak następujące możliwości:  
  
 [!code-csharp[System.DateTimeOffset.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/cs/Operators.cs#7)]
 [!code-vb[System.DateTimeOffset.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/vb/Operators.vb#7)]  
  
 Ta metoda jest odpowiednikiem <xref:System.DateTimeOffset.%23ctor%2A> konstruktora. Przesunięcie powstałe w ten sposób <xref:System.DateTimeOffset> obiektu zależy od wartości <xref:System.DateTime.Kind%2A?displayProperty=nameWithType> właściwość `dateTime` parametru:  
  
-   Jeśli wartość <xref:System.DateTime.Kind%2A?displayProperty=nameWithType> właściwość jest <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, Data i godzina <xref:System.DateTimeOffset> obiektu jest równe `dateTime`, a jego <xref:System.DateTimeOffset.Offset%2A> właściwość ma wartość równą 0.  
  
-   Jeśli wartość <xref:System.DateTime.Kind%2A?displayProperty=nameWithType> właściwość jest <xref:System.DateTimeKind.Local?displayProperty=nameWithType> lub <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>, Data i godzina <xref:System.DateTimeOffset> obiektu jest równe `dateTime`, a jego <xref:System.DateTimeOffset.Offset%2A> właściwość ma wartość równą przesunięcie bieżącej strefy czasowej systemu lokalnego.  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTimeOffset.%23ctor%28System.DateTime%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Uniwersalny czas koordynowany (UTC), datę i godzinę, będącą wynikiem zastosowania przesunięcie jest starsza niż <see cref="F:System.DateTimeOffset.MinValue" />.  - lub - jest późniejsza niż data i godzina, będącą wynikiem zastosowania przesunięcie UTC <see cref="F:System.DateTimeOffset.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (DateTimeOffset left, DateTimeOffset right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.DateTimeOffset left, valuetype System.DateTimeOffset right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.op_Inequality(System.DateTimeOffset,System.DateTimeOffset)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As DateTimeOffset, right As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(DateTimeOffset left, DateTimeOffset right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : DateTimeOffset * DateTimeOffset -&gt; bool" Usage="System.DateTimeOffset.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.DateTimeOffset" />
        <Parameter Name="right" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="right">Drugi obiekt, który będzie porównywany.</param>
        <summary>Określa, czy dwa określone <see cref="T:System.DateTimeOffset" /> obiektów dotyczą różnych punktach w czasie.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie mają takie same <see cref="P:System.DateTimeOffset.UtcDateTime" /> wartości; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.op_Inequality%2A> Metoda definiuje operacji operator nierówności <xref:System.DateTimeOffset> obiektów. Zawsze zwraca przeciwną wynik <xref:System.DateTimeOffset.op_Equality%2A>. <xref:System.DateTimeOffset.op_Inequality%2A> Metoda umożliwia następującego kodu:  
  
 [!code-csharp[System.DateTimeOffset.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/cs/Operators.cs#8)]
 [!code-vb[System.DateTimeOffset.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/vb/Operators.vb#8)]  
  
 Przed obliczeniem `left` i `right` operandy pod kątem równości, operator konwertuje obie wartości uniwersalny czas koordynowany (UTC). Operacja ta jest równoważna z wykonaniem następujących czynności:  
  
 [!code-csharp[System.DateTimeOffset.Syntax#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Syntax/cs/Syntax.cs#4)]
 [!code-vb[System.DateTimeOffset.Syntax#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Syntax/vb/Syntax.vb#4)]  
  
 Innymi słowy <xref:System.DateTimeOffset.op_Inequality%2A> Metoda określa, czy dwa <xref:System.DateTimeOffset> reprezentować różnych punktach w czasie. Porównuje bezpośrednio daty i godziny, a nie przesunięcia.  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.DateTimeOffset.Compare%2A> metody zamiast tego. Ponadto w przypadku niektórych języków może także wywołać <xref:System.DateTimeOffset.op_Inequality%2A> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.DateTimeOffset.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/vb/Operators.vb#9)]  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTimeOffset.Compare%28System.DateTimeOffset%2CSystem.DateTimeOffset%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (DateTimeOffset left, DateTimeOffset right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.DateTimeOffset left, valuetype System.DateTimeOffset right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.op_LessThan(System.DateTimeOffset,System.DateTimeOffset)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As DateTimeOffset, right As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(DateTimeOffset left, DateTimeOffset right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : DateTimeOffset * DateTimeOffset -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.DateTimeOffset" />
        <Parameter Name="right" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="right">Drugi obiekt, który będzie porównywany.</param>
        <summary>Określa, czy określone jedną <see cref="T:System.DateTimeOffset" /> obiektów jest mniejsza niż 1 sekunda określony <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="P:System.DateTimeOffset.UtcDateTime" /> wartość <paramref name="left" /> jest starsza niż <see cref="P:System.DateTimeOffset.UtcDateTime" /> wartość <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.op_LessThan%2A> Metoda definiuje operację mniejszej niż operator <xref:System.DateTimeOffset> obiektów. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.DateTimeOffset.Operators#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/cs/Operators.cs#10)]
 [!code-vb[System.DateTimeOffset.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/vb/Operators.vb#10)]  
  
 Przed obliczeniem `left` i `right` argumentów operacji, operator konwertuje oba argumenty uniwersalny czas koordynowany (UTC). Operacja ta jest równoważna z wykonaniem następujących czynności:  
  
 [!code-csharp[System.DateTimeOffset.Syntax#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Syntax/cs/Syntax.cs#8)]
 [!code-vb[System.DateTimeOffset.Syntax#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Syntax/vb/Syntax.vb#8)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.DateTimeOffset.Compare%2A> metody zamiast tego. Ponadto w przypadku niektórych języków może także wywołać <xref:System.DateTimeOffset.op_LessThan%2A> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.DateTimeOffset.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/vb/Operators.vb#11)]  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTimeOffset.Compare%28System.DateTimeOffset%2CSystem.DateTimeOffset%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (DateTimeOffset left, DateTimeOffset right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.DateTimeOffset left, valuetype System.DateTimeOffset right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.op_LessThanOrEqual(System.DateTimeOffset,System.DateTimeOffset)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As DateTimeOffset, right As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(DateTimeOffset left, DateTimeOffset right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : DateTimeOffset * DateTimeOffset -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.DateTimeOffset" />
        <Parameter Name="right" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy obiekt, który ma zostać porównany.</param>
        <param name="right">Drugi obiekt, który będzie porównywany.</param>
        <summary>Określa, czy określone jedną <see cref="T:System.DateTimeOffset" /> obiektów jest mniejsza niż 1 sekunda określony <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="P:System.DateTimeOffset.UtcDateTime" /> wartość <paramref name="left" /> jest starsza niż <see cref="P:System.DateTimeOffset.UtcDateTime" /> wartość <paramref name="right" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.op_LessThanOrEqual%2A> Metoda definiuje działania mniejsze niż lub równe operatora dla <xref:System.DateTimeOffset> obiektów. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.DateTimeOffset.Operators#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/cs/Operators.cs#12)]
 [!code-vb[System.DateTimeOffset.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/vb/Operators.vb#12)]  
  
 Języki, które nie obsługują niestandardowych operatorzy mogą wywoływać <xref:System.DateTimeOffset.Compare%2A> metody zamiast tego. W przypadku niektórych języków może także wywołać <xref:System.DateTimeOffset.op_LessThanOrEqual%2A> metody bezpośrednio, jak w poniższym przykładzie przedstawiono.  
  
 [!code-vb[System.DateTimeOffset.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/vb/Operators.vb#13)]  
  
 Przed obliczeniem `left` i `right` argumentów operacji, operator konwertuje obie wartości uniwersalny czas koordynowany (UTC). Operacja ta jest równoważna z wykonaniem następujących czynności:  
  
 [!code-csharp[System.DateTimeOffset.Syntax#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Syntax/cs/Syntax.cs#9)]
 [!code-vb[System.DateTimeOffset.Syntax#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Syntax/vb/Syntax.vb#9)]  
  
 Jest równoważne metodę dla tego operatora <xref:System.DateTimeOffset.Compare%28System.DateTimeOffset%2CSystem.DateTimeOffset%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Subtraction">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odejmuje określoną <see cref="T:System.DateTimeOffset" /> lub <see cref="T:System.TimeSpan" /> obiekt z <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static TimeSpan operator - (DateTimeOffset left, DateTimeOffset right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.TimeSpan op_Subtraction(valuetype System.DateTimeOffset left, valuetype System.DateTimeOffset right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.op_Subtraction(System.DateTimeOffset,System.DateTimeOffset)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As DateTimeOffset, right As DateTimeOffset) As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TimeSpan operator -(DateTimeOffset left, DateTimeOffset right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : DateTimeOffset * DateTimeOffset -&gt; TimeSpan" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.DateTimeOffset" />
        <Parameter Name="right" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="left">Odjemna.</param>
        <param name="right">Odjemnik.</param>
        <summary>Odejmuje jedną <see cref="T:System.DateTimeOffset" /> obiektu z innego i zwraca przedział czasu.</summary>
        <returns>Obiekt reprezentujący różnica między <paramref name="left" /> i <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.op_Subtraction%2A> Metoda definiuje operacji odejmowania <xref:System.DateTimeOffset> obiektów. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.DateTimeOffset.Operators#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/cs/Operators.cs#14)]
 [!code-vb[System.DateTimeOffset.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/vb/Operators.vb#14)]  
  
 Języki, które nie obsługują niestandardowych operatory i przeładowania operatora można wywołać <xref:System.DateTimeOffset.Subtract%28System.DateTimeOffset%29?displayProperty=nameWithType> metody zamiast tego.  
  
 Metoda równoważne tego operatora jest <xref:System.DateTimeOffset.Subtract%28System.TimeSpan%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.DateTimeOffset.Subtract(System.DateTimeOffset)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static DateTimeOffset operator - (DateTimeOffset dateTimeOffset, TimeSpan timeSpan);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.DateTimeOffset op_Subtraction(valuetype System.DateTimeOffset dateTimeOffset, valuetype System.TimeSpan timeSpan) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.op_Subtraction(System.DateTimeOffset,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTimeOffset operator -(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);" />
      <MemberSignature Language="F#" Value="static member ( - ) : DateTimeOffset * TimeSpan -&gt; DateTimeOffset" Usage="dateTimeOffset - timeSpan" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dateTimeOffset" Type="System.DateTimeOffset" />
        <Parameter Name="timeSpan" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="dateTimeOffset">Data i godzina obiekt chcesz odjąć od.</param>
        <param name="timeSpan">Interwał czasu, który należy odjąć.</param>
        <summary>Odejmuje określony interwał od określonej daty i godziny i zwraca nową datę i godzinę.</summary>
        <returns>Obiekt, który jest taki sam, jak wartość <paramref name="dateTimeOffset" /> minus <paramref name="timeSpan" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.op_Subtraction%2A> Metoda definiuje operacji odejmowania <xref:System.DateTimeOffset> obiektów. Umożliwia stosowanie kodu takiego jak następujący:  
  
 [!code-csharp[System.DateTimeOffset.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/cs/Operators.cs#15)]
 [!code-vb[System.DateTimeOffset.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Operators/vb/Operators.vb#15)]  
  
 Języki, które nie obsługują niestandardowych operatory i przeładowania operatora można wywołać <xref:System.DateTimeOffset.Subtract%28System.TimeSpan%29?displayProperty=nameWithType> metody zamiast tego.  
  
 Metoda równoważne tego operatora jest <xref:System.DateTimeOffset.Subtract%28System.TimeSpan%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest mniejsza niż <see cref="F:System.DateTimeOffset.MinValue" /> lub większa niż <see cref="F:System.DateTimeOffset.MaxValue" />.</exception>
        <altmember cref="M:System.DateTimeOffset.Subtract(System.TimeSpan)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTimeOffset" /> równoważne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static DateTimeOffset Parse (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTimeOffset Parse(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (input As String) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTimeOffset Parse(System::String ^ input);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; DateTimeOffset" Usage="System.DateTimeOffset.Parse input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg zawierający datę i godzinę, które należy przekształcić.</param>
        <summary>Konwertuje określoną reprezentację ciągu daty, godziny i przesunięcie do jego <see cref="T:System.DateTimeOffset" /> równoważne.</summary>
        <returns>Obiekt, który jest odpowiednikiem daty i czasu, który jest zawarty w <paramref name="input" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.Parse%28System.String%29> analizuje ciągu z trzech elementów, które mogą być wyświetlane w dowolnej kolejności i są rozdzielane znakami odstępu. Te trzy elementy są opisane w poniższej tabeli.  
  
|Element|Przykład|  
|-------------|-------------|  
|\<Data >|"2/10/2007"|  
|\<Time>|"1:02:03 PM"|  
|\<Przesunięcie >|"-7:30"|  
  
 Mimo że każda z tych elementów jest opcjonalny, \<przesunięcie > nie może występować samodzielnie. Należy podać razem albo \<Data > lub \<czasu >. Jeśli \<Data > Brak domyślnej wartości jest bieżącego dnia. Jeśli \<czasu > brakuje jej domyślna wartość to 00:00:00: 00. Jeśli \<Data > jest obecny, ale jego roku składnik obejmuje tylko dwie cyfry, zostanie przekonwertowane na roku w kalendarzu bieżącego bieżącej kultury, na podstawie wartości z <xref:System.Globalization.Calendar.TwoDigitYearMax%2A?displayProperty=nameWithType> właściwości. Jeśli \<przesunięcie > brakuje jej domyślna wartość to przesunięcie w lokalnej strefie czasowej. \<Przesunięcie > może reprezentować ujemny lub dodatnią przesunięcie z uniwersalnego czasu koordynowanego (UTC). W obu przypadkach \<przesunięcie > musi zawierać symbol znaku.  
  
 `input` , Korzystając z informacji formatowania w zostanie przeanalizowany ciąg <xref:System.Globalization.DateTimeFormatInfo> obiekt, który został zainicjowany dla bieżącej kultury. Aby przeanalizować ciąg zawierający wyznaczonych formatowania, który nie odpowiada formatowanie bieżącej kultury, użyj <xref:System.DateTimeOffset.ParseExact%2A> — metoda i podaj specyfikator formatu.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.DateTimeOffset.Parse%28System.String%29> metodę, aby przeanalizować kilka ciągów daty i godziny. Przykład zawiera dane wyjściowe z 22 marca 2007 w systemie, w których kultury jest en-us.  
  
 [!code-csharp[System.DateTimeOffset.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Parse/cs/ParseExamples.cs#1)]
 [!code-vb[System.DateTimeOffset.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Parse/vb/ParseExamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Przesunięcie jest większe niż 14 godzin lub mniejsze niż-14 godzin.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="input" /> nie zawiera prawidłową reprezentacją ciągu daty i godziny.  - lub - <paramref name="input" /> zawiera reprezentację ciągu wartość przesunięcia bez daty lub godziny.</exception>
        <altmember cref="Overload:System.DateTimeOffset.TryParse" />
        <altmember cref="Overload:System.DateTimeOffset.ParseExact" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static DateTimeOffset Parse (string input, IFormatProvider formatProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTimeOffset Parse(string input, class System.IFormatProvider formatProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (input As String, formatProvider As IFormatProvider) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTimeOffset Parse(System::String ^ input, IFormatProvider ^ formatProvider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; DateTimeOffset" Usage="System.DateTimeOffset.Parse (input, formatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="formatProvider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg zawierający datę i godzinę, które należy przekształcić.</param>
        <param name="formatProvider">Obiekt, który zawiera informacje specyficzne dla kultury format o <c>wejściowych</c>.</param>
        <summary>Konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTimeOffset" /> odpowiednik, korzystając z informacji zawartych w określonym formacie specyficzne dla kultury.</summary>
        <returns>Obiekt, który jest odpowiednikiem daty i czasu, który jest zawarty w <paramref name="input" />, zgodnie z określonym <paramref name="formatProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda analizuje ciągu z trzech elementów, które mogą być wyświetlane w dowolnej kolejności i są rozdzielane znakami odstępu. W poniższej tabeli przedstawiono te trzy elementy.  
  
|Element|Przykład|  
|-------------|-------------|  
|\<Data >|"2/10/2007"|  
|\<Time>|"1:02:03 PM"|  
|\<Przesunięcie >|"-7:30"|  
  
 Mimo że każda z tych elementów jest opcjonalny, \<przesunięcie > nie może występować samodzielnie. Należy podać razem albo \<Data > lub \<czasu >. Jeśli \<Data > Brak domyślnej wartości jest bieżącego dnia. Jeśli \<Data > jest obecny, ale jego roku składnik obejmuje tylko dwie cyfry, zostanie przekonwertowane na roku w `provider` parametru bieżącego kalendarza na podstawie wartości z <xref:System.Globalization.Calendar.TwoDigitYearMax%2A?displayProperty=nameWithType> właściwości. Jeśli \<czasu > brakuje jej domyślna wartość to 00:00:00: 00. Jeśli \<przesunięcie > brakuje jej domyślna wartość to przesunięcie w lokalnej strefie czasowej. \<Przesunięcie > może reprezentować ujemny lub dodatnią przesunięcie z uniwersalnego czasu koordynowanego (UTC). W obu przypadkach \<przesunięcie > musi zawierać symbol znaku.  
  
 Format tych trzech elementów jest zdefiniowany przez `formatProvider` parametr, który może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury, którego formatowanie jest używany w `input` parametru. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez <xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> definiuje właściwości formatowania użytego w `input`.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format daty i godziny.  
  
 Jeśli `formatprovider` jest `null`, <xref:System.Globalization.CultureInfo> obiekt, który odpowiada bieżącej kultury jest używany.  
  
 Dodatnie lub ujemne znaku używanego w \<przesunięcie > musi być równa albo + lub -. Nie jest zdefiniowany przez <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A> lub <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A> właściwości <xref:System.Globalization.NumberFormatInfo> obiektu `formatProvider` parametru.  
  
   
  
## Examples  
 Poniższy przykład analizuje Data i godzina ciągów, które są sformatowane dla kultury fr-fr i wyświetla je przy użyciu systemu lokalnego domyślne en-us kultury.  
  
 [!code-csharp[System.DateTimeOffset.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Parse/cs/ParseExamples.cs#2)]
 [!code-vb[System.DateTimeOffset.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Parse/vb/ParseExamples.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Przesunięcie jest większe niż 14 godzin lub mniejsze niż-14 godzin.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="input" /> nie zawiera prawidłową reprezentacją ciągu daty i godziny.  - lub - <paramref name="input" /> zawiera reprezentację ciągu wartość przesunięcia bez daty lub godziny.</exception>
        <altmember cref="Overload:System.DateTimeOffset.TryParse" />
        <altmember cref="Overload:System.DateTimeOffset.ParseExact" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static DateTimeOffset Parse (ReadOnlySpan&lt;char&gt; input, IFormatProvider formatProvider = null, System.Globalization.DateTimeStyles styles = System.Globalization.DateTimeStyles.None);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTimeOffset Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; input, class System.IFormatProvider formatProvider, valuetype System.Globalization.DateTimeStyles styles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (input As ReadOnlySpan(Of Char), Optional formatProvider As IFormatProvider = null, Optional styles As DateTimeStyles = System.Globalization.DateTimeStyles.None) As DateTimeOffset" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTimeOffset" Usage="System.DateTimeOffset.Parse (input, formatProvider, styles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="formatProvider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="input">To be added.</param>
        <param name="formatProvider">To be added.</param>
        <param name="styles">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static DateTimeOffset Parse (string input, IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTimeOffset Parse(string input, class System.IFormatProvider formatProvider, valuetype System.Globalization.DateTimeStyles styles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.Parse(System.String,System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (input As String, formatProvider As IFormatProvider, styles As DateTimeStyles) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTimeOffset Parse(System::String ^ input, IFormatProvider ^ formatProvider, System::Globalization::DateTimeStyles styles);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTimeOffset" Usage="System.DateTimeOffset.Parse (input, formatProvider, styles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="formatProvider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg zawierający datę i godzinę, które należy przekształcić.</param>
        <param name="formatProvider">Obiekt, który zawiera informacje specyficzne dla kultury format o <c>wejściowych</c>.</param>
        <param name="styles">Bitowe połączenie wartości wyliczenia wskazujących format dozwolonych <c>wejściowych</c>. Jest Typowa wartość do określenia <see cref="F:System.Globalization.DateTimeStyles.None" />.</param>
        <summary>Konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTimeOffset" /> równoważne korzystając z informacji zawartych w określonym formacie specyficzne dla kultury formatowanie i style.</summary>
        <returns>Obiekt, który jest odpowiednikiem daty i czasu, który jest zawarty w <paramref name="input" /> określone przez <paramref name="formatProvider" /> i <paramref name="styles" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda analizuje ciągu z trzech elementów, które mogą być wyświetlane w dowolnej kolejności i są rozdzielane znakami odstępu. W poniższej tabeli przedstawiono te trzy elementy.  
  
|Element|Przykład|  
|-------------|-------------|  
|\<Data >|"2/10/2007"|  
|\<Time>|"1:02:03 PM"|  
|\<Przesunięcie >|"-7:30"|  
  
 Mimo że każda z tych elementów jest opcjonalny, \<przesunięcie > nie może występować samodzielnie. Należy podać razem albo \<Data > lub \<czasu >. Jeśli \<Data > Brak domyślnej wartości jest bieżącego dnia. Jeśli \<Data > jest obecny, ale jego roku składnik obejmuje tylko dwie cyfry, zostanie przekonwertowane na roku w `provider` parametru bieżącego kalendarza na podstawie wartości z <xref:System.Globalization.Calendar.TwoDigitYearMax%2A?displayProperty=nameWithType> właściwości. Jeśli \<czasu > brakuje jej domyślna wartość to 00:00:00: 00. Jeśli \<przesunięcie > Brak domyślnej wartości jest przesunięcie w lokalnej strefie czasowej, lub <xref:System.TimeSpan.Zero?displayProperty=nameWithType> Jeśli dowolny <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> lub <xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType> wartość została określona w `styles` parametru. Jeśli \<przesunięcie > jest obecny, może to oznaczać ujemny lub dodatnią przesunięcie z uniwersalnego czasu koordynowanego (UTC). W obu przypadkach \<przesunięcie > musi zawierać symbol znaku.  
  
 Format tych trzech elementów jest zdefiniowany przez `formatProvider` parametr, który może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury, którego formatowanie jest używany w `input` parametru. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez <xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> definiuje właściwości formatowania użytego w `input`.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format daty i godziny.  
  
 Każdy element może również być ujęta w wiodących i końcowych białych i \<Data > a \<czasu > może to być wewnętrzny biały znak (na przykład 6:00:00). Tylko \<przesunięcie > składnika nie może zawierać wewnętrzny biały znak.  
  
 Jeśli `formatprovider` jest `null`, <xref:System.Globalization.CultureInfo> obiekt, który odpowiada bieżącej kultury jest używany.  
  
 Dodatnie lub ujemne znaku używanego w \<przesunięcie > musi być równa albo + lub -. Nie jest zdefiniowany przez <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A> lub <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A> właściwości <xref:System.Globalization.NumberFormatInfo> obiektu zwróconego przez `formatProvider` parametru.  
  
 W poniższej tabeli przedstawiono elementy członkowskie <xref:System.Globalization.DateTimeStyles?displayProperty=nameWithType> wyliczenia, które są obsługiwane.  
  
|Element członkowski DateTimeStyles|Opis|  
|---------------------------|-----------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|Analizuje reprezentowany przez ciąg `input` i, w razie potrzeby, konwertuje ją na czas UTC. Jest to równoważne do analizowania parametrów, a następnie wywołując <xref:System.DateTimeOffset.ToUniversalTime%2A?displayProperty=nameWithType> metody zwracana <xref:System.DateTimeOffset> obiektu.|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|Choć ważna, wartość ta jest ignorowana. Wewnętrzny biały znak jest dozwolone w \<Data > a \<czasu > elementów.|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|Choć ważna, wartość ta jest ignorowana. Początkowe biały znak jest dozwolony na początku każdego składnika w analizowany ciąg.|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|Choć ważna, wartość ta jest ignorowana. Końcowe biały znak jest dozwolony na początku każdego składnika w analizowany ciąg.|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|Jest to zachowanie domyślne. Nie można zastąpić podając bardziej restrykcyjne <xref:System.Globalization.DateTimeStyles> wyliczenia wartości, takich jak <xref:System.Globalization.DateTimeStyles.None?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|Oznacza to, że, jeśli `input` brakuje parametru \<przesunięcie > element, należy podać przesunięcie w lokalnej strefie czasowej. Jest to domyślne zachowanie <xref:System.DateTimeOffset.Parse%2A> metody.|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|Oznacza to, że, jeśli `input` brakuje parametru \<przesunięcie > element, należy podać przesunięcie czasu UTC (00:00).|  
|<xref:System.Globalization.DateTimeStyles.None>|Mimo że jest prawidłowy, ta wartość jest ignorowana i nie ma wpływu.|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|Ponieważ <xref:System.DateTimeOffset> nie ma struktury `Kind` właściwość, ta wartość nie ma wpływu.|  
  
 Tylko <xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType> wartość nie jest obsługiwana. <xref:System.ArgumentException> Jest generowany, jeśli ta wartość jest uwzględniona w `styles` parametru.  
  
   
  
## Examples  
 Poniższy przykład ilustruje efekt przekazywanie <xref:System.Globalization.DateTimeStyles.AssumeLocal?displayProperty=nameWithType>, <xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType>, i <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> wartości do `styles` parametr <xref:System.DateTimeOffset.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29> metody.  
  
 [!code-csharp[System.DateTimeOffset.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Parse/cs/ParseExamples.cs#3)]
 [!code-vb[System.DateTimeOffset.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Parse/vb/ParseExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Przesunięcie jest większe niż 14 godzin lub mniejsze niż-14 godzin.  - lub - <paramref name="styles" /> nie jest prawidłową <see cref="T:System.Globalization.DateTimeStyles" /> wartość.  - lub - <paramref name="styles" /> zawiera nieobsługiwany <see cref="T:System.Globalization.DateTimeStyles" /> wartość.  - lub - <paramref name="styles" /> obejmuje <see cref="T:System.Globalization.DateTimeStyles" /> wartości, które nie mogą być używane razem.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="input" /> nie zawiera prawidłową reprezentacją ciągu daty i godziny.  - lub - <paramref name="input" /> zawiera reprezentację ciągu wartość przesunięcia bez daty lub godziny.</exception>
        <altmember cref="Overload:System.DateTimeOffset.TryParse" />
        <altmember cref="Overload:System.DateTimeOffset.ParseExact" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ParseExact">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTimeOffset" /> równoważne. Format ciągu reprezentującego musi dokładnie pasować do wskazanego formatu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTimeOffset ParseExact (string input, string format, IFormatProvider formatProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTimeOffset ParseExact(string input, string format, class System.IFormatProvider formatProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.ParseExact(System.String,System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (input As String, format As String, formatProvider As IFormatProvider) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTimeOffset ParseExact(System::String ^ input, System::String ^ format, IFormatProvider ^ formatProvider);" />
      <MemberSignature Language="F#" Value="static member ParseExact : string * string * IFormatProvider -&gt; DateTimeOffset" Usage="System.DateTimeOffset.ParseExact (input, format, formatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="formatProvider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg zawierający datę i godzinę, które należy przekształcić.</param>
        <param name="format">Specyfikator formatu, który definiuje z oczekiwanym formatem <c>wejściowych</c>.</param>
        <param name="formatProvider">Obiekt, który dostarcza specyficzne dla kultury formatowania informacji na temat <c>wejściowych</c>.</param>
        <summary>Konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTimeOffset" /> równoważne przy użyciu określonego formatu i informacji o formacie specyficzne dla kultury. Format ciągu reprezentującego musi dokładnie pasować do wskazanego formatu.</summary>
        <returns>Obiekt, który jest odpowiednikiem daty i czasu, który jest zawarty w <paramref name="input" /> określone przez <paramref name="format" /> i <paramref name="formatProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%29> Metody analizuje reprezentację ciągu daty, która musi być w formacie zdefiniowane przez `format` parametru. On również wymaga, aby \<Data >, \<czasu >, i \<przesunięcia > elementy reprezentację ciągu daty i godziny są wyświetlane w kolejności określonej przez `format`. Jeśli `input` ciąg nie jest zgodny z tym `format` parametr, metoda wygeneruje <xref:System.FormatException>.  Z kolei <xref:System.DateTimeOffset.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody analizuje reprezentację ciągu na datę w jednym z formatów rozpoznany przez dostawcę format <xref:System.Globalization.DateTimeFormatInfo> obiektu. <xref:System.DateTimeOffset.Parse%2A> Umożliwia również \<Data >, \<czasu >, i \<przesunięcie > elementy reprezentację ciągu daty i godziny są wyświetlane w dowolnej kolejności.  
  
 `format` Parametr jest ciąg znaków zawierający pojedynczy standardowy specyfikator formatu lub specyfikatory formatu niestandardowego, które definiują wymagany format `input` parametru. Aby uzyskać więcej informacji o prawidłowe kody formatowania, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Jeśli `format` obejmuje `z`, `zz`, lub `zzz` specyfikatorów formatu niestandardowego, aby wskazać, że przesunięcia musi znajdować się w `input`, które musi zawierać symbolu wartości ujemnej lub znak dodatni. Jeśli brakuje znaku, metoda wygeneruje <xref:System.FormatException>.  
  
 Jeśli `format` wymaga, aby `input` zawierać datę, ale nie godziny, powstałe w ten sposób <xref:System.DateTimeOffset> obiekt jest przypisany przez czas północy (0: 00:00). Jeśli `format` wymaga, aby `input` zawiera godzinę, ale nie Data, powstałe w ten sposób <xref:System.DateTimeOffset> obiekt jest przypisany bieżącą datę w systemie lokalnym. Jeśli `format` nie wymaga, aby `input` zawiera przesunięcie powstałe w ten sposób <xref:System.DateTimeOffset> obiekt jest przypisany przesunięcia strefy czasowej systemu lokalnego.  
  
 Określonej daty i czasu symbole i parametrów używanych w `input` są definiowane przez `formatProvider` parametru jest dokładne format `input` Jeśli `format` jest ciąg specyfikatora formatu standardowych. `formatProvider` Parametr może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury na podstawie którego `input` jest interpretowany. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez jego <xref:System.Globalization.CultureInfo.DateTimeFormat%2A> właściwość definiuje symbole i formatowania w `input`.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format daty i godziny.  
  
 Jeśli `formatprovider` jest `null`, <xref:System.Globalization.CultureInfo> obiekt, który odpowiada bieżącej kultury jest używany.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTimeOffset.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metody specyfikatory formatu standardowych i niestandardowych i Niezmienna kultura, można przeanalizować kilka ciągów daty i godziny.  
  
 [!code-csharp[System.DateTimeOffset.ParseExact#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.ParseExact/cs/ParseExact.cs#1)]
 [!code-vb[System.DateTimeOffset.ParseExact#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.ParseExact/vb/ParseExact.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Przesunięcie jest większe niż 14 godzin lub mniejsze niż-14 godzin.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> jest <see langword="null" />.  - lub - <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="input" /> to ciąg pusty ("").  - lub - <paramref name="input" /> nie zawiera prawidłową reprezentacją ciągu daty i godziny.  - lub - <paramref name="format" /> jest pustym ciągiem.  - lub - składnik godziny i oznaczenie AM/PM w <paramref name="input" /> nie są zgodne.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] <see cref="Overload:System.DateTimeOffset.ParseExact" /> metoda zgłasza <see cref="T:System.FormatException" /> ciąg do przeanalizowania zawiera składnik godziny i oznaczenie AM/PM, które nie są umowy. W [! INCLUDE[net_v35_short](~/includes/NET-v35-Short-MD.MD)] i starszych wersjach, oznaczenie AM/PM jest ignorowana.</para>
        </block>
        <altmember cref="Overload:System.DateTimeOffset.TryParseExact" />
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTimeOffset ParseExact (ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; format, IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles = System.Globalization.DateTimeStyles.None);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTimeOffset ParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; input, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider formatProvider, valuetype System.Globalization.DateTimeStyles styles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.ParseExact(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (input As ReadOnlySpan(Of Char), format As ReadOnlySpan(Of Char), formatProvider As IFormatProvider, Optional styles As DateTimeStyles = System.Globalization.DateTimeStyles.None) As DateTimeOffset" />
      <MemberSignature Language="F#" Value="static member ParseExact : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTimeOffset" Usage="System.DateTimeOffset.ParseExact (input, format, formatProvider, styles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="formatProvider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="input">To be added.</param>
        <param name="format">To be added.</param>
        <param name="formatProvider">To be added.</param>
        <param name="styles">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTimeOffset ParseExact (ReadOnlySpan&lt;char&gt; input, string[] formats, IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles = System.Globalization.DateTimeStyles.None);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTimeOffset ParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; input, string[] formats, class System.IFormatProvider formatProvider, valuetype System.Globalization.DateTimeStyles styles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.ParseExact(System.ReadOnlySpan{System.Char},System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (input As ReadOnlySpan(Of Char), formats As String(), formatProvider As IFormatProvider, Optional styles As DateTimeStyles = System.Globalization.DateTimeStyles.None) As DateTimeOffset" />
      <MemberSignature Language="F#" Value="static member ParseExact : ReadOnlySpan&lt;char&gt; * string[] * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTimeOffset" Usage="System.DateTimeOffset.ParseExact (input, formats, formatProvider, styles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="formats" Type="System.String[]" />
        <Parameter Name="formatProvider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="input">To be added.</param>
        <param name="formats">To be added.</param>
        <param name="formatProvider">To be added.</param>
        <param name="styles">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTimeOffset ParseExact (string input, string format, IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTimeOffset ParseExact(string input, string format, class System.IFormatProvider formatProvider, valuetype System.Globalization.DateTimeStyles styles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.ParseExact(System.String,System.String,System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (input As String, format As String, formatProvider As IFormatProvider, styles As DateTimeStyles) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTimeOffset ParseExact(System::String ^ input, System::String ^ format, IFormatProvider ^ formatProvider, System::Globalization::DateTimeStyles styles);" />
      <MemberSignature Language="F#" Value="static member ParseExact : string * string * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTimeOffset" Usage="System.DateTimeOffset.ParseExact (input, format, formatProvider, styles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="formatProvider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg zawierający datę i godzinę, które należy przekształcić.</param>
        <param name="format">Specyfikator formatu, który definiuje z oczekiwanym formatem <c>wejściowych</c>.</param>
        <param name="formatProvider">Obiekt, który dostarcza specyficzne dla kultury formatowania informacji na temat <c>wejściowych</c>.</param>
        <param name="styles">Bitowe połączenie wartości wyliczenia wskazujących format dozwolonych <c>wejściowych</c>.</param>
        <summary>Konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTimeOffset" /> równoważne przy użyciu określonego formatu, informacji o formacie specyficzne dla kultury i styl. Format ciągu reprezentującego musi dokładnie pasować do wskazanego formatu.</summary>
        <returns>Obiekt, który jest odpowiednikiem daty i czasu, który jest zawarty w <paramref name="input" /> określony przez parametr <paramref name="format" />, <paramref name="formatProvider" />, i <paramref name="styles" /> parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> Metody analizuje reprezentację ciągu daty, która musi być w formacie zdefiniowane przez `format` parametru. On również wymaga, aby \<Data >, \<czasu >, i \<przesunięcia > elementy reprezentację ciągu daty i godziny są wyświetlane w kolejności określonej przez `format`. Jeśli `input` ciąg nie odpowiada wzorcowi `format` parametru z żadnych zmian, zdefiniowane przez `styles` parametr, metoda wygeneruje <xref:System.FormatException>.  Z kolei <xref:System.DateTimeOffset.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> metody analizuje reprezentację ciągu na datę w jednym z formatów rozpoznany przez dostawcę format <xref:System.Globalization.DateTimeFormatInfo> obiektu. <xref:System.DateTimeOffset.Parse%2A> Umożliwia również \<Data >, \<czasu >, i \<przesunięcie > elementy reprezentację ciągu daty i godziny są wyświetlane w dowolnej kolejności.  
  
 `format` Parametr jest ciąg znaków zawierający specyfikator formatu pojedynczy standardowy lub specyfikatorów formatu niestandardowego, definiujące wymagany wzorzec `input` parametru. Aby uzyskać więcej informacji o prawidłowe kody formatowania, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Jeśli `format` obejmuje `z`, `zz`, lub `zzz` specyfikatorów formatu niestandardowego, aby wskazać, że przesunięcia musi znajdować się w `input`, które musi zawierać symbolu wartości ujemnej lub znak dodatni. Jeśli brakuje znaku, metoda wygeneruje <xref:System.FormatException>.  
  
 Jeśli `format` wymaga, aby `input` zawierać datę, ale nie godziny, powstałe w ten sposób <xref:System.DateTimeOffset> obiekt jest przypisany przez czas północy (0: 00:00). Jeśli `format` wymaga, aby `input` zawiera godzinę, ale nie Data, powstałe w ten sposób <xref:System.DateTimeOffset> obiekt jest przypisany bieżącą datę w systemie lokalnym. Jeśli `format` nie wymaga, aby `input` zawiera przesunięcie przesunięcie powstałe w ten sposób <xref:System.DateTimeOffset> obiektu zależy od wartości `styles` parametru. Jeśli `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeLocal>, przesunięcie w lokalnej strefie czasowej jest przypisany do <xref:System.DateTimeOffset> obiektu. Jeśli `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeUniversal>, przesunięciem uniwersalnego czasu koordynowanego (UTC) lub + 00:00, jest przypisany do <xref:System.DateTimeOffset> obiektu. Jeśli żadna wartość nie jest określona, używane jest przesunięcie lokalnej strefy czasowej.  
  
 Określonej daty i czasu symbole i parametrów używanych w `input` są definiowane przez `formatProvider` parametru. To samo dotyczy dokładne format `input`, jeśli `format` jest ciąg specyfikatora formatu standardowych. `formatProvider` Parametr może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury na podstawie którego `input` jest interpretowany. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez <xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> właściwość definiuje symbole i formatowania w `input`.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format daty i godziny.  
  
 Jeśli `formatprovider` jest `null`, <xref:System.Globalization.CultureInfo> obiekt, który odpowiada bieżącej kultury jest używany.  
  
 `styles` Parametr określa, czy biały znak jest dozwolony w ciągu wejściowym wskazuje sposób analizowania są ciągi bez jawnego przesunięcia składnik, a także obsługuje UTC konwersji w ramach operacji analizy. Wszystkie elementy członkowskie <xref:System.Globalization.DateTimeStyles> wyliczenia są obsługiwane z wyjątkiem <xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>. Poniższa tabela zawiera listę działania każdego z obsługiwanych elementów członkowskich.  
  
|`DateTimeStyles` element członkowski|Zachowanie|  
|-----------------------------|--------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|Analizuje `input` i, w razie potrzeby, konwertuje ją na czas UTC. Jest to równoważne do analizowania parametrów, a następnie podczas wywoływania <xref:System.DateTimeOffset.ToUniversalTime%2A?displayProperty=nameWithType> metody zwracana <xref:System.DateTimeOffset> obiektu.|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|Jeśli `format` nie wymaga, aby `input` zawiera wartość przesunięcia zwróconego <xref:System.DateTimeOffset> obiektu podano przesunięcie w lokalnej strefie czasowej. Jest to wartość domyślna.|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|Jeśli `format` nie wymaga, aby `input` zawiera wartość przesunięcia zwróconego <xref:System.DateTimeOffset> obiektu podano przesunięcie UTC (+ 00:00).|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|Umożliwia `input` uwzględnienie wewnętrzny biały znak nie został określony przez `format`. Dodatkowe wolne miejsce może wystąpić między składnikami daty i godziny oraz w poszczególnych składników, a jest ignorowany podczas analizowania parametrów.|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|Umożliwia `input` uwzględnienie spacje początkowe nie został określony przez `format`. Są one ignorowane podczas analizowania ciągu.|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|Umożliwia `input` uwzględnienie końcowe spacje nie został określony przez `format`. Są one ignorowane podczas analizowania ciągu.|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|Umożliwia `input` do spacji wiodących końcowe i wewnętrzny nie został określony przez `format`. Wszystkie dodatkowe białych znaków, nie jest określony w `format` podczas analizowania parametrów są ignorowane.|  
|<xref:System.Globalization.DateTimeStyles.None>|Wskazuje, że dodatkowe biały znak jest niedozwolony w `input`. Biały znak musi znajdować się dokładnie tak jak określono w `format`. Jest to zachowanie domyślne.|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|Nie obowiązuje, ponieważ <xref:System.DateTimeOffset> nie ma struktury `Kind` właściwości.|  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTimeOffset.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> metody specyfikatory formatu standardowych i niestandardowych, niezmienna kultura i różnymi <xref:System.Globalization.DateTimeStyles> wartości, aby przeanalizować kilka ciągów daty i godziny.  
  
 [!code-csharp[System.DateTimeOffset.ParseExact#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.ParseExact/cs/ParseExact.cs#2)]
 [!code-vb[System.DateTimeOffset.ParseExact#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.ParseExact/vb/ParseExact.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Przesunięcie jest większe niż 14 godzin lub mniejsze niż-14 godzin.  - lub - <paramref name="styles" /> parametr zawiera nieobsługiwaną wartość.  - lub - <paramref name="styles" /> zawiera parametr <see cref="T:System.Globalization.DateTimeStyles" /> wartości, które nie mogą być używane razem.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> jest <see langword="null" />.  - lub - <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="input" /> to ciąg pusty ("").  - lub - <paramref name="input" /> nie zawiera prawidłową reprezentacją ciągu daty i godziny.  - lub - <paramref name="format" /> jest pustym ciągiem.  - lub - składnik godziny i oznaczenie AM/PM w <paramref name="input" /> nie są zgodne.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] <see cref="Overload:System.DateTimeOffset.ParseExact" /> metoda zgłasza <see cref="T:System.FormatException" /> ciąg do przeanalizowania zawiera składnik godziny i oznaczenie AM/PM, które nie są umowy. W [! INCLUDE[net_v35_short](~/includes/NET-v35-Short-MD.MD)] i starszych wersjach, oznaczenie AM/PM jest ignorowana.</para>
        </block>
        <altmember cref="Overload:System.DateTimeOffset.TryParseExact" />
      </Docs>
    </Member>
    <Member MemberName="ParseExact">
      <MemberSignature Language="C#" Value="public static DateTimeOffset ParseExact (string input, string[] formats, IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTimeOffset ParseExact(string input, string[] formats, class System.IFormatProvider formatProvider, valuetype System.Globalization.DateTimeStyles styles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.ParseExact(System.String,System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ParseExact (input As String, formats As String(), formatProvider As IFormatProvider, styles As DateTimeStyles) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTimeOffset ParseExact(System::String ^ input, cli::array &lt;System::String ^&gt; ^ formats, IFormatProvider ^ formatProvider, System::Globalization::DateTimeStyles styles);" />
      <MemberSignature Language="F#" Value="static member ParseExact : string * string[] * IFormatProvider * System.Globalization.DateTimeStyles -&gt; DateTimeOffset" Usage="System.DateTimeOffset.ParseExact (input, formats, formatProvider, styles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="formats" Type="System.String[]" />
        <Parameter Name="formatProvider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg zawierający datę i godzinę, które należy przekształcić.</param>
        <param name="formats">Tablica specyfikatory formatu, które definiują oczekiwane formaty <c>wejściowych</c>.</param>
        <param name="formatProvider">Obiekt, który dostarcza specyficzne dla kultury formatowania informacji na temat <c>wejściowych</c>.</param>
        <param name="styles">Bitowe połączenie wartości wyliczenia wskazujących format dozwolonych <c>wejściowych</c>.</param>
        <summary>Konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTimeOffset" /> równoważne przy użyciu określonych formatów, informacji o formacie specyficzne dla kultury i styl. Format ciągu reprezentującego musi dokładnie pasować do jednego ze wskazanych formatów.</summary>
        <returns>Obiekt, który jest odpowiednikiem daty i czasu, który jest zawarty w <paramref name="input" /> określony przez parametr <paramref name="formats" />, <paramref name="formatProvider" />, i <paramref name="styles" /> parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.ParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> Metody analizuje reprezentację ciągu daty, który pasuje do jednej z wzorców przypisane do `formats` parametru. Jeśli `input` ciąg nie jest zgodny ze wszystkimi zmian zdefiniowane przez jeden z tych wzorców `styles` parametr, metoda wygeneruje <xref:System.FormatException>. Jako uzupełnienie porównanie `input` do wielu wzorców formatowania, to przeciążenie zachowuje się tak samo do <xref:System.DateTimeOffset.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> metody.  
  
 `formats` Parametr jest tablicą ciągów, których elementy zawierają specyfikator formatu pojedynczy standardowy lub specyfikatorów formatu niestandardowego, definiujące możliwe wzorzec `input` parametru. Po wywołaniu metody `input` musi być zgodny z jednym tych wzorców. Aby uzyskać więcej informacji o prawidłowe kody formatowania, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Jeśli element dopasowane `formats` obejmuje `z`, `zz`, lub `zzz` specyfikatorów formatu niestandardowego, aby wskazać, że przesunięcia musi znajdować się w `input`, które musi zawierać symbolu wartości ujemnej lub znak dodatni. Jeśli brakuje znaku, metoda wygeneruje <xref:System.FormatException>.  
  
> [!IMPORTANT]
>  Przy użyciu `formats` parametru tego przeciążenia, aby określić wiele formatów mogą pomóc w zmniejszeniu frustracji spowodowanej wielu użytkowników występują po wprowadzeniu daty i godziny. W szczególności możliwość definiowania wielu wzorców wejściowych włącza aplikację do obsługi Data i godzina oświadczenia, które można uwzględnić lub braku zera wiodące w miesięcy, dni, godziny, minuty i sekundy. W przykładzie przedstawiono ilustracja to.  
  
 Jeśli element dopasowane w `formats` wymaga, aby `input` zawierać datę, ale nie godziny, powstałe w ten sposób <xref:System.DateTimeOffset> obiekt jest przypisany przez czas północy (0: 00:00). Jeśli element dopasowane w `formats` wymaga, aby `input` zawiera godzinę, ale nie Data, powstałe w ten sposób <xref:System.DateTimeOffset> obiekt jest przypisany bieżącą datę w systemie lokalnym. Jeśli element dopasowane w `formats` nie wymaga, aby `input` zawiera przesunięcie przesunięcie powstałe w ten sposób <xref:System.DateTimeOffset> obiektu zależy od wartości `styles` parametru. Jeśli `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeLocal>, przesunięcie w lokalnej strefie czasowej jest przypisany do <xref:System.DateTimeOffset> obiektu. Jeśli `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeUniversal>, przesunięciem uniwersalnego czasu koordynowanego (UTC) lub + 00:00, jest przypisany do <xref:System.DateTimeOffset> obiektu. Jeśli żadna wartość nie jest określona, używane jest przesunięcie lokalnej strefy czasowej.  
  
 Określonej daty i czasu symbole i parametrów używanych w `input` są definiowane przez `formatProvider` parametru. To samo dotyczy dokładne format `input`, jeśli pasującego elementu `formats` jest ciąg specyfikatora formatu standardowych. `formatProvider` Parametr może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury na podstawie którego `input` jest interpretowany. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez <xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> właściwość definiuje symbole i formatowania w `input`.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format daty i godziny.  
  
 Jeśli `formatprovider` jest `null`, <xref:System.Globalization.CultureInfo> obiekt, który odpowiada bieżącej kultury jest używany.  
  
 `styles` Parametr określa, czy biały znak jest dozwolone w ciągu wejściowym wskazuje sposób analizowania są ciągi bez jawnego przesunięcia składnik, a także obsługuje UTC konwersji w ramach operacji analizy. Wszystkie elementy członkowskie <xref:System.Globalization.DateTimeStyles> wyliczenia są obsługiwane z wyjątkiem <xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>. Poniższa tabela zawiera listę działania każdego z obsługiwanych elementów członkowskich.  
  
|`DateTimeStyles` element członkowski|Zachowanie|  
|-----------------------------|--------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|Analizuje `input` i, w razie potrzeby, konwertuje ją na czas UTC. Jest to równoważne do analizowania parametrów, a następnie podczas wywoływania <xref:System.DateTimeOffset.ToUniversalTime%2A?displayProperty=nameWithType> metody zwracana <xref:System.DateTimeOffset> obiektu.|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|Jeśli element dopasowane w `formats` nie wymaga, aby `input` zawiera wartość przesunięcia zwróconego <xref:System.DateTimeOffset> obiektu podano przesunięcie w lokalnej strefie czasowej. Jest to wartość domyślna.|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|Jeśli element dopasowane w `formats` nie wymaga, aby `input` zawiera wartość przesunięcia zwróconego <xref:System.DateTimeOffset> obiektu podano przesunięcie UTC (+ 00:00).|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|Umożliwia `input` uwzględnienie wewnętrzny biały znak nie został określony przez `format`. Dodatkowe wolne miejsce może wystąpić między składnikami daty i godziny oraz w poszczególnych składników (z wyjątkiem przesunięcie) i jest ignorowany podczas analizowania parametrów.|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|Umożliwia `input` uwzględnienie spacje początkowe nie został określony przez `formats`. Są one ignorowane podczas analizowania ciągu.|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|Umożliwia `input` uwzględnienie końcowe spacje nie został określony przez `formats`. Są one ignorowane podczas analizowania ciągu.|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|Umożliwia `input` do spacji wiodących końcowe i wewnętrzny nie został określony przez `formats`. Wszystkie bardzo białych znaków, nie jest określony w elemencie dopasowane w `formats` podczas analizowania parametrów są ignorowane.|  
|<xref:System.Globalization.DateTimeStyles.None>|Wskazuje, że dodatkowe biały znak jest niedozwolony w `input`. Biały znak musi znajdować się dokładnie tak jak określono w poszczególnych elementów `formats` dopasowanie występuje. Jest to zachowanie domyślne.|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|Nie obowiązuje, ponieważ <xref:System.DateTimeOffset> nie ma struktury `Kind` właściwości.|  
  
   
  
## Examples  
 Poniższy przykład definiuje wiele formatów wejściowych reprezentacji ciągu daty i godziny oraz wartość przesunięcia, a następnie przekazuje ciąg, który jest wprowadzana przez użytkownika w celu <xref:System.DateTimeOffset.ParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> metody.  
  
 [!code-csharp[System.DateTimeOffset.ParseExact#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.ParseExact/cs/ParseExact.cs#3)]
 [!code-vb[System.DateTimeOffset.ParseExact#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.ParseExact/vb/ParseExact.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Przesunięcie jest większe niż 14 godzin lub mniejsze niż-14 godzin.  - lub - <paramref name="styles" /> zawiera nieobsługiwaną wartość.  - lub - <paramref name="styles" /> zawiera parametr <see cref="T:System.Globalization.DateTimeStyles" /> wartości, które nie mogą być używane razem.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="input" /> to ciąg pusty ("").  - lub - <paramref name="input" /> nie zawiera prawidłową reprezentacją ciągu daty i godziny.  - lub - nie elementu <paramref name="formats" /> zawiera prawidłowym specyfikatorem formatu.  - lub - składnik godziny i oznaczenie AM/PM w <paramref name="input" /> nie są zgodne.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] <see cref="Overload:System.DateTimeOffset.ParseExact" /> metoda zgłasza <see cref="T:System.FormatException" /> ciąg do przeanalizowania zawiera składnik godziny i oznaczenie AM/PM, które nie są umowy. W [! INCLUDE[net_v35_short](~/includes/NET-v35-Short-MD.MD)] i starszych wersjach, oznaczenie AM/PM jest ignorowana.</para>
        </block>
        <altmember cref="Overload:System.DateTimeOffset.TryParseExact" />
      </Docs>
    </Member>
    <Member MemberName="Second">
      <MemberSignature Language="C#" Value="public int Second { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Second" />
      <MemberSignature Language="DocId" Value="P:System.DateTimeOffset.Second" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Second As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Second { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Second : int" Usage="System.DateTimeOffset.Second" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera drugi składnik czasu zegara reprezentowany przez bieżący <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <value>Drugim składnikiem <see cref="T:System.DateTimeOffset" /> obiektu, wyrażony jako wartość całkowitą od 0 do 59.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.Second%2A> Właściwość nie ma wpływu na wartość <xref:System.DateTimeOffset.Offset%2A> właściwości.  
  
 Można również utworzyć reprezentację ciągu <xref:System.DateTimeOffset> drugi składnik obiektu przez wywołanie metody <xref:System.DateTimeOffset.ToString%2A> metody "s" lub "ss" specyfikatorów formatu niestandardowego.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono drugim składnikiem <xref:System.DateTimeOffset> obiektu na trzy sposoby:  
  
-   Pobierając zaletą <xref:System.DateTimeOffset.Second%2A> właściwości.  
  
-   Wywołując <xref:System.DateTimeOffset.ToString%28System.String%29> metody z specyfikator formatu "s".  
  
-   Wywołując <xref:System.DateTimeOffset.ToString%28System.String%29> specyfikatorze formatu metody "ss".  
  
 [!code-csharp[System.DateTimeOffset.Properties#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/cs/Properties.cs#14)]
 [!code-vb[System.DateTimeOffset.Properties#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/vb/Properties.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odejmuje określonych godzinach lub czasu trwania z bieżącego <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public TimeSpan Subtract (DateTimeOffset value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.TimeSpan Subtract(valuetype System.DateTimeOffset value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.Subtract(System.DateTimeOffset)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract (value As DateTimeOffset) As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TimeSpan Subtract(DateTimeOffset value);" />
      <MemberSignature Language="F#" Value="member this.Subtract : DateTimeOffset -&gt; TimeSpan" Usage="dateTimeOffset.Subtract value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt reprezentujący wartość do odjęcia.</param>
        <summary>Odejmuje <see cref="T:System.DateTimeOffset" /> wartość reprezentującą określoną datę i godzinę z bieżącego <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <returns>Obiekt, który określa interwał między tymi dwoma <see cref="T:System.DateTimeOffset" /> obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda konwertuje zarówno <xref:System.DateTimeOffset> obiektów uniwersalny czas koordynowany (UTC) przed obliczeniem przedział czasu, która oddziela je. Spowoduje to usunięcie wszelkich wpływ, jaki mają różne przesunięcia od czasu UTC na porównania.  
  
> [!NOTE]
>  Dla języków, które obsługuje niestandardowe operatorów można również wykonywać za pomocą operator odejmowania odejmowania daty i godziny. Aby uzyskać więcej informacji, zobacz <xref:System.DateTimeOffset.op_Subtraction%2A> metody.  
  
 Ponieważ ani bieżącego <xref:System.DateTimeOffset> obiektu ani `value` parametr reprezentować daty i godziny w określonej strefy czasowej, <xref:System.DateTimeOffset.Subtract%28System.DateTimeOffset%29> — metoda nie należy wziąć pod uwagę daną strefę czasową dostosowania reguł podczas jego odejmuje daty i godziny.  
  
   
  
## Examples  
 Poniższy przykład przedstawia odejmowania, która używa <xref:System.DateTimeOffset.Subtract%28System.DateTimeOffset%29> metody.  
  
 [!code-csharp[System.DateTimeOffset.Methods#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/cs/Methods.cs#13)]
 [!code-vb[System.DateTimeOffset.Methods#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/vb/Methods.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public DateTimeOffset Subtract (TimeSpan value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset Subtract(valuetype System.TimeSpan value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.Subtract(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract (value As TimeSpan) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset Subtract(TimeSpan value);" />
      <MemberSignature Language="F#" Value="member this.Subtract : TimeSpan -&gt; DateTimeOffset" Usage="dateTimeOffset.Subtract value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="value">Interwał czasu, który należy odjąć.</param>
        <summary>Odejmuje określony interwał z bieżącego <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <returns>Obiekt, który jest taki sam, Data i czas reprezentowany przez bieżący <see cref="T:System.DateTimeOffset" /> obiektu minus czas reprezentowany przez <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć <xref:System.DateTimeOffset.Subtract%2A> metody do odjęcia więcej niż jednego rodzaju interwału czasu (dni, godziny, minuty, sekundy lub milisekund) w ramach jednej operacji. Jego zachowanie jest takie same jak <xref:System.DateTimeOffset.op_Subtraction%28System.DateTimeOffset%2CSystem.TimeSpan%29> metodę, która definiuje operator odejmowania. <xref:System.DateTimeOffset> Struktury obsługuje również metody dodawania specjalne (takie jak <xref:System.DateTimeOffset.AddDays%2A>, <xref:System.DateTimeOffset.AddHours%2A>, i <xref:System.DateTimeOffset.AddMinutes%2A>) umożliwiające wykonywanie odejmowania przypisując ujemnej wartości do parametru metody.  
  
> [!NOTE]
>  Ta metoda zwraca nową <xref:System.DateTimeOffset> obiektu. Nie modyfikuje wartość bieżącego obiektu przez dodanie `timeSpan` do jego daty i godziny.  
  
 <xref:System.DateTimeOffset.Subtract%2A> — Metoda nie ma wpływu na wartość <xref:System.DateTimeOffset> obiektu <xref:System.DateTimeOffset.Offset%2A> właściwości. Zwrócona <xref:System.DateTimeOffset> obiekt ma tego samego przesunięcie do oryginalnego obiektu.  
  
 Ponieważ bieżącego <xref:System.DateTimeOffset> obiekt nie reprezentuje datę i godzinę w określonej strefy czasowej, <xref:System.DateTimeOffset.Subtract%28System.TimeSpan%29> — metoda nie należy wziąć pod uwagę daną strefę czasową dostosowania reguł podczas wykonywania odejmowania.  
  
   
  
## Examples  
 Poniższy przykład przedstawia odejmowania, która używa <xref:System.DateTimeOffset.Subtract%2A> metody.  
  
 [!code-csharp[System.DateTimeOffset.Methods#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/cs/Methods.cs#14)]
 [!code-vb[System.DateTimeOffset.Methods#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/vb/Methods.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest mniejsza niż <see cref="F:System.DateTimeOffset.MinValue" />.  - lub - powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> wartość jest większa niż <see cref="F:System.DateTimeOffset.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z bieżącym <see cref="T:System.DateTimeOffset" /> obiektu.</param>
        <summary>Porównuje bieżącą wartość <see cref="T:System.DateTimeOffset" /> obiekt z innym obiektem tego samego typu.</summary>
        <returns>32-bitowe liczby całkowite ze znakiem wskazuje, czy bieżący <see cref="T:System.DateTimeOffset" /> obiekt jest mniejszy, równy lub większy niż <paramref name="obj" />. W następujący sposób interpretowania wartości zwracanych metody: <list type="table"><listheader><term> zwrócić wartość </term><description> opis </description></listheader><item><term> mniej niż zero  </term><description> Bieżącego <see cref="T:System.DateTimeOffset" /> obiekt jest mniejszy niż (starsze niż) <paramref name="obj" />.  </description></item><item><term> Zero </term><description> bieżącego <see cref="T:System.DateTimeOffset" /> obiekt jest taki sam (tego samego punktu w czasie, gdy) <paramref name="obj" />.  </description></item><item><term> Większa od zera </term><description> bieżącego <see cref="T:System.DateTimeOffset" /> obiekt jest większy niż (później niż) <paramref name="obj" />.  </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.IDeserializationCallback.OnDeserialization">
      <MemberSignature Language="C#" Value="void IDeserializationCallback.OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDeserialization (sender As Object) Implements IDeserializationCallback.OnDeserialization" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System::Object ^ sender) = System::Runtime::Serialization::IDeserializationCallback::OnDeserialization;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">Obiekt, który zainicjował wywołanie zwrotne. Funkcje tego parametru nie są obecnie implementowane.</param>
        <summary>Uruchamia się po zakończeniu deserializacji obiektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Obiekt używany do wypełniania danymi.</param>
        <param name="context">Lokalizacja docelowa tej serializacji (zobacz <see cref="T:System.Runtime.Serialization.StreamingContext" />).</param>
        <summary>Wypełnia <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiektu przy użyciu danych wymaganych do zserializowania bieżącego <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> Parametr jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Ticks">
      <MemberSignature Language="C#" Value="public long Ticks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Ticks" />
      <MemberSignature Language="DocId" Value="P:System.DateTimeOffset.Ticks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Ticks As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Ticks { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Ticks : int64" Usage="System.DateTimeOffset.Ticks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ich liczba reprezentująca datę i godzinę bieżącego <see cref="T:System.DateTimeOffset" /> obiektu w zegarze.</summary>
        <value>Liczbę znaczników w <see cref="T:System.DateTimeOffset" /> czasu zegara obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.Ticks%2A> Właściwość nie ma wpływu na wartość <xref:System.DateTimeOffset.Offset%2A> właściwości.  
  
 Wartość <xref:System.DateTimeOffset.Ticks%2A> właściwość reprezentuje liczbę 100-nanosekundowych interwałów, które upłynęły od północy 12:00:00 w dniu 1 stycznia 0001 (wartość <xref:System.DateTimeOffset.MinValue>). Nie ma Takty dodanych sekund przestępnym. Nanosekundowych jest billionth jednej sekundy; Brak dziesięć milionów impulsów na sekundę. Wartość <xref:System.DateTimeOffset.Ticks%2A> właściwości zakresów z `DateTimeOffset.MinValue.Ticks` do `DateTimeOffset.MaxValue.Ticks`.  
  
 Można przypisać liczbę taktów do <xref:System.DateTimeOffset> obiektu przy użyciu <xref:System.DateTimeOffset.%23ctor%28System.Int64%2CSystem.TimeSpan%29> przeładowania konstruktora.  
  
   
  
## Examples  
 W poniższym przykładzie inicjowane <xref:System.DateTimeOffset> obiektu poprzez zbliżenie liczbę taktów daty 1 lipca 2008 1:23:07. Następnie wyświetla datę i ich liczba reprezentowany przez tą datą do konsoli.  
  
 [!code-csharp[System.DateTimeOffset.Properties#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/cs/Properties.cs#15)]
 [!code-vb[System.DateTimeOffset.Properties#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/vb/Properties.vb#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.DateTimeOffset.UtcDateTime" />
      </Docs>
    </Member>
    <Member MemberName="TimeOfDay">
      <MemberSignature Language="C#" Value="public TimeSpan TimeOfDay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeOfDay" />
      <MemberSignature Language="DocId" Value="P:System.DateTimeOffset.TimeOfDay" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeOfDay As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeOfDay { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TimeOfDay : TimeSpan" Usage="System.DateTimeOffset.TimeOfDay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera godzinę dla bieżącego <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <value>Przedział czasu dla bieżącej daty, który upłynął od północy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.TimeOfDay%2A> Właściwość nie ma wpływu na wartość <xref:System.DateTimeOffset.Offset%2A> właściwości.  
  
 <xref:System.DateTimeOffset.TimeOfDay%2A> Właściwość zwraca składnik godziny <xref:System.DateTimeOffset> obiektu w postaci <xref:System.TimeSpan> obiektu. Jest to równoważne <xref:System.DateTime.TimeOfDay%2A?displayProperty=nameWithType> właściwości.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTimeOffset.TimeOfDay%2A> właściwość, aby wyodrębnić czasu i wyświetl ją do konsoli.  
  
 [!code-csharp[System.DateTimeOffset.Properties#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/cs/Properties.cs#16)]
 [!code-vb[System.DateTimeOffset.Properties#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/vb/Properties.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToFileTime">
      <MemberSignature Language="C#" Value="public long ToFileTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ToFileTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.ToFileTime" />
      <MemberSignature Language="VB.NET" Value="Public Function ToFileTime () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long ToFileTime();" />
      <MemberSignature Language="F#" Value="member this.ToFileTime : unit -&gt; int64" Usage="dateTimeOffset.ToFileTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącej <see cref="T:System.DateTimeOffset" /> obiektu do czasu pliku systemu Windows.</summary>
        <returns>Wartość bieżącego <see cref="T:System.DateTimeOffset" /> obiektu wyrażona jako czas plików systemu Windows.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czas pliku systemu Windows ma wartość 64-bitową. Reprezentuje ona liczbę 100-nanosekundowych przedziałów czasu, które upłynęły od północy 1 stycznia 1601 roku n.e. (C.E.) Uniwersalny czas koordynowany (UTC). System Windows wykorzystuje czas pliku do rejestrowania informacji o tym, kiedy aplikacja tworzy, uzyskuje dostęp do zapisuje do pliku.  
  
 <xref:System.DateTimeOffset.ToFileTime%2A> Metoda Konwertuje bieżący <xref:System.DateTimeOffset> Data i Godzina UTC przed rozpoczęciem konwersji obiektu. Innymi słowy, wywoływania <xref:System.DateTimeOffset.ToFileTime%2A> metoda jest odpowiednikiem następujące wywołanie metody:  
  
```csharp
this.ToUtcDateTime().ToFileTime();  
```  
  
```vb  
Me.ToUtcDateTime().ToFileTime()  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wynikowa czasu pliku będzie reprezentować datę i godzinę przed północy 1 stycznia 1601 r. N.E. Uniwersalny czas koordynowany (UTC).</exception>
        <altmember cref="M:System.DateTimeOffset.FromFileTime(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="ToLocalTime">
      <MemberSignature Language="C#" Value="public DateTimeOffset ToLocalTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset ToLocalTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.ToLocalTime" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLocalTime () As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset ToLocalTime();" />
      <MemberSignature Language="F#" Value="member this.ToLocalTime : unit -&gt; DateTimeOffset" Usage="dateTimeOffset.ToLocalTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje bieżący <see cref="T:System.DateTimeOffset" /> do obiektu <see cref="T:System.DateTimeOffset" /> obiekt, który reprezentuje czas lokalny.</summary>
        <returns>Obiekt reprezentujący datę i godzinę bieżącego <see cref="T:System.DateTimeOffset" /> przekonwertować obiektu na czas lokalny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wykonywanie konwersji na czas lokalny, metoda najpierw konwertuje bieżący <xref:System.DateTimeOffset> Data i godzina uniwersalny czas koordynowany (UTC) przez odjęcie przesunięcie od chwili obiektu. Następnie konwertuje Data i Godzina UTC na czas lokalny przez dodanie przesunięcia strefy czasu lokalnego. W ten sposób uwzględnia wszystkie reguły korekty w lokalnej strefie czasowej.  
  
 Wartość bieżącego <xref:System.DateTimeOffset> obiektu i wartość <xref:System.DateTimeOffset> obiektu zwróconego przez wywołanie metody reprezentują tego samego punktu w czasie. Oznacza to jeśli obie są przekazywane do <xref:System.DateTimeOffset.Equals%28System.DateTimeOffset%2CSystem.DateTimeOffset%29?displayProperty=nameWithType> metody, metoda zwróci `true`.  
  
 Jeśli konwersja powoduje, że czas, który jest poza zakresem <xref:System.DateTimeOffset> typu <xref:System.DateTimeOffset.ToLocalTime%2A> metoda zwraca <xref:System.DateTimeOffset> obiektu, który ma Data i godzina ustawiona jako <xref:System.DateTimeOffset.MaxValue> lub <xref:System.DateTimeOffset.MinValue> i Przesunięcie wartość przesunięcia lokalnej strefy czasowej.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTimeOffset.ToLocalTime%2A> metodę, aby przekonwertować <xref:System.DateTimeOffset> wartość na czas lokalny w pacyficzny standardowa strefy czasowej. Również dwie metody obsługę reguł korygowania strefy czasu lokalnego.  
  
 [!code-csharp[System.DateTimeOffset.Methods#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/cs/Methods.cs#15)]
 [!code-vb[System.DateTimeOffset.Methods#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/vb/Methods.vb#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTimeOffset.ToUniversalTime" />
      </Docs>
    </Member>
    <Member MemberName="ToOffset">
      <MemberSignature Language="C#" Value="public DateTimeOffset ToOffset (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset ToOffset(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.ToOffset(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToOffset (offset As TimeSpan) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset ToOffset(TimeSpan offset);" />
      <MemberSignature Language="F#" Value="member this.ToOffset : TimeSpan -&gt; DateTimeOffset" Usage="dateTimeOffset.ToOffset offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Przesunięcie można przekonwertować <see cref="T:System.DateTimeOffset" /> do wartości.</param>
        <summary>Konwertuje wartość bieżącej <see cref="T:System.DateTimeOffset" /> obiektu datę i godzinę, określonym przez wartość przesunięcia.</summary>
        <returns>Obiekt, który jest taki sam, jak oryginalna <see cref="T:System.DateTimeOffset" /> obiektu (to znaczy ich <see cref="M:System.DateTimeOffset.ToUniversalTime" /> metody zwracają identyczne punkty w czasie), ale których <see cref="P:System.DateTimeOffset.Offset" /> właściwość jest ustawiona na <paramref name="offset" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.ToOffset%2A> Metody stanowi alternatywę dla wywołania <xref:System.TimeZoneInfo.ConvertTime%28System.DateTimeOffset%2CSystem.TimeZoneInfo%29?displayProperty=nameWithType> metody. Może być przydatne do wykonywania prostych konwersji między strefami czasowymi do innego, gdy wiadomo, przesunięć stref czasowych z uniwersalnego czasu koordynowanego (UTC). Jednak ponieważ ani oryginalny <xref:System.DateTimeOffset> obiektu ani nowe <xref:System.DateTimeOffset> obiektu zwróconego przez wywołanie metody są jednoznacznie powiązane z daną strefę czasową, metoda nie obejmuje żadnych reguł korygowania strefę czasową w konwersji.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób użycia <xref:System.DateTimeOffset.ToOffset%2A> metodę, aby przekonwertować <xref:System.DateTimeOffset> do obiektu <xref:System.DateTimeOffset> obiekt z inną przesunięcie.  
  
 [!code-csharp[System.DateTimeOffset.ToOffset#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.ToOffset/cs/ToOffset.cs#1)]
 [!code-vb[System.DateTimeOffset.ToOffset#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.ToOffset/vb/ToOffset.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> obiekt ma <see cref="P:System.DateTimeOffset.DateTime" /> wartość wcześniejszy niż <see cref="F:System.DateTimeOffset.MinValue" />.  - lub - powstałe w ten sposób <see cref="T:System.DateTimeOffset" /> obiekt ma <see cref="P:System.DateTimeOffset.DateTime" /> wartość później niż <see cref="F:System.DateTimeOffset.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> jest mniejsza niż-14 godzin.  - lub - <paramref name="offset" /> przekracza 14 godzin.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość bieżącej <see cref="T:System.DateTimeOffset" /> obiekt do reprezentacji ciągu równoważne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dateTimeOffset.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość bieżącej <see cref="T:System.DateTimeOffset" /> obiekt do reprezentacji ciągu równoważne.</summary>
        <returns>Reprezentacja ciągu <see cref="T:System.DateTimeOffset" /> obiekt, który obejmuje przesunięcie dołączany na końcu ciągu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana tej metody jest identyczna ze <xref:System.DateTime.ToString?displayProperty=nameWithType> metody, z wyjątkiem, że zawiera spację następuje przesunięcie dołączany na końcu ciągu. Innymi słowy, formatowania danych wyjściowych za pomocą wzorzec krótkiej daty wzorzec dużo czasu i `zzz` niestandardowy ciąg formatu, z każdym elementem oddzielona od poprzedniego elementu spację. Na przykład jeśli <xref:System.DateTime.ToString?displayProperty=nameWithType> zwraca wartość 1-12-2008 18:15:50: 00, <xref:System.DateTimeOffset.ToString> zwraca wartość 1-12-2008 18:15:50: 00 -08:00 czasu, która jest osiem godzin za uniwersalny czas koordynowany (UTC).  
  
 Metoda ta wykorzystuje informacje o formatowaniu pochodzące z bieżącej kultury. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.CultureInfo.CurrentCulture%2A>. Inne przeciążenia <xref:System.DateTimeOffset.ToString%2A> metody umożliwiają określenie kultury którego formatowanie do użycia oraz do definiowania struktury danych wyjściowych <xref:System.DateTimeOffset> wartość.  
  
   
  
## Examples  
 Poniższy przykład przedstawia wywołań <xref:System.DateTimeOffset.ToString> — metoda i wyświetla dane wyjściowe w systemie, w których bieżącej kultury jest en-us.  
  
 [!code-csharp[System.DateTimeOffset.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.ToString/cs/ToString.cs#1)]
 [!code-vb[System.DateTimeOffset.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.ToString/vb/ToString.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Data i godzina jest poza zakresem dat obsługiwanym przez kalendarz używany przez bieżącą kulturę.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.DateTimeOffset.ToString" /> Metoda zwraca reprezentację ciągu daty i godziny w kalendarzu używane przez bieżącej kultury. Jeśli wartość bieżącej klasy <see cref="T:System.DateTimeOffset" /> wystąpienia jest starsza niż <see cref="P:System.Globalization.Calendar.MinSupportedDateTime" /> lub nowszej niż <see cref="P:System.Globalization.Calendar.MaxSupportedDateTime" />, metoda wygeneruje <see cref="T:System.ArgumentOutOfRangeException" />. Poniższy przykład stanowi ilustrację. Próbuje formatowania daty, która jest poza zakresem <see cref="T:System.Globalization.HijriCalendar" /> klasy po bieżącej kultury arabski (Syria).  [! kodu języka csharp [System.DateTimeOffset.ToString.ArgumentOutOfRangeException#2] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetimeoffset.tostring.argumentoutofrangeexception/cs/ datetimeoffset.toString.argumentoutofrangeexception2.CS#2)] [! kodu języka vb [System.DateTimeOffset.ToString.ArgumentOutOfRangeException#2] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/ System.datetimeoffset.toString.argumentoutofrangeexception/VB/datetimeoffset.toString.argumentoutofrangeexception2.VB#2)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider formatProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider formatProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (formatProvider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ formatProvider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="dateTimeOffset.ToString formatProvider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="formatProvider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="formatProvider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość bieżącej <see cref="T:System.DateTimeOffset" /> obiekt do reprezentacji ciągu równoważne, przy użyciu określonego formatowania informacje specyficzne dla kultury.</summary>
        <returns>Reprezentacja ciągu wartości bieżącego <see cref="T:System.DateTimeOffset" /> obiekt określony przez <paramref name="formatProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana tej metody jest identyczna jak jego odpowiednik przeciążenia <xref:System.DateTime.ToString%2A?displayProperty=nameWithType> metody, z wyjątkiem, że zawiera spację następuje przesunięcie dołączany na końcu ciągu. Innymi słowy, formatowania danych wyjściowych za pomocą wzorzec krótkiej daty wzorzec dużo czasu i `zzz` niestandardowy ciąg formatu, z każdym elementem oddzielona od poprzedniego elementu spację.  
  
 Format tych trzech elementów jest zdefiniowany przez `formatProvider` parametru. `formatProvider` Parametr może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury, na których Konwencji formatowania są stosowane do zwracany ciąg. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez <xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> definiuje właściwości formatowania zwracany ciąg.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format daty i godziny.  
  
 Jeśli `formatProvider` jest `null`, <xref:System.Globalization.DateTimeFormatInfo> jest używany obiekt skojarzony z bieżącej kultury (zobacz <xref:System.Globalization.CultureInfo.CurrentCulture%2A>).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono <xref:System.DateTimeOffset> przy użyciu <xref:System.Globalization.CultureInfo> obiektów, które reprezentują Niezmienna kultura, a także czterech innych kultur.  
  
 [!code-csharp[System.DateTimeOffset.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.ToString/cs/ToString.cs#2)]
 [!code-vb[System.DateTimeOffset.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.ToString/vb/ToString.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Data i godzina jest spoza zakresu dat obsługiwana przez używany kalendarz przez <paramref name="formatProvider" />.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.DateTimeOffset.ToString(System.IFormatProvider)" /> Metoda zwraca reprezentację ciągu daty i godziny w kalendarzu używane przez kultury reprezentowany przez <paramref name="formatProvider" /> parametru. Jego kalendarza jest definiowana za pomocą <see cref="P:System.Globalization.DateTimeFormatInfo.Calendar" /> właściwości. Jeśli wartość bieżącej klasy <see cref="T:System.DateTimeOffset" /> wystąpienia jest starsza niż <see cref="P:System.Globalization.Calendar.MinSupportedDateTime" /> lub nowszej niż <see cref="P:System.Globalization.Calendar.MaxSupportedDateTime" />, metoda wygeneruje <see cref="T:System.ArgumentOutOfRangeException" />. Poniższy przykład stanowi ilustrację. Próbuje formatowania daty, która jest poza zakresem <see cref="T:System.Globalization.JapaneseCalendar" /> klasy.  [! kodu języka csharp [System.DateTimeOffset.ToString.ArgumentOutOfRangeException#1] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetimeoffset.tostring.argumentoutofrangeexception/cs/ datetimeoffset.toString.argumentoutofrangeexception1.CS#1)] [! kodu języka vb [System.DateTimeOffset.ToString.ArgumentOutOfRangeException#1] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/ System.datetimeoffset.toString.argumentoutofrangeexception/VB/datetimeoffset.toString.argumentoutofrangeexception1.VB#1)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="dateTimeOffset.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu.</param>
        <summary>Konwertuje wartość bieżącej <see cref="T:System.DateTimeOffset" /> obiektu do jego odpowiednik reprezentację w określonym formacie.</summary>
        <returns>Reprezentacja ciągu wartości bieżącego <see cref="T:System.DateTimeOffset" /> obiekt określony przez <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `format` Parametr powinien zawierać albo znak specyfikator formatu pojedynczego (zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md)) lub wzorzec formatu niestandardowego (zobacz [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md) ) definiuje format zwracany ciąg. Jeśli `format` jest zerowy lub pusty ciąg (""), <xref:System.DateTimeOffset> wartości wyjściowych przy użyciu domyślnego formatu.  
  
 W poniższej tabeli przedstawiono dokładne funkcjonowania niektórych specyfikatory formatu w przypadku użycia z <xref:System.DateTimeOffset>, który różni się od ich zachowania, gdy jest używany z <xref:System.DateTime>.  
  
|Istniejące specyfikator formatu|Nowe zachowanie|  
|-------------------------------|------------------|  
|„K”|Przeznaczony do przesyłania danych daty i godziny. Z <xref:System.DateTimeOffset>, mapuje "zzz" (przesunięcie jest zawsze wyświetlany z godzinach i minutach). Należy pamiętać, że "K" specyfikatora formatu niestandardowego; nie może występować jako pojedynczy znak `format`.|  
|„U”|Nieobsługiwane.|  
|"r"|Konwertuje <xref:System.DateTimeOffset> obiektu uniwersalny czas koordynowany (UTC) i wyświetla go za pomocą niestandardowy ciąg formatu `ddd, dd MMM yyyy HH:mm:ss GMT`.|  
|„u”|Konwertuje <xref:System.DateTimeOffset> object UTC i wyświetla go w formacie `yyyy-MM-dd HH:mm:ssZ`.|  
  
 Pozostałe standardowa Data i godzina specyfikatory formatu działają w ten sam z <xref:System.DateTimeOffset.ToString%28System.String%29> metodę jak w <xref:System.DateTime.ToString%2A> — metoda.  
  
 Metoda ta wykorzystuje informacje o formatowaniu pochodzące z bieżącej kultury. Aby uzyskać więcej informacji, zobacz <xref:System.Globalization.CultureInfo.CurrentCulture%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono <xref:System.DateTimeOffset> obiektu w konsoli przy użyciu standardowa Data i godzina specyfikatory formatu. Wynik jest formatowany przy użyciu en-us kultury.  
  
 [!code-csharp[System.DateTimeOffset.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.ToString/cs/ToString.cs#3)]
 [!code-vb[System.DateTimeOffset.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.ToString/vb/ToString.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Długość <paramref name="format" /> jest jednym z nich, i nie jest jednym z znaki specyfikatora formatu standardowych zdefiniowane dla <see cref="T:System.Globalization.DateTimeFormatInfo" />.  - lub - <paramref name="format" /> nie zawiera wzorca prawidłowy format niestandardowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Data i godzina jest poza zakresem dat obsługiwanym przez kalendarz używany przez bieżącą kulturę.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.DateTimeOffset.ToString(System.String)" /> Metoda zwraca reprezentację ciągu daty i godziny w kalendarzu używane przez bieżącej kultury. Jeśli wartość bieżącej klasy <see cref="T:System.DateTimeOffset" /> wystąpienia jest starsza niż <see cref="P:System.Globalization.Calendar.MinSupportedDateTime" /> lub nowszej niż <see cref="P:System.Globalization.Calendar.MaxSupportedDateTime" />, metoda wygeneruje <see cref="T:System.ArgumentOutOfRangeException" />. Poniższy przykład stanowi ilustrację. Próbuje formatowania daty, która jest poza zakresem <see cref="T:System.Globalization.HebrewCalendar" /> klasy po bieżącej kultury hebrajski (Izrael).  [! kodu języka csharp [System.DateTimeOffset.ToString.ArgumentOutOfRangeException#3] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetimeoffset.tostring.argumentoutofrangeexception/cs/ datetimeoffset.toString.argumentoutofrangeexception3.CS#3)] [! kodu języka vb [System.DateTimeOffset.ToString.ArgumentOutOfRangeException#3] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/ System.datetimeoffset.toString.argumentoutofrangeexception/VB/datetimeoffset.toString.argumentoutofrangeexception3.VB#3)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider formatProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider formatProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, formatProvider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ formatProvider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="dateTimeOffset.ToString (format, formatProvider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="formatProvider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu.</param>
        <param name="formatProvider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <summary>Konwertuje wartość bieżącej <see cref="T:System.DateTimeOffset" /> obiekt do reprezentacji ciągu równoważne, używając określonego formatu i informacji o formacie specyficzne dla kultury.</summary>
        <returns>Reprezentacja ciągu wartości bieżącego <see cref="T:System.DateTimeOffset" /> obiekt określony przez <paramref name="format" /> i <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `format` Parametr powinien zawierać albo znak specyfikator formatu pojedynczego (zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md)) lub wzorzec formatu niestandardowego (zobacz [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md) ). Jeśli `format` jest zerowy lub pusty ciąg (""), <xref:System.DateTimeOffset> obiektu jest wyprowadzana przy użyciu domyślnego formatu.  
  
 W poniższej tabeli przedstawiono dokładne funkcjonowania niektórych specyfikatory formatu w przypadku użycia z <xref:System.DateTimeOffset>, który różni się od ich zachowania, gdy jest używany z <xref:System.DateTime>.  
  
|Istniejące specyfikator formatu|Nowe zachowanie|  
|-------------------------------|------------------|  
|„K”|Przeznaczony do przesyłania danych daty i godziny. Z <xref:System.DateTimeOffset>, mapuje "zzz" (przesunięcie jest zawsze wyświetlany z godzinach i minutach). Należy pamiętać, że "K" specyfikatora formatu niestandardowego; nie może występować jako pojedynczy znak `format`.|  
|„U”|Nieobsługiwane.|  
|"r"|Konwertuje <xref:System.DateTimeOffset> obiektu uniwersalny czas koordynowany (UTC) i wyświetla go za pomocą niestandardowy ciąg formatu `ddd, dd MMM yyyy HH:mm:ss GMT`.|  
|„u”|Konwertuje <xref:System.DateTimeOffset> wartości UTC i wyświetla go w formacie `yyyy-MM-dd HH:mm:ssZ`.|  
  
 Pozostałe standardowa Data i godzina specyfikatory formatu działają w ten sam z <xref:System.DateTimeOffset.ToString%28System.String%29> metodę jak w <xref:System.DateTime.ToString%2A> — metoda.  
  
 Wzorzec, który odpowiada specyfikatory standardowym formacie, a także symbole i nazw składników datę i godzinę, jest definiowana za pomocą `formatProvider` parametru. `formatProvider` Parametr może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury, którego formatowanie jest używany w `input`. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez <xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> definiuje właściwości formatowania użytego w `input`.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format daty i godziny.  
  
 Jeśli `formatProvider` jest `null`, <xref:System.Globalization.DateTimeFormatInfo> jest używany obiekt skojarzony z bieżącej kultury (zobacz <xref:System.Globalization.CultureInfo.CurrentCulture%2A>).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTimeOffset.ToString%28System.String%2CSystem.IFormatProvider%29> metodę w celu wyświetlenia <xref:System.DateTimeOffset> przy użyciu ciągu formatu niestandardowego dla kilku różnych kultur.  
  
 [!code-csharp[System.DateTimeOffset.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.ToString/cs/ToString.cs#4)]
 [!code-vb[System.DateTimeOffset.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.ToString/vb/ToString.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Długość <paramref name="format" /> jest jednym z nich, i nie jest jednym z znaki specyfikatora formatu standardowych zdefiniowane dla <see cref="T:System.Globalization.DateTimeFormatInfo" />.  - lub - <paramref name="format" /> nie zawiera wzorca prawidłowy format niestandardowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Data i godzina jest spoza zakresu dat obsługiwana przez używany kalendarz przez <paramref name="formatProvider" />.</exception>
        <block subset="none" type="usage">
          <para>
            <see cref="M:System.DateTimeOffset.ToString(System.String,System.IFormatProvider)" /> Metoda zwraca reprezentację ciągu daty i godziny w kalendarzu używane przez <paramref name="formatProvider" /> parametru. Jego kalendarza jest definiowana za pomocą <see cref="P:System.Globalization.DateTimeFormatInfo.Calendar" /> właściwości. Jeśli wartość bieżącej klasy <see cref="T:System.DateTimeOffset" /> wystąpienia jest starsza niż <see cref="P:System.Globalization.Calendar.MinSupportedDateTime" /> lub nowszej niż <see cref="P:System.Globalization.Calendar.MaxSupportedDateTime" />, metoda wygeneruje <see cref="T:System.ArgumentOutOfRangeException" />. Poniższy przykład stanowi ilustrację. Próbuje formatowania daty, która jest poza zakresem <see cref="T:System.Globalization.UmAlQuraCalendar" /> klasy.  [! kodu języka csharp [System.DateTimeOffset.ToString.ArgumentOutOfRangeException#4] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetimeoffset.tostring.argumentoutofrangeexception/cs/ datetimeoffset.toString.argumentoutofrangeexception4.CS#4)] [! kodu języka vb [System.DateTimeOffset.ToString.ArgumentOutOfRangeException#4] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/ System.datetimeoffset.toString.argumentoutofrangeexception/VB/datetimeoffset.toString.argumentoutofrangeexception4.VB#4)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ToUniversalTime">
      <MemberSignature Language="C#" Value="public DateTimeOffset ToUniversalTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset ToUniversalTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.ToUniversalTime" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUniversalTime () As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset ToUniversalTime();" />
      <MemberSignature Language="F#" Value="member this.ToUniversalTime : unit -&gt; DateTimeOffset" Usage="dateTimeOffset.ToUniversalTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje bieżący <see cref="T:System.DateTimeOffset" /> do obiektu <see cref="T:System.DateTimeOffset" /> wartość, która reprezentuje uniwersalny czas koordynowany (UTC).</summary>
        <returns>Obiekt reprezentujący datę i godzinę bieżącego <see cref="T:System.DateTimeOffset" /> przekonwertować obiektu uniwersalny czas koordynowany (UTC).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca <xref:System.DateTimeOffset> którego <xref:System.DateTimeOffset.Offset%2A> wartość właściwości jest równa zero.  
  
 Wartość bieżącego <xref:System.DateTimeOffset> obiektu i wartość <xref:System.DateTimeOffset> obiektu zwróconego przez wywołanie metody reprezentują tego samego punktu w czasie. Oznacza to jeśli obie są przekazywane do <xref:System.DateTimeOffset.Equals%28System.DateTimeOffset%2CSystem.DateTimeOffset%29?displayProperty=nameWithType> metody, metoda zwróci `true`.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.DateTimeOffset.ToUniversalTime%2A> metodę, aby przekonwertować czasem lokalnym i kilka innych razy uniwersalny czas koordynowany (UTC).  
  
 [!code-csharp[System.DateTimeOffset.Methods#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/cs/Methods.cs#16)]
 [!code-vb[System.DateTimeOffset.Methods#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Methods/vb/Methods.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTimeOffset.ToLocalTime" />
        <altmember cref="M:System.DateTimeOffset.ToOffset(System.TimeSpan)" />
      </Docs>
    </Member>
    <Member MemberName="ToUnixTimeMilliseconds">
      <MemberSignature Language="C#" Value="public long ToUnixTimeMilliseconds ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ToUnixTimeMilliseconds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.ToUnixTimeMilliseconds" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUnixTimeMilliseconds () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long ToUnixTimeMilliseconds();" />
      <MemberSignature Language="F#" Value="member this.ToUnixTimeMilliseconds : unit -&gt; int64" Usage="dateTimeOffset.ToUnixTimeMilliseconds " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca liczbę milisekund, które upłynęły od 1970-01-01T00:00:00.000Z.</summary>
        <returns>Liczba milisekund, które upłynęły od 1970-01-01T00:00:00.000Z.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czas UNIX reprezentuje liczbę sekund, które upłynęły od 1970-01-01T00:00:00Z (1 stycznia 1970 roku w UTC 00:00:00). Go nie uwzględniać sekund przestępnym. Ta metoda zwraca liczbę milisekund w czasie systemu Unix.  
  
 Ta metoda konwertuje najpierw bieżącego wystąpienia UTC przed zwróceniem wyrażony w milisekundach czas, w czasie jego Unix. Dla wartości daty i godziny przed rokiem 1970-01-01T00:00:00Z, ta metoda zwraca wartość ujemną.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTimeOffset.ToUnixTimeSeconds" />
        <altmember cref="M:System.DateTimeOffset.FromUnixTimeMilliseconds(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="ToUnixTimeSeconds">
      <MemberSignature Language="C#" Value="public long ToUnixTimeSeconds ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ToUnixTimeSeconds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.ToUnixTimeSeconds" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUnixTimeSeconds () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long ToUnixTimeSeconds();" />
      <MemberSignature Language="F#" Value="member this.ToUnixTimeSeconds : unit -&gt; int64" Usage="dateTimeOffset.ToUnixTimeSeconds " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca liczbę sekund, które upłynęły od 1970-01-01T00:00:00Z.</summary>
        <returns>Liczba sekund, które upłynęły od 1970-01-01T00:00:00Z.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czas UNIX reprezentuje liczbę sekund, które upłynęły od 1970-01-01T00:00:00Z (1 stycznia 1970 roku w UTC 00:00:00). Go nie uwzględniać sekund przestępnym.  
  
 Ta metoda konwertuje najpierw bieżącego wystąpienia UTC przed zwróceniem jej czas systemu Unix. Dla wartości daty i godziny przed rokiem 1970-01-01T00:00:00Z, ta metoda zwraca wartość ujemną.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.DateTimeOffset.ToUnixTimeSeconds%2A> metodę, aby zwrócić czasu Unix wartości, które są równe, tuż przed i wkrótce po 1970-01-01T00:00:00Z.  
  
 [!code-csharp[System.DateTimeOffset.ToUnixTimeSeconds#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.datetimeoffset.tounixtimeseconds/cs/tounixtimeseconds1.cs#1)]
 [!code-vb[System.DateTimeOffset.ToUnixTimeSeconds#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.datetimeoffset.tounixtimeseconds/vb/tounixtimeseconds1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.DateTimeOffset.FromUnixTimeSeconds(System.Int64)" />
        <altmember cref="M:System.DateTimeOffset.ToUnixTimeMilliseconds" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider formatProvider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider formatProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional formatProvider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="dateTimeOffset.TryFormat (destination, charsWritten, format, formatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="formatProvider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="formatProvider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTimeOffset" /> równoważne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; input, out DateTimeOffset result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; input, [out] valuetype System.DateTimeOffset&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.TryParse(System.ReadOnlySpan{System.Char},System.DateTimeOffset@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (input As ReadOnlySpan(Of Char), ByRef result As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; input, [Runtime::InteropServices::Out] DateTimeOffset % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.DateTimeOffset.TryParse (input, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.DateTimeOffset&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string input, out DateTimeOffset result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string input, [out] valuetype System.DateTimeOffset&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.TryParse(System.String,System.DateTimeOffset@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (input As String, ByRef result As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ input, [Runtime::InteropServices::Out] DateTimeOffset % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.DateTimeOffset.TryParse (input, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="result" Type="System.DateTimeOffset&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg zawierający datę i godzinę, które należy przekształcić.</param>
        <param name="result">Gdy metoda zwróci wartość, zawiera <see cref="T:System.DateTimeOffset" /> odpowiednikiem daty i godziny <c>wejściowych</c>, jeśli konwersja powiodła się, lub <see cref="F:System.DateTimeOffset.MinValue" />, jeśli konwersja nie powiodła się. Konwersja nie powiedzie się, jeśli <c>wejściowych</c> parametr jest <see langword="null" /> lub nie zawiera prawidłową reprezentacją ciągu daty i godziny. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Próbuje konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTimeOffset" /> równoważnej i zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="input" /> parametr jest pomyślnie przekonwertowana; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie metody <xref:System.DateTimeOffset.TryParse%28System.String%2CSystem.DateTimeOffset%40%29> przypomina metody <xref:System.DateTimeOffset.Parse%28System.String%29?displayProperty=nameWithType> metody, z wyjątkiem, że nie zgłosić wyjątek, jeśli konwersja nie powiedzie się. Analizuje ciągu z trzech elementów, które mogą być wyświetlane w dowolnej kolejności i są rozdzielane znakami odstępu. W poniższej tabeli przedstawiono te trzy elementy.  
  
|Element|Przykład|  
|-------------|-------------|  
|\<Data >|"2/10/2007"|  
|\<Time>|"1:02:03 PM"|  
|\<Przesunięcie >|"-7:30"|  
  
 Mimo że każda z tych elementów jest opcjonalny, \<przesunięcie > nie może występować samodzielnie. Należy podać razem albo \<Data > lub \<czasu >. Jeśli \<Data > Brak domyślnej wartości jest bieżącego dnia. Jeśli \<Data > jest obecny, ale jego roku składnik obejmuje tylko dwie cyfry, zostanie przekonwertowane na roku w kalendarzu bieżącego bieżącej kultury, na podstawie wartości z <xref:System.Globalization.Calendar.TwoDigitYearMax%2A?displayProperty=nameWithType> właściwości. Jeśli \<czasu > brakuje jej domyślna wartość to 00:00:00: 00. Jeśli \<przesunięcie > brakuje jej domyślna wartość to przesunięcie w lokalnej strefie czasowej. Jeśli \<przesunięcie > jest obecny, może to oznaczać ujemny lub dodatnią przesunięcie z uniwersalnego czasu koordynowanego (UTC). W obu przypadkach \<przesunięcia > musi zawierać symbol znaku lub metoda zwraca `false`.  
  
 `input` , Korzystając z informacji formatowania w zostanie przeanalizowany ciąg <xref:System.Globalization.DateTimeFormatInfo> obiektu zainicjowany dla bieżącej kultury. Aby przeanalizować ciąg zawierający wyznaczonych formatowania, który nie zawsze odpowiada z bieżącej kultury, użyj <xref:System.DateTimeOffset.TryParseExact%2A> — metoda i podaj specyfikator formatu.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.DateTimeOffset.TryParse%28System.String%2CSystem.DateTimeOffset%40%29> metodę, aby przeanalizować kilka ciągów z różnych formatów daty i godziny.  
  
 [!code-csharp[System.DateTimeOffset.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.TryParse/cs/TryParse.cs#1)]
 [!code-vb[System.DateTimeOffset.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.TryParse/vb/TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.DateTimeOffset.Parse" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; input, IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, out DateTimeOffset result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; input, class System.IFormatProvider formatProvider, valuetype System.Globalization.DateTimeStyles styles, [out] valuetype System.DateTimeOffset&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTimeOffset@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (input As ReadOnlySpan(Of Char), formatProvider As IFormatProvider, styles As DateTimeStyles, ByRef result As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; input, IFormatProvider ^ formatProvider, System::Globalization::DateTimeStyles styles, [Runtime::InteropServices::Out] DateTimeOffset % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTimeOffset.TryParse (input, formatProvider, styles, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="formatProvider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTimeOffset&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">To be added.</param>
        <param name="formatProvider">To be added.</param>
        <param name="styles">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string input, IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, out DateTimeOffset result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string input, class System.IFormatProvider formatProvider, valuetype System.Globalization.DateTimeStyles styles, [out] valuetype System.DateTimeOffset&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.TryParse(System.String,System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTimeOffset@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (input As String, formatProvider As IFormatProvider, styles As DateTimeStyles, ByRef result As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ input, IFormatProvider ^ formatProvider, System::Globalization::DateTimeStyles styles, [Runtime::InteropServices::Out] DateTimeOffset % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTimeOffset.TryParse (input, formatProvider, styles, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="formatProvider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTimeOffset&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg zawierający datę i godzinę, które należy przekształcić.</param>
        <param name="formatProvider">Obiekt, który zawiera informacje dotyczące formatowania specyficzne dla kultury o <c>wejściowych</c>.</param>
        <param name="styles">Bitowe połączenie wartości wyliczenia wskazujących format dozwolonych <c>wejściowych</c>.</param>
        <param name="result">Gdy metoda zwróci wartość, zawiera <see cref="T:System.DateTimeOffset" /> odpowiednikiem daty i godziny wartość <c>wejściowych</c>, jeśli konwersja powiodła się, lub <see cref="F:System.DateTimeOffset.MinValue" />, jeśli konwersja nie powiodła się. Konwersja nie powiedzie się, jeśli <c>wejściowych</c> parametr jest <see langword="null" /> lub nie zawiera prawidłową reprezentacją ciągu daty i godziny. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Próbuje przekonwertować określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTimeOffset" /> równoważnej i zwraca wartość wskazującą, czy konwersja powiodła się.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="input" /> parametr jest pomyślnie przekonwertowana; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie metody <xref:System.DateTimeOffset.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTimeOffset%40%29> przypomina metody <xref:System.DateTimeOffset.Parse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> metody, z wyjątkiem, że nie zgłosić wyjątek, jeśli konwersja nie powiedzie się. Metoda analizuje ciągu z trzech elementów, które mogą być wyświetlane w dowolnej kolejności i są rozdzielane znakami odstępu. W poniższej tabeli przedstawiono te trzy elementy.  
  
|Element|Przykład|  
|-------------|-------------|  
|\<Data >|"2/10/2007"|  
|\<Time>|"1:02:03 PM"|  
|\<Przesunięcie >|"-7:30"|  
  
 Mimo że każda z tych elementów jest opcjonalny, \<przesunięcie > nie może występować samodzielnie. Należy podać razem albo \<Data > lub \<czasu >. Jeśli \<Data > Brak domyślnej wartości jest bieżącego dnia. Jeśli \<Data > jest obecny, ale jego roku składnik obejmuje tylko dwie cyfry, zostanie przekonwertowane na roku w `provider` parametru bieżącego kalendarza na podstawie wartości z <xref:System.Globalization.Calendar.TwoDigitYearMax%2A?displayProperty=nameWithType> właściwości. Jeśli \<czasu > brakuje jej domyślna wartość to 00:00:00: 00. Jeśli \<przesunięcie > Brak domyślnej wartości jest przesunięcie w lokalnej strefie czasowej, lub <xref:System.TimeSpan.Zero> Jeśli <xref:System.Globalization.DateTimeStyles.AdjustToUniversal?displayProperty=nameWithType> lub <xref:System.Globalization.DateTimeStyles.AssumeUniversal?displayProperty=nameWithType> wartość została określona w `styles`. Jeśli \<przesunięcie > jest obecny, może to oznaczać ujemny lub dodatnią przesunięcie z uniwersalnego czasu koordynowanego (UTC). W obu przypadkach \<przesunięcia > musi zawierać symbol znaku lub metoda zwraca `false`.  
  
 `input` Zostanie przeanalizowany ciąg przy użyciu formatowania informacje specyficzne dla kultury w <xref:System.Globalization.DateTimeFormatInfo> dostarczony przez obiekt `formatProvider` parametru. `formatProvider` Parametr może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury, którego formatowanie jest używany w `input`. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez <xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> właściwość definiuje format, który jest używany w `input`.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format daty i godziny.  
  
 Ponadto każdy element może być rozdzielone wiodących i końcowych białych i \<Data > a \<czasu > składniki mogą zawierać wewnętrzny biały znak (na przykład 6:00:00). Tylko \<przesunięcie > składnika nie może zawierać wewnętrzny biały znak.  
  
 Jeśli `provider` jest `null`, <xref:System.Globalization.CultureInfo> obiekt, który odpowiada bieżącej kultury jest używany.  
  
 Dodatnie lub ujemne znaku używanego w \<przesunięcie > musi być równa albo + lub -. Nie jest zdefiniowany przez <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A> lub <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A> właściwości <xref:System.Globalization.NumberFormatInfo> obiektu zwróconego przez `formatprovider` parametru <xref:System.Globalization.CultureInfo.NumberFormat%2A> właściwości.  
  
 Następujące elementy członkowskie z <xref:System.Globalization.DateTimeStyles> wyliczenia są obsługiwane:  
  
|Element członkowski DateTimeStyles|Komentarze|  
|---------------------------|--------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|Analizuje reprezentowany przez ciąg `input` i, w razie potrzeby, konwertuje ją na czas UTC. Jest to równoważne do analizowania parametrów, a następnie wywołując zwrócony obiekt <xref:System.DateTimeOffset.ToUniversalTime> metody.|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|Choć ważna, wartość ta jest ignorowana. Wewnętrzny biały znak jest dozwolony w \<Data > a \<czasu > składniki.|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|Choć ważna, wartość ta jest ignorowana. Początkowe biały znak jest dozwolone przed poszczególnych składników analizowany ciąg.|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|Choć ważna, wartość ta jest ignorowana. Końcowe biały znak jest dozwolone przed poszczególnych składników analizowany ciąg.|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|Jest to zachowanie domyślne. Nie można zastąpić podając bardziej restrykcyjne <xref:System.Globalization.DateTimeStyles> wyliczenia wartości, takich jak <xref:System.Globalization.DateTimeStyles.None?displayProperty=nameWithType>.|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|Oznacza to, że, jeśli `input` brakuje parametru \<przesunięcie > element, należy podać przesunięcie w lokalnej strefie czasowej. Jest to domyślne zachowanie <xref:System.DateTimeOffset.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTimeOffset%40%29> metody.|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|Oznacza to, że, jeśli `input` brakuje parametru \<przesunięcie > element, należy podać przesunięcie czasu UTC (00:00).|  
|<xref:System.Globalization.DateTimeStyles.None>|Mimo że jest prawidłowy, ta wartość jest ignorowana i nie ma wpływu.|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|Ponieważ <xref:System.DateTimeOffset> nie ma struktury `Kind` właściwość, ta wartość nie ma wpływu.|  
  
 Tylko <xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault?displayProperty=nameWithType> wartość nie jest obsługiwana. <xref:System.ArgumentException> Jest generowany, jeśli ta wartość jest uwzględniona w `styles` parametru.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.DateTimeOffset.TryParse%28System.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTimeOffset%40%29> metody z różnymi <xref:System.Globalization.DateTimeStyles> wartości, aby przeanalizować niektórych ciągów z różnych formatów daty i godziny.  
  
 [!code-csharp[System.DateTimeOffset.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.TryParse/cs/TryParse.cs#2)]
 [!code-vb[System.DateTimeOffset.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.TryParse/vb/TryParse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="styles" /> obejmują niezdefiniowanej <see cref="T:System.Globalization.DateTimeStyles" /> wartość.  - lub - <see cref="F:System.Globalization.DateTimeStyles.NoCurrentDateDefault" /> nie jest obsługiwane.  - lub - <paramref name="styles" /> obejmuje wykluczają się wzajemnie <see cref="T:System.Globalization.DateTimeStyles" /> wartości.</exception>
        <altmember cref="Overload:System.DateTimeOffset.Parse" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParseExact">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTimeOffset" /> równoważne. Format ciągu reprezentującego musi dokładnie pasować do wskazanego formatu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; format, IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, out DateTimeOffset result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; input, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider formatProvider, valuetype System.Globalization.DateTimeStyles styles, [out] valuetype System.DateTimeOffset&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.TryParseExact(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTimeOffset@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (input As ReadOnlySpan(Of Char), format As ReadOnlySpan(Of Char), formatProvider As IFormatProvider, styles As DateTimeStyles, ByRef result As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; format, IFormatProvider ^ formatProvider, System::Globalization::DateTimeStyles styles, [Runtime::InteropServices::Out] DateTimeOffset % result);" />
      <MemberSignature Language="F#" Value="static member TryParseExact : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTimeOffset.TryParseExact (input, format, formatProvider, styles, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="formatProvider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTimeOffset&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">To be added.</param>
        <param name="format">To be added.</param>
        <param name="formatProvider">To be added.</param>
        <param name="styles">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (ReadOnlySpan&lt;char&gt; input, string[] formats, IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, out DateTimeOffset result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(valuetype System.ReadOnlySpan`1&lt;char&gt; input, string[] formats, class System.IFormatProvider formatProvider, valuetype System.Globalization.DateTimeStyles styles, [out] valuetype System.DateTimeOffset&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.TryParseExact(System.ReadOnlySpan{System.Char},System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTimeOffset@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (input As ReadOnlySpan(Of Char), formats As String(), formatProvider As IFormatProvider, styles As DateTimeStyles, ByRef result As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(ReadOnlySpan&lt;char&gt; input, cli::array &lt;System::String ^&gt; ^ formats, IFormatProvider ^ formatProvider, System::Globalization::DateTimeStyles styles, [Runtime::InteropServices::Out] DateTimeOffset % result);" />
      <MemberSignature Language="F#" Value="static member TryParseExact : ReadOnlySpan&lt;char&gt; * string[] * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTimeOffset.TryParseExact (input, formats, formatProvider, styles, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="formats" Type="System.String[]" />
        <Parameter Name="formatProvider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTimeOffset&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">To be added.</param>
        <param name="formats">To be added.</param>
        <param name="formatProvider">To be added.</param>
        <param name="styles">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (string input, string format, IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, out DateTimeOffset result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(string input, string format, class System.IFormatProvider formatProvider, valuetype System.Globalization.DateTimeStyles styles, [out] valuetype System.DateTimeOffset&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.TryParseExact(System.String,System.String,System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTimeOffset@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (input As String, format As String, formatProvider As IFormatProvider, styles As DateTimeStyles, ByRef result As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(System::String ^ input, System::String ^ format, IFormatProvider ^ formatProvider, System::Globalization::DateTimeStyles styles, [Runtime::InteropServices::Out] DateTimeOffset % result);" />
      <MemberSignature Language="F#" Value="static member TryParseExact : string * string * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTimeOffset.TryParseExact (input, format, formatProvider, styles, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="formatProvider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTimeOffset&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg zawierający datę i godzinę, które należy przekształcić.</param>
        <param name="format">Specyfikator formatu, który definiuje wymagany format <c>wejściowych</c>.</param>
        <param name="formatProvider">Obiekt, który dostarcza specyficzne dla kultury formatowania informacji na temat <c>wejściowych</c>.</param>
        <param name="styles">Bitowe połączenie wartości wyliczenia wskazująca dozwolony format danych wejściowych. Jest Typowa wartość do określenia <see langword="None" />.</param>
        <param name="result">Gdy metoda zwróci wartość, zawiera <see cref="T:System.DateTimeOffset" /> odpowiednikiem daty i godziny <c>wejściowych</c>, jeśli konwersja powiodła się, lub <see cref="F:System.DateTimeOffset.MinValue" />, jeśli konwersja nie powiodła się. Konwersja nie powiedzie się, jeśli <c>wejściowych</c> parametr jest <see langword="null" />, lub nie zawiera prawidłową reprezentacją ciągu daty i godziny w oczekiwanym formacie zdefiniowane przez <c>format</c> i <c> Dostawca</c>. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTimeOffset" /> równoważne przy użyciu określonego formatu, informacji o formacie specyficzne dla kultury i styl. Format ciągu reprezentującego musi dokładnie pasować do wskazanego formatu.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="input" /> parametr jest pomyślnie przekonwertowana; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie metody <xref:System.DateTimeOffset.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTimeOffset%40%29> przypomina metody <xref:System.DateTimeOffset.ParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> metody z tą różnicą, że ta metoda nie zgłosić wyjątek, jeśli konwersja nie powiedzie się. Analizuje reprezentację ciągu daty i godziny musi dokładnie odpowiadać wzorca określonego przez `format` parametru. Jeśli `input` ciąg nie jest zgodny z tego wzorca z niektórych zmian biały znak, zdefiniowane przez `styles` parametru podczas analizowania kończy się niepowodzeniem i metoda zwraca `false`.  
  
 `format` Parametr jest ciąg znaków zawierający specyfikator formatu pojedynczy standardowy lub specyfikatorów formatu niestandardowego, definiujące wymagany wzorzec `input`. Aby uzyskać więcej informacji o prawidłowe kody formatowania, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Jeśli `format` obejmuje `z`, `zz`, lub `zzz` specyfikatorów formatu niestandardowego, aby wskazać, że przesunięcia musi znajdować się w `input`, które musi zawierać symbolu wartości ujemnej lub znak dodatni. Jeśli brakuje znaku, analizy kończy się niepowodzeniem i metoda zwraca `false`.  
  
 Jeśli `format` wymaga, aby `input` zawierać datę, ale nie godziny, powstałe w ten sposób <xref:System.DateTimeOffset> obiekt jest przypisany przez czas północy (0: 00:00). Jeśli `format` wymaga, aby `input` zawiera godzinę, ale nie Data, powstałe w ten sposób <xref:System.DateTimeOffset> obiekt jest przypisany bieżącą datę w systemie lokalnym. Jeśli `format` nie wymaga, aby `input` zawiera przesunięcie przesunięcie powstałe w ten sposób <xref:System.DateTimeOffset> obiektu zależy od wartości `styles` parametru. Jeśli `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeLocal>, przesunięcie w lokalnej strefie czasowej jest przypisany do <xref:System.DateTimeOffset> obiektu. Jeśli `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeUniversal>, przesunięciem uniwersalnego czasu koordynowanego (UTC) lub + 00:00, jest przypisany do <xref:System.DateTimeOffset> obiektu. Jeśli żadna wartość nie jest określona, używane jest przesunięcie lokalnej strefy czasowej.  
  
 Określonej daty i czasu symbole i parametrów używanych w `input` są definiowane przez `formatProvider` parametru. To samo dotyczy dokładne wzorzec `input` Jeśli `format` jest ciąg specyfikatora formatu standardowych. `formatProvider` Parametr może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury na podstawie którego `input` jest interpretowany. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez <xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> w dozwolone standardowych formatów i symboli definiuje właściwość `input`.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format daty i godziny.  
  
 Jeśli `formatprovider` jest `null`, <xref:System.Globalization.CultureInfo> obiekt, który odpowiada bieżącej kultury jest używany.  
  
 `styles` Parametr określa, czy biały znak jest dozwolony w ciągu wejściowym wskazuje sposób analizowania są ciągi bez jawnego przesunięcia składnik, a także obsługuje UTC konwersji w ramach operacji analizy. Wszystkie elementy członkowskie <xref:System.Globalization.DateTimeStyles> wyliczenia są obsługiwane z wyjątkiem <xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>. Poniższa tabela zawiera listę działania każdego z obsługiwanych elementów członkowskich.  
  
|`DateTimeStyles` element członkowski|Zachowanie|  
|-----------------------------|--------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|Analizuje `input` i, w razie potrzeby, konwertuje ją na czas UTC. Jest to równoważne do analizowania parametrów, a następnie podczas wywoływania <xref:System.DateTimeOffset.ToUniversalTime%2A?displayProperty=nameWithType> metody zwracana <xref:System.DateTimeOffset> obiektu.|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|Jeśli `format` nie wymaga, aby `input` zawiera wartość przesunięcia zwróconego <xref:System.DateTimeOffset> obiektu podano przesunięcie w lokalnej strefie czasowej. Jest to zachowanie domyślne.|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|Jeśli `format` nie wymaga, aby `input` zawiera wartość przesunięcia zwróconego <xref:System.DateTimeOffset> obiektu podano przesunięcie UTC (+ 00:00).|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|Umożliwia `input` uwzględnienie wewnętrzny biały znak nie określił formatu. Dodatkowe wolne miejsce mogą występować między składnikami daty i godziny oraz w poszczególnych składników, z wyjątkiem przesunięcie i jest ignorowany podczas analizowania parametrów.|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|Umożliwia `input` uwzględnienie spacje początkowe nie został określony przez `format`. Są one ignorowane podczas analizowania ciągu.|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|Umożliwia `input` uwzględnienie końcowe spacje nie został określony przez `format`. Są one ignorowane podczas analizowania ciągu.|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|Umożliwia `input` do spacji wiodących końcowe i wewnętrzny nie został określony przez `format`. Wszystkie dodatkowe białych znaków, nie jest określony w `format` podczas analizowania parametrów są ignorowane.|  
|<xref:System.Globalization.DateTimeStyles.None>|Wskazuje, że dodatkowe biały znak jest niedozwolony w `input`. Biały znak musi znajdować się dokładnie tak jak określono w `format`. Jest to zachowanie domyślne.|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|Nie obowiązuje, ponieważ <xref:System.DateTimeOffset> nie ma struktury `Kind` właściwości.|  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.DateTimeOffset.TryParseExact%28System.String%2CSystem.String%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTimeOffset%40%29> metody specyfikatory formatu standardowych i niestandardowych, niezmienna kultura i różnymi <xref:System.Globalization.DateTimeStyles> wartości, aby przeanalizować kilka ciągów daty i godziny.  
  
 [!code-csharp[System.DateTimeOffset.TryParseExact#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.TryParseExact/cs/TryParseExact.cs#1)]
 [!code-vb[System.DateTimeOffset.TryParseExact#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.TryParseExact/vb/TryParseExact.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="styles" /> obejmują niezdefiniowanej <see cref="T:System.Globalization.DateTimeStyles" /> wartość.  - lub - <see cref="F:System.Globalization.DateTimeStyles.NoCurrentDateDefault" /> nie jest obsługiwane.  - lub - <paramref name="styles" /> obejmuje wykluczają się wzajemnie <see cref="T:System.Globalization.DateTimeStyles" /> wartości.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] <see cref="Overload:System.DateTimeOffset.TryParseExact" /> zwraca <see langword="false" /> ciąg do przeanalizowania zawiera składnik godziny i oznaczenie AM/PM, które nie są umowy. W [! INCLUDE[net_v35_short](~/includes/NET-v35-Short-MD.MD)] i starszych wersjach, oznaczenie AM/PM jest ignorowana.</para>
        </block>
        <altmember cref="Overload:System.DateTimeOffset.ParseExact" />
      </Docs>
    </Member>
    <Member MemberName="TryParseExact">
      <MemberSignature Language="C#" Value="public static bool TryParseExact (string input, string[] formats, IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, out DateTimeOffset result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParseExact(string input, string[] formats, class System.IFormatProvider formatProvider, valuetype System.Globalization.DateTimeStyles styles, [out] valuetype System.DateTimeOffset&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.DateTimeOffset.TryParseExact(System.String,System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles,System.DateTimeOffset@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParseExact (input As String, formats As String(), formatProvider As IFormatProvider, styles As DateTimeStyles, ByRef result As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParseExact(System::String ^ input, cli::array &lt;System::String ^&gt; ^ formats, IFormatProvider ^ formatProvider, System::Globalization::DateTimeStyles styles, [Runtime::InteropServices::Out] DateTimeOffset % result);" />
      <MemberSignature Language="F#" Value="static member TryParseExact : string * string[] * IFormatProvider * System.Globalization.DateTimeStyles *  -&gt; bool" Usage="System.DateTimeOffset.TryParseExact (input, formats, formatProvider, styles, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="formats" Type="System.String[]" />
        <Parameter Name="formatProvider" Type="System.IFormatProvider" />
        <Parameter Name="styles" Type="System.Globalization.DateTimeStyles" />
        <Parameter Name="result" Type="System.DateTimeOffset&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg zawierający datę i godzinę, które należy przekształcić.</param>
        <param name="formats">Tablica, która definiuje oczekiwane formaty <c>wejściowych</c>.</param>
        <param name="formatProvider">Obiekt, który dostarcza specyficzne dla kultury formatowania informacji na temat <c>wejściowych</c>.</param>
        <param name="styles">Bitowe połączenie wartości wyliczenia wskazująca dozwolony format danych wejściowych. Jest Typowa wartość do określenia <see langword="None" />.</param>
        <param name="result">Gdy metoda zwróci wartość, zawiera <see cref="T:System.DateTimeOffset" /> odpowiednikiem daty i godziny <c>wejściowych</c>, jeśli konwersja powiodła się, lub <see cref="F:System.DateTimeOffset.MinValue" />, jeśli konwersja nie powiodła się. Konwersja nie powiedzie się, jeśli <c>wejściowych</c> nie zawiera prawidłową reprezentacją ciągu daty i godziny lub nie zawiera datę i godzinę w oczekiwanym formacie zdefiniowane przez <c>format</c>, lub jeśli <c> formaty</c> jest <see langword="null" />. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje określoną reprezentację ciągu daty i czasu jego <see cref="T:System.DateTimeOffset" /> równoważne przy użyciu określonej tablicy formatów, informacji o formacie specyficzne dla kultury i styl. Format ciągu reprezentującego musi dokładnie pasować do jednego ze wskazanych formatów.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="input" /> parametr jest pomyślnie przekonwertowana; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.TryParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTimeOffset%40%29> Metody analizuje reprezentację ciągu daty, który pasuje do jednej z wzorców przypisane do `formats` tablicy. Jeśli `input` ciąg nie jest zgodny z jednego z tych wzorców z żadnych zmian, zdefiniowane przez `styles` parametru podczas analizowania kończy się niepowodzeniem i metoda zwraca `false`. Jako uzupełnienie porównanie `input` do wielu ciągów zawierających specyfikatory formatu tego przeciążenia zachowuje się tak samo do <xref:System.DateTimeOffset.ParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%29?displayProperty=nameWithType> metody.  
  
 `formats` Parametr jest tablicą ciągów, których elementy zawierają specyfikator formatu pojedynczy standardowy lub specyfikatorów formatu niestandardowego, definiujące możliwe wzorzec `input`. Aby uzyskać więcej informacji o prawidłowe kody formatowania, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Jeśli element dopasowane `formats` obejmuje `z`, `zz`, lub `zzz` specyfikatorów formatu niestandardowego, aby wskazać, że przesunięcia musi znajdować się w `input`, które musi zawierać symbolu wartości ujemnej lub znak dodatni. Jeśli brakuje znaku, analizy kończy się niepowodzeniem i metoda zwraca `false`.  
  
> [!IMPORTANT]
>  Przy użyciu `formats` parametru tego przeciążenia, aby określić wiele formatów mogą pomóc w zmniejszeniu frustracji spowodowanej wielu użytkowników występują po wprowadzeniu daty i godziny. W szczególności możliwość definiowania wielu wzorców wejściowych włącza aplikację do obsługi Data i godzina oświadczenia, które można uwzględnić lub braku zera wiodące w miesięcy, dni, godziny, minuty i sekundy. W przykładzie przedstawiono ilustracja to.  
  
 Jeśli element dopasowane w `formats` wymaga, aby `input` zawierać datę, ale nie godziny, powstałe w ten sposób <xref:System.DateTimeOffset> obiekt jest przypisany przez czas północy (0: 00:00). Jeśli element dopasowane `formats` wymaga, aby dane wejściowe zawierają raz, ale nie Data, powstałe w ten sposób <xref:System.DateTimeOffset> obiekt jest przypisany bieżącą datę w systemie lokalnym. Jeśli element dopasowane w `formats` nie wymaga, aby `input` zawiera przesunięcie przesunięcie powstałe w ten sposób <xref:System.DateTimeOffset> obiektu zależy od wartości `styles` parametru. Jeśli `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeLocal>, przesunięcie w lokalnej strefie czasowej jest przypisany do <xref:System.DateTimeOffset> obiektu. Jeśli `styles` obejmuje <xref:System.Globalization.DateTimeStyles.AssumeUniversal>, przesunięciem uniwersalnego czasu koordynowanego (UTC) lub + 00:00, jest przypisany do <xref:System.DateTimeOffset> obiektu. Jeśli żadna wartość nie jest określona, używane jest przesunięcie lokalnej strefy czasowej.  
  
 Określonej daty i czasu symbole i parametrów używanych w `input` są definiowane przez `formatProvider` parametru. To samo dotyczy dokładne wzorzec `input` Jeśli pasującego elementu `formats` jest ciąg specyfikatora formatu standardowych. `formatProvider` Parametr może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który reprezentuje kultury na podstawie którego `input` jest interpretowany. <xref:System.Globalization.DateTimeFormatInfo> Obiektu zwróconego przez <xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> właściwość definiuje symbole i formatowania w `input`.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiektu, który definiuje format daty i godziny.  
  
 Jeśli `formatprovider` jest `null`, <xref:System.Globalization.CultureInfo> obiekt, który odpowiada bieżącej kultury jest używany.  
  
 `styles` Parametr określa, czy biały znak jest dozwolone w ciągu wejściowym wskazuje sposób analizowania są ciągi bez jawnego przesunięcia składnik, a także obsługuje UTC konwersji w ramach operacji analizy. Wszystkie elementy członkowskie <xref:System.Globalization.DateTimeStyles> wyliczenia są obsługiwane z wyjątkiem <xref:System.Globalization.DateTimeStyles.NoCurrentDateDefault>. Poniższa tabela zawiera listę działania każdego z obsługiwanych elementów członkowskich.  
  
|`DateTimeStyles` element członkowski|Zachowanie|  
|-----------------------------|--------------|  
|<xref:System.Globalization.DateTimeStyles.AdjustToUniversal>|Analizuje `input` i, w razie potrzeby, konwertuje ją na czas UTC. Jest to równoważne do analizowania parametrów, a następnie podczas wywoływania <xref:System.DateTimeOffset.ToUniversalTime%2A?displayProperty=nameWithType> metody zwracana <xref:System.DateTimeOffset> obiektu.|  
|<xref:System.Globalization.DateTimeStyles.AssumeLocal>|Jeśli element dopasowane w `formats` nie wymaga, aby `input` zawiera wartość przesunięcia zwróconego <xref:System.DateTimeOffset> obiektu podano przesunięcie w lokalnej strefie czasowej. Jest to wartość domyślna.|  
|<xref:System.Globalization.DateTimeStyles.AssumeUniversal>|Jeśli element dopasowane w `formats` nie wymaga, aby `input` zawiera wartość przesunięcia zwróconego <xref:System.DateTimeOffset> obiektu podano przesunięcie UTC (+ 00:00).|  
|<xref:System.Globalization.DateTimeStyles.AllowInnerWhite>|Umożliwia `input` uwzględnienie wewnętrzny biały znak nie został określony przez elementy `formats`. Dodatkowe wolne miejsce mogą występować między składnikami daty i godziny oraz w poszczególnych składników (z wyjątkiem przesunięcie) i jest ignorowany podczas analizowania parametrów.|  
|<xref:System.Globalization.DateTimeStyles.AllowLeadingWhite>|Umożliwia `input` do Dołącz wiodące spacje nie został określony przez elementy `formats`. Są one ignorowane podczas analizowania ciągu.|  
|<xref:System.Globalization.DateTimeStyles.AllowTrailingWhite>|Umożliwia `input` uwzględnienie końcowe spacje nie został określony przez elementy `formats`. Są one ignorowane podczas analizowania ciągu.|  
|<xref:System.Globalization.DateTimeStyles.AllowWhiteSpaces>|Umożliwia `input` do spacji wiodących końcowe i wewnętrzny nie został określony przez elementy `formats`. Wszystkie bardzo białych znaków, nie jest określony w elemencie dopasowane w `formats` podczas analizowania parametrów są ignorowane.|  
|<xref:System.Globalization.DateTimeStyles.None>|Wskazuje, że dodatkowe biały znak jest niedozwolony w `input`. Biały znak musi znajdować się dokładnie tak jak określono w dany element w `formats` dla pomyślnego dopasowania występuje. Jest to zachowanie domyślne.|  
|<xref:System.Globalization.DateTimeStyles.RoundtripKind>|Nie obowiązuje, ponieważ <xref:System.DateTimeOffset> nie ma struktury `Kind` właściwości.|  
  
   
  
## Examples  
 Poniższy przykład definiuje wiele formatów wejściowych reprezentacji ciągu daty i godziny oraz wartość przesunięcia, a następnie przekazuje ciąg, który jest wprowadzana przez użytkownika w celu <xref:System.DateTimeOffset.TryParseExact%28System.String%2CSystem.String%5B%5D%2CSystem.IFormatProvider%2CSystem.Globalization.DateTimeStyles%2CSystem.DateTimeOffset%40%29> metody.  
  
 [!code-csharp[System.DateTimeOffset.TryParseExact#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.TryParseExact/cs/TryParseExact.cs#2)]
 [!code-vb[System.DateTimeOffset.TryParseExact#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.TryParseExact/vb/TryParseExact.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="styles" /> obejmują niezdefiniowanej <see cref="T:System.Globalization.DateTimeStyles" /> wartość.  - lub - <see cref="F:System.Globalization.DateTimeStyles.NoCurrentDateDefault" /> nie jest obsługiwane.  - lub - <paramref name="styles" /> obejmuje wykluczają się wzajemnie <see cref="T:System.Globalization.DateTimeStyles" /> wartości.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] <see cref="Overload:System.DateTimeOffset.TryParseExact" /> zwraca <see langword="false" /> ciąg do przeanalizowania zawiera składnik godziny i oznaczenie AM/PM, które nie są umowy. W [! INCLUDE[net_v35_short](~/includes/NET-v35-Short-MD.MD)] i starszych wersjach, oznaczenie AM/PM jest ignorowana.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="UnixEpoch">
      <MemberSignature Language="C#" Value="public static readonly DateTimeOffset UnixEpoch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTimeOffset UnixEpoch" />
      <MemberSignature Language="DocId" Value="F:System.DateTimeOffset.UnixEpoch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnixEpoch As DateTimeOffset " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTimeOffset UnixEpoch;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnixEpoch : DateTimeOffset" Usage="System.DateTimeOffset.UnixEpoch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UtcDateTime">
      <MemberSignature Language="C#" Value="public DateTime UtcDateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime UtcDateTime" />
      <MemberSignature Language="DocId" Value="P:System.DateTimeOffset.UtcDateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UtcDateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime UtcDateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.UtcDateTime : DateTime" Usage="System.DateTimeOffset.UtcDateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.DateTime" /> wartość, która reprezentuje uniwersalny czas koordynowany (UTC) datę i godzinę bieżącego <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <value>Uniwersalny czas koordynowany (UTC) datę i godzinę bieżącego <see cref="T:System.DateTimeOffset" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.UtcDateTime%2A> Właściwość wykonuje podwójna konwersja:  
  
-   Konwertuje datę i godzinę bieżącego <xref:System.DateTimeOffset> obiektu uniwersalny czas koordynowany (UTC). Konwersja jest wykonywana przez odjęcie wartości <xref:System.DateTimeOffset.Offset%2A> właściwość Data i godzina bieżącego <xref:System.DateTimeOffset> obiektu.  
  
-   Konwertuje <xref:System.DateTimeOffset> do wartości <xref:System.DateTime> wartość.  
  
 <xref:System.DateTime.Kind%2A> Właściwości zwracana <xref:System.DateTimeOffset.DateTime%2A> ma wartość <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>.  
  
 Pobieranie wartości <xref:System.DateTimeOffset.UtcDateTime%2A> właściwości jest odpowiednikiem wywołania bieżącego <xref:System.DateTimeOffset> obiektu `ToUniversalTime.DateTime` właściwości, z wyjątkiem <xref:System.DateTime.Kind%2A> właściwości tych <xref:System.DateTime> wartość jest <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób korzystania z <xref:System.DateTimeOffset.UtcDateTime%2A> właściwość, aby wyświetlić <xref:System.DateTimeOffset> wartość i jego odpowiedni czas UTC.  
  
 [!code-csharp[System.DateTimeOffset.Properties#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/cs/Properties.cs#17)]
 [!code-vb[System.DateTimeOffset.Properties#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/vb/Properties.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UtcNow">
      <MemberSignature Language="C#" Value="public static DateTimeOffset UtcNow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.DateTimeOffset UtcNow" />
      <MemberSignature Language="DocId" Value="P:System.DateTimeOffset.UtcNow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UtcNow As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property DateTimeOffset UtcNow { DateTimeOffset get(); };" />
      <MemberSignature Language="F#" Value="member this.UtcNow : DateTimeOffset" Usage="System.DateTimeOffset.UtcNow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.DateTimeOffset" /> obiektów, których data i godzina są ustawione na bieżące uniwersalny czas koordynowany (UTC), datę i godzinę i którego przesunięcie jest <see cref="F:System.TimeSpan.Zero" />.</summary>
        <value>Obiekt, którego daty i godziny jest bieżący uniwersalny czas koordynowany (UTC) i którego przesunięcie jest <see cref="F:System.TimeSpan.Zero" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.UtcNow%2A> Właściwość oblicza bieżący uniwersalny czas koordynowany (UTC) na podstawie systemu lokalnego czasu zegara, przesunięcie określone przez strefy czasowej systemu lokalnego.  
  
 Dokładność składnika milisekund bieżący czas UTC zależy od rozdzielczości zegara systemowego. Systemu Windows NT w wersji 3.5 lub nowszej i systemów operacyjnych Windows Vista rozdzielczość zegara to około 10 – 15 milisekund.  
  
   
  
## Examples  
 Poniższy przykład przedstawia relację między uniwersalny czas koordynowany (UTC) i czasem lokalnym.  
  
 [!code-csharp[System.DateTimeOffset.Properties#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/cs/Properties.cs#18)]
 [!code-vb[System.DateTimeOffset.Properties#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/vb/Properties.vb#18)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.DateTimeOffset.Now" />
      </Docs>
    </Member>
    <Member MemberName="UtcTicks">
      <MemberSignature Language="C#" Value="public long UtcTicks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 UtcTicks" />
      <MemberSignature Language="DocId" Value="P:System.DateTimeOffset.UtcTicks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UtcTicks As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long UtcTicks { long get(); };" />
      <MemberSignature Language="F#" Value="member this.UtcTicks : int64" Usage="System.DateTimeOffset.UtcTicks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ich liczba reprezentująca datę i godzinę bieżącego <see cref="T:System.DateTimeOffset" /> obiektu uniwersalny czas koordynowany (UTC).</summary>
        <value>Liczbę znaczników w <see cref="T:System.DateTimeOffset" /> obiektu uniwersalny czas koordynowany (UTC).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.DateTimeOffset.UtcTicks%2A> właściwość reprezentuje liczbę 100-nanosekundowych interwałów, które upłynęły od północy 12:00:00 w dniu 1 stycznia 0001 (wartość <xref:System.DateTimeOffset.MinValue>). Nie ma Takty dodanych sekund przestępnym. Nanosekundowych jest billionth jednej sekundy; Brak dziesięć milionów impulsów na sekundę. Wartość <xref:System.DateTimeOffset.UtcTicks%2A> właściwości zakresów z `DateTimeOffset.MinValue.Ticks` do `DateTimeOffset.MaxValue.Ticks`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Year">
      <MemberSignature Language="C#" Value="public int Year { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Year" />
      <MemberSignature Language="DocId" Value="P:System.DateTimeOffset.Year" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Year As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Year { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Year : int" Usage="System.DateTimeOffset.Year" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera składnik roku daty reprezentowany przez bieżący <see cref="T:System.DateTimeOffset" /> obiektu.</summary>
        <value>Składnik roku bieżącego <see cref="T:System.DateTimeOffset" /> obiektu, wyrażony jako wartość całkowitą od 0 do 9999.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.DateTimeOffset.Year%2A> Właściwość nie ma wpływu na wartość <xref:System.DateTimeOffset.Offset%2A> właściwości.  
  
 Można również utworzyć reprezentację ciągu <xref:System.DateTimeOffset> składnik roku obiektu przez wywołanie metody <xref:System.DateTimeOffset.ToString%2A> metody z specyfikatorów formatu niestandardowego "y", "yy" lub "yyyy".  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono składnik roku z <xref:System.DateTimeOffset> wartość na cztery różne sposoby:  
  
-   Pobierając zaletą <xref:System.DateTimeOffset.Year%2A> właściwości.  
  
-   Wywołując <xref:System.DateTimeOffset.ToString%28System.String%29> metody z specyfikator formatu "y".  
  
-   Wywołując <xref:System.DateTimeOffset.ToString%28System.String%29> metody z specyfikator formatu "yy".  
  
-   Wywołując <xref:System.DateTimeOffset.ToString%28System.String%29> metody z specyfikator formatu "yyyy".  
  
 [!code-csharp[System.DateTimeOffset.Properties#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/cs/Properties.cs#19)]
 [!code-vb[System.DateTimeOffset.Properties#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.DateTimeOffset.Properties/vb/Properties.vb#19)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
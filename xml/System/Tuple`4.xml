<Type Name="Tuple&lt;T1,T2,T3,T4&gt;" FullName="System.Tuple&lt;T1,T2,T3,T4&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c10e333e47f8a9986d4bfd66c1d085fbc098df09" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69419028" /></Metadata><TypeSignature Language="C#" Value="public class Tuple&lt;T1,T2,T3,T4&gt; : IComparable, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Tuple`4&lt;T1, T2, T3, T4&gt; extends System.Object implements class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.IComparable" />
  <TypeSignature Language="DocId" Value="T:System.Tuple`4" />
  <TypeSignature Language="VB.NET" Value="Public Class Tuple(Of T1, T2, T3, T4)&#xA;Implements IComparable, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T1, typename T2, typename T3, typename T4&gt;&#xA;public ref class Tuple : IComparable, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Tuple&lt;'T1, 'T2, 'T3, 'T4&gt; = class&#xA;    interface IStructuralEquatable&#xA;    interface IStructuralComparable&#xA;    interface IComparable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T1" />
    <TypeParameter Name="T2" />
    <TypeParameter Name="T3" />
    <TypeParameter Name="T4" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T1">Typ pierwszego składnika spójnej kolekcji.</typeparam>
    <typeparam name="T2">Typ drugiego składnika spójnej kolekcji.</typeparam>
    <typeparam name="T3">Typ trzeciego składnika spójnej kolekcji.</typeparam>
    <typeparam name="T4">Typ czwartego składnika spójnej kolekcji.</typeparam>
    <summary>Reprezentuje 4-krotkę lub czterokrotnie.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spójna kolekcja to struktura danych, która ma określoną liczbę i kolejność wartości. <xref:System.Tuple%604> Klasa reprezentuje 4-krotkę lub czterokrotność, która jest krotką zawierającą cztery składniki.  
  
 Można utworzyć wystąpienie <xref:System.Tuple%604> obiektu przez wywołanie <xref:System.Tuple%604.%23ctor%2A> konstruktora lub metody statycznej <xref:System.Tuple.Create%60%604%28%60%600%2C%60%601%2C%60%602%2C%60%603%29?displayProperty=nameWithType> . Możesz pobrać wartość składników krotki przy użyciu <xref:System.Tuple%604.Item1%2A>właściwości tylko do odczytu <xref:System.Tuple%604.Item3%2A>, <xref:System.Tuple%604.Item2%2A>, i <xref:System.Tuple%604.Item4%2A> wystąpienia.  
  
 Spójne kolekcje są powszechnie wykorzystywane na cztery różne sposoby:  
  
-   Reprezentowanie jednego zestawu danych. Na przykład spójna kolekcja może reprezentować rekord bazy danych, a jej składniki mogą reprezentować poszczególne pola rekordu.  
  
-   Zapewnienie łatwego dostępu do zestawu danych i możliwości wykonywania w nim różnych operacji. W poniższym przykładzie zdefiniowano tablicę <xref:System.Tuple%604> obiektów, które zawierają nazwy siatkówkiki, liczbę inningsów, a liczba uruchomień (przebiega bez błędów polowych) i trafień. Tablica jest przenoszona do `ComputeStatistics` metody, która oblicza średnią liczbę uruchomień (średnia liczba przebiegów w ciągu dziewięciu Inning) i średnią liczbę trafień uzyskanych na Inning. Metoda używa również tych dwóch średnich do obliczenia hipotetycznej średniej skuteczności.  
  
     [!code-csharp[System.Tuple\`4.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`4.class/cs/example1.cs#1)]
     [!code-vb[System.Tuple\`4.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`4.class/vb/example1.vb#1)]  
  
-   Aby zwrócić wiele wartości z metody bez użycia `out` parametrów (in C#) lub `ByRef` Parameters (w Visual Basic). Na przykład w poprzednim przykładzie funkcja zwraca dane statystyczne, wraz z nazwą dzbanka, w tablicy <xref:System.Tuple%604> obiektów.  
  
-   Przekazywanie wielu wartości do metody za pomocą jednego parametru. Na przykład <xref:System.Threading.Thread.Start%28System.Object%29?displayProperty=nameWithType> Metoda ma jeden parametr, który umożliwia podawanie jednej wartości metodzie wykonywanej przez wątek przy uruchamianiu. W przypadku podania <xref:System.Tuple%604> obiektu jako argumentu metody można dostarczyć procedurę uruchamiania wątku z czterema elementami danych.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Tuple" />
    <altmember cref="T:System.Tuple`1" />
    <altmember cref="T:System.Tuple`2" />
    <altmember cref="T:System.Tuple`3" />
    <altmember cref="T:System.Tuple`5" />
    <altmember cref="T:System.Tuple`6" />
    <altmember cref="T:System.Tuple`7" />
    <altmember cref="T:System.Tuple`8" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Tuple (T1 item1, T2 item2, T3 item3, T4 item4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T1 item1, !T2 item2, !T3 item3, !T4 item4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`4.#ctor(`0,`1,`2,`3)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (item1 As T1, item2 As T2, item3 As T3, item4 As T4)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Tuple(T1 item1, T2 item2, T3 item3, T4 item4);" />
      <MemberSignature Language="F#" Value="new Tuple&lt;'T1, 'T2, 'T3, 'T4&gt; : 'T1 * 'T2 * 'T3 * 'T4 -&gt; Tuple&lt;'T1, 'T2, 'T3, 'T4&gt;" Usage="new System.Tuple&lt;'T1, 'T2, 'T3, 'T4&gt; (item1, item2, item3, item4)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
        <Parameter Name="item2" Type="T2" />
        <Parameter Name="item3" Type="T3" />
        <Parameter Name="item4" Type="T4" />
      </Parameters>
      <Docs>
        <param name="item1">Wartość pierwszego składnika spójnej kolekcji.</param>
        <param name="item2">Wartość drugiego składnika spójnej kolekcji.</param>
        <param name="item3">Wartość trzeciego składnika spójnej kolekcji.</param>
        <param name="item4">Wartość czwartego składnika spójnej kolekcji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Tuple`4" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można również użyć statycznej <xref:System.Tuple.Create%60%604%28%60%600%2C%60%601%2C%60%602%2C%60%603%29?displayProperty=nameWithType> metody do tworzenia wystąpienia obiektu spoiny 4 bez konieczności jawnego określania typów jego składników. W poniższym przykładzie zastosowano <xref:System.Tuple.Create%60%604%28%60%600%2C%60%601%2C%60%602%2C%60%603%29?displayProperty=nameWithType> metodę, aby utworzyć wystąpienie kolekcji 4, której składniki są typu <xref:System.String>, <xref:System.Double>, <xref:System.Double>, i <xref:System.Double>.  
  
 [!code-csharp[System.Tuple.Create#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple.create/cs/create1.cs#7)]
 [!code-vb[System.Tuple.Create#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple.create/vb/create1.vb#7)]  
  
 Jest to równoważne następującej wywołaniu <xref:System.Tuple%604.%23ctor%2A> konstruktora klasy.  
  
 [!code-csharp[System.Tuple.Create#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple.create/cs/create1.cs#8)]
 [!code-vb[System.Tuple.Create#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple.create/vb/create1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`4.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="tuple.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, który ma zostać porównany z tym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy bieżący <see cref="T:System.Tuple`4" /> obiekt jest równy podanemu obiektowi.</summary>
        <returns><see langword="true" />Jeśli bieżące wystąpienie jest równe podanemu obiektowi; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `obj` Parametr jest traktowany jako równy bieżącemu wystąpieniu w następujących warunkach:  
  
-   Jest <xref:System.Tuple%604> to obiekt.  
  
-   Jego cztery składniki są tego samego typu co bieżące wystąpienie.  
  
-   Jego cztery składniki są równe bieżącym wystąpieniu. Równość jest określana przez domyślny moduł porównywania równości obiektów dla każdego składnika.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano tablicę <xref:System.Tuple%604> obiektów, która dostarcza dane dla temperatury o trzy razy w danym dniu. Metoda <xref:System.Tuple%604.Equals%28System.Object%29> jest wywoływana, aby porównać każdy <xref:System.Tuple%604> obiekt z każdym innym <xref:System.Tuple%604> obiektem. Dane wyjściowe ilustrują, <xref:System.Tuple%604.Equals%28System.Object%29> że metoda `true` zwraca tylko wtedy, gdy <xref:System.Tuple%604> wszystkie cztery składniki obiektów mają równe wartości.  
  
 [!code-csharp[System.Tuple\`4.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`4.equals/cs/equals1.cs#1)]
 [!code-vb[System.Tuple\`4.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`4.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`4.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="tuple.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla bieżącego <see cref="T:System.Tuple`4" /> obiektu.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item1">
      <MemberSignature Language="C#" Value="public T1 Item1 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T1 Item1" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`4.Item1" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item1 As T1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T1 Item1 { T1 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item1 : 'T1" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4&gt;.Item1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T1</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość pierwszego składnika bieżącego <see cref="T:System.Tuple`4" /> obiektu.</summary>
        <value>Wartość pierwszego składnika bieżącego <see cref="T:System.Tuple`4" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ <xref:System.Tuple%604.Item1%2A> składnika można dynamicznie określić na jeden z dwóch sposobów:  
  
-   Przez wywołanie `GetType` metody na wartości zwracanej <xref:System.Tuple%604.Item1%2A> przez właściwość.  
  
-   Pobierając <xref:System.Type> obiekt, który <xref:System.Tuple%604> reprezentuje obiekt, i pobierając pierwszy element z tablicy, która jest zwracana przez jego <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metodę.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano tablicę <xref:System.Tuple%604> obiektów, których składniki zawierają nazwę miasta, miesiąc roku i średnią górną i niską temperaturę danego miesiąca. Następnie pobiera i wyświetla wartości każdego składnika.  
  
 [!code-csharp[System.Tuple\`4.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`4.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`4.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`4.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item2">
      <MemberSignature Language="C#" Value="public T2 Item2 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T2 Item2" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`4.Item2" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item2 As T2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T2 Item2 { T2 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item2 : 'T2" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4&gt;.Item2" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T2</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość drugiego składnika bieżącego <see cref="T:System.Tuple`4" /> obiektu.</summary>
        <value>Wartość drugiego składnika bieżącego <see cref="T:System.Tuple`4" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ <xref:System.Tuple%604.Item2%2A> składnika można dynamicznie określić na jeden z dwóch sposobów:  
  
-   Przez wywołanie `GetType` metody na wartości zwracanej <xref:System.Tuple%604.Item2%2A> przez właściwość.  
  
-   Pobierając <xref:System.Type> obiekt, który <xref:System.Tuple%604> reprezentuje obiekt, i pobierając drugi element z tablicy, która jest zwracana przez jego <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metodę.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano tablicę <xref:System.Tuple%604> obiektów, których składniki zawierają nazwę miasta, miesiąc roku i średnią górną i niską temperaturę danego miesiąca. Następnie pobiera i wyświetla wartości każdego składnika.  
  
 [!code-csharp[System.Tuple\`4.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`4.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`4.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`4.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item3">
      <MemberSignature Language="C#" Value="public T3 Item3 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T3 Item3" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`4.Item3" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item3 As T3" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T3 Item3 { T3 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item3 : 'T3" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4&gt;.Item3" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T3</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość trzeciego składnika bieżącego <see cref="T:System.Tuple`4" /> obiektu.</summary>
        <value>Wartość trzeciego składnika bieżącego <see cref="T:System.Tuple`4" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ <xref:System.Tuple%604.Item3%2A> składnika można dynamicznie określić na jeden z dwóch sposobów:  
  
-   Przez wywołanie `GetType` metody na wartości zwracanej <xref:System.Tuple%604.Item3%2A> przez właściwość.  
  
-   Pobierając <xref:System.Type> obiekt, który <xref:System.Tuple%604> reprezentuje obiekt, i pobierając trzeci element z tablicy, która jest zwracana przez jego <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metodę.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano tablicę <xref:System.Tuple%604> obiektów, których składniki zawierają nazwę miasta, miesiąc roku i średnią górną i niską temperaturę danego miesiąca. Następnie pobiera i wyświetla wartości każdego składnika.  
  
 [!code-csharp[System.Tuple\`4.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`4.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`4.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`4.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item4">
      <MemberSignature Language="C#" Value="public T4 Item4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T4 Item4" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`4.Item4" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item4 As T4" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T4 Item4 { T4 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item4 : 'T4" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4&gt;.Item4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T4</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość czwartego składnika bieżącego <see cref="T:System.Tuple`4" /> obiektu.</summary>
        <value>Wartość czwartego składnika bieżącego <see cref="T:System.Tuple`4" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ <xref:System.Tuple%604.Item4%2A> składnika można dynamicznie określić na jeden z dwóch sposobów:  
  
-   Przez wywołanie `GetType` metody na wartości zwracanej <xref:System.Tuple%604.Item4%2A> przez właściwość.  
  
-   Pobierając <xref:System.Type> obiekt, który <xref:System.Tuple%604> reprezentuje obiekt, i pobierając czwarty element z tablicy, która jest zwracana przez jego <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metodę.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano tablicę <xref:System.Tuple%604> obiektów, których składniki zawierają nazwę miasta, miesiąc roku i średnią górną i niską temperaturę danego miesiąca. Następnie pobiera i wyświetla wartości każdego składnika.  
  
 [!code-csharp[System.Tuple\`4.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`4.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`4.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`4.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`4.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt, który ma zostać porównany z bieżącym wystąpieniem.</param>
        <param name="comparer">Obiekt dostarczający niestandardowe reguły na potrzeby porównania.</param>
        <summary>Porównuje bieżący <see cref="T:System.Tuple`4" /> obiekt z określonym obiektem przy użyciu określonej funkcji porównującej i zwraca liczbę całkowitą, która wskazuje, czy bieżący obiekt jest przed, po lub w tym samym położeniu, co określony obiekt w kolejności sortowania.</summary>
        <returns>Liczba całkowita ze znakiem, która wskazuje względną pozycję tego <paramref name="other" /> wystąpienia i w kolejności sortowania, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Opis 
 </description></listheader><item><term> Ujemna liczba całkowita 
 </term><description> To wystąpienie poprzedza <paramref name="other" />.  
  
 </description></item><item><term> Zero 
 </term><description> To wystąpienie i <paramref name="other" /> ma takie same położenie w kolejności sortowania.  
  
 </description></item><item><term> Dodatnia liczba całkowita 
 </term><description> To wystąpienie jest <paramref name="other" />następujące.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Tuple%604> gdy wystąpienie jest rzutowane <xref:System.Collections.IStructuralComparable> do interfejsu.  
  
 Chociaż ta metoda może być wywoływana bezpośrednio, jest najczęściej wywoływana przez metody sortowania kolekcji, które obejmują <xref:System.Collections.IComparer> parametry w celu uporządkowania elementów członkowskich kolekcji. Na przykład jest wywoływana <xref:System.Array.Sort%28System.Array%2CSystem.Collections.IComparer%29?displayProperty=nameWithType> przez metodę <xref:System.Collections.SortedList.Add%2A> i metodę <xref:System.Collections.SortedList> <xref:System.Collections.SortedList.%23ctor%28System.Collections.IComparer%29?displayProperty=nameWithType> obiektu, którego wystąpienie jest tworzone przy użyciu konstruktora.  
  
> [!CAUTION]
>  <xref:System.Tuple%604.System%23Collections%23IStructuralComparable%23CompareTo%28System.Object%2CSystem.Collections.IComparer%29> Metoda jest przeznaczona do użycia podczas sortowania operacji. Nie należy jej używać, gdy głównym celem porównania jest ustalenie, czy dwa obiekty są sobie równe. Aby określić, czy dwa obiekty są równe, wywołaj <xref:System.Tuple%604.System%23Collections%23IStructuralEquatable%23Equals%28System.Object%2CSystem.Collections.IEqualityComparer%29> metodę.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę <xref:System.Tuple%604> obiektów, które zawierają dane statystyczne dotyczące siatkówkiki. Elementy danych obejmują nazwę dzbanka, liczbę innings o pochyleniach, średnią liczbę uruchomień (średnia liczba uruchomień na grę) i liczbę trafień w podanej wysokości. W przykładzie przedstawiono składnik każdej krotki w tablicy w kolejności niesortowanej, Sortuje tablicę, a następnie wywołuje <xref:System.Tuple%604.ToString%2A> w celu wyświetlenia wartości poszczególnych krotek w sortowanej kolejności. Aby posortować tablicę, w przykładzie zdefiniowano `PitcherComparer` klasę generyczną <xref:System.Collections.IComparer> implementującą <xref:System.Tuple%604> interfejs i sortuje obiekty w kolejności rosnącej według wartości ich trzeciego składnika (średni przebiegu wypracowanego), a nie pierwszego składnika. Należy zauważyć, że przykład nie wywołuje <xref:System.Tuple%604.System%23Collections%23IStructuralComparable%23CompareTo%28System.Object%2CSystem.Collections.IComparer%29> bezpośrednio metody. Ta metoda jest wywoływana niejawnie przez <xref:System.Array.Sort%28System.Array%2CSystem.Collections.IComparer%29?displayProperty=nameWithType> metodę dla każdego elementu w tablicy.  
  
 [!code-csharp[System.Tuple\`4.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`4.compareto/cs/compareto2.cs#2)]
 [!code-vb[System.Tuple\`4.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`4.compareto/vb/compareto2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="other" />nie <see cref="T:System.Tuple`4" /> jest obiektem.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`4.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt, który ma zostać porównany z tym wystąpieniem.</param>
        <param name="comparer">Obiekt definiujący metodę służącą ocenie, czy dwa obiekty są sobie równe.</param>
        <summary>Zwraca wartość wskazującą, czy bieżący <see cref="T:System.Tuple`4" /> obiekt jest równy podanemu obiektowi w oparciu o określoną metodę porównania.</summary>
        <returns><see langword="true" />Jeśli bieżące wystąpienie jest równe podanemu obiektowi; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Tuple%604> gdy wystąpienie jest rzutowane <xref:System.Collections.IStructuralEquatable> do interfejsu.  
  
 C# <xref:System.Tuple%604> `null` `other` Implementacja jest wywoływana tylko wtedy, gdy nie jest, i jeśli można ją pomyślnie rzutować (w) lub skonwertować (w Visual Basic) do obiektu, którego składniki są tego samego typu co bieżące wystąpienie. <xref:System.Collections.IEqualityComparer.Equals%2A?displayProperty=nameWithType> Metoda najpierw <xref:System.Collections.IEqualityComparer.Equals%2A?displayProperty=nameWithType> przekazuje wartości obiektów<xref:System.Tuple%604> do porównania z implementacją. <xref:System.Tuple%604.Item1%2A> <xref:System.Tuple%604.System%23Collections%23IStructuralEquatable%23Equals%28System.Object%2CSystem.Collections.IEqualityComparer%29> Jeśli wywołanie metody zwróci wartość `true`, Metoda zostanie wywołana ponownie i <xref:System.Tuple%604.Item2%2A> przekazała wartości dwóch <xref:System.Tuple%604> obiektów. Jeśli wywołanie metody powraca `true` ponownie, metoda jest wywoływana jako trzeci czas i <xref:System.Tuple%604.Item3%2A> przekazała wartości dwóch <xref:System.Tuple%604> obiektów. Jeśli wywołanie metody powraca `true` ponownie, metoda jest wywoływana dla czwartego i końcowego czasu i <xref:System.Tuple%604.Item4%2A> przekazała wartości dwóch <xref:System.Tuple%604> obiektów.  
  
   
  
## Examples  
 Poniższy przykład definiuje `Item3And4Comparer` klasę, która <xref:System.Collections.IEqualityComparer> implementuje interfejs i <xref:System.Tuple%604> zmienia sposób, w jaki obiekty są oceniane pod kątem równości. Metoda zawsze `true` zwraca, gdy jest <xref:System.Tuple%604.Item1%2A> przenoszona <xref:System.Tuple%604.Item2%2A> wartości właściwości dwóch <xref:System.Tuple%604> obiektów i wywołuje `obj.Equals` metodę w celu obliczenia <xref:System.Tuple%604.Item3%2A> wartości właściwości. To wywołanie metody zwraca wartość true, a `obj.Equals` także wywołuje metodę w celu obliczenia wartości <xref:System.Tuple%604.Item4%2A> właściwości krotek. W związku z tym Metoda sprawdza równość na podstawie wartości <xref:System.Tuple%604.Item3%2A> właściwości i. <xref:System.Tuple%604.Item4%2A> Dane wyjściowe ilustrują wynik dla zestawu <xref:System.Tuple%604> danych obiektów, które zapisują nazwę miasta USA, miesiąc roku i średnią wysoką i niską temperaturę w danym miesiącu.  
  
 [!code-csharp[System.Tuple\`4.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`4.equals/cs/equals2.cs#2)]
 [!code-vb[System.Tuple\`4.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`4.equals/vb/equals2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`4.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">Obiekt, którego <see cref="M:System.Collections.IEqualityComparer.GetHashCode(System.Object)" /> Metoda oblicza kod skrótu bieżącego <see cref="T:System.Tuple`4" /> obiektu.</param>
        <summary>Oblicza kod skrótu dla bieżącego <see cref="T:System.Tuple`4" /> obiektu za pomocą określonej metody obliczeniowej.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Tuple%604> gdy wystąpienie jest rzutowane <xref:System.Collections.IStructuralEquatable> do interfejsu.  
  
 Metoda po prostu zawija wywołanie do `comparer` <xref:System.Collections.IEqualityComparer.GetHashCode%2A?displayProperty=nameWithType> implementacji obiektu.  
  
 Algorytm używany do obliczania kodu skrótu powinien zwracać ten sam kod skrótu dla dwóch <xref:System.Tuple%604> obiektów, które są uważane za równe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`4.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt, który ma zostać porównany z bieżącym wystąpieniem.</param>
        <summary>Porównuje bieżący <see cref="T:System.Tuple`4" /> obiekt z określonym obiektem i zwraca liczbę całkowitą, która wskazuje, czy bieżący obiekt jest przed, po lub w tym samym położeniu, co określony obiekt w kolejności sortowania.</summary>
        <returns>Liczba całkowita ze znakiem, która wskazuje względną pozycję tego <paramref name="obj" /> wystąpienia i w kolejności sortowania, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość 
 </term><description> Opis 
 </description></listheader><item><term> Ujemna liczba całkowita 
 </term><description> To wystąpienie poprzedza <paramref name="obj" />.  
  
 </description></item><item><term> Zero 
 </term><description> To wystąpienie i <paramref name="obj" /> ma takie same położenie w kolejności sortowania.  
  
 </description></item><item><term> Dodatnia liczba całkowita 
 </term><description> To wystąpienie jest <paramref name="obj" />następujące.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Tuple%604> gdy wystąpienie jest rzutowane <xref:System.IComparable> do interfejsu.  
  
 Ta metoda zapewnia <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> implementację <xref:System.Tuple%604> klasy. Mimo że metoda może być wywoływana bezpośrednio, jest najczęściej wywoływana przez domyślne przeciążenia metod sortowania kolekcji, takich jak <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> i <xref:System.Collections.SortedList.Add%2A?displayProperty=nameWithType>, w celu uporządkowania elementów członkowskich kolekcji.  
  
> [!CAUTION]
>  <xref:System.Tuple%604.System%23IComparable%23CompareTo%2A> Metoda jest przeznaczona do użycia podczas sortowania operacji. Nie należy jej używać, gdy głównym celem porównania jest ustalenie, czy dwa obiekty są sobie równe. Aby określić, czy dwa obiekty są równe, wywołaj <xref:System.Tuple%604.Equals%2A> metodę.  
  
 <xref:System.Tuple%604.System%23IComparable%23CompareTo%2A> Metoda używa domyślnego programu porównującego obiekty do porównania każdego składnika.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę <xref:System.Tuple%604> obiektów, których składniki składają się z nazwy siatkówki dzbanka, liczby innings i liczby trafień i zdobytych wyników. Wyświetla składniki każdej krotki w tablicy w kolejności niesortowanej, Sortuje tablicę, a następnie wywołuje <xref:System.Tuple%604.ToString%2A> w celu wyświetlenia każdej krotki w sortowanej kolejności. Dane wyjściowe pokazują, że tablica jest posortowana według nazw i który element jest pierwszy. Należy zauważyć, że przykład nie wywołuje <xref:System.Tuple%604.System%23IComparable%23CompareTo%28System.Object%29> bezpośrednio metody. Ta metoda jest wywoływana niejawnie przez <xref:System.Array.Sort%28System.Array%29> metodę dla każdego elementu w tablicy.  
  
 [!code-csharp[System.Tuple\`4.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`4.compareto/cs/compareto1.cs#1)]
 [!code-vb[System.Tuple\`4.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`4.compareto/vb/compareto1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="obj" />nie <see cref="T:System.Tuple`4" /> jest obiektem.</exception>
        <altmember cref="M:System.Tuple`4.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.CompilerServices.ITuple.Item">
      <MemberSignature Language="C#" Value="object System.Runtime.CompilerServices.ITuple.Item[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Runtime.CompilerServices.ITuple.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`4.System#Runtime#CompilerServices#ITuple#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Item(index As Integer) As Object Implements ITuple.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Runtime::CompilerServices::ITuple::Item[int] { System::Object ^ get(int index); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.CompilerServices.ITuple.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.CompilerServices.ITuple.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">Indeks określonego <see langword="Tuple" /> elementu. <paramref name="index" />może przyjmować wartość od 0 do 3.</param>
        <summary>Pobiera wartość określonego <see langword="Tuple" /> elementu.</summary>
        <value>Wartość <see langword="Tuple" /> elementu w określonej pozycji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Tuple%604.System%23Runtime%23CompilerServices%23ITuple%23Item%2A?displayProperty=nameWithType> Właściwość jest jawną implementacją interfejsu. Aby wywołać tę metodę, należy rzutować lub przekonwertować <xref:System.Tuple%604> obiekt <xref:System.Runtime.CompilerServices.ITuple> na obiekt interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" />jest mniejsza niż 0 lub większa niż 3.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.CompilerServices.ITuple.Length">
      <MemberSignature Language="C#" Value="int System.Runtime.CompilerServices.ITuple.Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Runtime.CompilerServices.ITuple.Length" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`4.System#Runtime#CompilerServices#ITuple#Length" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Length As Integer Implements ITuple.Length" />
      <MemberSignature Language="C++ CLI" Value="property int System::Runtime::CompilerServices::ITuple::Length { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.CompilerServices.ITuple.Length" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.CompilerServices.ITuple.Length</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów w <see langword="Tuple" />.</summary>
        <value>4 — liczba elementów w <see cref="T:System.Tuple`4" /> obiekcie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Tuple%604.System%23Runtime%23CompilerServices%23ITuple%23Length%2A> Właściwość jest jawną implementacją interfejsu. Aby wywołać tę metodę, należy rzutować lub przekonwertować <xref:System.Tuple%604> obiekt <xref:System.Runtime.CompilerServices.ITuple> na obiekt interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`4.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="tuple.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ciąg, który reprezentuje wartość tego <see cref="T:System.Tuple`4" /> wystąpienia.</summary>
        <returns>Ciąg reprezentujący ten <see cref="T:System.Tuple`4" /> obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciąg zwracany przez tę metodę przyjmuje postać (*Item1 —*, *Item2 —*, *Item3 —*, *Item4 —*), gdzie *Item1 —*, *Item2 —*, *Item3 —* i *Item4 —* reprezentuje wartości elementu <xref:System.Tuple%604.Item1%2A>, <xref:System.Tuple%604.Item2%2A> , <xref:System.Tuple%604.Item3%2A> i<xref:System.Tuple%604.Item4%2A> odpowiednio właściwości. Jeśli dowolna z wartości właściwości jest `null`, jest reprezentowana jako. <xref:System.String.Empty?displayProperty=nameWithType>  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Tuple%604.ToString%2A> metodę. Są w nim wyświetlane składniki tablicy obiektów z 4 kolekcjami, które zawierają nazwę miasta, miesiąc roku i górną i niską średnią temperaturę w danym miesiącu.  
  
 [!code-csharp[System.Tuple\`4.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`4.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Tuple\`4.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`4.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

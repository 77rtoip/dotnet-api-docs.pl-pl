<Type Name="Array" FullName="System.Array">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="930914b33f5750628300f900292f1f758dfe2bb4" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52613012" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IList&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zawiera metody służące do tworzenia, modyfikowania, wyszukiwania i sortowania tablic, a tym samym służy jako klasa bazowa dla wszystkich tablicach w środowisko uruchomieniowe języka wspólnego.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Klasa nie jest częścią <xref:System.Collections> przestrzeni nazw. Jednak nadal uważa się kolekcji, ponieważ jest on oparty na <xref:System.Collections.IList> interfejsu.  
  
 <xref:System.Array> Klasa jest klasą bazową dla implementacji języka, które obsługuje tablic. Jednak tylko system i kompilatorów mogą dziedziczyć jawnie <xref:System.Array> klasy. Użytkownicy powinny zostać konstrukcje tablicy, dostarczone przez język.  
  
 Element ma wartość w <xref:System.Array>. Długość <xref:System.Array> jest to całkowita liczba elementów może zawierać. Dolna granica <xref:System.Array> jest indeksem jej pierwszego elementu. <xref:System.Array> Może mieć żadnych dolną granicę, ale ma ona dolną granicę równą zero, domyślnie. Podczas tworzenia wystąpienia obiektu można zdefiniować różne dolna granica <xref:System.Array> przy użyciu <xref:System.Array.CreateInstance%2A>. Wielowymiarowe <xref:System.Array> mogą mieć różne granice dla każdego wymiaru. Tablica nie może przekraczać 32 wymiarów.  
  
 W odróżnieniu od klas w <xref:System.Collections> przestrzeni nazw, <xref:System.Array> ma stały pojemność. Aby zwiększyć pojemność, należy utworzyć nowy <xref:System.Array> obiektów z wymaganą pojemnością, skopiuj elementy ze starego <xref:System.Array> do nowego obiektu, a następnie usuń stare <xref:System.Array>.  
  
 Domyślnie maksymalny rozmiar <xref:System.Array> wynosi 2 gigabajty (GB). W 64-bitowego środowiska, można uniknąć ograniczenie rozmiaru, ustawiając `enabled` atrybutu [gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) element konfiguracji do `true` w środowisku uruchomieniowym. Tablica nadal będą jednak ograniczone daje w sumie elementy 4 miliardów i maksymalna indeks 0X7FEFFFFF w dowolnym danego wymiaru (0X7FFFFFC7 dla tablic bajtów i tablic struktur pojedynczych bajtów).  
  
 Tablice jednowymiarowe zaimplementować <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> i <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> interfejsów ogólnych. Implementacje są dostarczane do tablic w czasie wykonywania, a w rezultacie interfejsy ogólne nie są wyświetlane w składni deklaracji <xref:System.Array> klasy. Ponadto nie ma żadnych tematy referencyjne dotyczące składowych interfejsu, które są dostępne tylko przez rzutowanie tablicę do typu interfejsu ogólnego (jawne implementacje interfejsu). Kluczową kwestią, aby wiedzieć, jeśli zrzutować tablicę do jednej z tych interfejsów polega na elementy członkowskie, które dodają, Wstaw lub usunąć elementy throw <xref:System.NotSupportedException>.  
  
 <xref:System.Type> obiekty zawierają informacje dotyczące deklaracje typu tablicy. <xref:System.Array> obiekty z tego samego typu tablicy współużytkować ten sam <xref:System.Type> obiektu.  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType> i <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> mogą nie zwracać oczekiwanych wyników z <xref:System.Array> ponieważ jeśli tablica jest rzutowany na typ <xref:System.Array>, wynik jest obiektem, nie tablica. Oznacza to, że `typeof(System.Array).IsArray` zwraca `false`, i `typeof(System.Array).GetElementType` zwraca `null`.  
  
 <xref:System.Array.Copy%2A?displayProperty=nameWithType> Metoda kopiuje elementy nie tylko między macierzami z tego samego typu, ale również między standard tablice o różnych typach; obsługuje on automatycznie rzutowanie.  
  
 Niektóre metody, takie jak <xref:System.Array.CreateInstance%2A>, <xref:System.Array.Copy%2A>, <xref:System.Array.CopyTo%2A>, <xref:System.Array.GetValue%2A>, i <xref:System.Array.SetValue%2A>, zapewnienia przeciążenia, które akceptują 64-bitowych liczb całkowitych jako parametry do dostosowania tablice dużej pojemności. <xref:System.Array.LongLength%2A> i <xref:System.Array.GetLongLength%2A> zwracają 64-bitowe liczby całkowite, wskazujący długość tablicy.  
  
 <xref:System.Array> Nie jest gwarantowana ma zostać posortowana.  Możesz sortować <xref:System.Array> przed wykonaniem operacji (takich jak <xref:System.Array.BinarySearch%2A>), które wymagają <xref:System.Array> ma zostać posortowana.  
  
 Za pomocą <xref:System.Array> obiektu wskaźników w kodzie macierzystym nie jest obsługiwana i zgłosi <xref:System.NotSupportedException> dla kilku metod.  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład sposobu <xref:System.Array.Copy%2A?displayProperty=nameWithType> kopiuje elementy między tablicą typu Integer i tablicę typu <xref:System.Object>.  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 Poniższy przykład kodu tworzy i inicjuje <xref:System.Array> i wyświetla jej właściwości i jej elementów.  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Publiczne statyczne (<see langword="Shared" /> w języku Visual Basic) elementy członkowskie tego typu są bezpieczne dla wątków. Wystąpienia elementów członkowskich nie dają gwarancji bezpieczeństwa wątków.  
  
Ta implementacja nie zapewnia zsynchronizowane (wątkowo) otoka dla <see cref="T:System.Array" />; jednak na podstawie klas .NET Framework <see cref="T:System.Array" /> Podaj swoją własną wersję zsynchronizowane za pomocą kolekcji <see cref="P:System.Array.SyncRoot" /> właściwości.  
  
Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
    <related type="Article" href="~/docs/csharp/programming-guide/arrays/index.md">Tablice (Przewodnik programowania w języku C#)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/arrays/index.md">Tablice w Visual Basic</related>
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsReadOnly : 'T[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="System.Array.AsReadOnly array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Tablica jednowymiarowo, zaczynający się od zera do opakowania w trybie tylko do odczytu <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> otoki.</param>
        <summary>Zwraca tylko do odczytu otoki dla określonej tablicy.</summary>
        <returns>Tylko do odczytu <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> otoki dla określonej tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zapobiec wszelkie zmiany w tablicy, uwidocznić tablicy tylko przez tę otokę.  
  
 Kolekcja, która jest tylko do odczytu, jest po prostu zbiorem z otoką uniemożliwiającą zmianę kolekcji; w związku z tym, jeśli zmiany zostaną wprowadzone do podstawowej kolekcji, kolekcja tylko do odczytu uwzględni te zmiany.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład otacza tablicę tylko do odczytu <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje jednowymiarowa sortowane <see cref="T:System.Array" /> dla wartości, przy użyciu algorytmu wyszukiwania binarnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Sortowany jednowymiarowy <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <summary>Tablica wyszukiwania na całą jednowymiarowa sortowane dla określonego elementu przy użyciu <see cref="T:System.IComparable" /> interfejs implementowany przez każdy element tablicy i określonego obiektu.</summary>
        <returns>Indeksuje określony <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> jest; w przeciwnym razie wartość ujemną. Jeśli <paramref name="value" /> nie zostanie znaleziony i <paramref name="value" /> jest mniejszy od jednego lub większej liczby elementów w <paramref name="array" />, liczba ujemna zwrócony uzupełnienie bitowe indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie zostanie znaleziony i <paramref name="value" /> jest większa niż wszystkie elementy w <paramref name="array" />, liczba ujemna zwrócony uzupełnienie bitowe (indeks ostatniego elementu plus 1). Jeśli ta metoda jest wywoływana z innych niż sortowane <paramref name="array" />, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <paramref name="value" /> znajduje się w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje tablic wyszukiwanie, zawierających indeksy ujemne. `array` musi być sortowana przed wywołaniem tej metody.  
  
 Jeśli <xref:System.Array> nie zawiera określonej wartości, Metoda ta zwraca ujemną liczbę całkowitą. Można zastosować operator dopełnienia bitowego (~ w języku C# `Not` w języku Visual Basic) wyniku ujemnego w celu utworzenia indeksu. Jeśli ten indeks większa niż górna granica tablicy, nie ma elementów większych niż `value` w tablicy. W przeciwnym razie jest indeks pierwszego elementu, który jest większy niż `value`.  
  
 Albo `value` lub każdego elementu `array` musi implementować <xref:System.IComparable> interfejs, który jest używany do porównania. Elementy `array` muszą być już posortowane rosnąco, zgodnie z porządkiem sortowania zdefiniowanym przez <xref:System.IComparable> wdrażania; w przeciwnym razie wynik może być niepoprawny.  
  
> [!NOTE]
>  Jeśli`value` nie implementuje <xref:System.IComparable> interfejsu elementy `array` nie są sprawdzane pod kątem <xref:System.IComparable> przed rozpoczęciem wyszukiwania. Wyjątek jest generowany, jeśli wyszukiwanie napotka element, który nie implementuje <xref:System.IComparable>.  
  
 Dozwolone są zduplikowane elementy. Jeśli <xref:System.Array> zawiera więcej niż jeden element równy `value`, Metoda ta zwraca indeks tylko jednego wystąpienia ale niekoniecznie pierwszy z nich.  
  
 `null` zawsze można porównać z innym typem odwołania; w związku z tym, do porównania z wartością `null` nie wygeneruje wyjątek.  
  
> [!NOTE]
>  Dla każdego badanego elementu `value` jest przekazywany do odpowiedniej <xref:System.IComparable> wdrożenia, nawet jeśli `value` jest `null`. Oznacza to, że <xref:System.IComparable> implementacja Określa, jak dany element można porównać do `null`.  
  
 Ta metoda jest O (log `n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Array.BinarySearch%2A> zlokalizować konkretny obiekt <xref:System.Array>.  
  
> [!NOTE]
>  Tablica jest tworzona z jego elementów w kolejności rosnącej. <xref:System.Array.BinarySearch%2A> Metoda wymaga tablicy, które mają być sortowane w kolejności rosnącej.  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ma charakter wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> jest typu, który nie jest zgodny z elementami <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> nie implementuje <see cref="T:System.IComparable" /> interfejsu i wyszukiwanie napotka element, który nie implementuje <see cref="T:System.IComparable" /> interfejsu.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Sortowany jednowymiarowy <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <param name="comparer">
          <see cref="T:System.Collections.IComparer" /> Wdrożenia do użycia podczas porównywania elementów.  
  
—lub— 
 <see langword="null" /> Aby użyć <see cref="T:System.IComparable" /> wykonania każdego elementu.</param>
        <summary>Tablica wyszukiwania na całą jednowymiarowa sortowane dla wartości przy użyciu określonego <see cref="T:System.Collections.IComparer" /> interfejsu.</summary>
        <returns>Indeksuje określony <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> jest; w przeciwnym razie wartość ujemną. Jeśli <paramref name="value" /> nie zostanie znaleziony i <paramref name="value" /> jest mniejszy od jednego lub większej liczby elementów w <paramref name="array" />, liczba ujemna zwrócony uzupełnienie bitowe indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie zostanie znaleziony i <paramref name="value" /> jest większa niż wszystkie elementy w <paramref name="array" />, liczba ujemna zwrócony uzupełnienie bitowe (indeks ostatniego elementu plus 1). Jeśli ta metoda jest wywoływana z innych niż sortowane <paramref name="array" />, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <paramref name="value" /> znajduje się w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje tablic wyszukiwanie, zawierających indeksy ujemne. `array` musi być sortowana przed wywołaniem tej metody.  
  
 Jeśli <xref:System.Array> nie zawiera określonej wartości, Metoda ta zwraca ujemną liczbę całkowitą. Można zastosować operator dopełnienia bitowego (~ w języku C# `Not` w języku Visual Basic) wyniku ujemnego w celu utworzenia indeksu. Jeśli ten indeks większa niż górna granica tablicy, nie ma elementów większych niż `value` w tablicy. W przeciwnym razie jest indeks pierwszego elementu, który jest większy niż `value`.  
  
 Moduł porównujący dostosowuje sposób porównywania elementów. Na przykład, można użyć <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> jako modułu porównującego do wyszukiwania ciągów bez uwzględniania wielkości liter.  
  
 Jeśli `comparer` nie `null`, elementy `array` są porównywane z określoną wartość, przy użyciu określonego <xref:System.Collections.IComparer> implementacji. Elementy `array` muszą być już posortowane rosnąco, zgodnie z porządkiem sortowania zdefiniowanym przez `comparer`; w przeciwnym razie wynik może być niepoprawny.  
  
 Jeśli`comparer` jest `null`, porównanie odbywa się przy użyciu <xref:System.IComparable> implementacji zapewnionej przez sam ten element lub przez określoną wartość. Elementy `array` muszą być już posortowane rosnąco, zgodnie z porządkiem sortowania zdefiniowanym przez <xref:System.IComparable> wdrażania; w przeciwnym razie wynik może być niepoprawny.  
  
> [!NOTE]
>  Jeśli `comparer` jest `null` i `value` nie implementuje <xref:System.IComparable> interfejsu elementy `array` nie są sprawdzane pod kątem <xref:System.IComparable> przed rozpoczęciem wyszukiwania. Wyjątek jest generowany, jeśli wyszukiwanie napotka element, który nie implementuje <xref:System.IComparable>.  
  
 Dozwolone są zduplikowane elementy. Jeśli <xref:System.Array> zawiera więcej niż jeden element równy `value`, Metoda ta zwraca indeks tylko jednego wystąpienia ale niekoniecznie pierwszy z nich.  
  
 `null` zawsze można porównać z innym typem odwołania; w związku z tym, do porównania z wartością `null` nie wygeneruje wyjątek.  
  
> [!NOTE]
>  Dla każdego badanego elementu `value` jest przekazywany do odpowiedniej <xref:System.IComparable> wdrożenia, nawet jeśli `value` jest `null`. Oznacza to, że <xref:System.IComparable> implementacja Określa, jak dany element można porównać do `null`.  
  
 Ta metoda jest O (log `n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ma charakter wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> jest <see langword="null" />, i <paramref name="value" /> typu, który nie jest zgodny z elementami <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />, <paramref name="value" /> nie implementuje <see cref="T:System.IComparable" /> interfejsu i wyszukiwanie napotka element, który nie implementuje <see cref="T:System.IComparable" /> interfejsu.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Sortowany jednowymiarowy <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="index">Indeks początkowy zakresu wyszukiwania.</param>
        <param name="length">Długość zakresu wyszukiwania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <summary>Wyszukuje zakres elementów w jednowymiarowa posortowaną tablicę wartości, przy użyciu <see cref="T:System.IComparable" /> interfejs implementowany przez każdy element tablicy i określoną wartość.</summary>
        <returns>Indeksuje określony <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> jest; w przeciwnym razie wartość ujemną. Jeśli <paramref name="value" /> nie zostanie znaleziony i <paramref name="value" /> jest mniejszy od jednego lub większej liczby elementów w <paramref name="array" />, liczba ujemna zwrócony uzupełnienie bitowe indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie zostanie znaleziony i <paramref name="value" /> jest większa niż wszystkie elementy w <paramref name="array" />, liczba ujemna zwrócony uzupełnienie bitowe (indeks ostatniego elementu plus 1). Jeśli ta metoda jest wywoływana z innych niż sortowane <paramref name="array" />, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <paramref name="value" /> znajduje się w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje tablic wyszukiwanie, zawierających indeksy ujemne. `array` musi być sortowana przed wywołaniem tej metody.  
  
 Jeśli <xref:System.Array> nie zawiera określonej wartości, Metoda ta zwraca ujemną liczbę całkowitą. Można zastosować operator dopełnienia bitowego (~ w języku C# `Not` w języku Visual Basic) wyniku ujemnego w celu utworzenia indeksu. Jeśli ten indeks większa niż górna granica tablicy, nie ma elementów większych niż `value` w tablicy. W przeciwnym razie jest indeks pierwszego elementu, który jest większy niż `value`.  
  
 Albo `value` lub każdego elementu `array` musi implementować <xref:System.IComparable> interfejs, który jest używany do porównania. Elementy `array` muszą być już posortowane rosnąco, zgodnie z porządkiem sortowania zdefiniowanym przez <xref:System.IComparable> wdrażania; w przeciwnym razie wynik może być niepoprawny.  
  
> [!NOTE]
>  Jeśli `value` nie implementuje <xref:System.IComparable> interfejsu elementy `array` nie są sprawdzane pod kątem <xref:System.IComparable> przed rozpoczęciem wyszukiwania. Wyjątek jest generowany, jeśli wyszukiwanie napotka element, który nie implementuje <xref:System.IComparable>.  
  
 Dozwolone są zduplikowane elementy. Jeśli <xref:System.Array> zawiera więcej niż jeden element równy `value`, Metoda ta zwraca indeks tylko jednego wystąpienia ale niekoniecznie pierwszy z nich.  
  
 `null` zawsze można porównać z innym typem odwołania; w związku z tym, do porównania z wartością `null` nie wygeneruje wyjątek.  
  
> [!NOTE]
>  Dla każdego badanego elementu `value` jest przekazywany do odpowiedniej <xref:System.IComparable> wdrożenia, nawet jeśli `value` jest `null`. Oznacza to, że <xref:System.IComparable> implementacja Określa, jak dany element można porównać do `null`.  
  
 Ta metoda jest O (log `n`) operacji, gdzie `n` jest `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ma charakter wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.  
  
—lub— 
 <paramref name="length" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="length" /> nie określono prawidłowego zakresu <paramref name="array" />.  
  
—lub— 
 <paramref name="value" /> jest typu, który nie jest zgodny z elementami <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> nie implementuje <see cref="T:System.IComparable" /> interfejsu i wyszukiwanie napotka element, który nie implementuje <see cref="T:System.IComparable" /> interfejsu.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Sortowany jednowymiarowy <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="index">Indeks początkowy zakresu wyszukiwania.</param>
        <param name="length">Długość zakresu wyszukiwania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <param name="comparer">
          <see cref="T:System.Collections.IComparer" /> Wdrożenia do użycia podczas porównywania elementów.  
  
—lub— 
 <see langword="null" /> Aby użyć <see cref="T:System.IComparable" /> wykonania każdego elementu.</param>
        <summary>Wyszukuje zakres elementów w jednowymiarowa posortowaną tablicę wartości, przy użyciu określonego <see cref="T:System.Collections.IComparer" /> interfejsu.</summary>
        <returns>Indeksuje określony <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> jest; w przeciwnym razie wartość ujemną. Jeśli <paramref name="value" /> nie zostanie znaleziony i <paramref name="value" /> jest mniejszy od jednego lub większej liczby elementów w <paramref name="array" />, liczba ujemna zwrócony uzupełnienie bitowe indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie zostanie znaleziony i <paramref name="value" /> jest większa niż wszystkie elementy w <paramref name="array" />, liczba ujemna zwrócony uzupełnienie bitowe (indeks ostatniego elementu plus 1). Jeśli ta metoda jest wywoływana z innych niż sortowane <paramref name="array" />, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <paramref name="value" /> znajduje się w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje tablic wyszukiwanie, zawierających indeksy ujemne. `array` musi być sortowana przed wywołaniem tej metody.  
  
 Jeśli <xref:System.Array> nie zawiera określonej wartości, Metoda ta zwraca ujemną liczbę całkowitą. Można zastosować operator dopełnienia bitowego (~ w języku C# `Not` w języku Visual Basic) wyniku ujemnego w celu utworzenia indeksu. Jeśli ten indeks większa niż górna granica tablicy, nie ma elementów większych niż `value` w tablicy. W przeciwnym razie jest indeks pierwszego elementu, który jest większy niż `value`.  
  
 Moduł porównujący dostosowuje sposób porównywania elementów. Na przykład, można użyć <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> jako modułu porównującego do wyszukiwania ciągów bez uwzględniania wielkości liter.  
  
 Jeśli `comparer` nie `null`, elementy `array` są porównywane z określoną wartość, przy użyciu określonego <xref:System.Collections.IComparer> implementacji. Elementy `array` muszą być już posortowane rosnąco, zgodnie z porządkiem sortowania zdefiniowanym przez `comparer`; w przeciwnym razie wynik może być niepoprawny.  
  
 Jeśli `comparer` jest `null`, porównanie odbywa się przy użyciu <xref:System.IComparable> implementacji zapewnionej przez sam ten element lub przez określoną wartość. Elementy `array` muszą być już posortowane rosnąco, zgodnie z porządkiem sortowania zdefiniowanym przez <xref:System.IComparable> wdrażania; w przeciwnym razie wynik może być niepoprawny.  
  
> [!NOTE]
>  Jeśli `comparer` jest `null` i `value` nie implementuje <xref:System.IComparable> interfejsu elementy `array` nie są sprawdzane pod kątem <xref:System.IComparable> przed rozpoczęciem wyszukiwania. Wyjątek jest generowany, jeśli wyszukiwanie napotka element, który nie implementuje <xref:System.IComparable>.  
  
 Dozwolone są zduplikowane elementy. Jeśli <xref:System.Array> zawiera więcej niż jeden element równy `value`, Metoda ta zwraca indeks tylko jednego wystąpienia ale niekoniecznie pierwszy z nich.  
  
 `null` zawsze można porównać z innym typem odwołania; w związku z tym, do porównania z wartością `null` nie wygeneruje wyjątek, korzystając z <xref:System.IComparable>.  
  
> [!NOTE]
>  Dla każdego badanego elementu `value` jest przekazywany do odpowiedniej <xref:System.IComparable> wdrożenia, nawet jeśli `value` jest `null`. Oznacza to, że <xref:System.IComparable> implementacja Określa, jak dany element można porównać do `null`.  
  
 Ta metoda jest O (log `n`) operacji, gdzie `n` jest `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ma charakter wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.  
  
—lub— 
 <paramref name="length" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="length" /> nie określono prawidłowego zakresu <paramref name="array" />.  
  
—lub— 
 <paramref name="comparer" /> jest <see langword="null" />, i <paramref name="value" /> typu, który nie jest zgodny z elementami <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />, <paramref name="value" /> nie implementuje <see cref="T:System.IComparable" /> interfejsu i wyszukiwanie napotka element, który nie implementuje <see cref="T:System.IComparable" /> interfejsu.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Sortowany jednowymiarowo, zaczynający się od zera <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <summary>Tablica wyszukiwania na całą jednowymiarowa sortowane dla określonego elementu przy użyciu <see cref="T:System.IComparable`1" /> ogólny interfejs implementowany przez każdy element obiektu <see cref="T:System.Array" /> , jak określony obiekt.</summary>
        <returns>Indeksuje określony <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> jest; w przeciwnym razie wartość ujemną. Jeśli <paramref name="value" /> nie zostanie znaleziony i <paramref name="value" /> jest mniejszy od jednego lub większej liczby elementów w <paramref name="array" />, liczba ujemna zwrócony uzupełnienie bitowe indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie zostanie znaleziony i <paramref name="value" /> jest większa niż wszystkie elementy w <paramref name="array" />, liczba ujemna zwrócony uzupełnienie bitowe (indeks ostatniego elementu plus 1). Jeśli ta metoda jest wywoływana z innych niż sortowane <paramref name="array" />, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <paramref name="value" /> znajduje się w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje tablic wyszukiwanie, zawierających indeksy ujemne. `array` musi być sortowana przed wywołaniem tej metody.  
  
 Jeśli `array` nie zawiera określonej wartości, Metoda ta zwraca ujemną liczbę całkowitą. Można zastosować operator dopełnienia bitowego (~ w języku C# `Not` w języku Visual Basic) wyniku ujemnego w celu utworzenia indeksu. Jeśli indeks ten jest równy rozmiarowi tablicy, nie ma elementów większych niż `value` w tablicy. W przeciwnym razie jest indeks pierwszego elementu, który jest większy niż `value`.  
  
 `T` musisz zaimplementować <xref:System.IComparable%601> ogólny interfejs, który służy do porównania. Elementy `array` muszą być już posortowane rosnąco, zgodnie z porządkiem sortowania zdefiniowanym przez <xref:System.IComparable%601> wdrażania; w przeciwnym razie wynik może być niepoprawny.  
  
 Dozwolone są zduplikowane elementy. Jeśli <xref:System.Array> zawiera więcej niż jeden element równy `value`, Metoda ta zwraca indeks tylko jednego wystąpienia ale niekoniecznie pierwszy z nich.  
  
 `null` zawsze można porównać z innym typem odwołania; w związku z tym, do porównania z wartością `null` nie wygeneruje wyjątek.  
  
> [!NOTE]
>  Dla każdego badanego elementu `value` jest przekazywany do odpowiedniej <xref:System.IComparable%601> wdrożenia, nawet jeśli `value` jest `null`. Oznacza to, że <xref:System.IComparable%601> implementacja Określa, jak dany element można porównać do `null`.  
  
 Ta metoda jest O (log `n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> przeciążenie metody rodzajowe i <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> przeciążenia metody rodzajowej. Tworzona jest tablica ciągów, w losowej kolejności.  
  
 Tablica jest wyświetlana, sortowana i ponownie wyświetlana. Tablice muszą być sortowane, aby można było używać <xref:System.Array.BinarySearch%2A> metody.  
  
> [!NOTE]
>  Wywołania <xref:System.Array.Sort%2A> i <xref:System.Array.BinarySearch%2A> metody ogólne nie wyglądają inaczej niż wywołania ich odpowiedników nierodzajowych, ponieważ wywnioskować typu parametru typu ogólnego z typu pierwszego argumentu, Visual Basic, C# i C++. Jeśli używasz [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do zbadania języka Microsoft intermediate language (MSIL), możesz zobaczyć, że wywoływane są metody rodzajowe.  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> Przeciążenia metody ogólnej jest następnie używany do dwóch ciągów wyszukiwania, taki, który nie znajduje się w tablicy, a drugi, jest. Tablica i wartość zwracana przez <xref:System.Array.BinarySearch%2A> metody są przekazywane do `ShowWhere` metody rodzajowej, który zawiera wartość indeksu, jeśli ciąg zostanie znaleziony, a w przeciwnym razie elementy ciągu wyszukiwania spadnie między gdyby w tablicy. Indeks jest ujemny, jeśli ciąg nie jest w tablicy, więc `ShowWhere` metoda pobiera bitowe uzupełnienie (~ operatora w języku C# i Visual C++ `Xor`-1 w języku Visual Basic) w celu uzyskania indeksu pierwszego elementu na liście, który jest większy niż wyszukiwanie str w toku.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> nie implementuje <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Sortowany jednowymiarowo, zaczynający się od zera <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> Wdrożenia do użycia podczas porównywania elementów.  
  
—lub— 
 <see langword="null" /> Aby użyć <see cref="T:System.IComparable`1" /> wykonania każdego elementu.</param>
        <summary>Tablica wyszukiwania na całą jednowymiarowa sortowane dla wartości przy użyciu określonego <see cref="T:System.Collections.Generic.IComparer`1" /> interfejs generyczny.</summary>
        <returns>Indeksuje określony <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> jest; w przeciwnym razie wartość ujemną. Jeśli <paramref name="value" /> nie zostanie znaleziony i <paramref name="value" /> jest mniejszy od jednego lub większej liczby elementów w <paramref name="array" />, liczba ujemna zwrócony uzupełnienie bitowe indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie zostanie znaleziony i <paramref name="value" /> jest większa niż wszystkie elementy w <paramref name="array" />, liczba ujemna zwrócony uzupełnienie bitowe (indeks ostatniego elementu plus 1). Jeśli ta metoda jest wywoływana z innych niż sortowane <paramref name="array" />, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <paramref name="value" /> znajduje się w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje tablic wyszukiwanie, zawierających indeksy ujemne. `array` musi być sortowana przed wywołaniem tej metody.  
  
 Jeśli <xref:System.Array> nie zawiera określonej wartości, Metoda ta zwraca ujemną liczbę całkowitą. Można zastosować operator dopełnienia bitowego (~ w języku C# `Not` w języku Visual Basic) wyniku ujemnego w celu utworzenia indeksu. Jeśli indeks ten jest równy rozmiarowi tablicy, nie ma elementów większych niż `value` w tablicy. W przeciwnym razie jest indeks pierwszego elementu, który jest większy niż `value`.  
  
 Moduł porównujący dostosowuje sposób porównywania elementów. Na przykład, można użyć <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> jako modułu porównującego do wyszukiwania ciągów bez uwzględniania wielkości liter.  
  
 Jeśli `comparer` nie `null`, elementy `array` są porównywane z określoną wartość, przy użyciu określonego <xref:System.Collections.Generic.IComparer%601> implementacją ogólnego interfejsu. Elementy `array` muszą być już posortowane rosnąco, zgodnie z porządkiem sortowania zdefiniowanym przez `comparer`; w przeciwnym razie wynik może być niepoprawny.  
  
 Jeśli `comparer` jest `null`, porównanie odbywa się przy użyciu <xref:System.IComparable%601> implementacji interfejsu ogólnego, dostarczone przez `T`. Elementy `array` muszą być już posortowane rosnąco, zgodnie z porządkiem sortowania zdefiniowanym przez <xref:System.IComparable%601> wdrażania; w przeciwnym razie wynik może być niepoprawny.  
  
> [!NOTE]
>  Jeśli `comparer` jest `null` i `value` nie implementuje <xref:System.IComparable%601> ogólny interfejs, elementy `array` nie są sprawdzane pod kątem <xref:System.IComparable%601> przed rozpoczęciem wyszukiwania. Wyjątek jest generowany, jeśli wyszukiwanie napotka element, który nie implementuje <xref:System.IComparable%601>.  
  
 Dozwolone są zduplikowane elementy. Jeśli <xref:System.Array> zawiera więcej niż jeden element równy `value`, Metoda ta zwraca indeks tylko jednego wystąpienia ale niekoniecznie pierwszy z nich.  
  
 `null` zawsze można porównać z innym typem odwołania; w związku z tym, do porównania z wartością `null` nie wygeneruje wyjątek.  
  
> [!NOTE]
>  Dla każdego badanego elementu `value` jest przekazywany do odpowiedniej <xref:System.IComparable%601> wdrożenia, nawet jeśli `value` jest `null`. Oznacza to, że <xref:System.IComparable%601> implementacja Określa, jak dany element można porównać do `null`.  
  
 Ta metoda jest O (log `n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> przeciążenie metody rodzajowe i <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> przeciążenia metody rodzajowej.  
  
 Kodu przykładowy definiuje alternatywny moduł porównujący dla ciągów o nazwie `ReverseCompare`, który implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Moduł porównujący wywołuje <xref:System.String.CompareTo%28System.String%29> metody, odwracając kolejność argumentów porównawczych, tak aby posortować ciągi wysokiej do minimum zamiast niska wysoka.  
  
 Tablica jest wyświetlana, sortowana i ponownie wyświetlana. Tablice muszą być sortowane, aby można było używać <xref:System.Array.BinarySearch%2A> metody.  
  
> [!NOTE]
>  Wywołania <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> i <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metody ogólne nie wyglądają inaczej niż wywołania ich odpowiedników nierodzajowych, ponieważ wywnioskować typu parametru typu ogólnego z typu pierwszego argumentu, Visual Basic, C# i C++. Jeśli używasz [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do zbadania języka Microsoft intermediate language (MSIL), możesz zobaczyć, że wywoływane są metody rodzajowe.  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenia metody ogólnej jest następnie używany do dwóch ciągów wyszukiwania, taki, który nie znajduje się w tablicy, a drugi, jest. Tablica i wartość zwracana przez <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metody są przekazywane do `ShowWhere` metody rodzajowej, który zawiera wartość indeksu, jeśli ciąg zostanie znaleziony, a w przeciwnym razie elementy ciągu wyszukiwania spadnie między gdyby w tablicy. Indeks jest ujemny, jeśli ciąg nie jest n tablicy, więc `ShowWhere` metoda pobiera bitowe uzupełnienie (~ operatora w języku C# i Visual C++ `Xor` -1 w języku Visual Basic) w celu uzyskania indeksu pierwszego elementu na liście, który jest większy niż ściśle wyszukiwania NG.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> jest <see langword="null" />, i <paramref name="value" /> typu, który nie jest zgodny z elementami <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />, i <paramref name="T" /> nie implementuje <see cref="T:System.IComparable`1" /> interfejs ogólny</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Sortowany jednowymiarowo, zaczynający się od zera <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="index">Indeks początkowy zakresu wyszukiwania.</param>
        <param name="length">Długość zakresu wyszukiwania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <summary>Wyszukuje zakres elementów w jednowymiarowa posortowaną tablicę wartości, przy użyciu <see cref="T:System.IComparable`1" /> ogólny interfejs implementowany przez każdy element obiektu <see cref="T:System.Array" /> i przez określoną wartość.</summary>
        <returns>Indeksuje określony <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> jest; w przeciwnym razie wartość ujemną. Jeśli <paramref name="value" /> nie zostanie znaleziony i <paramref name="value" /> jest mniejszy od jednego lub większej liczby elementów w <paramref name="array" />, liczba ujemna zwrócony uzupełnienie bitowe indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie zostanie znaleziony i <paramref name="value" /> jest większa niż wszystkie elementy w <paramref name="array" />, liczba ujemna zwrócony uzupełnienie bitowe (indeks ostatniego elementu plus 1). Jeśli ta metoda jest wywoływana z innych niż sortowane <paramref name="array" />, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <paramref name="value" /> znajduje się w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje tablic wyszukiwanie, zawierających indeksy ujemne. `array` musi być sortowana przed wywołaniem tej metody.  
  
 Jeśli macierz nie zawiera określonej wartości, metoda zwraca ujemną liczbę całkowitą. Można zastosować operator dopełnienia bitowego (~ w języku C# `Not` w języku Visual Basic) wyniku ujemnego w celu utworzenia indeksu. Jeśli indeks ten jest równy rozmiarowi tablicy, nie ma elementów większych niż `value` w tablicy. W przeciwnym razie jest indeks pierwszego elementu, który jest większy niż `value`.  
  
 `T` musisz zaimplementować <xref:System.IComparable%601> ogólny interfejs, który służy do porównania. Elementy `array` muszą być już posortowane rosnąco, zgodnie z porządkiem sortowania zdefiniowanym przez <xref:System.IComparable%601> wdrażania; w przeciwnym razie wynik może być niepoprawny.  
  
 Dozwolone są zduplikowane elementy. Jeśli <xref:System.Array> zawiera więcej niż jeden element równy `value`, Metoda ta zwraca indeks tylko jednego wystąpienia ale niekoniecznie pierwszy z nich.  
  
 `null` zawsze można porównać z innym typem odwołania; w związku z tym, do porównania z wartością `null` nie wygeneruje wyjątek.  
  
> [!NOTE]
>  Dla każdego badanego elementu `value` jest przekazywany do odpowiedniej <xref:System.IComparable%601> wdrożenia, nawet jeśli `value` jest `null`. Oznacza to, że <xref:System.IComparable%601> implementacja Określa, jak dany element można porównać do `null`.  
  
 Ta metoda jest O (log `n`) operacji, gdzie `n` jest `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.  
  
—lub— 
 <paramref name="length" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="length" /> nie określono prawidłowego zakresu <paramref name="array" />.  
  
—lub— 
 <paramref name="value" /> jest typu, który nie jest zgodny z elementami <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> nie implementuje <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Sortowany jednowymiarowo, zaczynający się od zera <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="index">Indeks początkowy zakresu wyszukiwania.</param>
        <param name="length">Długość zakresu wyszukiwania.</param>
        <param name="value">Obiekt, który trzeba wyszukać.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> Wdrożenia do użycia podczas porównywania elementów.  
  
—lub— 
 <see langword="null" /> Aby użyć <see cref="T:System.IComparable`1" /> wykonania każdego elementu.</param>
        <summary>Wyszukuje zakres elementów w jednowymiarowa posortowaną tablicę wartości, przy użyciu określonego <see cref="T:System.Collections.Generic.IComparer`1" /> interfejs generyczny.</summary>
        <returns>Indeksuje określony <paramref name="value" /> w określonym <paramref name="array" />, jeśli <paramref name="value" /> jest; w przeciwnym razie wartość ujemną. Jeśli <paramref name="value" /> nie zostanie znaleziony i <paramref name="value" /> jest mniejszy od jednego lub większej liczby elementów w <paramref name="array" />, liczba ujemna zwrócony uzupełnienie bitowe indeksu pierwszego elementu, który jest większy niż <paramref name="value" />. Jeśli <paramref name="value" /> nie zostanie znaleziony i <paramref name="value" /> jest większa niż wszystkie elementy w <paramref name="array" />, liczba ujemna zwrócony uzupełnienie bitowe (indeks ostatniego elementu plus 1). Jeśli ta metoda jest wywoływana z innych niż sortowane <paramref name="array" />, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <paramref name="value" /> znajduje się w <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie obsługuje tablic wyszukiwanie, zawierających indeksy ujemne. `array` musi być sortowana przed wywołaniem tej metody.  
  
 Jeśli macierz nie zawiera określonej wartości, metoda zwraca ujemną liczbę całkowitą. Można zastosować operator dopełnienia bitowego (~ w języku C# `Not` w języku Visual Basic) wyniku ujemnego w celu utworzenia indeksu. Jeśli indeks ten jest równy rozmiarowi tablicy, nie ma elementów większych niż `value` w tablicy. W przeciwnym razie jest indeks pierwszego elementu, który jest większy niż `value`.  
  
 Moduł porównujący dostosowuje sposób porównywania elementów. Na przykład, można użyć <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> jako modułu porównującego do wyszukiwania ciągów bez uwzględniania wielkości liter.  
  
 Jeśli `comparer` nie `null`, elementy `array` są porównywane z określoną wartość, przy użyciu określonego <xref:System.Collections.Generic.IComparer%601> implementacją ogólnego interfejsu. Elementy `array` muszą być już posortowane rosnąco, zgodnie z porządkiem sortowania zdefiniowanym przez `comparer`; w przeciwnym razie wynik może być niepoprawny.  
  
 Jeśli `comparer` jest `null`, porównanie odbywa się przy użyciu <xref:System.IComparable%601> implementacji ogólny interfejs dostarczony dla typu `T`. Elementy `array` muszą być już posortowane rosnąco, zgodnie z porządkiem sortowania zdefiniowanym przez <xref:System.IComparable%601> wdrażania; w przeciwnym razie wynik może być niepoprawny.  
  
 Dozwolone są zduplikowane elementy. Jeśli <xref:System.Array> zawiera więcej niż jeden element równy `value`, Metoda ta zwraca indeks tylko jednego wystąpienia ale niekoniecznie pierwszy z nich.  
  
 `null` zawsze można porównać z innym typem odwołania; w związku z tym, do porównania z wartością `null` nie wygeneruje wyjątek, korzystając z <xref:System.IComparable%601>.  
  
> [!NOTE]
>  Dla każdego badanego elementu `value` jest przekazywany do odpowiedniej <xref:System.IComparable%601> wdrożenia, nawet jeśli `value` jest `null`. Oznacza to, że <xref:System.IComparable%601> implementacja Określa, jak dany element można porównać do `null`.  
  
 Ta metoda jest O (log `n`) operacji, gdzie `n` jest `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.  
  
—lub— 
 <paramref name="length" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="length" /> nie określono prawidłowego zakresu <paramref name="array" />.  
  
—lub— 
 <paramref name="comparer" /> jest <see langword="null" />, i <paramref name="value" /> typu, który nie jest zgodny z elementami <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />, i <paramref name="T" /> nie implementuje <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Clear : Array * int * int -&gt; unit" Usage="System.Array.Clear (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica, której elementy muszą zostać wyczyszczone.</param>
        <param name="index">Indeks początkowy zakresu elementów, aby wyczyścić.</param>
        <param name="length">Liczba elementów do wyczyszczenia.</param>
        <summary>Ustawia zakres elementów w tablicy na wartość domyślną każdego typu elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powoduje zresetowanie każdego elementu w tablicy na wartość domyślną typu elementu. Ustawia elementy Typy odwołań (w tym <xref:System.String> elementy) do `null`i ustawia elementy typu wartości do wartości domyślne, pokazana w poniższej tabeli.  
  
|Typ|Wartość|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|Wszystkie typy liczbowe punktu całkowite i zmiennoprzecinkowe|0 (zero)|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|Inne typy wartości|Wartość domyślna pola typu|  
  
 Zakres wyczyszczone Zawijaj elementy wiersz po wierszu w tablicy wielowymiarowej.  
  
 Ta metoda usuwa tylko wartości elementów; nie powoduje usunięcia samych elementów. Tablica ma stały rozmiar; w związku z tym elementów nie można dodać ani usunąć.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest `length`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Array.Clear%2A> metodę, aby zresetować wartości całkowitych w tablicy jednowymiarowa dwuwymiarowej i trójwymiarowych.  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 W poniższym przykładzie zdefiniowano `TimeZoneTime` strukturę, która obejmuje <xref:System.TimeZoneInfo> pola i <xref:System.DateTimeOffset> pola. Następnie wywołuje <xref:System.Array.Clear%2A> metodę, aby wyczyścić jeden element w tablicy dwuelementową `TimeZoneTime` wartości. Metoda ustawia wartość elementu wyczyszczone wartość domyślną <xref:System.TimeZoneInfo> obiektu, który jest `null`i wartość domyślną <xref:System.DateTimeOffset> obiektu, który jest <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.  
  
—lub— 
 <paramref name="length" /> jest mniejsza niż zero.  
  
—lub— 
Suma <paramref name="index" /> i <paramref name="length" /> jest większy niż rozmiar <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="array.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię pobieżną <see cref="T:System.Array" />.</summary>
        <returns>Kopia pobieżna <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kopia pobieżna <xref:System.Array> kopiuje elementy ze <xref:System.Array>na to, czy typy odwołań i typy wartości, ale nie są kopiowane obiektów, które dotyczą odwołania. Odwołania w nowym <xref:System.Array> wskaż takie same obiekty, które odwołań w oryginalnym <xref:System.Array> wskaż.  
  
 Natomiast głębokie kopiowanie obiektu <xref:System.Array> kopiuje elementy i wszystko bezpośrednio lub pośrednio odwołuje się do elementów.  
  
 Klon jest tego samego <xref:System.Type> co oryginalny <xref:System.Array>.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A>.  
  
   
  
## Examples  
 Poniższy kod przykładowy klony <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> macierz, a następnie przedstawia działanie wykonywana jest płytka kopia.  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member ConstrainedCopy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.ConstrainedCopy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">
          <see cref="T:System.Array" /> Zawierający dane do skopiowania.</param>
        <param name="sourceIndex">32-bitowa liczba całkowita, która reprezentuje indeks w <paramref name="sourceArray" /> od rozpoczyna się kopiowanie które.</param>
        <param name="destinationArray">
          <see cref="T:System.Array" /> Który odbiera dane.</param>
        <param name="destinationIndex">32-bitowa liczba całkowita, która reprezentuje indeks w <paramref name="destinationArray" /> od przechowywania, który rozpoczyna się.</param>
        <param name="length">32-bitową liczbę całkowitą reprezentującą liczbę elementów do skopiowania.</param>
        <summary>Kopiuje szereg elementów z <see cref="T:System.Array" /> zaczynając od indeksu określonego źródła i wkleja je do innego <see cref="T:System.Array" /> zaczynając od indeksu w określonej lokalizacji docelowej.  Gwarantuje, że wszystkie zmiany zostaną cofnięte jeśli kopii nie powiedzie się całkowicie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` i `destinationArray` parametrów muszą mieć taką samą liczbę wymiarów.  `sourceArray` Typu musi być taka sama jak lub pochodną `destinationArray` typu; w przeciwnym razie <xref:System.ArrayTypeMismatchException> zgłaszany.  W odróżnieniu od <xref:System.Array.Copy%2A>, <xref:System.Array.ConstrainedCopy%2A> sprawdza zgodność typów tablicowych przed wykonaniem żadnych operacji.  
  
 Podczas kopiowania między tablic wielowymiarowych, tablicy zachowuje się jak długo Jednowymiarowa tablica, której wiersze (lub kolumny) są koncepcyjnie ustanowione end-to-end. Jeśli na przykład tablica ma trzy wiersze (lub kolumny) z czterema elementami, skopiowanie sześciu elementów od początku tablicy może spowodować skopiowanie wszystkich czterech elementów pierwszego wiersza (lub kolumny) i pierwszych dwóch elementów drugiego wiersza (lub kolumny). Aby rozpocząć kopiowanie od drugiego elementu trzeci wiersz (lub kolumny), `sourceIndex` musi być górną granicę pierwszego wiersza (lub kolumny) plus Długość drugiego wiersza (lub kolumny) oraz dwa.  
  
 Jeśli `sourceArray` i `destinationArray` nakładają się na siebie, Metoda ta działa tak, jakby oryginalne wartości parametru `sourceArray` zostały zachowane w lokalizacji tymczasowej przed `destinationArray` zostanie zastąpiony.  
  
 [C++]  
  
 Ta metoda jest równoważna standardowej funkcji C/C++ `memmove`, a nie `memcpy`.  
  
 Tablice mogą być tablicami typu odwołania lub tablicami typu wartości.  Jeśli `sourceArray` i `destinationArray` obydwiema tablicami typu odwołania lub obydwiema tablicami typu <xref:System.Object>, płytka kopia. Kopia pobieżna <xref:System.Array> jest nowym <xref:System.Array> zawierające odwołania do tych samych elementów co oryginał <xref:System.Array>. Nie są kopiowane same elementy ani to, co odwołuje się do elementów. Natomiast głębokie kopiowanie obiektu <xref:System.Array> kopiuje elementy i wszystko bezpośrednio lub pośrednio odwołuje się do elementów.  
  
 Jeśli ta metoda zgłasza wyjątek podczas kopiowania, `destinationArray` pozostaje niezmieniona; dlatego <xref:System.Array.ConstrainedCopy%2A> mogą być używane w regionie ograniczonego wykonania (<xref:System.Runtime.ConstrainedExecution.Cer>).  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="destinationArray" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> i <paramref name="destinationArray" /> mają różną rangę.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> Jest żadna taka sama jak typ, ani pochodną <paramref name="destinationArray" /> typu.</exception>
        <exception cref="T:System.InvalidCastException">Co najmniej jeden element w <paramref name="sourceArray" /> nie można rzutować na typ <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> jest mniejsza niż dolna granica pierwszego wymiaru <paramref name="sourceArray" />.  
  
—lub— 
 <paramref name="destinationIndex" /> jest mniejsza niż dolna granica pierwszego wymiaru <paramref name="destinationArray" />.  
  
—lub— 
 <paramref name="length" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> jest większa niż liczba elementów od <paramref name="sourceIndex" /> na końcu <paramref name="sourceArray" />.  
  
—lub— 
 <paramref name="length" /> jest większa niż liczba elementów od <paramref name="destinationIndex" /> na końcu <paramref name="destinationArray" />.</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="static member ConvertAll : 'Input[] * Converter&lt;'Input, 'Output&gt; -&gt; 'Output[]" Usage="System.Array.ConvertAll (array, converter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Typ elementów tablicy źródłowej.</typeparam>
        <typeparam name="TOutput">Typ elementów tablicy docelowej.</typeparam>
        <param name="array">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> można przekonwertować na typ docelowy.</param>
        <param name="converter">A <see cref="T:System.Converter`2" /> , konwertuje każdy element z jednego typu na inny typ.</param>
        <summary>Konwertuje tablicę jednego typu na tablicę innego typu.</summary>
        <returns>Tablica typu docelowego zawierający elementy przekonwertowana z tablica źródłowa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602> Jest delegatem metody, która konwertuje obiekt na typ docelowy.  Elementy `array` są indywidualnie przekazywane do <xref:System.Converter%602>, i przekonwertowane elementy są zapisywane w nowej tablicy.  
  
 Źródło `array` pozostaje bez zmian.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu przedstawia metodę o nazwie `PointFToPoint` konwertująca <xref:System.Drawing.PointF> struktury do <xref:System.Drawing.Point> struktury. Przykład tworzy następnie tablicę <xref:System.Drawing.PointF> struktury, tworzy `Converter<PointF, Point>` delegowanie (`Converter(Of PointF, Point)` w języku Visual Basic) do reprezentowania `PointFToPoint` metody i przekazuje delegata do <xref:System.Array.ConvertAll%2A> metody. <xref:System.Array.ConvertAll%2A> Metoda kończy się powodzeniem każdy element listy danych wejściowych w celu `PointFToPoint` metody i umieszcza elementy przekonwertowana z nową listę <xref:System.Drawing.Point> struktury. Zarówno listy są wyświetlane.  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="converter" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiuje zakres elementów w jednym <see cref="T:System.Array" /> do innego <see cref="T:System.Array" /> i wykonuje typ rzutowania i pakowanie, zgodnie z potrzebami.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">
          <see cref="T:System.Array" /> Zawierający dane do skopiowania.</param>
        <param name="destinationArray">
          <see cref="T:System.Array" /> Który odbiera dane.</param>
        <param name="length">32-bitową liczbę całkowitą reprezentującą liczbę elementów do skopiowania.</param>
        <summary>Kopiuje szereg elementów z <see cref="T:System.Array" /> począwszy od pierwszego elementu i wkleja je do innego <see cref="T:System.Array" /> zaczynając od pierwszego elementu. Długość jest określona jako 32-bitową liczbę całkowitą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` i `destinationArray` parametrów muszą mieć taką samą liczbę wymiarów. Ponadto `destinationArray` musi już mieć wymiary i musi mieć wystarczającą liczbę elementów do uwzględnienia skopiowane dane.  
  
 Podczas kopiowania między tablic wielowymiarowych, tablicy zachowuje się jak długo Jednowymiarowa tablica, której wiersze (lub kolumny) są koncepcyjnie określić typu end to end. Jeśli na przykład tablica ma trzy wiersze (lub kolumny) z czterema elementami, skopiowanie sześciu elementów od początku tablicy może spowodować skopiowanie wszystkich czterech elementów pierwszego wiersza (lub kolumny) i pierwszych dwóch elementów drugiego wiersza (lub kolumny).  
  
 Jeśli `sourceArray` i `destinationArray` nakładają się na siebie, Metoda ta działa tak, jakby oryginalne wartości parametru `sourceArray` zostały zachowane w lokalizacji tymczasowej przed `destinationArray` zostanie zastąpiony.  
  
 [C++]  
  
 Ta metoda jest równoważna standardowej funkcji C/C++ `memmove`, a nie `memcpy`.  
  
 Tablice mogą być tablicami typu odwołania lub tablicami typu wartości. Rzutowanie typu w dół jest wykonywane odpowiednio do potrzeb.  
  
-   Podczas kopiowania z tablicy typu odwołania do tablicy typu wartości każdy element jest rozpakowywany, a następnie kopiowany. Podczas kopiowania z tablicy wartości typu do tablicy typu odwołania każdy element jest pakowany, a następnie kopiowany.  
  
-   Podczas kopiowania z tablicy typu odwołania lub typu wartości do <xref:System.Object> tablicy, <xref:System.Object> jest utworzona w celu przechowywania każdej wartości lub odwołania, a następnie kopiowany. Podczas kopiowania z <xref:System.Object> tablicy do tablicy typu odwołania lub typu wartości i przypisania nie jest możliwe, <xref:System.InvalidCastException> zgłaszany.  
  
-   Jeśli `sourceArray` i `destinationArray` obydwiema tablicami typu odwołania lub obydwiema tablicami typu <xref:System.Object>, płytka kopia. Kopia pobieżna <xref:System.Array> jest nowym <xref:System.Array> zawierające odwołania do tych samych elementów co oryginał <xref:System.Array>. Nie są kopiowane same elementy ani to, co odwołuje się do elementów. Natomiast głębokie kopiowanie obiektu <xref:System.Array> kopiuje elementy i wszystko bezpośrednio lub pośrednio odwołuje się do elementów.  
  
 <xref:System.ArrayTypeMismatchException> Jest generowany, jeśli tablice mają niezgodne typy. Zgodność z typem jest zdefiniowana w następujący sposób:  
  
-   Typ jest zgodny z samym sobą.  
  
-   Typ wartości jest zgodny z <xref:System.Object> i z typem interfejsu implementowanym przez ten typ wartości. Typ wartości jest uważany za podłączony do interfejsu tylko wtedy, gdy bezpośrednio implementuje ten interfejs. Odłączony typy nie są zgodne.  
  
-   Dwa typy rzeczywistej wartości wewnętrznej (wstępnie zdefiniowane) są zgodne w przypadku kopiowania z typu źródłowego na typ docelowy w konwersji rozszerzającej. Konwersja rozszerzająca nigdy nie traci informacji, podczas gdy konwersja zawężająca może utracić informacje. Na przykład konwersja 32-bitowej oznaczonej liczby całkowitej na 64-bitową jest konwersją rozszerzającą, a 64-bitowej oznaczonej liczby całkowitej na 32-bitową jest konwersją zawężającą. Aby uzyskać więcej informacji dotyczących konwersji, zobacz <xref:System.Convert>.  
  
-   Typ wartości niewewnętrznej (zdefiniowanej przez użytkownika) jest zgodny tylko z samym sobą.  
  
-   Wyliczenia mają niejawną konwersję do <xref:System.Enum> i ich typu podstawowego.  
  
 Jeśli każdy element w kolekcji `sourceArray` wymaga rzutowania (na przykład z klasy bazowej do klasy pochodnej lub z interfejsu na obiekt) i jeden lub więcej elementów nie można rzutować na odpowiedni typ w `destinationArray`, <xref:System.InvalidCastException> zgłaszany.  
  
 Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan `destinationArray` jest niezdefiniowana.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="destinationArray" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> i <paramref name="destinationArray" /> mają różną rangę.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> i <paramref name="destinationArray" /> mają niezgodne typy.</exception>
        <exception cref="T:System.InvalidCastException">Co najmniej jeden element w <paramref name="sourceArray" /> nie można rzutować na typ <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> jest większa niż liczba elementów w <paramref name="sourceArray" />.  
  
—lub— 
 <paramref name="length" /> jest większa niż liczba elementów w <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">
          <see cref="T:System.Array" /> Zawierający dane do skopiowania.</param>
        <param name="destinationArray">
          <see cref="T:System.Array" /> Który odbiera dane.</param>
        <param name="length">64-bitową liczbę całkowitą reprezentującą liczbę elementów do skopiowania. Liczba całkowita musi należeć do zakresu od zera i <see cref="F:System.Int32.MaxValue" />włącznie.</param>
        <summary>Kopiuje szereg elementów z <see cref="T:System.Array" /> począwszy od pierwszego elementu i wkleja je do innego <see cref="T:System.Array" /> zaczynając od pierwszego elementu. Długość jest określona jako 64-bitową liczbę całkowitą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` i `destinationArray` parametrów muszą mieć taką samą liczbę wymiarów. Ponadto `destinationArray` musi już mieć wymiary i musi mieć wystarczającą liczbę elementów do uwzględnienia skopiowane dane.  
  
 Podczas kopiowania między tablic wielowymiarowych, tablicy zachowuje się jak długo Jednowymiarowa tablica, której wiersze (lub kolumny) są koncepcyjnie określić typu end to end. Jeśli na przykład tablica ma trzy wiersze (lub kolumny) z czterema elementami, skopiowanie sześciu elementów od początku tablicy może spowodować skopiowanie wszystkich czterech elementów pierwszego wiersza (lub kolumny) i pierwszych dwóch elementów drugiego wiersza (lub kolumny).  
  
 Jeśli `sourceArray` i `destinationArray` nakładają się na siebie, Metoda ta działa tak, jakby oryginalne wartości parametru `sourceArray` zostały zachowane w lokalizacji tymczasowej przed `destinationArray` zostanie zastąpiony.  
  
 [C++]  
  
 Ta metoda jest równoważna standardowej funkcji C/C++ `memmove`, a nie `memcpy`.  
  
 Tablice mogą być tablicami typu odwołania lub tablicami typu wartości. Rzutowanie typu w dół jest wykonywane odpowiednio do potrzeb.  
  
-   Podczas kopiowania z tablicy typu odwołania do tablicy typu wartości każdy element jest rozpakowywany, a następnie kopiowany. Podczas kopiowania z tablicy wartości typu do tablicy typu odwołania każdy element jest pakowany, a następnie kopiowany.  
  
-   Podczas kopiowania z tablicy typu odwołania lub typu wartości do <xref:System.Object> tablicy, <xref:System.Object> jest utworzona w celu przechowywania każdej wartości lub odwołania, a następnie kopiowany. Podczas kopiowania z <xref:System.Object> tablicy do tablicy typu odwołania lub typu wartości i przypisania nie jest możliwe, <xref:System.InvalidCastException> zgłaszany.  
  
-   Jeśli `sourceArray` i `destinationArray` obydwiema tablicami typu odwołania lub obydwiema tablicami typu <xref:System.Object>, płytka kopia. Kopia pobieżna <xref:System.Array> jest nowym <xref:System.Array> zawierające odwołania do tych samych elementów co oryginał <xref:System.Array>. Nie są kopiowane same elementy ani to, co odwołuje się do elementów. Natomiast głębokie kopiowanie obiektu <xref:System.Array> kopiuje elementy i wszystko bezpośrednio lub pośrednio odwołuje się do elementów.  
  
 <xref:System.ArrayTypeMismatchException> Jest generowany, jeśli tablice mają niezgodne typy. Zgodność z typem jest zdefiniowana w następujący sposób:  
  
-   Typ jest zgodny z samym sobą.  
  
-   Typ wartości jest zgodny z <xref:System.Object> i z typem interfejsu implementowanym przez ten typ wartości. Typ wartości jest uważany za podłączony do interfejsu tylko wtedy, gdy bezpośrednio implementuje ten interfejs. Odłączony typy nie są zgodne.  
  
-   Dwa typy rzeczywistej wartości wewnętrznej (wstępnie zdefiniowane) są zgodne w przypadku kopiowania z typu źródłowego na typ docelowy w konwersji rozszerzającej. Konwersja rozszerzająca nigdy nie traci informacji, podczas gdy konwersja zawężająca może utracić informacje. Na przykład konwersja 32-bitowej oznaczonej liczby całkowitej na 64-bitową jest konwersją rozszerzającą, a 64-bitowej oznaczonej liczby całkowitej na 32-bitową jest konwersją zawężającą. Aby uzyskać więcej informacji dotyczących konwersji, zobacz <xref:System.Convert>.  
  
-   Typ wartości niewewnętrznej (zdefiniowanej przez użytkownika) jest zgodny tylko z samym sobą.  
  
-   Wyliczenia mają niejawną konwersję do <xref:System.Enum> i ich typu podstawowego.  
  
 Jeśli każdy element w kolekcji `sourceArray` wymaga rzutowania (na przykład z klasy bazowej do klasy pochodnej lub z interfejsu na obiekt) i jeden lub więcej elementów nie można rzutować na odpowiedni typ w `destinationArray`, <xref:System.InvalidCastException> zgłaszany.  
  
 Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan `destinationArray` jest niezdefiniowana.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="destinationArray" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> i <paramref name="destinationArray" /> mają różną rangę.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> i <paramref name="destinationArray" /> mają niezgodne typy.</exception>
        <exception cref="T:System.InvalidCastException">Co najmniej jeden element w <paramref name="sourceArray" /> nie można rzutować na typ <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> jest mniejsza niż 0 lub większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> jest większa niż liczba elementów w <paramref name="sourceArray" />.  
  
—lub— 
 <paramref name="length" /> jest większa niż liczba elementów w <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">
          <see cref="T:System.Array" /> Zawierający dane do skopiowania.</param>
        <param name="sourceIndex">32-bitowa liczba całkowita, która reprezentuje indeks w <paramref name="sourceArray" /> od rozpoczyna się kopiowanie które.</param>
        <param name="destinationArray">
          <see cref="T:System.Array" /> Który odbiera dane.</param>
        <param name="destinationIndex">32-bitowa liczba całkowita, która reprezentuje indeks w <paramref name="destinationArray" /> od przechowywania, który rozpoczyna się.</param>
        <param name="length">32-bitową liczbę całkowitą reprezentującą liczbę elementów do skopiowania.</param>
        <summary>Kopiuje szereg elementów z <see cref="T:System.Array" /> zaczynając od indeksu określonego źródła i wkleja je do innego <see cref="T:System.Array" /> zaczynając od indeksu w określonej lokalizacji docelowej. Długość i indeksy są określane jako 32-bitowych liczb całkowitych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` i `destinationArray` parametrów muszą mieć taką samą liczbę wymiarów. Ponadto `destinationArray` musi już mieć wymiary i musi mieć wystarczającą liczbę elementów, poczynając od `destinationIndex` pozycji, aby pomieścić dane skopiowane.  
  
 Podczas kopiowania między tablic wielowymiarowych, tablicy zachowuje się jak długo Jednowymiarowa tablica, której wiersze (lub kolumny) są koncepcyjnie ustanowione end-to-end. Jeśli na przykład tablica ma trzy wiersze (lub kolumny) z czterema elementami, skopiowanie sześciu elementów od początku tablicy może spowodować skopiowanie wszystkich czterech elementów pierwszego wiersza (lub kolumny) i pierwszych dwóch elementów drugiego wiersza (lub kolumny). Aby rozpocząć kopiowanie od drugiego elementu trzeci wiersz (lub kolumny), `sourceIndex` musi być górną granicę pierwszego wiersza (lub kolumny) plus Długość drugiego wiersza (lub kolumny) oraz dwa.  
  
 Jeśli `sourceArray` i `destinationArray` nakładają się na siebie, Metoda ta działa tak, jakby oryginalne wartości parametru `sourceArray` zostały zachowane w lokalizacji tymczasowej przed `destinationArray` zostanie zastąpiony.  
  
 [C++]  
  
 Ta metoda jest równoważna standardowej funkcji C/C++ `memmove`, a nie `memcpy`.  
  
 Tablice mogą być tablicami typu odwołania lub tablicami typu wartości. Rzutowanie typu w dół jest wykonywane odpowiednio do potrzeb.  
  
-   Podczas kopiowania z tablicy typu odwołania do tablicy typu wartości każdy element jest rozpakowywany, a następnie kopiowany. Podczas kopiowania z tablicy wartości typu do tablicy typu odwołania każdy element jest pakowany, a następnie kopiowany.  
  
-   Podczas kopiowania z tablicy typu odwołania lub typu wartości do <xref:System.Object> tablicy, <xref:System.Object> jest utworzona w celu przechowywania każdej wartości lub odwołania, a następnie kopiowany. Podczas kopiowania z <xref:System.Object> tablicy do tablicy typu odwołania lub typu wartości i przypisania nie jest możliwe, <xref:System.InvalidCastException> zgłaszany.  
  
-   Jeśli `sourceArray` i `destinationArray` obydwiema tablicami typu odwołania lub obydwiema tablicami typu <xref:System.Object>, płytka kopia. Kopia pobieżna <xref:System.Array> jest nowym <xref:System.Array> zawierające odwołania do tych samych elementów co oryginał <xref:System.Array>. Nie są kopiowane same elementy ani to, co odwołuje się do elementów. Natomiast głębokie kopiowanie obiektu <xref:System.Array> kopiuje elementy i wszystko bezpośrednio lub pośrednio odwołuje się do elementów.  
  
 <xref:System.ArrayTypeMismatchException> Jest generowany, jeśli tablice mają niezgodne typy. Zgodność z typem jest zdefiniowana w następujący sposób:  
  
-   Typ jest zgodny z samym sobą.  
  
-   Typ wartości jest zgodny z <xref:System.Object> i z typem interfejsu implementowanym przez ten typ wartości. Typ wartości jest uważany za podłączony do interfejsu tylko wtedy, gdy bezpośrednio implementuje ten interfejs. Odłączony typy nie są zgodne.  
  
-   Dwa typy rzeczywistej wartości wewnętrznej (wstępnie zdefiniowane) są zgodne w przypadku kopiowania z typu źródłowego na typ docelowy w konwersji rozszerzającej. Konwersja rozszerzająca nigdy nie traci informacji, podczas gdy konwersja zawężająca może utracić informacje. Na przykład konwersja 32-bitowej oznaczonej liczby całkowitej na 64-bitową jest konwersją rozszerzającą, a 64-bitowej oznaczonej liczby całkowitej na 32-bitową jest konwersją zawężającą. Aby uzyskać więcej informacji dotyczących konwersji, zobacz <xref:System.Convert>.  
  
-   Typ wartości niewewnętrznej (zdefiniowanej przez użytkownika) jest zgodny tylko z samym sobą.  
  
-   Wyliczenia mają niejawną konwersję do <xref:System.Enum> i ich typu podstawowego.  
  
 Jeśli każdy element w kolekcji `sourceArray` wymaga rzutowania (na przykład z klasy bazowej do klasy pochodnej lub z interfejsu na obiekt) i jeden lub więcej elementów nie można rzutować na odpowiedni typ w `destinationArray`, <xref:System.InvalidCastException> zgłaszany.  
  
 Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan `destinationArray` jest niezdefiniowana.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób kopiowania z jednego <xref:System.Array> typu <xref:System.Object> do innego <xref:System.Array> typu Integer.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="destinationArray" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> i <paramref name="destinationArray" /> mają różną rangę.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> i <paramref name="destinationArray" /> mają niezgodne typy.</exception>
        <exception cref="T:System.InvalidCastException">Co najmniej jeden element w <paramref name="sourceArray" /> nie można rzutować na typ <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> jest mniejsza niż dolna granica pierwszego wymiaru <paramref name="sourceArray" />.  
  
—lub— 
 <paramref name="destinationIndex" /> jest mniejsza niż dolna granica pierwszego wymiaru <paramref name="destinationArray" />.  
  
—lub— 
 <paramref name="length" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> jest większa niż liczba elementów od <paramref name="sourceIndex" /> na końcu <paramref name="sourceArray" />.  
  
—lub— 
 <paramref name="length" /> jest większa niż liczba elementów od <paramref name="destinationIndex" /> na końcu <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int64 * Array * int64 * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int64" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">
          <see cref="T:System.Array" /> Zawierający dane do skopiowania.</param>
        <param name="sourceIndex">64-bitowa liczba całkowita, która reprezentuje indeks w <paramref name="sourceArray" /> od rozpoczyna się kopiowanie które.</param>
        <param name="destinationArray">
          <see cref="T:System.Array" /> Który odbiera dane.</param>
        <param name="destinationIndex">64-bitowa liczba całkowita, która reprezentuje indeks w <paramref name="destinationArray" /> od przechowywania, który rozpoczyna się.</param>
        <param name="length">64-bitową liczbę całkowitą reprezentującą liczbę elementów do skopiowania. Liczba całkowita musi należeć do zakresu od zera i <see cref="F:System.Int32.MaxValue" />włącznie.</param>
        <summary>Kopiuje szereg elementów z <see cref="T:System.Array" /> zaczynając od indeksu określonego źródła i wkleja je do innego <see cref="T:System.Array" /> zaczynając od indeksu w określonej lokalizacji docelowej. Długość i indeksy są określane jako 64-bitowych liczb całkowitych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` i `destinationArray` parametrów muszą mieć taką samą liczbę wymiarów. Ponadto `destinationArray` musi już mieć wymiary i musi mieć wystarczającą liczbę elementów, poczynając od `destinationIndex` pozycji, aby pomieścić dane skopiowane.  
  
 Podczas kopiowania między tablic wielowymiarowych, tablicy zachowuje się jak długo Jednowymiarowa tablica, której wiersze (lub kolumny) są koncepcyjnie ustanowione end-to-end. Jeśli na przykład tablica ma trzy wiersze (lub kolumny) z czterema elementami, skopiowanie sześciu elementów od początku tablicy może spowodować skopiowanie wszystkich czterech elementów pierwszego wiersza (lub kolumny) i pierwszych dwóch elementów drugiego wiersza (lub kolumny). Aby rozpocząć kopiowanie od drugiego elementu trzeci wiersz (lub kolumny), `sourceIndex` musi być górną granicę pierwszego wiersza (lub kolumny) plus Długość drugiego wiersza (lub kolumny) oraz dwa.  
  
 Jeśli `sourceArray` i `destinationArray` nakładają się na siebie, Metoda ta działa tak, jakby oryginalne wartości parametru `sourceArray` zostały zachowane w lokalizacji tymczasowej przed `destinationArray` zostanie zastąpiony.  
  
 [C++]  
  
 Ta metoda jest równoważna standardowej funkcji C/C++ `memmove`, a nie `memcpy`.  
  
 Tablice mogą być tablicami typu odwołania lub tablicami typu wartości. Rzutowanie typu w dół jest wykonywane odpowiednio do potrzeb.  
  
-   Podczas kopiowania z tablicy typu odwołania do tablicy typu wartości każdy element jest rozpakowywany, a następnie kopiowany. Podczas kopiowania z tablicy wartości typu do tablicy typu odwołania każdy element jest pakowany, a następnie kopiowany.  
  
-   Podczas kopiowania z tablicy typu odwołania lub typu wartości do <xref:System.Object> tablicy, <xref:System.Object> jest utworzona w celu przechowywania każdej wartości lub odwołania, a następnie kopiowany. Podczas kopiowania z <xref:System.Object> tablicy do tablicy typu odwołania lub typu wartości i przypisania nie jest możliwe, <xref:System.InvalidCastException> zgłaszany.  
  
-   Jeśli `sourceArray` i `destinationArray` obydwiema tablicami typu odwołania lub obydwiema tablicami typu <xref:System.Object>, płytka kopia. Kopia pobieżna <xref:System.Array> jest nowym <xref:System.Array> zawierające odwołania do tych samych elementów co oryginał <xref:System.Array>. Nie są kopiowane same elementy ani to, co odwołuje się do elementów. Natomiast głębokie kopiowanie obiektu <xref:System.Array> kopiuje elementy i wszystko bezpośrednio lub pośrednio odwołuje się do elementów.  
  
 <xref:System.ArrayTypeMismatchException> Jest generowany, jeśli tablice mają niezgodne typy. Zgodność z typem jest zdefiniowana w następujący sposób:  
  
-   Typ jest zgodny z samym sobą.  
  
-   Typ wartości jest zgodny z <xref:System.Object> i z typem interfejsu implementowanym przez ten typ wartości. Typ wartości jest uważany za podłączony do interfejsu tylko wtedy, gdy bezpośrednio implementuje ten interfejs. Odłączony typy nie są zgodne.  
  
-   Dwa typy rzeczywistej wartości wewnętrznej (wstępnie zdefiniowane) są zgodne w przypadku kopiowania z typu źródłowego na typ docelowy w konwersji rozszerzającej. Konwersja rozszerzająca nigdy nie traci informacji, podczas gdy konwersja zawężająca może utracić informacje. Na przykład konwersja 32-bitowej oznaczonej liczby całkowitej na 64-bitową jest konwersją rozszerzającą, a 64-bitowej oznaczonej liczby całkowitej na 32-bitową jest konwersją zawężającą. Aby uzyskać więcej informacji dotyczących konwersji, zobacz <xref:System.Convert>.  
  
-   Typ wartości niewewnętrznej (zdefiniowanej przez użytkownika) jest zgodny tylko z samym sobą.  
  
-   Wyliczenia mają niejawną konwersję do <xref:System.Enum> i ich typu podstawowego.  
  
 Jeśli każdy element w kolekcji `sourceArray` wymaga rzutowania (na przykład z klasy bazowej do klasy pochodnej lub z interfejsu na obiekt) i jeden lub więcej elementów nie można rzutować na odpowiedni typ w `destinationArray`, <xref:System.InvalidCastException> zgłaszany.  
  
 Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan `destinationArray` jest niezdefiniowana.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób kopiowania z jednego <xref:System.Array> typu <xref:System.Object> do innego <xref:System.Array> typu Integer.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="destinationArray" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> i <paramref name="destinationArray" /> mają różną rangę.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> i <paramref name="destinationArray" /> mają niezgodne typy.</exception>
        <exception cref="T:System.InvalidCastException">Co najmniej jeden element w <paramref name="sourceArray" /> nie można rzutować na typ <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> znajduje się poza zakresem prawidłowych indeksów dla <paramref name="sourceArray" />.  
  
—lub— 
 <paramref name="destinationIndex" /> znajduje się poza zakresem prawidłowych indeksów dla <paramref name="destinationArray" />.  
  
—lub— 
 <paramref name="length" /> jest mniejsza niż 0 lub większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> jest większa niż liczba elementów od <paramref name="sourceIndex" /> na końcu <paramref name="sourceArray" />.  
  
—lub— 
 <paramref name="length" /> jest większa niż liczba elementów od <paramref name="destinationIndex" /> na końcu <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiuje wszystkie elementy bieżącej tablicy jednowymiarowej do określonej tablicy jednowymiarowej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która jest lokalizacją docelową elementów kopiowanych z bieżącej tablicy.</param>
        <param name="index">32-bitowa liczba całkowita, która reprezentuje indeks w <paramref name="array" /> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopiuje wszystkie elementy w bieżącej tablicy jednowymiarowej do określonej tablicy jednowymiarowej, zaczynając od indeksu tablicy w określonej lokalizacji docelowej. Indeks jest określony jako 32-bitową liczbę całkowitą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kopiuje wszystkie elementy w bieżącym wystąpieniu tablicy do `array` docelowej tablicy, zaczynając od indeksu `index`. `array` Tablicy docelowej musi już mieć wymiary i musi mieć wystarczającą liczbę elementów do uwzględnienia skopiowane elementy. W przeciwnym razie metoda zgłasza wyjątek.  
  
 Ta metoda obsługuje <xref:System.Collections.ICollection?displayProperty=nameWithType> interfejsu. W przypadku implementowania <xref:System.Collections.ICollection?displayProperty=nameWithType> jest wymagane nie zostały jawnie, użyj <xref:System.Array.Copy%2A> Aby uniknąć dodatkowych pośredniego.  
  
 Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan `array` jest niezdefiniowana.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A>. Wykonuje płytką kopię tylko.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób kopiowania <xref:System.Array> do innego <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 Poniższy przykład kodu pokazuje sposób kopiowania <xref:System.Array> do innego <xref:System.Array> z dolną granicą wartość różną od zera. Należy pamiętać, że całe źródło <xref:System.Array> jest kopiowany, łącznie z pustych elementów, które zastąpią istniejące elementy w elemencie docelowym <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> ma charakter wielowymiarowy.  
  
—lub— 
Liczba elementów w tablicy źródłowej jest większa niż liczba dostępnych elementów z <paramref name="index" /> do końca tablicy docelowej <paramref name="array" />.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Typ źródła <see cref="T:System.Array" /> nie można automatycznie rzutować na typ docelowy <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">Tablica źródłowa jest wielowymiarowy.</exception>
        <exception cref="T:System.InvalidCastException">Co najmniej jeden element w źródle <see cref="T:System.Array" /> nie można rzutować na typ docelowy <paramref name="array" />.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która jest lokalizacją docelową elementów kopiowanych z bieżącej tablicy.</param>
        <param name="index">64-bitowa liczba całkowita, która reprezentuje indeks w <paramref name="array" /> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopiuje wszystkie elementy w bieżącej tablicy jednowymiarowej do określonej tablicy jednowymiarowej, zaczynając od indeksu tablicy w określonej lokalizacji docelowej. Indeks jest określony jako 64-bitową liczbę całkowitą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda kopiuje wszystkie elementy w bieżącym wystąpieniu tablicy do `array` docelowej tablicy, zaczynając od indeksu `index`. `array` Tablicy docelowej musi już mieć wymiary i musi mieć wystarczającą liczbę elementów do uwzględnienia skopiowane elementy. W przeciwnym razie metoda zgłasza wyjątek.  
  
 Ta metoda obsługuje <xref:System.Collections.ICollection?displayProperty=nameWithType> interfejsu. W przypadku implementowania <xref:System.Collections.ICollection?displayProperty=nameWithType> jest wymagane nie zostały jawnie, użyj <xref:System.Array.Copy%2A> Aby uniknąć dodatkowych pośredniego.  
  
 Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan `array` jest niezdefiniowana.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A>. Wykonuje płytką kopię tylko.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób kopiowania <xref:System.Array> do innego <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 Poniższy przykład kodu pokazuje sposób kopiowania <xref:System.Array> do innego <xref:System.Array> z dolną granicą wartość różną od zera. Należy pamiętać, że całe źródło <xref:System.Array> jest kopiowany, łącznie z pustych elementów, które zastąpią istniejące elementy w elemencie docelowym <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> znajduje się poza zakresem prawidłowych indeksów dla <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> ma charakter wielowymiarowy.  
  
—lub— 
Liczba elementów w tablicy źródłowej jest większa niż liczba dostępnych elementów z <paramref name="index" /> do końca tablicy docelowej <paramref name="array" />.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Typ źródła <see cref="T:System.Array" /> nie można automatycznie rzutować na typ docelowy <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">Źródło <see cref="T:System.Array" /> ma charakter wielowymiarowy.</exception>
        <exception cref="T:System.InvalidCastException">Co najmniej jeden element w źródle <see cref="T:System.Array" /> nie można rzutować na typ docelowy <paramref name="array" />.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Array" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">
          <see cref="T:System.Type" /> z <see cref="T:System.Array" /> do utworzenia.</param>
        <param name="length">Rozmiar <see cref="T:System.Array" /> do utworzenia.</param>
        <summary>Tworzy jednowymiarową <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> i długość, za pomocą indeksowania zaczynającego się od zera.</summary>
        <returns>Nowy jednowymiarowa <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> o określonej długości, za pomocą indeksowania zaczynającego się od zera.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości klas <xref:System.Array> zapewnia <xref:System.Array.CreateInstance%2A> metody zamiast publicznych konstruktory, aby umożliwić dostępu.  
  
 Elementy typu odwołania są inicjowane `null`. Elementy typu wartości są inicjowane od zera.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć i zainicjować jednowymiarową <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> nie jest prawidłowym <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> nie jest obsługiwane. Na przykład <see cref="T:System.Void" /> nie jest obsługiwane.  
  
—lub— 
 <paramref name="elementType" /> jest to otwarty typ ogólny.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> jest mniejsza niż zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">
          <see cref="T:System.Type" /> z <see cref="T:System.Array" /> do utworzenia.</param>
        <param name="lengths">Tablica 32-bitowych liczb całkowitych reprezentujących rozmiar każdego wymiaru <see cref="T:System.Array" /> do utworzenia.</param>
        <summary>Tworzy wielowymiarowe <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> i wymiar długości, za pomocą indeksowania zaczynającego się od zera. Długości wymiarów są określone w tablicy 32-bitowych liczb całkowitych.</summary>
        <returns>Nowy wielowymiarowe <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> o określonej długości dla każdego wymiaru przy użyciu indeksowania zaczynającego się od zera.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości klas <xref:System.Array> zapewnia <xref:System.Array.CreateInstance%2A> metody zamiast publicznych konstruktory, aby umożliwić dostępu.  
  
 Liczba elementów w `lengths` tablicy musi być równa liczba wymiarów w nowym <xref:System.Array>. Każdy element obiektu `lengths` tablicy należy określić długości odpowiedniego wymiaru w nowym <xref:System.Array>.  
  
 Elementy typu odwołania są inicjowane `null`. Elementy typu wartości są inicjowane od zera.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest produktem wszystkich wartości w `lengths`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć i zainicjować wielowymiarowe <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="lengths" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> nie jest prawidłowym <see cref="T:System.Type" />.  
  
—lub— 
<paramref name="lengths" /> Tablica zawiera mniej niż jeden element.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> nie jest obsługiwane. Na przykład <see cref="T:System.Void" /> nie jest obsługiwane.  
  
—lub— 
 <paramref name="elementType" /> jest to otwarty typ ogólny.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Dowolna wartość <paramref name="lengths" /> jest mniejsza niż zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int64[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">
          <see cref="T:System.Type" /> z <see cref="T:System.Array" /> do utworzenia.</param>
        <param name="lengths">64-bitowych liczb całkowitych reprezentujących rozmiar każdego wymiaru tablicy <see cref="T:System.Array" /> do utworzenia. Każda liczba całkowita w tablicy musi mieć długość od zera i <see cref="F:System.Int32.MaxValue" />włącznie.</param>
        <summary>Tworzy wielowymiarowe <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> i wymiar długości, za pomocą indeksowania zaczynającego się od zera. Długości wymiarów są określone w tablicy, 64-bitowych liczb całkowitych.</summary>
        <returns>Nowy wielowymiarowe <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> o określonej długości dla każdego wymiaru przy użyciu indeksowania zaczynającego się od zera.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości klas <xref:System.Array> zapewnia <xref:System.Array.CreateInstance%2A> metody zamiast publicznych konstruktory, aby umożliwić dostępu.  
  
 Liczba elementów w `lengths` tablicy musi być równa liczba wymiarów w nowym <xref:System.Array>. Każdy element obiektu `lengths` tablicy należy określić długości odpowiedniego wymiaru w nowym <xref:System.Array>.  
  
 Elementy typu odwołania są inicjowane `null`. Elementy typu wartości są inicjowane od zera.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest produktem wszystkich wartości w `lengths`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć i zainicjować wielowymiarowe <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="lengths" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> nie jest prawidłowym <see cref="T:System.Type" />.  
  
—lub— 
<paramref name="lengths" /> Tablica zawiera mniej niż jeden element.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> nie jest obsługiwane. Na przykład <see cref="T:System.Void" /> nie jest obsługiwane.  
  
—lub— 
 <paramref name="elementType" /> jest to otwarty typ ogólny.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Dowolna wartość <paramref name="lengths" /> jest mniejsza od zera lub większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">
          <see cref="T:System.Type" /> z <see cref="T:System.Array" /> do utworzenia.</param>
        <param name="length1">Rozmiar pierwszego wymiaru <see cref="T:System.Array" /> do utworzenia.</param>
        <param name="length2">Rozmiar drugiego wymiaru <see cref="T:System.Array" /> do utworzenia.</param>
        <summary>Tworzy dwuwymiarowy <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> i wymiar długości, za pomocą indeksowania zaczynającego się od zera.</summary>
        <returns>Nowy dwuwymiarową <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> o określonej długości dla każdego wymiaru przy użyciu indeksowania zaczynającego się od zera.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości klas <xref:System.Array> zapewnia <xref:System.Array.CreateInstance%2A> metody zamiast publicznych konstruktory, aby umożliwić dostępu.  
  
 Elementy typu odwołania są inicjowane `null`. Elementy typu wartości są inicjowane od zera.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest wynikiem `length1` i `length2`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć i zainicjować dwuwymiarowym <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> nie jest prawidłowym <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> nie jest obsługiwane. Na przykład <see cref="T:System.Void" /> nie jest obsługiwane.  
  
—lub— 
 <paramref name="elementType" /> jest to otwarty typ ogólny.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="length2" /> jest mniejsza niż zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths, lowerBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">
          <see cref="T:System.Type" /> z <see cref="T:System.Array" /> do utworzenia.</param>
        <param name="lengths">Jednowymiarowa tablica, która zawiera rozmiar każdego wymiaru <see cref="T:System.Array" /> do utworzenia.</param>
        <param name="lowerBounds">Jednowymiarowa tablica, która zawiera dolna granica (indeks początkowy) każdego wymiaru <see cref="T:System.Array" /> do utworzenia.</param>
        <summary>Tworzy wielowymiarowe <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> i wymiar długości, z określonym dolne granice.</summary>
        <returns>Nowy wielowymiarowe <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> o określonej długości i dolną granicę dla każdego wymiaru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości klas <xref:System.Array> zapewnia <xref:System.Array.CreateInstance%2A> metody zamiast publicznych konstruktory, aby umożliwić dostępu.  
  
 `lengths` i `lowerBounds` tablice muszą mieć taką samą liczbę elementów. Liczba elementów w `lengths` tablicy musi być równa liczba wymiarów w nowym <xref:System.Array>.  
  
 Każdy element obiektu `lengths` tablicy należy określić długości odpowiedniego wymiaru w nowym <xref:System.Array>.  
  
 Każdy element obiektu `lowerBounds` tablicy należy określić dolna granica odpowiedniego wymiaru w nowym <xref:System.Array>. Ogólnie rzecz biorąc biblioteki klas .NET Framework i wielu języków programowania nie obsługują wartość różną od zera dolne granice.  
  
 Elementy typu odwołania są inicjowane `null`. Elementy typu wartości są inicjowane od zera.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest produktem wszystkich wartości w `lengths`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć i zainicjować wielowymiarowe <xref:System.Array> przy użyciu określonego dolne granice.  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="lengths" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="lowerBounds" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> nie jest prawidłowym <see cref="T:System.Type" />.  
  
—lub— 
<paramref name="lengths" /> Tablica zawiera mniej niż jeden element.  
  
—lub— 
<paramref name="lengths" /> i <paramref name="lowerBounds" /> tablic nie zawierają taką samą liczbę elementów.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> nie jest obsługiwane. Na przykład <see cref="T:System.Void" /> nie jest obsługiwane.  
  
—lub— 
 <paramref name="elementType" /> jest to otwarty typ ogólny.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Dowolna wartość <paramref name="lengths" /> jest mniejsza niż zero.  
  
—lub— 
Dowolna wartość <paramref name="lowerBounds" /> jest bardzo duża, w taki sposób, że suma dolna granica wymiarów i długość jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2, length3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="length3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">
          <see cref="T:System.Type" /> z <see cref="T:System.Array" /> do utworzenia.</param>
        <param name="length1">Rozmiar pierwszego wymiaru <see cref="T:System.Array" /> do utworzenia.</param>
        <param name="length2">Rozmiar drugiego wymiaru <see cref="T:System.Array" /> do utworzenia.</param>
        <param name="length3">Rozmiar w trzecim wymiarze <see cref="T:System.Array" /> do utworzenia.</param>
        <summary>Tworzy trójwymiarowy <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> i wymiar długości, za pomocą indeksowania zaczynającego się od zera.</summary>
        <returns>Nowy trójwymiarowej <see cref="T:System.Array" /> określonego <see cref="T:System.Type" /> o określonej długości dla każdego wymiaru przy użyciu indeksowania zaczynającego się od zera.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przeciwieństwie do większości klas <xref:System.Array> zapewnia <xref:System.Array.CreateInstance%2A> metody zamiast publicznych konstruktory, aby umożliwić dostępu.  
  
 Elementy typu odwołania są inicjowane `null`. Elementy typu wartości są inicjowane od zera.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest wynikiem `length1`, `length2`, i `length3`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć i zainicjować trójwymiarowym <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> nie jest prawidłowym <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> nie jest obsługiwane. Na przykład <see cref="T:System.Void" /> nie jest obsługiwane.  
  
—lub— 
 <paramref name="elementType" /> jest to otwarty typ ogólny.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="length2" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="length3" /> jest mniejsza niż zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; 'T[]" Usage="System.Array.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <summary>Zwraca pustą tablicę.</summary>
        <returns>Zwraca pustą <see cref="T:System.Array" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Exists : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.Exists (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Definiuje warunki elementy do wyszukania.</param>
        <summary>Określa, czy określona tablica zawiera elementy odpowiadające warunkom zdefiniowanym przez określony predykat.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="array" /> zawiera jeden lub więcej elementów, które pasują do warunków zdefiniowanych przez określony predykat; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy `array` są indywidualnie przekazywane do <xref:System.Predicate%601>, a przetwarzanie jest zatrzymywany, gdy zostanie znalezione dopasowanie.  
  
> [!NOTE]
>  W języku C# i Visual Basic nie jest niezbędne do utworzenia <xref:System.Predicate%601> delegować w jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 W poniższym przykładzie określono warunków dopasowania <xref:System.Array.Exists%2A> wyrażeń usinglambda metody do sprawdzenia, czy globalnej rozpoczyna się od danej litery, lub czy planety znajduje się na danej tablicy.  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 W poniższym przykładzie użyto <xref:System.Array.Exists%2A> metodę w celu wskazania, czy wszystkie nazwy w tablicy ciągów zaczynają się od określonego znaku. Przykład tworzy `StringSearcher` obiektu, przekazując ciąg do wyszukania do jej konstruktora klasy. `StringSearcher.StartsWith` Metoda ma ten sam podpis, jak <xref:System.Predicate%601> delegować. Gdy <xref:System.Array.Exists%2A> metoda jest wywoływana, każdy element członkowski tablicy jest przekazywany do obiektu delegowanego, dopóki zwróci `true` lub dokonuje iteracji wszystkich elementów w tablicy.  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 Można również użyć wyrażenia lambda zamiast jawnie zdefiniować metodę, którego podpis odnosi się do tego delegata. Poniższy przykład zastępuje `StringSearcher` klasy i jego `StartsWith` metody za pomocą wyrażenia lambda.  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
        <related type="Article" href="~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md">Wyrażenia lambda (Przewodnik programowania w języku C#)</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md">Lambda — Wyrażenia (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T -&gt; unit" Usage="System.Array.Fill (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T * int * int -&gt; unit" Usage="System.Array.Fill (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Find : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.Find (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Tablica jednowymiarowo, zaczynający się od zera do wyszukiwania.</param>
        <param name="match">Predykat definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca pierwsze wystąpienie w ramach całego <see cref="T:System.Array" />.</summary>
        <returns>Pierwszy element, który pasuje do warunków zdefiniowanych przez określony predykat, jeśli znaleziono; w przeciwnym razie wartość domyślna dla typu <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegatem metody lub wyrażenie lambda, które zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi delegatem lub wyrażeniem lambda.  Elementy `array` są indywidualnie przekazywane do <xref:System.Predicate%601>, rozpoczynając od pierwszego elementu, a kończąc na ostatnim elemencie.  Przetwarzanie jest zatrzymywany, gdy zostanie znalezione dopasowanie.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Predicate%601> delegowanie przy użyciu <xref:System.Array.Find%2A> metodę rodzajową, aby wyszukać tablicę <xref:System.Drawing.Point> struktury. Metoda reprezentuje obiekt delegowany, `ProductGT10`, zwraca `true` Jeśli produktu X i Y pola jest większa niż 100 000. <xref:System.Array.Find%2A> Metoda wywołuje delegata dla każdego elementu tablicy, zwracanie pierwszego punktu, który spełnia warunek testu.  
  
> [!NOTE]
>  Visual Basic i C# użytkowników nie trzeba jawnie Utwórz delegata lub Określ argument typu metody ogólnej. Kompilatory określają wymaganych typów z argumenty metody, które dostarczasz.  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 Zamiast jawnie definiować metody podpisem konieczne utworzenie wystąpienia <xref:System.Predicate%601> delegować, a następnie przekazanie delegata do <xref:System.Array.Find%2A> metody jest zwyczajowego użycia wyrażenia lambda. Poniższy przykład jest taka sama jak poprzedni, z tą różnicą, że używa wyrażenia lambda jako `match` argumentu.  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindAll : 'T[] * Predicate&lt;'T&gt; -&gt; 'T[]" Usage="System.Array.FindAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Definiuje warunki elementy do wyszukania.</param>
        <summary>Pobiera wszystkie elementy odpowiadające warunkom zdefiniowanym przez określony predykat.</summary>
        <returns>
          <see cref="T:System.Array" /> Zawierający wszystkie elementy spełniających warunki zdefiniowane przez określony predykat, jeśli je znaleziono; w przeciwnym razie, pusta <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy `array` są indywidualnie przekazywane do <xref:System.Predicate%601>, a elementy, które spełniają warunki są zapisywane w zwróconej tablicy.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład tworzy tablicę liczb losowych 50 wartościami, które należą do zakresu od 0 do 1000. Następnie wywołuje <xref:System.Array.FindAll%2A> metody za pomocą wyrażenia lambda, które zwraca wartości zakresu od 300 do 600. Należy pamiętać, że wyrażenie lambda jest przekazywany parametr o nazwie `x`;  Ta pozycja reprezentuje poszczególne element członkowski, który jest przekazywany do <xref:System.Predicate%601>. Należy również zauważyć, że lokalna `lBound` i `uBound` zmienne są dostępne w wyrażeniu lambda.  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 Poniższy przykład kodu demonstruje <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, i <xref:System.Array.FindAll%2A> metod ogólnych. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. Przykładowy kod definiuje również metodę wyszukiwania predykatów o nazwie `EndsWithSaurus`, który przyjmuje parametr ciąg i zwraca wartość logiczną wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Array.Find%2A> Metody ogólnej przesyłane za pośrednictwem tablicy od początku, przekazywać z kolei do każdego elementu `EndsWithSaurus` metody. Wyszukiwanie zatrzymuje się, gdy `EndsWithSaurus` metoda zwraca `true` dla elementu "Amargasaurus".  
  
> [!NOTE]
>  W języku C# i Visual Basic nie jest niezbędne do utworzenia `Predicate<string>` delegowanie (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 <xref:System.Array.FindLast%2A> Metody ogólnej służy do wyszukiwania do tyłu od końca tablicy. Znajduje element „Dilophosaurus” w pozycji 5. <xref:System.Array.FindAll%2A> Metody ogólnej służy do zwracania tablicę zawierającą wszystkie elementy, które kończą się na "saurus". Elementy są wyświetlane.  
  
 Przykład kodu ilustruje też <xref:System.Array.Exists%2A> i <xref:System.Array.TrueForAll%2A> metod ogólnych.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks pierwszego wystąpienia w ramach <see cref="T:System.Array" /> lub jego część.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Definiuje warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks pierwszego wystąpienia w ramach całego <see cref="T:System.Array" />.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Przeszukiwany jest do przodu zaczynając od pierwszego elementu, a kończąc na ostatnim elemencie.  
  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy `array` są indywidualnie przekazywane do <xref:System.Predicate%601>.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wszystkich trzech przeciążeń <xref:System.Array.FindIndex%2A> metody rodzajowej. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. Przykładowy kod definiuje również metodę wyszukiwania predykatów o nazwie `EndsWithSaurus`, który przyjmuje parametr ciąg i zwraca wartość logiczną wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Przeciążenie metody przesyłane za pośrednictwem tablicy od początku, przekazywać z kolei do każdego elementu `EndsWithSaurus` metody. Wyszukiwanie zatrzymuje się, gdy `EndsWithSaurus` metoda zwraca `true` dla elementu na pozycji 1.  
  
> [!NOTE]
>  W języku C# i Visual Basic nie jest niezbędne do utworzenia `Predicate<string>` delegowanie (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Metoda przeciążenia służy do wyszukiwania tablicy, zaczynając od pozycji 2 i przechodzić do końca tablicy. Znajduje element w pozycji 5. Na koniec <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> metoda przeciążenia służy do wyszukiwania zakres trzy elementy, zaczynając od pozycji 2. Ponieważ nie ma nazw dinozaurów w tym zakresie kończących się ciągiem „saurus”, zwraca wartość –1.  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Definiuje warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks pierwszego wystąpienia w zakresie elementów w <see cref="T:System.Array" /> który rozciąga się od określonego indeksu do ostatniego elementu.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Jest przeszukiwany w przód od `startIndex` a kończąc na do ostatniego elementu.  
  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy `array` są indywidualnie przekazywane do <xref:System.Predicate%601>.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest liczba elementów od `startIndex` na końcu `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wszystkich trzech przeciążeń <xref:System.Array.FindIndex%2A> metody rodzajowej. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. Przykładowy kod definiuje również metodę wyszukiwania predykatów o nazwie `EndsWithSaurus`, który przyjmuje parametr ciąg i zwraca wartość logiczną wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Przeciążenie metody przesyłane za pośrednictwem tablicy od początku, przekazywać z kolei do każdego elementu `EndsWithSaurus` metody. Wyszukiwanie zatrzymuje się, gdy `EndsWithSaurus` metoda zwraca `true` dla elementu na pozycji 1.  
  
> [!NOTE]
>  W języku C# i Visual Basic nie jest niezbędne do utworzenia `Predicate<string>` delegowanie (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Metoda przeciążenia służy do wyszukiwania tablicy, zaczynając od pozycji 2 i przechodzić do końca tablicy. Znajduje element w pozycji 5. Na koniec <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> metoda przeciążenia służy do wyszukiwania zakres trzy elementy, zaczynając od pozycji 2. Ponieważ nie ma nazw dinozaurów w tym zakresie kończących się ciągiem „saurus”, zwraca wartość –1.  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem prawidłowych indeksów dla <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Definiuje warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks pierwszego wystąpienia w zakresie elementów w <see cref="T:System.Array" /> , rozpoczyna się od określonego indeksu i zawiera określoną liczbę elementów.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Jest przeszukiwany w przód od `startIndex` i kończące się wierszem `startIndex` oraz `count` minus 1, jeśli `count` jest większa niż 0.  
  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy `array` są indywidualnie przekazywane do <xref:System.Predicate%601>.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest `count`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wszystkich trzech przeciążeń <xref:System.Array.FindIndex%2A> metody rodzajowej. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. Przykładowy kod definiuje również metodę wyszukiwania predykatów o nazwie `EndsWithSaurus`, który przyjmuje parametr ciąg i zwraca wartość logiczną wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Przeciążenie metody przesyłane za pośrednictwem tablicy od początku, przekazywać z kolei do każdego elementu `EndsWithSaurus` metody. Wyszukiwanie zatrzymuje się, gdy `EndsWithSaurus` metoda zwraca `true` dla elementu na pozycji 1.  
  
> [!NOTE]
>  W języku C# i Visual Basic nie jest niezbędne do utworzenia `Predicate<string>` delegowanie (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Metoda przeciążenia służy do wyszukiwania tablicy, zaczynając od pozycji 2 i przechodzić do końca tablicy. Znajduje element w pozycji 5. Na koniec <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> metoda przeciążenia służy do wyszukiwania zakres trzy elementy, zaczynając od pozycji 2. Ponieważ nie ma nazw dinozaurów w tym zakresie kończących się ciągiem „saurus”, zwraca wartość –1.  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem prawidłowych indeksów dla <paramref name="array" />.  
  
—lub— 
 <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="startIndex" /> i <paramref name="count" /> nie określają prawidłowej sekcji w <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLast : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.FindLast (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Definiuje warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca ostatnie wystąpienie w ramach całego <see cref="T:System.Array" />.</summary>
        <returns>Ostatni element, który pasuje do warunków zdefiniowanych przez określony predykat, jeśli znaleziono; w przeciwnym razie wartość domyślna dla typu <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy `array` są indywidualnie przekazywane do <xref:System.Predicate%601>, przenoszenie do tyłu w <xref:System.Array>, począwszy od ostatniego elementu, a kończąc na pierwszy element.  Przetwarzanie jest zatrzymywany, gdy zostanie znalezione dopasowanie.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, i <xref:System.Array.FindAll%2A> metod ogólnych. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. Przykładowy kod definiuje również metodę wyszukiwania predykatów o nazwie `EndsWithSaurus`, który przyjmuje parametr ciąg i zwraca wartość logiczną wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Array.Find%2A> Metody ogólnej przesyłane za pośrednictwem tablicy od początku, przekazywać z kolei do każdego elementu `EndsWithSaurus` metody. Wyszukiwanie zatrzymuje się, gdy `EndsWithSaurus` metoda zwraca `true` dla elementu "Amargasaurus".  
  
> [!NOTE]
>  W języku C# i Visual Basic nie jest niezbędne do utworzenia`Predicate<string>` delegowanie (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 <xref:System.Array.FindLast%2A> Metody ogólnej służy do wyszukiwania do tyłu od końca tablicy. Znajduje element „Dilophosaurus” w pozycji 5. <xref:System.Array.FindAll%2A> Metody ogólnej służy do zwracania tablicę zawierającą wszystkie elementy, które kończą się na "saurus". Elementy są wyświetlane.  
  
 Przykład kodu ilustruje też <xref:System.Array.Exists%2A> i <xref:System.Array.TrueForAll%2A> metod ogólnych.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks ostatniego wystąpienia w ramach <see cref="T:System.Array" /> lub jego część.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Definiuje warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks ostatniego wystąpienia w ramach całego <see cref="T:System.Array" />.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Jest przeszukiwany w tył od ostatniego elementu, a kończąc na pierwszy element.  
  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy `array` są indywidualnie przekazywane do <xref:System.Predicate%601>.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wszystkich trzech przeciążeń <xref:System.Array.FindLastIndex%2A> metody rodzajowej. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. Przykładowy kod definiuje również metodę wyszukiwania predykatów o nazwie `EndsWithSaurus`, który przyjmuje parametr ciąg i zwraca wartość logiczną wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Przeciążenie metody przechodzi z poprzednimi wersjami tablicy od końca przekazywać z kolei do każdego elementu `EndsWithSaurus` metody. Wyszukiwanie zatrzymuje się, gdy `EndsWithSaurus` metoda zwraca `true` dla elementu w pozycji 5.  
  
> [!NOTE]
>  W języku C# i Visual Basic nie jest niezbędne do utworzenia `Predicate<string>` delegowanie (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Metoda przeciążenia służy do wyszukiwania tablicy, zaczynając od pozycji 4 i w dalszym ciągu wstecz początku tablicy. Znajduje element na pozycji 1. Na koniec <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> metoda przeciążenia służy do wyszukiwania zakres trzech elementów począwszy od pozycji 4 i pracą z nimi Wstecz (oznacza to, 4, 3 i 2). Ponieważ nie ma nazw dinozaurów w tym zakresie kończących się ciągiem „saurus”, zwraca wartość –1.  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Definiuje warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Array" /> który rozciąga się od pierwszego elementu zgodnie z określonym indeksem.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Jest wyszukiwanych ze starszymi wersjami zaczynając od `startIndex` a kończąc na pierwszy element.  
  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy `array` są indywidualnie przekazywane do <xref:System.Predicate%601>.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest liczba elementów od początku `array` do `startIndex`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wszystkich trzech przeciążeń <xref:System.Array.FindLastIndex%2A> metody rodzajowej. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. Przykładowy kod definiuje również metodę wyszukiwania predykatów o nazwie `EndsWithSaurus`, który przyjmuje parametr ciąg i zwraca wartość logiczną wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Przeciążenie metody przechodzi z poprzednimi wersjami tablicy od końca przekazywać z kolei do każdego elementu `EndsWithSaurus` metody. Wyszukiwanie zatrzymuje się, gdy `EndsWithSaurus` metoda zwraca `true` dla elementu w pozycji 5.  
  
> [!NOTE]
>  W języku C# i Visual Basic nie jest niezbędne do utworzenia `Predicate<string>` delegowanie (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Metoda przeciążenia służy do wyszukiwania tablicy, zaczynając od pozycji 4 i w dalszym ciągu wstecz początku tablicy. Znajduje element na pozycji 1. Na koniec <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> metoda przeciążenia służy do wyszukiwania zakres trzech elementów począwszy od pozycji 4 i pracą z nimi Wstecz (oznacza to, 4, 3 i 2). Ponieważ nie ma nazw dinozaurów w tym zakresie kończących się ciągiem „saurus”, zwraca wartość –1.  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem prawidłowych indeksów dla <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Definiuje warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Array" /> , zawierający określoną liczbę elementów, a kończy się na określony indeks.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Jest wyszukiwanych ze starszymi wersjami zaczynając od `startIndex` i kończące się wierszem `startIndex` minus `count` plus 1, jeśli `count` jest większa niż 0.  
  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy `array` są indywidualnie przekazywane do <xref:System.Predicate%601>.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest `count`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wszystkich trzech przeciążeń <xref:System.Array.FindLastIndex%2A> metody rodzajowej. Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”. Przykładowy kod definiuje również metodę wyszukiwania predykatów o nazwie `EndsWithSaurus`, który przyjmuje parametr ciąg i zwraca wartość logiczną wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> Przeciążenie metody przechodzi z poprzednimi wersjami tablicy od końca przekazywać z kolei do każdego elementu `EndsWithSaurus` metody. Wyszukiwanie zatrzymuje się, gdy `EndsWithSaurus` metoda zwraca `true` dla elementu w pozycji 5.  
  
> [!NOTE]
>  W języku C# i Visual Basic nie jest niezbędne do utworzenia `Predicate<string>` delegowanie (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Metoda przeciążenia służy do wyszukiwania tablicy, zaczynając od pozycji 4 i w dalszym ciągu wstecz początku tablicy. Znajduje element na pozycji 1. Na koniec <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> metoda przeciążenia służy do wyszukiwania zakres trzech elementów począwszy od pozycji 4 i pracą z nimi Wstecz (oznacza to, 4, 3 i 2). Ponieważ nie ma nazw dinozaurów w tym zakresie kończących się ciągiem „saurus”, zwraca wartość –1.  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem prawidłowych indeksów dla <paramref name="array" />.  
  
—lub— 
 <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="startIndex" /> i <paramref name="count" /> nie określają prawidłowej sekcji w <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member ForEach : 'T[] * Action&lt;'T&gt; -&gt; unit" Usage="System.Array.ForEach (array, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> elementów, których ma być wykonywane działania.</param>
        <param name="action">
          <see cref="T:System.Action`1" /> Do wykonania dla każdego elementu <paramref name="array" />.</param>
        <summary>Wykonuje określoną czynność dla każdego elementu w określonej tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601> Jest przekazany obiekt delegowany do metody, która wykonuje akcję na obiekcie.  Elementy `array` są indywidualnie przekazywane do <xref:System.Action%601>.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Array.ForEach%2A> do wyświetlenia kwadratów każdego elementu w tablicę liczb całkowitych.  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="action" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="array.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Collections.IEnumerator" /> dla <see cref="T:System.Array" />.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> Dla <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 `foreach` Instrukcja języka C# (`for each` w języku C++, `For Each` w języku Visual Basic) powoduje ukrycie złożoności modułów wyliczających. W związku z tym, za pomocą `foreach` jest to zalecane, zamiast bezpośredniego wykonywania operacji modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> Przełącza moduł wyliczający do tej pozycji.  W tym miejscu <xref:System.Collections.IEnumerator.Current%2A> jest niezdefiniowana. W związku z tym, należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> do wyprzedzeniem modułu wyliczającego do pierwszego elementu kolekcji przed odczytaniem wartości właściwości <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> zwraca ten sam obiekt, do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przebiegów koniec kolekcji, moduł wyliczający jest umieszczany za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu, kolejne wywołania <xref:System.Collections.IEnumerator.MoveNext%2A> również zwracać `false`. Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił `false`, <xref:System.Collections.IEnumerator.Current%2A> jest niezdefiniowana. Aby ustawić <xref:System.Collections.IEnumerator.Current%2A> do pierwszego elementu w kolekcji ponownie wywołaj <xref:System.Collections.IEnumerator.Reset%2A> następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie czy usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniany, a jego zachowanie staje się niezdefiniowane.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji w związku z tym wyliczanie w kolekcji nie jest wewnętrznie bezpieczne procedury wątku.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Array.GetEnumerator%2A> Aby wyświetlić listę elementów tablicy.  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLength : int -&gt; int" Usage="array.GetLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Liczony od zera wymiaru <see cref="T:System.Array" /> trzeba określić o długości.</param>
        <summary>Pobiera 32-bitowa liczba całkowita, która reprezentuje liczbę elementów w określonym wymiarze <see cref="T:System.Array" />.</summary>
        <returns>32-bitową liczbę całkowitą reprezentującą liczbę elementów w określonym wymiarze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przykładem <xref:System.Array.GetLength%2A> jest `GetLength(0)`, która zwraca liczbę elementów w pierwszym wymiarze <xref:System.Array>.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Array.GetLength%2A> do wyświetlenia wymiary dwóch tablic o różnym stopniu.  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="dimension" /> jest równa lub większa niż <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLongLength : int -&gt; int64" Usage="array.GetLongLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Liczony od zera wymiaru <see cref="T:System.Array" /> trzeba określić o długości.</param>
        <summary>Pobiera 64-bitowa liczba całkowita, która reprezentuje liczbę elementów w określonym wymiarze <see cref="T:System.Array" />.</summary>
        <returns>64-bitową liczbę całkowitą reprezentującą liczbę elementów w określonym wymiarze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przykładem <xref:System.Array.GetLongLength%2A> jest `GetLongLength(0)`, która zwraca liczbę elementów w pierwszym wymiarze <xref:System.Array>.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="dimension" /> jest równa lub większa niż <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLowerBound : int -&gt; int" Usage="array.GetLowerBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Liczony od zera wymiar tablicy, w których indeks początkowy trzeba określić.</param>
        <summary>Pobiera indeks pierwszego elementu określonego wymiaru tablicy.</summary>
        <returns>Indeks pierwszego elementu określonego wymiaru tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)` Zwraca wartość początkowa indeksu pierwszego wymiaru tablicy, a `GetLowerBound(Rank - 1)` zwraca indeks początkowy ostatniego wymiaru tablicy.  
  
 <xref:System.Array.GetLowerBound%2A> Metoda zawsze zwraca wartość, która wskazuje indeks dolna granica tablicy, nawet jeśli tablica jest pusta.  
  
 Należy zauważyć, że, mimo że większość tablic w programie .NET Framework są oparte na zerze (czyli <xref:System.Array.GetLowerBound%2A> metoda zwraca wartość zero dla każdego wymiaru tablicy), .NET Framework obsługuje tablic, które nie są oparte na zerze. Można tworzyć z tymi macierzami <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29> metody, a także mogą być zwracane z niezarządzanego kodu.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metody do wyświetlania granice tablicy jednowymiarowej i dwuwymiarowej i wyświetla wartości elementów tablicy.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="dimension" /> jest równa lub większa niż <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetUpperBound : int -&gt; int" Usage="array.GetUpperBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Liczony od zera wymiar tablicy, w których górną granicę, trzeba określić.</param>
        <summary>Pobiera indeks ostatniego elementu określonego wymiaru tablicy.</summary>
        <returns>Indeks ostatniego elementu określonego wymiaru w tablicy lub -1, jeśli określony wymiar jest pusty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)` Zwraca ostatni indeks pierwszego wymiaru tablicy, a `GetUpperBound(Rank - 1)` zwraca ostatni indeks ostatniego wymiaru tablicy.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metody do wyświetlania granice tablicy jednowymiarowej i dwuwymiarowej i wyświetla wartości elementów tablicy.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="dimension" /> jest równa lub większa niż <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wartość określonego elementu w bieżącym <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">32-bitowa liczba całkowita, która reprezentuje pozycję <see cref="T:System.Array" /> elementu do pobrania.</param>
        <summary>Pobiera wartość w określonej pozycji w jednowymiarowy <see cref="T:System.Array" />. Indeks jest określony jako 32-bitową liczbę całkowitą.</summary>
        <returns>Wartość w określonej pozycji w jednowymiarowy <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy wartość `index` jest poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżący <see cref="T:System.Array" /> nie ma dokładnie jednego wymiaru.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> znajduje się poza zakresem prawidłowych indeksów dla bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Jednowymiarowa tablica 32-bitowych liczb całkowitych, reprezentujących indeksy określające pozycję <see cref="T:System.Array" /> elementu do pobrania.</param>
        <summary>Pobiera wartość w określonej pozycji w wielowymiarowych <see cref="T:System.Array" />. Indeksy są określane jako tablica 32-bitowych liczb całkowitych.</summary>
        <returns>Wartość w określonej pozycji w wielowymiarowych <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba elementów w `indices` musi być równa liczbie wymiarów w <xref:System.Array>. Wszystkie elementy w `indices` tablicy muszą wspólnie określać położenie żądanego elementu w wielowymiarowych <xref:System.Array>.  
  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy indeksy są poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba wymiarów w bieżącym <see cref="T:System.Array" /> nie jest równa liczbie elementów w <paramref name="indices" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Dowolny element w <paramref name="indices" /> znajduje się poza zakresem prawidłowego indeksowania dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">64-bitowa liczba całkowita, która reprezentuje pozycję <see cref="T:System.Array" /> elementu do pobrania.</param>
        <summary>Pobiera wartość w określonej pozycji w jednowymiarowy <see cref="T:System.Array" />. Indeks jest określony jako 64-bitową liczbę całkowitą.</summary>
        <returns>Wartość w określonej pozycji w jednowymiarowy <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy wartość `index` jest poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżący <see cref="T:System.Array" /> nie ma dokładnie jednego wymiaru.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> znajduje się poza zakresem prawidłowych indeksów dla bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Jednowymiarowa tablica, 64-bitowych liczb całkowitych, reprezentujących indeksy określające pozycję <see cref="T:System.Array" /> elementu do pobrania.</param>
        <summary>Pobiera wartość w określonej pozycji w wielowymiarowych <see cref="T:System.Array" />. Indeksy są określane jako tablica 64-bitowych liczb całkowitych.</summary>
        <returns>Wartość w określonej pozycji w wielowymiarowych <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba elementów w `indices` musi być równa liczbie wymiarów w <xref:System.Array>. Wszystkie elementy w `indices` tablicy muszą wspólnie określać położenie żądanego elementu w wielowymiarowych <xref:System.Array>.  
  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy indeksy są poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba wymiarów w bieżącym <see cref="T:System.Array" /> nie jest równa liczbie elementów w <paramref name="indices" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Dowolny element w <paramref name="indices" /> znajduje się poza zakresem prawidłowego indeksowania dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">32-bitowa liczba całkowita, która reprezentuje indeks pierwszego wymiaru <see cref="T:System.Array" /> elementu do pobrania.</param>
        <param name="index2">32-bitowa liczba całkowita, która reprezentuje indeks drugiego wymiaru <see cref="T:System.Array" /> elementu do pobrania.</param>
        <summary>Pobiera wartość w określonej pozycji w dwuwymiarowej <see cref="T:System.Array" />. Indeksy są określane jako 32-bitowe liczby całkowite.</summary>
        <returns>Wartość w określonej pozycji w dwuwymiarowej <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy indeksy są poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżący <see cref="T:System.Array" /> nie ma dokładnie dwóch wymiarów.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Albo <paramref name="index1" /> lub <paramref name="index2" /> znajduje się poza zakresem prawidłowego indeksowania dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">64-bitowa liczba całkowita, która reprezentuje indeks pierwszego wymiaru <see cref="T:System.Array" /> elementu do pobrania.</param>
        <param name="index2">64-bitowa liczba całkowita, która reprezentuje indeks drugiego wymiaru <see cref="T:System.Array" /> elementu do pobrania.</param>
        <summary>Pobiera wartość w określonej pozycji w dwuwymiarowej <see cref="T:System.Array" />. Indeksy są określane jako 64-bitowych liczb całkowitych.</summary>
        <returns>Wartość w określonej pozycji w dwuwymiarowej <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy indeksy są poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżący <see cref="T:System.Array" /> nie ma dokładnie dwóch wymiarów.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Albo <paramref name="index1" /> lub <paramref name="index2" /> znajduje się poza zakresem prawidłowego indeksowania dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int * int -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">32-bitowa liczba całkowita, która reprezentuje indeks pierwszego wymiaru <see cref="T:System.Array" /> elementu do pobrania.</param>
        <param name="index2">32-bitowa liczba całkowita, która reprezentuje indeks drugiego wymiaru <see cref="T:System.Array" /> elementu do pobrania.</param>
        <param name="index3">32-bitowa liczba całkowita, która reprezentuje indeks trzeciego wymiaru <see cref="T:System.Array" /> elementu do pobrania.</param>
        <summary>Pobiera wartość w określonej pozycji w trójwymiarowej <see cref="T:System.Array" />. Indeksy są określane jako 32-bitowe liczby całkowite.</summary>
        <returns>Wartość w określonej pozycji w trójwymiarowej <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy indeksy są poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżący <see cref="T:System.Array" /> nie ma dokładnie trzech wymiarów.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> lub <paramref name="index2" /> lub <paramref name="index3" /> znajduje się poza zakresem prawidłowego indeksowania dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">64-bitowa liczba całkowita, która reprezentuje indeks pierwszego wymiaru <see cref="T:System.Array" /> elementu do pobrania.</param>
        <param name="index2">64-bitowa liczba całkowita, która reprezentuje indeks drugiego wymiaru <see cref="T:System.Array" /> elementu do pobrania.</param>
        <param name="index3">64-bitowa liczba całkowita, która reprezentuje indeks trzeciego wymiaru <see cref="T:System.Array" /> elementu do pobrania.</param>
        <summary>Pobiera wartość w określonej pozycji w trójwymiarowej <see cref="T:System.Array" />. Indeksy są określane jako 64-bitowych liczb całkowitych.</summary>
        <returns>Wartość w określonej pozycji w trójwymiarowej <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy indeksy są poza zakresem.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżący <see cref="T:System.Array" /> nie ma dokładnie trzech wymiarów.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> lub <paramref name="index2" /> lub <paramref name="index3" /> znajduje się poza zakresem prawidłowego indeksowania dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje określonego obiektu i zwraca indeks jego pierwszego wystąpienia w tablicy jednowymiarowej lub zakres elementów w tablicy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która do wyszukiwania.</param>
        <param name="value">Obiekt do zlokalizowania w <paramref name="array" />.</param>
        <summary>Wyszukuje określonego obiektu i zwraca indeks swoje pierwsze wystąpienie jednowymiarowej tablicy.</summary>
        <returns>Indeks pierwszego wystąpienia <paramref name="value" /> w <paramref name="array" />, jeśli znaleziono; w przeciwnym razie dolna granica tablicy minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta wyszukuje wszystkie elementy jednowymiarowa arrayfor `value`. Aby określić, czy `value` istnieje w `array`, metoda przeprowadza porównanie równości, wywołując każdy element `Equals` metody do momentu znalezienia dopasowania. Oznacza to, że jeśli zastępuje element <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> wywoływana jest metoda, zastąpienie.  
  
 Ponieważ większość tablic ma dolną granicę równą zero, Metoda ta zazwyczaj zwraca -1, jeśli`value` nie zostanie znaleziona. W rzadkich przypadkach, dolna granica tablicy jest równa <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) i `value` nie zostanie odnaleziony, Metoda ta zwraca <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Przykład wywołuje następujących trzech przeciążeń <xref:System.Array.IndexOf%2A> metody do znalezienia indeksu ciągu w tablicy ciągów:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, aby określić pierwsze wystąpienie ciągu "", w tablicy ciągów.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, aby określić pierwsze wystąpienie ciągu "" w czwartym do ostatnich elementów tablicy ciągów.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, aby określić pierwsze wystąpienie ciągu "" w ciągu tablicy z elementu, który następuje ostatniego pomyślnego dopasowania do końca tablicy.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ma charakter wielowymiarowy.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która do wyszukiwania.</param>
        <param name="value">Obiekt do zlokalizowania w <paramref name="array" />.</param>
        <param name="startIndex">Wartość początkowa indeksu wyszukiwania. 0 (zero) jest prawidłową wartością w pustej tablicy.</param>
        <summary>Wyszukuje określony obiekt w zakresie elementów tablicy jednowymiarowej, a następnie zwraca indeks jej pierwszego wystąpienia. Z zakresu od określonego indeksu do końca tablicy.</summary>
        <returns>Indeks pierwszego wystąpienia <paramref name="value" />, jeśli zostanie znaleziony, w zakresie elementów w <paramref name="array" /> rozciąga się od <paramref name="startIndex" /> do ostatniego elementu; w przeciwnym razie dolna granica tablicy minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta wyszukuje Jednowymiarowa tablica z elementu o indeksie `startIndex` do ostatniego elementu. Aby określić, czy `value` istnieje w `array`, metoda przeprowadza porównanie równości, wywołując `Equals` metoda każdego elementu, do momentu znalezienia dopasowania. Oznacza to, że jeśli zastępuje element <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> wywoływana jest metoda, zastąpienie.  
  
 Ponieważ większość tablic ma dolną granicę równą zero, Metoda ta zazwyczaj zwraca -1, jeśli `value` nie zostanie znaleziona. W rzadkich przypadkach, dolna granica tablicy jest równa <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) i `value` nie zostanie odnaleziony, Metoda ta zwraca <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Jeśli `startIndex` jest równa <xref:System.Array.Length%2A?displayProperty=nameWithType>, metoda zwraca wartość -1. Jeśli `startIndex` jest większa niż <xref:System.Array.Length%2A?displayProperty=nameWithType>, metoda zgłasza <xref:System.ArgumentOutOfRangeException>.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest liczba elementów od `startIndex` na końcu `array`.  
  
   
  
## Examples  
 Przykład wywołuje następujących trzech przeciążeń <xref:System.Array.IndexOf%2A> metody do znalezienia indeksu ciągu w tablicy ciągów:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, aby określić pierwsze wystąpienie ciągu "", w tablicy ciągów.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, aby określić pierwsze wystąpienie ciągu "" w czwartym do ostatnich elementów tablicy ciągów.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, aby określić pierwsze wystąpienie ciągu "" w ciągu tablicy z elementu, który następuje ostatniego pomyślnego dopasowania do końca tablicy.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem prawidłowych indeksów dla <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ma charakter wielowymiarowy.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która do wyszukiwania.</param>
        <param name="value">Obiekt do zlokalizowania w <paramref name="array" />.</param>
        <param name="startIndex">Wartość początkowa indeksu wyszukiwania. 0 (zero) jest prawidłową wartością w pustej tablicy.</param>
        <param name="count">Liczba elementów do wyszukania.</param>
        <summary>Wyszukuje określony obiekt w zakresie elementów tablicy jednowymiarowej, a następnie zwraca indeks pierwszego wystąpienia ifs. Z zakresu od określonego indeksu dla określonej liczby elementów.</summary>
        <returns>Indeks pierwszego wystąpienia <paramref name="value" />, jeśli został znaleziony w <paramref name="array" /> z indeksu <paramref name="startIndex" /> do <paramref name="startIndex" />  +  <paramref name="count" /> — 1; w przeciwnym razie dolna granica tablicy minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta wyszukuje elementy jednowymiarowa arrayfrom `startIndex` do `startIndex` oraz `count` minus 1, jeśli `count` jest większa niż 0. Aby określić, czy `value` istnieje w `array`, metoda przeprowadza porównanie równości, wywołując `Equals` metoda każdego elementu, do momentu znalezienia dopasowania. Oznacza to, że jeśli zastępuje element <xref:System.Object.Equals%2A?displayProperty=nameWithType> wywoływana jest metoda, zastąpienie.  
  
 Becausemost tablic ma dolną granicę równą zero, ta metoda zwraca wartość-1, gdy `value` nie zostanie znaleziona. W rzadkich przypadkach, dolna granica tablicy jest równa <xref:System.Int32.MinValue?displayProperty=nameWithType> (0x80000000) i `value` nie zostanie odnaleziony, Metoda ta zwraca <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Jeśli `startindex` jest równa <xref:System.Array.Length%2A?displayProperty=nameWithType>, metoda zwraca wartość -1. Jeśli `startIndex` jest większa niż <xref:System.Array.Length%2A?displayProperty=nameWithType>, metoda zgłasza <xref:System.ArgumentOutOfRangeException>.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest `count`.  
  
   
  
## Examples  
 Przykład wywołuje następujących trzech przeciążeń <xref:System.Array.IndexOf%2A> metody do znalezienia indeksu ciągu w tablicy ciągów:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, aby określić pierwsze wystąpienie ciągu "", w tablicy ciągów.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, aby określić pierwsze wystąpienie ciągu "" w czwartym do ostatnich elementów tablicy ciągów.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, aby określić pierwsze wystąpienie ciągu "" w ciągu tablicy z elementu, który następuje ostatniego pomyślnego dopasowania do końca tablicy. Aby określić wartość `count` argument, odejmuje górna granica tablicy od indeks początkowy i dodaje jeden.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem prawidłowych indeksów dla <paramref name="array" />.  
  
—lub— 
 <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="startIndex" /> i <paramref name="count" /> nie określają prawidłowej sekcji w <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ma charakter wielowymiarowy.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Tablica jednowymiarowo, zaczynający się od zera do wyszukiwania.</param>
        <param name="value">Obiekt do zlokalizowania w <paramref name="array" />.</param>
        <summary>Wyszukuje określonego obiektu i zwraca indeks swoje pierwsze wystąpienie jednowymiarowej tablicy.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia <paramref name="value" /> w całej <paramref name="array" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta wyszukuje wszystkie elementy tablicy jednowymiarowej dla `value`. Aby określić, czy `value` istnieje w `array`, metoda przeprowadza porównanie równości, wywołując `T.Equals` metody dla każdego elementu. Oznacza to, że jeśli `T` zastępuje <xref:System.Object.Equals%2A> wywoływana jest metoda, zastąpienie.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkich trzech ogólnych przeciążeń <xref:System.Array.IndexOf%2A> metody. Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> Przeciążenie metody przeszukuje tablicy od początku, a znajduje pierwsze wystąpienie ciągu. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Metoda przeciążenia służy do wyszukiwania w tablicy, począwszy od indeksu lokalizacja 3 i przechodzić do końca tablicy i znajduje drugie wystąpienie ciągu. Na koniec <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> metoda przeciążenia służy do wyszukiwania szeroką gamę dwóch wpisów, rozpoczynając od lokalizacji indeksu dwóch; zwraca -1, ponieważ żadnych wystąpień wyszukiwanego ciągu w tym zakresie.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Tablica jednowymiarowo, zaczynający się od zera do wyszukiwania.</param>
        <param name="value">Obiekt do zlokalizowania w <paramref name="array" />.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania. 0 (zero) jest prawidłową wartością w pustej tablicy.</param>
        <summary>Wyszukuje określony obiekt w zakresie elementów Jednowymiarowa tablica, a następnie zwraca indeks jej pierwszego wystąpienia. Z zakresu od określonego indeksu do końca tablicy.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia <paramref name="value" /> w zakresie elementów w <paramref name="array" /> rozciąga się od <paramref name="startIndex" /> do ostatniego elementu, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta wyszukuje Jednowymiarowa tablica z elementu w `startIndex` do końca tablicy. Aby określić, czy `value` istnieje w `array`, metoda przeprowadza porównanie równości, wywołując `T.Equals` metody dla każdego elementu. Oznacza to, że jeśli `T` zastępuje <xref:System.Object.Equals%2A> wywoływana jest metoda, zastąpienie.  
  
 Jeśli `startIndex` jest równa <xref:System.Array.Length%2A>, metoda zwraca wartość - 1.If `startIndex` jest większa niż <xref:System.Array.Length%2A?displayProperty=nameWithType>, metoda zgłasza <xref:System.ArgumentOutOfRangeException>.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest liczba elementów od `startIndex` na końcu `array`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkich trzech ogólnych przeciążeń <xref:System.Array.IndexOf%2A> metody. Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> Przeciążenie metody przeszukuje tablicy od początku, a znajduje pierwsze wystąpienie ciągu. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Metoda przeciążenia służy do wyszukiwania w tablicy, począwszy od indeksu lokalizacja 3 i przechodzić do końca tablicy i znajduje drugie wystąpienie ciągu. Na koniec <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> metoda przeciążenia służy do wyszukiwania szeroką gamę dwóch wpisów, rozpoczynając od lokalizacji indeksu dwóch; zwraca -1, ponieważ żadnych wystąpień wyszukiwanego ciągu w tym zakresie.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem prawidłowych indeksów dla <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Tablica jednowymiarowo, zaczynający się od zera do wyszukiwania.</param>
        <param name="value">Obiekt do zlokalizowania w <paramref name="array" />.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania. 0 (zero) jest prawidłową wartością w pustej tablicy.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <summary>Wyszukuje określony obiekt w zakresie elementów tablicy jednowymiarowej, a następnie zwraca indeks jej pierwszego wystąpienia. Z zakresu od określonego indeksu dla określonej liczby elementów.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia <paramref name="value" /> w zakresie elementów w <paramref name="array" /> rozpoczynająca się w <paramref name="startIndex" /> i zawiera liczbę elementów wymienionych w <paramref name="count" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy searchesthe metody to Jednowymiarowa tablica z `startIndex` do `startIndex` oraz `count` minus 1, jeśli `count` jest większa niż 0. Aby określić, czy `value` istnieje w `array`, metoda przeprowadza porównanie równości, wywołując `T.Equals` metody dla każdego elementu. Oznacza to, że jeśli `T` zastępuje <xref:System.Object.Equals%2A> wywoływana jest metoda, zastąpienie.  
  
 Jeśli `startIndex` jest równa <xref:System.Array.Length%2A?displayProperty=nameWithType>, metoda zwraca wartość -1.  Jeśli `startIndex` jest większa niż <xref:System.Array.Length%2A?displayProperty=nameWithType>, metoda zgłasza <xref:System.ArgumentOutOfRangeException>.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest `count`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkich trzech ogólnych przeciążeń <xref:System.Array.IndexOf%2A> metody. Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> Przeciążenie metody przeszukuje tablicy od początku, a znajduje pierwsze wystąpienie ciągu. <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Metoda przeciążenia służy do wyszukiwania w tablicy, począwszy od indeksu lokalizacja 3 i przechodzić do końca tablicy i znajduje drugie wystąpienie ciągu. Na koniec <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> metoda przeciążenia służy do wyszukiwania szeroką gamę dwóch wpisów, rozpoczynając od lokalizacji indeksu dwóch; zwraca -1, ponieważ żadnych wystąpień wyszukiwanego ciągu w tym zakresie.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem prawidłowych indeksów dla <paramref name="array" />.  
  
—lub— 
 <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="startIndex" /> i <paramref name="count" /> nie określają prawidłowej sekcji w <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberSignature Language="F#" Value="member this.Initialize : unit -&gt; unit" Usage="array.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje każdy element typu wartości <see cref="T:System.Array" /> przez wywołanie konstruktora domyślnego typu wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda ma na celu kompilatory, które obsługują tablicami typu wartości; Większość użytkowników nie muszą tej metody. Nie może być używany na tablicami typu odwołania.  
  
 Jeśli <xref:System.Array> nie jest typem wartości <xref:System.Array> lub jeśli typ wartości nie ma domyślnego konstruktora <xref:System.Array> nie jest modyfikowany.  
  
 Typ wartości <xref:System.Array> może mieć żadnych dolną granicę i dowolną liczbę wymiarów.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A>.  
  
> [!CAUTION]
>  Tej metody można użyć tylko dla typów wartości, które mają konstruktory; jednak typów wartości, które są natywne dla języka C# ma konstruktorów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Array.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Array" /> ma stały rozmiar.</summary>
        <value>Ta właściwość jest zawsze <see langword="true" /> dla wszystkich tablic.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementuje <xref:System.Array.IsFixedSize%2A> właściwości, ponieważ jest to wymagane przez <xref:System.Collections.IList?displayProperty=nameWithType> interfejsu.  
  
 Tablica o stałym rozmiarze nie zezwala na dodawanie i usuwanie elementów po utworzeniu tablicy, ale pozwala modyfikować istniejące elementy.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Array.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Array" /> jest tylko do odczytu.</summary>
        <value>Ta właściwość jest zawsze <see langword="false" /> dla wszystkich tablic.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementuje <xref:System.Array.IsReadOnly%2A> właściwości, ponieważ jest to wymagane przez <xref:System.Collections.IList?displayProperty=nameWithType> interfejsu. Tablica, która jest tylko do odczytu nie umożliwia dodawania, usuwania lub modyfikowania elementów po utworzeniu tablicy.  
  
 Jeśli kolekcja tylko do odczytu, należy używać <xref:System.Collections> klasę, która implementuje <xref:System.Collections.IList?displayProperty=nameWithType> interfejsu.  
  
 Jeśli rzutowania lub przekonwertować tablicę do <xref:System.Collections.IList> obiektu interfejsu <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> właściwość zwraca `false`. Jednak jeśli rzutowania lub przekonwertować tablicę do <xref:System.Collections.Generic.IList%601> interfejsu `IsReadOnly` właściwość zwraca `true`.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Array.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy dostęp do <see cref="T:System.Array" /> jest synchronizowane (wątkowo).</summary>
        <value>Ta właściwość jest zawsze <see langword="false" /> dla wszystkich tablic.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementuje <xref:System.Array.IsSynchronized%2A> właściwości, ponieważ jest to wymagane przez <xref:System.Collections.ICollection?displayProperty=nameWithType> interfejsu.  
  
 Na podstawie klas .NET framework <xref:System.Array> Podaj swoją własną wersję zsynchronizowane za pomocą kolekcji <xref:System.Array.SyncRoot%2A> właściwości.  
  
 Klasy korzystające z tablicami, mogą także implementować własne synchronizacji przy użyciu <xref:System.Array.SyncRoot%2A> właściwości. Synchronizowanie kodu należy wykonywać operacje na `SyncRoot` kolekcji, a nie bezpośrednio w kolekcji. Gwarantuje to prawidłowe funkcjonowanie kolekcji, które są uzyskiwane z innych obiektów. W szczególności zachowuje właściwe synchronizacji z innych wątków, które mogą być jednocześnie modyfikowania kolekcji. Należy pamiętać, że niektóre implementacje <xref:System.Array.SyncRoot%2A> może zwrócić <xref:System.Array> sam.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie bezpieczne procedury wątku. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zablokować tablicy podczas całego procesu wyliczania, przy użyciu <xref:System.Array.SyncRoot%2A> właściwości.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca indeks ostatniego wystąpienia wartości w jednowymiarowym <see cref="T:System.Array" /> lub w części <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="value">Obiekt do zlokalizowania w <paramref name="array" />.</param>
        <summary>Wyszukuje określonego obiektu i zwraca indeks ostatniego wystąpienia w ramach całego jednowymiarowa <see cref="T:System.Array" />.</summary>
        <returns>Indeks ostatniego wystąpienia <paramref name="value" /> w obrębie całego <paramref name="array" />, jeśli znaleziono; w przeciwnym razie dolna granica tablicy minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jednowymiarowy <xref:System.Array> jest przeszukiwany w tył od ostatniego elementu, a kończąc na pierwszy element.  
  
 Elementy są porównywane z określoną wartością za pomocą <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody. Jeśli typ elementu jest typu niewewnętrznego (zdefiniowany przez użytkownika) `Equals` implementacji tego typu jest używany.  
  
 Ponieważ większość tablic ma dolną granicę równą zero, Metoda ta zazwyczaj zwraca – 1, gdy `value` nie zostanie znaleziony. W rzadkich przypadkach, dolna granica tablicy jest równa <xref:System.Int32.MinValue?displayProperty=nameWithType> i `value` nie zostanie znaleziony, Metoda ta zwraca <xref:System.Int32.MaxValue?displayProperty=nameWithType>, czyli `System.Int32.MinValue - 1`.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
 W programie .NET Framework 2.0, Metoda ta wykorzystuje <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody <xref:System.Array> ustalenie, czy <xref:System.Object> określony przez `value` parametr istnieje. We wcześniejszych wersjach programu .NET Framework oznaczanie to było wykonywane przy użyciu <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody `value` <xref:System.Object> sam.  
  
 <xref:System.IComparable.CompareTo%2A> metody `item` parametru na obiektach w kolekcji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak określić indeks ostatniego wystąpienia określony element w tablicy.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ma charakter wielowymiarowy.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="value">Obiekt do zlokalizowania w <paramref name="array" />.</param>
        <param name="startIndex">Wartość początkowa indeksu wyszukiwania z poprzednimi wersjami.</param>
        <summary>Wyszukuje określonego obiektu i zwraca indeks ostatniego wystąpienia w zakresie elementów w jednowymiarowy <see cref="T:System.Array" /> który rozciąga się od pierwszego elementu zgodnie z określonym indeksem.</summary>
        <returns>Indeks ostatniego wystąpienia <paramref name="value" /> w zakresie elementów w <paramref name="array" /> rozciąga się od pierwszego elementu na <paramref name="startIndex" />, jeśli znaleziono; w przeciwnym razie dolna granica tablicy minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jednowymiarowy <xref:System.Array> jest wyszukiwanych ze starszymi wersjami zaczynając od `startIndex` a kończąc na pierwszy element.  
  
 Elementy są porównywane z określoną wartością za pomocą <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody. Jeśli typ elementu jest typu niewewnętrznego (zdefiniowany przez użytkownika) `Equals` implementacji tego typu jest używany.  
  
 Ponieważ większość tablic ma dolną granicę równą zero, Metoda ta zazwyczaj zwraca – 1, gdy `value` nie zostanie znaleziony. W rzadkich przypadkach, dolna granica tablicy jest równa <xref:System.Int32.MinValue?displayProperty=nameWithType> i `value` nie zostanie znaleziony, Metoda ta zwraca <xref:System.Int32.MaxValue?displayProperty=nameWithType>, czyli `System.Int32.MinValue - 1`.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest liczba elementów od początku `array` do `startIndex`.  
  
 W programie .NET Framework 2.0, Metoda ta wykorzystuje <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody <xref:System.Array> ustalenie, czy <xref:System.Object> określony przez `value` parametr istnieje. We wcześniejszych wersjach programu .NET Framework oznaczanie to było wykonywane przy użyciu <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody `value` <xref:System.Object> sam.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak określić indeks ostatniego wystąpienia określony element w tablicy.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem prawidłowych indeksów dla <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ma charakter wielowymiarowy.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="value">Obiekt do zlokalizowania w <paramref name="array" />.</param>
        <param name="startIndex">Wartość początkowa indeksu wyszukiwania z poprzednimi wersjami.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <summary>Wyszukuje określonego obiektu i zwraca indeks ostatniego wystąpienia w zakresie elementów w jednowymiarowy <see cref="T:System.Array" /> zawierający określoną liczbę elementów i kończy się pod określonym indeksem.</summary>
        <returns>Indeks ostatniego wystąpienia <paramref name="value" /> w zakresie elementów w <paramref name="array" /> zawierającą liczbę elementów określony w <paramref name="count" /> i kończy się <paramref name="startIndex" />, jeśli znaleziono; w przeciwnym razie dolna granica tablicy minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jednowymiarowy <xref:System.Array> jest wyszukiwanych ze starszymi wersjami zaczynając od `startIndex` i kończące się wierszem `startIndex` minus `count` plus 1, jeśli `count` jest większa niż 0.  
  
 Elementy są porównywane z określoną wartością za pomocą <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody. Jeśli typ elementu jest typu niewewnętrznego (zdefiniowany przez użytkownika)`Equals` implementacji tego typu jest używany.  
  
 Ponieważ większość tablic ma dolną granicę równą zero, Metoda ta zazwyczaj zwraca – 1, gdy `value` nie zostanie znaleziony. W rzadkich przypadkach, dolna granica tablicy jest równa <xref:System.Int32.MinValue?displayProperty=nameWithType> i `value` nie zostanie znaleziony, Metoda ta zwraca <xref:System.Int32.MaxValue?displayProperty=nameWithType>, czyli `System.Int32.MinValue - 1`.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest `count`.  
  
 W programie .NET Framework 2.0, Metoda ta wykorzystuje <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody <xref:System.Array> ustalenie, czy <xref:System.Object> określony przez `value` parametr istnieje. We wcześniejszych wersjach programu .NET Framework oznaczanie to było wykonywane przy użyciu <xref:System.Object.Equals%2A> i <xref:System.IComparable.CompareTo%2A> metody `value` <xref:System.Object> sam.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak określić indeks ostatniego wystąpienia określony element w tablicy. Należy pamiętać, że <xref:System.Array.LastIndexOf%2A> metodą jest wyszukiwania do tyłu; w związku z tym, `count` musi być mniejsza niż lub równe (`startIndex` minus dolna granica tablicy powiększoną o 1).  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem prawidłowych indeksów dla <paramref name="array" />.  
  
—lub— 
 <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="startIndex" /> i <paramref name="count" /> nie określają prawidłowej sekcji w <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ma charakter wielowymiarowy.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="value">Obiekt do zlokalizowania w <paramref name="array" />.</param>
        <summary>Wyszukuje określonego obiektu i zwraca indeks ostatniego wystąpienia w ramach całego <see cref="T:System.Array" />.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia <paramref name="value" /> w obrębie całego <paramref name="array" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Jest przeszukiwany w tył od ostatniego elementu, a kończąc na pierwszy element.  
  
 Elementy są porównywane z określoną wartością za pomocą <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody. Jeśli typ elementu jest typu niewewnętrznego (zdefiniowany przez użytkownika) `Equals` implementacji tego typu jest używany.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wszystkich trzech ogólnych przeciążeń <xref:System.Array.LastIndexOf%2A> metody. Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> Przeciążenie metody przeszukuje całej tablicy, od końca, a drugie wystąpienie ciągu znajduje. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Metoda przeciążenia służy do wyszukiwania z poprzednimi wersjami początku tablicy z lokalizacją indeksu 3 i przechodzić do początku tablicy i znajduje pierwsze wystąpienie ciągu. Na koniec <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> metoda przeciążenia służy do wyszukiwania szeroką gamę cztery wpisy, rozpoczynając od lokalizacji indeksu 4 i rozszerzanie Wstecz (czyli wyszukuje elementy w lokalizacjach, 4, 3, 2 i 1); to wyszukiwanie zwraca -1, ponieważ żadnych wystąpień wyszukiwania ciąg, w tym zakresie.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="value">Obiekt do zlokalizowania w <paramref name="array" />.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <summary>Wyszukuje określonego obiektu i zwraca indeks ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Array" /> który rozciąga się od pierwszego elementu zgodnie z określonym indeksem.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia <paramref name="value" /> w zakresie elementów w <paramref name="array" /> rozciąga się od pierwszego elementu na <paramref name="startIndex" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Jest wyszukiwanych ze starszymi wersjami zaczynając od `startIndex` a kończąc na pierwszy element.  
  
 Elementy są porównywane z określoną wartością za pomocą <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody. Jeśli typ elementu jest typu niewewnętrznego (zdefiniowany przez użytkownika) `Equals` implementacji tego typu jest używany.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest liczba elementów od początku `array` do `startIndex`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wszystkich trzech ogólnych przeciążeń <xref:System.Array.LastIndexOf%2A> metody. Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> Przeciążenie metody przeszukuje całej tablicy, od końca, a drugie wystąpienie ciągu znajduje. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Metoda przeciążenia służy do wyszukiwania z poprzednimi wersjami początku tablicy z lokalizacją indeksu 3 i przechodzić do początku tablicy i znajduje pierwsze wystąpienie ciągu. Na koniec <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> metoda przeciążenia służy do wyszukiwania szeroką gamę cztery wpisy, rozpoczynając od lokalizacji indeksu 4 i rozszerzanie Wstecz (czyli wyszukuje elementy w lokalizacjach, 4, 3, 2 i 1); to wyszukiwanie zwraca -1, ponieważ żadnych wystąpień wyszukiwania ciąg, w tym zakresie.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem prawidłowych indeksów dla <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> do wyszukania.</param>
        <param name="value">Obiekt do zlokalizowania w <paramref name="array" />.</param>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <summary>Wyszukuje określonego obiektu i zwraca indeks ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Array" /> zawierający określoną liczbę elementów i kończy się pod określonym indeksem.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia <paramref name="value" /> w zakresie elementów w <paramref name="array" /> zawierającą liczbę elementów określony w <paramref name="count" /> i kończy się <paramref name="startIndex" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> Jest wyszukiwanych ze starszymi wersjami zaczynając od `startIndex` i kończące się wierszem `startIndex` minus `count` plus 1, jeśli `count` jest większa niż 0.  
  
 Elementy są porównywane z określoną wartością za pomocą <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody. Jeśli typ elementu jest typu niewewnętrznego (zdefiniowany przez użytkownika) `Equals` implementacji tego typu jest używany.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest `count`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wszystkich trzech ogólnych przeciążeń <xref:System.Array.LastIndexOf%2A> metody. Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> Przeciążenie metody przeszukuje całej tablicy, od końca, a drugie wystąpienie ciągu znajduje. <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Metoda przeciążenia służy do wyszukiwania z poprzednimi wersjami początku tablicy z lokalizacją indeksu 3 i przechodzić do początku tablicy i znajduje pierwsze wystąpienie ciągu. Na koniec <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> metoda przeciążenia służy do wyszukiwania szeroką gamę cztery wpisy, rozpoczynając od lokalizacji indeksu 4 i rozszerzanie Wstecz (czyli wyszukuje elementy w lokalizacjach, 4, 3, 2 i 1); to wyszukiwanie zwraca -1, ponieważ żadnych wystąpień wyszukiwania ciąg, w tym zakresie.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem prawidłowych indeksów dla <paramref name="array" />.  
  
—lub— 
 <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="startIndex" /> i <paramref name="count" /> nie określają prawidłowej sekcji w <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Array.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowitą liczbę elementów w wszystkie wymiary <see cref="T:System.Array" />.</summary>
        <value>Całkowita liczba elementów w wszystkie wymiary <see cref="T:System.Array" />; zero, jeśli nie ma elementów w tablicy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Array.Length%2A> właściwości do pobrania całkowitą liczbę elementów w tablicy. Korzysta również <xref:System.Array.GetUpperBound%2A> metodę pozwala ustalić liczbę elementów w każdego wymiaru tablicy wielowymiarowej.  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Tablica ma charakter wielowymiarowy i zawiera więcej niż <see cref="F:System.Int32.MaxValue" /> elementów.</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LongLength : int64" Usage="System.Array.LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera 64-bitowa liczba całkowita, która reprezentuje całkowitą liczbę elementów w wszystkie wymiary <see cref="T:System.Array" />.</summary>
        <value>64-bitowa liczba całkowita, która reprezentuje całkowitą liczbę elementów w wszystkie wymiary <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Array.Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rangę (liczba wymiarów) <see cref="T:System.Array" />. Na przykład zwraca wartość 1, Jednowymiarowa tablica, zwraca tablicę dwuwymiarową, 2 i tak dalej.</summary>
        <value>Ranga (liczba wymiarów) <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład kod języka Visual Basic  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 i kodu C#  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 Utwórz tablicę trzech wymiarów z <xref:System.Array.Rank%2A> właściwość, której wartość jest 3.  
  
 Nieregularna tablica (tablicy tablic) to Jednowymiarowa tablica; wartość jego <xref:System.Array.Rank%2A> właściwość ma wartość 1.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 W poniższym przykładzie Inicjuje tablicę jednowymiarową tablicę dwuwymiarową i Tablica nieregularna i pobiera <xref:System.Array.Rank%2A> właściwości każdego z nich.  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberSignature Language="F#" Value="static member Resize :  * int -&gt; unit" Usage="System.Array.Resize (array, newSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="ref" />
        <Parameter Name="newSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Tablica jednowymiarowo, zaczynający się od zera, aby zmienić rozmiar, lub <see langword="null" /> Aby utworzyć nową tablicę z określonym rozmiarem.</param>
        <param name="newSize">Rozmiar nowej tablicy.</param>
        <summary>Liczba elementów w tablicy jednowymiarowej, które zmienia się na określonej nowy rozmiar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przydziela nową tablicę o określonym rozmiarze, kopiuje elementy z tablicy starej na nową i następnie zastępuje stare tablicy na nową. `array` musi być tablicą jednowymiarową.  
  
 Jeśli `array` jest `null`, ta metoda tworzy nową tablicę z określonym rozmiarem.  
  
 Jeśli `newSize` jest większa niż <xref:System.Array.Length%2A> stare tablicy jest przydzielany nową tablicę, a wszystkie elementy są kopiowane z tablicy starej na nową.  Jeśli `newSize` jest mniejsza niż <xref:System.Array.Length%2A> stare tablicy jest przydzielany nową tablicę i elementy są kopiowane z stare tablicy na nową, dopóki nie jest wypełniony nowego; pozostałe elementy w tablicy stare są ignorowane.  Jeśli `newSize` jest równa <xref:System.Array.Length%2A> stare tablicy, ta metoda nie wykonuje żadnych czynności.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest `newSize`.  
  
 <xref:System.Array.Resize%2A> Metoda zmienia rozmiar tylko Jednowymiarowa tablica. <xref:System.Array> Klasy nie zawiera metody do zmiany rozmiaru tablic wielowymiarowych. Aby to zrobić, możesz podać swój kod lub wywołanie metody specjalnego przeznaczenia biblioteki innej firmy. Poniższy kod ilustruje jedną możliwą implementację dla metody, która zmienia rozmiar tablicy *n* wymiarów.  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wpływa zmiana rozmiaru tablicy.  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newSize" /> jest mniejsza niż zero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odwraca kolejność elementów w jednowymiarowym <see cref="T:System.Array" /> lub w części <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> odwrócić.</param>
        <summary>Odwraca kolejność elementów w całej jednowymiarowa <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu tej metody do elementu w `myArray[i]`, gdzie `i` wszelkie indeks w tablicy, przeniesienie do `myArray[j]`, gdzie `j` jest równa `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
 Jak pokazano na poniższym przykładzie, <xref:System.Array.Reverse%2A> metoda służy do odwrócić tablicy nieregularnej. Nieregularna tablica z jednym elementem jest inicjowana w każdym miesiącu w bieżącym roku w kalendarzu bieżącej kultury. Każdy element zawiera tablicę, o tyle elementów, jako że miesiąc ma dni. Przykład wyświetla zawartość tablicy, wywołania <xref:System.Array.Reverse%2A> metody, a następnie wyświetla zawartość tablicy odwróconej.  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak Odwróć kolejność sortowania wartości w <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ma charakter wielowymiarowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> odwrócić.</param>
        <param name="index">Indeks początkowy sekcji, aby odwrócić.</param>
        <param name="length">Liczba elementów w sekcji, aby odwrócić.</param>
        <summary>Odwraca kolejność elementów w zakresie elementów w jednowymiarowy <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu tej metody do elementu w `myArray[i]`, gdzie `i` wszelkie indeks w tablicy, przeniesienie do `myArray[j]`, gdzie `j` jest równa `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 <xref:System.Array.Reverse%2A> Metoda służy do odwrócić tablicy nieregularnej.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak Odwróć kolejność sortowania wartości w szeregu elementów w <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ma charakter wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.  
  
—lub— 
 <paramref name="length" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="length" /> nie określono prawidłowego zakresu <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia określony element w bieżącym <see cref="T:System.Array" /> z podaną wartością.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="index">32-bitowa liczba całkowita, która reprezentuje pozycję <see cref="T:System.Array" /> elementu do ustawienia.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w jednowymiarowy <see cref="T:System.Array" />. Indeks jest określony jako 32-bitową liczbę całkowitą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy wartość `index` jest poza zakresem.  
  
 Aby uzyskać więcej informacji dotyczących konwersji, zobacz <xref:System.Convert>.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używany do przypisywania `null` do elementu tablicy typów wartości wszystkich pól elementu są inicjowane od zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżący <see cref="T:System.Array" /> nie ma dokładnie jednego wymiaru.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> Nie można rzutować na typ bieżącego elementu <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> znajduje się poza zakresem prawidłowych indeksów dla bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="indices">Jednowymiarowa tablica 32-bitowych liczb całkowitych, reprezentujących indeksy określające pozycję elementu do ustawienia.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w wielowymiarowych <see cref="T:System.Array" />. Indeksy są określane jako tablica 32-bitowych liczb całkowitych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba elementów w `indices` musi być równa liczbie wymiarów w <xref:System.Array>. Wszystkie elementy w `indices` tablicy muszą wspólnie określać położenie żądanego elementu w wielowymiarowych <xref:System.Array>.  
  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy dowolna z wartości w `indices` tablicy jest poza zakresem.  
  
 Aby uzyskać więcej informacji dotyczących konwersji, zobacz <xref:System.Convert>.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używany do przypisywania `null` do elementu tablicy typów wartości wszystkich pól elementu są inicjowane od zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba wymiarów w bieżącym <see cref="T:System.Array" /> nie jest równa liczbie elementów w <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> Nie można rzutować na typ bieżącego elementu <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Dowolny element w <paramref name="indices" /> znajduje się poza zakresem prawidłowego indeksowania dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="index">64-bitowa liczba całkowita, która reprezentuje pozycję <see cref="T:System.Array" /> elementu do ustawienia.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w jednowymiarowy <see cref="T:System.Array" />. Indeks jest określony jako 64-bitową liczbę całkowitą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy wartość `index` jest poza zakresem.  
  
 Aby uzyskać więcej informacji dotyczących konwersji, zobacz <xref:System.Convert>.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używany do przypisywania `null` do elementu tablicy typów wartości wszystkich pól elementu są inicjowane od zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżący <see cref="T:System.Array" /> nie ma dokładnie jednego wymiaru.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> Nie można rzutować na typ bieżącego elementu <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> znajduje się poza zakresem prawidłowych indeksów dla bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="indices">Jednowymiarowa tablica, 64-bitowych liczb całkowitych, reprezentujących indeksy określające pozycję elementu do ustawienia.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w wielowymiarowych <see cref="T:System.Array" />. Indeksy są określane jako tablica 64-bitowych liczb całkowitych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba elementów w `indices` musi być równa liczbie wymiarów w <xref:System.Array>. Wszystkie elementy w `indices` tablicy muszą wspólnie określać położenie żądanego elementu w wielowymiarowych <xref:System.Array>.  
  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy dowolna z wartości w `indices` tablicy jest poza zakresem.  
  
 Aby uzyskać więcej informacji dotyczących konwersji, zobacz <xref:System.Convert>.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używany do przypisywania `null` do elementu tablicy typów wartości wszystkich pól elementu są inicjowane od zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba wymiarów w bieżącym <see cref="T:System.Array" /> nie jest równa liczbie elementów w <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> Nie można rzutować na typ bieżącego elementu <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Dowolny element w <paramref name="indices" /> znajduje się poza zakresem prawidłowego indeksowania dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="index1">32-bitowa liczba całkowita, która reprezentuje indeks pierwszego wymiaru <see cref="T:System.Array" /> elementu do ustawienia.</param>
        <param name="index2">32-bitowa liczba całkowita, która reprezentuje indeks drugiego wymiaru <see cref="T:System.Array" /> elementu do ustawienia.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w dwuwymiarowej <see cref="T:System.Array" />. Indeksy są określane jako 32-bitowe liczby całkowite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy indeksy są poza zakresem.  
  
 Aby uzyskać więcej informacji dotyczących konwersji, zobacz <xref:System.Convert>.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używany do przypisywania `null` do elementu tablicy typów wartości wszystkich pól elementu są inicjowane od zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżący <see cref="T:System.Array" /> nie ma dokładnie dwóch wymiarów.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> Nie można rzutować na typ bieżącego elementu <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Albo <paramref name="index1" /> lub <paramref name="index2" /> znajduje się poza zakresem prawidłowego indeksowania dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="index1">64-bitowa liczba całkowita, która reprezentuje indeks pierwszego wymiaru <see cref="T:System.Array" /> elementu do ustawienia.</param>
        <param name="index2">64-bitowa liczba całkowita, która reprezentuje indeks drugiego wymiaru <see cref="T:System.Array" /> elementu do ustawienia.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w dwuwymiarowej <see cref="T:System.Array" />. Indeksy są określane jako 64-bitowych liczb całkowitych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy indeksy są poza zakresem.  
  
 Aby uzyskać więcej informacji dotyczących konwersji, zobacz <xref:System.Convert>.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używany do przypisywania `null` do elementu tablicy typów wartości wszystkich pól elementu są inicjowane od zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżący <see cref="T:System.Array" /> nie ma dokładnie dwóch wymiarów.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> Nie można rzutować na typ bieżącego elementu <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Albo <paramref name="index1" /> lub <paramref name="index2" /> znajduje się poza zakresem prawidłowego indeksowania dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="index1">32-bitowa liczba całkowita, która reprezentuje indeks pierwszego wymiaru <see cref="T:System.Array" /> elementu do ustawienia.</param>
        <param name="index2">32-bitowa liczba całkowita, która reprezentuje indeks drugiego wymiaru <see cref="T:System.Array" /> elementu do ustawienia.</param>
        <param name="index3">32-bitowa liczba całkowita, która reprezentuje indeks trzeciego wymiaru <see cref="T:System.Array" /> elementu do ustawienia.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w trójwymiarowej <see cref="T:System.Array" />. Indeksy są określane jako 32-bitowe liczby całkowite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy indeksy są poza zakresem.  
  
 Aby uzyskać więcej informacji dotyczących konwersji, zobacz <xref:System.Convert>.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używany do przypisywania `null` do elementu tablicy typów wartości wszystkich pól elementu są inicjowane od zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżący <see cref="T:System.Array" /> nie ma dokładnie trzech wymiarów.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> Nie można rzutować na typ bieżącego elementu <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> lub <paramref name="index2" /> lub <paramref name="index3" /> znajduje się poza zakresem prawidłowego indeksowania dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Nowa wartość dla określonego elementu.</param>
        <param name="index1">64-bitowa liczba całkowita, która reprezentuje indeks pierwszego wymiaru <see cref="T:System.Array" /> elementu do ustawienia.</param>
        <param name="index2">64-bitowa liczba całkowita, która reprezentuje indeks drugiego wymiaru <see cref="T:System.Array" /> elementu do ustawienia.</param>
        <param name="index3">64-bitowa liczba całkowita, która reprezentuje indeks trzeciego wymiaru <see cref="T:System.Array" /> elementu do ustawienia.</param>
        <summary>Ustawia wartość do elementu w określonej pozycji w trójwymiarowej <see cref="T:System.Array" />. Indeksy są określane jako 64-bitowych liczb całkowitych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> i <xref:System.Array.GetUpperBound%2A> metod można określić, czy indeksy są poza zakresem.  
  
 Aby uzyskać więcej informacji dotyczących konwersji, zobacz <xref:System.Convert>.  
  
 Ta metoda jest operacją O(1).  
  
> [!NOTE]
>  Jeśli <xref:System.Array.SetValue%2A> jest używany do przypisywania `null` do elementu tablicy typów wartości wszystkich pól elementu są inicjowane od zera. Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Bieżący <see cref="T:System.Array" /> nie ma dokładnie trzech wymiarów.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> Nie można rzutować na typ bieżącego elementu <see cref="T:System.Array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> lub <paramref name="index2" /> lub <paramref name="index3" /> znajduje się poza zakresem prawidłowego indeksowania dla odpowiedniego wymiaru bieżącego <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortuje elementów w tablicy jednowymiarowej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : Array -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> do sortowania.</param>
        <summary>Sortuje elementów w całej jednowymiarowa <see cref="T:System.Array" /> przy użyciu <see cref="T:System.IComparable" /> wykonania każdego elementu <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element obiektu `array` musi implementować <xref:System.IComparable> interfejsu, aby być w stanie porównania z wartością każdy inny element w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji wynosi mniej niż 16 elementów, używa [sortowania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * Dziennik<sup>N</sup>, gdzie *N* to zakres tablicy wejściowej, używa [sortowania przez Kopcowanie](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [sortowania](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane za pomocą algorytmów sortowania przez Kopcowanie i, w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób sortowania wartości w <xref:System.Array> przy użyciu domyślnego modułu porównującego i niestandardowego modułu porównującego, który odwraca porządek sortowania. Należy zauważyć, że wynik może się różnić w zależności od bieżącego <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ma charakter wielowymiarowy.</exception>
        <exception cref="T:System.InvalidOperationException">Jeden lub więcej elementów w <paramref name="array" /> nie należy implementować <see cref="T:System.IComparable" /> interfejsu.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="keys">Jednowymiarowy <see cref="T:System.Array" /> zawierającą klucze ze słownika do sortowania.</param>
        <param name="items">Jednowymiarowy <see cref="T:System.Array" /> zawiera elementy, które odnoszą się do każdego z kluczy w <paramref name="keys" /><see cref="T:System.Array" />.  
  
—lub— 
 <see langword="null" /> Aby posortować tylko <paramref name="keys" /><see cref="T:System.Array" />.</param>
        <summary>Sortuje pary jednowymiarowa <see cref="T:System.Array" /> obiektów (jedna z nich zawiera klucze, a drugi zawiera elementy odpowiednich) oparte na kluczach, w pierwszym <see cref="T:System.Array" /> przy użyciu <see cref="T:System.IComparable" /> wykonania każdego klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w `keys` <xref:System.Array> ma odpowiadający mu element w `items` <xref:System.Array>. Gdy ponownie klucza podczas sortowania, odpowiadający mu element w `items` <xref:System.Array> podobnie zmiany położenia. W związku z tym `items` <xref:System.Array> są sortowane zgodnie z ustaleniami odpowiadających im kluczy w `keys` <xref:System.Array>.  
  
 Każdy klucz w `keys` <xref:System.Array> musi implementować <xref:System.IComparable> interfejsu, aby być w stanie porównania z wartością co drugi klucz.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale nie będą sortowane elementy, które mają nie odpowiednich kluczy. Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <xref:System.ArgumentException>.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji wynosi mniej niż 16 elementów, używa [sortowania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * Dziennik<sup>N</sup>, gdzie *N* to zakres tablicy wejściowej, używa [sortowania przez Kopcowanie](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [sortowania](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane za pomocą algorytmów sortowania przez Kopcowanie i, w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `keys`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób sortowania dwie tablice skojarzone, której pierwsza tablica zawiera klucze, a druga tablica zawiera wartości. Sortuje są wykonywane przy użyciu domyślnego modułu porównującego i niestandardowego modułu porównującego, który odwraca porządek sortowania. Należy zauważyć, że wynik może się różnić w zależności od bieżącego <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> Jest wielowymiarowy.  
  
—lub— 
<paramref name="items" /><see cref="T:System.Array" /> Jest wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> nie jest <see langword="null" />, a długość <paramref name="keys" /> jest większa niż długość <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jeden lub więcej elementów w <paramref name="keys" /><see cref="T:System.Array" /> nie należy implementować <see cref="T:System.IComparable" /> interfejsu.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, do sortowania.</param>
        <param name="comparer">Implementacja do użycia podczas porównywania elementów.  
  
—lub— 
 <see langword="null" /> Aby użyć <see cref="T:System.IComparable" /> wykonania każdego elementu.</param>
        <summary>Sortuje elementy w jednowymiarowym <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparer` jest `null`, każdy element obiektu `array` musi implementować <xref:System.IComparable> interfejsu, aby być w stanie porównania z wartością każdy inny element w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji wynosi mniej niż 16 elementów, używa [sortowania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * Dziennik<sup>N</sup>, gdzie *N* to zakres tablicy wejściowej, używa [sortowania przez Kopcowanie](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [sortowania](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane za pomocą algorytmów sortowania przez Kopcowanie i, w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
 Program .NET Framework zawiera wstępnie zdefiniowane <xref:System.Collections.IComparer> implementacje wymienione w poniższej tabeli.  
  
|Implementacja|Opis|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty, ale wykonuje porównania bez uwzględniania ciągów.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty za pomocą konwencji sortowania bieżącej kultury.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty za pomocą konwencji sortowania niezmiennej kultury.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Porównuje dwa obiekty typu `T` przy użyciu sortowania domyślnego typu.|  
  
 Może również obsługiwać niestandardowe porównań, podając własne wystąpienie <xref:System.Collections.IComparer> implementacji `comparer` parametru. Przykład robi to definiując `ReverseComparer` klasy, która powoduje odwrócenie kolejności sortowania domyślnego wystąpienia typu i wykonuje porównania bez uwzględniania wielkości liter ciągu.  
  
   
  
## Examples  
 Poniższy przykład sortuje wartości w arrayby ciąg, przy użyciu domyślna funkcja porównująca. Umożliwia on również Definiowanie niestandardowego <xref:System.Collections.IComparer> wdrożenia o nazwie `ReverseComparer` który odwraca porządek sortowania domyślnego obiektu podczas przeprowadzania porównania bez uwzględniania wielkości liter ciągu. Należy pamiętać, że dane wyjściowe może się różnić w zależności od bieżącej kultury.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ma charakter wielowymiarowy.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> to <see langword="null" />, a jeden lub więcej elementów w <paramref name="array" /> nie implementuje <see cref="T:System.IComparable" /> interfejsu.</exception>
        <exception cref="T:System.ArgumentException">Implementacja <paramref name="comparer" /> spowodowane błędem podczas sortowania. Na przykład <paramref name="comparer" /> mogą nie zwracać na 0, podczas porównywania elementów z samym sobą.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 i starszych wersji należy używać algorytmu sortowania. Sortowania określa nieprawidłowy porównywanie w niektórych sytuacjach, w których zgłasza operacji <see cref="T:System.IndexOutOfRangeException" /> wyjątek i zgłasza <see cref="T:System.ArgumentException" /> wyjątek do obiektu wywołującego. Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], istnieje możliwość, że sortowanie operations w poprzednio zgłosił <see cref="T:System.ArgumentException" /> nie zgłosi wyjątku, ponieważ algorytmów sortowania i sortowania przez kopcowanie wstawiania nie wykrywaj nieprawidłowe porównania. W większości przypadków to dotyczy tablic z mniej niż 16 elementów.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">Jednowymiarowy <see cref="T:System.Array" /> zawierającą klucze ze słownika do sortowania.</param>
        <param name="items">Jednowymiarowy <see cref="T:System.Array" /> zawiera elementy, które odnoszą się do każdego z kluczy w <paramref name="keys" /><see cref="T:System.Array" />.  
  
—lub— 
 <see langword="null" /> Aby posortować tylko <paramref name="keys" /><see cref="T:System.Array" />.</param>
        <param name="comparer">
          <see cref="T:System.Collections.IComparer" /> Wdrożenia do użycia podczas porównywania elementów.  
  
—lub— 
 <see langword="null" /> Aby użyć <see cref="T:System.IComparable" /> wykonania każdego elementu.</param>
        <summary>Sortuje pary jednowymiarowa <see cref="T:System.Array" /> obiektów (jedna z nich zawiera klucze, a drugi zawiera elementy odpowiednich) oparte na kluczach, w pierwszym <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w `keys` <xref:System.Array> ma odpowiadający mu element w `items` <xref:System.Array>. Gdy ponownie klucza podczas sortowania, odpowiadający mu element w `items` <xref:System.Array> podobnie zmiany położenia. W związku z tym `items` <xref:System.Array> są sortowane zgodnie z ustaleniami odpowiadających im kluczy w `keys` <xref:System.Array>.  
  
 Jeśli `comparer` jest `null`, każdy klucz w `keys` <xref:System.Array> musi implementować <xref:System.IComparable> interfejsu, aby być w stanie porównania z wartością co drugi klucz.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale nie będą sortowane elementy, które mają nie odpowiednich kluczy. Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <xref:System.ArgumentException>.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Program .NET Framework zawiera wstępnie zdefiniowane <xref:System.Collections.IComparer> implementacje wymienione w poniższej tabeli.  
  
|Implementacja|Opis|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty, ale wykonuje porównania bez uwzględniania ciągów.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty za pomocą konwencji sortowania bieżącej kultury.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty za pomocą konwencji sortowania niezmiennej kultury.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Porównuje dwa obiekty typu `T` przy użyciu sortowania domyślnego typu.|  
  
 Może również obsługiwać niestandardowe porównań, podając własne wystąpienie <xref:System.Collections.IComparer> implementacji `comparer` parametru. Przykład robi to definiując <xref:System.Collections.IComparer> wdrożenia, który odwraca porządek sortowania domyślnego i wykonuje porównania bez uwzględniania wielkości liter ciągu.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji wynosi mniej niż 16 elementów, używa [sortowania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * Dziennik<sup>N</sup>, gdzie *N* to zakres tablicy wejściowej, używa [sortowania przez Kopcowanie](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [sortowania](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane za pomocą algorytmów sortowania przez Kopcowanie i, w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `keys`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób sortowania dwie tablice skojarzone, której pierwsza tablica zawiera klucze, a druga tablica zawiera wartości. Sortuje są wykonywane przy użyciu domyślnego modułu porównującego i niestandardowego modułu porównującego, który odwraca porządek sortowania. Należy zauważyć, że wynik może się różnić w zależności od bieżącego <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> Jest wielowymiarowy.  
  
—lub— 
<paramref name="items" /><see cref="T:System.Array" /> Jest wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> nie jest <see langword="null" />, a długość <paramref name="keys" /> jest większa niż długość <paramref name="items" />.  
  
—lub— 
Implementacja <paramref name="comparer" /> spowodowane błędem podczas sortowania. Na przykład <paramref name="comparer" /> mogą nie zwracać na 0, podczas porównywania elementów z samym sobą.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />i co najmniej jeden element w <paramref name="keys" /><see cref="T:System.Array" /> nie należy implementować <see cref="T:System.IComparable" /> interfejsu.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 i starszych wersji należy używać algorytmu sortowania. Sortowania określa nieprawidłowy porównywanie w niektórych sytuacjach, w których zgłasza operacji <see cref="T:System.IndexOutOfRangeException" /> wyjątek i zgłasza <see cref="T:System.ArgumentException" /> wyjątek do obiektu wywołującego. Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], jest możliwe, sortowanie operacje tego previouslythrew <see cref="T:System.ArgumentException" /> nie zgłosi wyjątku, ponieważ algorytmów sortowania i sortowania przez kopcowanie wstawiania nie wykrywaj nieprawidłowe porównania. W większości przypadków to dotyczy tablic z mniej niż 16 elementów.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> do sortowania.</param>
        <param name="index">Indeks początkowy zakresu do sortowania.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <summary>Sortuje elementy w zakresie elementów w jednowymiarowym <see cref="T:System.Array" /> przy użyciu <see cref="T:System.IComparable" /> wykonania każdego elementu <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element z określonego zakresu elementów w `array` musi implementować <xref:System.IComparable> interfejsu, aby być w stanie porównania z wartością każdy inny element w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji wynosi mniej niż 16 elementów, używa [sortowania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * Dziennik<sup>N</sup>, gdzie *N* to zakres tablicy wejściowej, używa [sortowania przez Kopcowanie](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [sortowania](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane za pomocą algorytmów sortowania przez Kopcowanie i, w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operacji, gdzie `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób sortowania wartości w <xref:System.Array> przy użyciu domyślnego modułu porównującego i niestandardowego modułu porównującego, który odwraca porządek sortowania. Należy zauważyć, że wynik może się różnić w zależności od bieżącego <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ma charakter wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.  
  
—lub— 
 <paramref name="length" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="length" /> nie określono prawidłowego zakresu <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jeden lub więcej elementów w <paramref name="array" /> nie należy implementować <see cref="T:System.IComparable" /> interfejsu.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keys">Jednowymiarowy <see cref="T:System.Array" /> zawierającą klucze ze słownika do sortowania.</param>
        <param name="items">Jednowymiarowy <see cref="T:System.Array" /> zawiera elementy, które odnoszą się do każdego z kluczy w <paramref name="keys" /><see cref="T:System.Array" />.  
  
—lub— 
 <see langword="null" /> Aby posortować tylko <paramref name="keys" /><see cref="T:System.Array" />.</param>
        <param name="index">Indeks początkowy zakresu do sortowania.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <summary>Sortuje zakres elementów w parze jednowymiarowa <see cref="T:System.Array" /> obiektów (jedna z nich zawiera klucze, a drugi zawiera elementy odpowiednich) oparte na kluczach, w pierwszym <see cref="T:System.Array" /> przy użyciu <see cref="T:System.IComparable" /> wykonania każdego klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w `keys` <xref:System.Array> ma odpowiadający mu element w `items` <xref:System.Array>. Gdy ponownie klucza podczas sortowania, odpowiadający mu element w `items` <xref:System.Array> podobnie zmiany położenia. W związku z tym `items` <xref:System.Array> są sortowane zgodnie z ustaleniami odpowiadających im kluczy w `keys` <xref:System.Array>.  
  
 Każdy klucz z określonego zakresu elementów w `keys` <xref:System.Array> musi implementować <xref:System.IComparable> interfejsu, aby być w stanie porównania z wartością co drugi klucz.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale nie będą sortowane elementy, które mają nie odpowiednich kluczy. Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <xref:System.ArgumentException>.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji wynosi mniej niż 16 elementów, używa [sortowania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * Dziennik<sup>N</sup>, gdzie *N* to zakres tablicy wejściowej, używa [sortowania przez Kopcowanie](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [sortowania](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane za pomocą algorytmów sortowania przez Kopcowanie i, w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operacji, gdzie `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób sortowania dwie tablice skojarzone, której pierwsza tablica zawiera klucze, a druga tablica zawiera wartości. Sortuje są wykonywane przy użyciu domyślnego modułu porównującego i niestandardowego modułu porównującego, który odwraca porządek sortowania. Należy zauważyć, że wynik może się różnić w zależności od bieżącego <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> Jest wielowymiarowy.  
  
—lub— 
<paramref name="items" /><see cref="T:System.Array" /> Jest wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="keys" />.  
  
—lub— 
 <paramref name="length" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> nie jest <see langword="null" />, a długość <paramref name="keys" /> jest większa niż długość <paramref name="items" />.  
  
—lub— 
 <paramref name="index" /> i <paramref name="length" /> nie określono prawidłowego zakresu <paramref name="keys" /><see cref="T:System.Array" />.  
  
—lub— 
 <paramref name="items" /> nie jest <see langword="null" />, i <paramref name="index" /> i <paramref name="length" /> nie określono prawidłowego zakresu <paramref name="items" /><see cref="T:System.Array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jeden lub więcej elementów w <paramref name="keys" /><see cref="T:System.Array" /> nie należy implementować <see cref="T:System.IComparable" /> interfejsu.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> do sortowania.</param>
        <param name="index">Indeks początkowy zakresu do sortowania.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <param name="comparer">
          <see cref="T:System.Collections.IComparer" /> Wdrożenia do użycia podczas porównywania elementów.  
  
—lub— 
 <see langword="null" /> Aby użyć <see cref="T:System.IComparable" /> wykonania każdego elementu.</param>
        <summary>Sortuje elementy w zakresie elementów w jednowymiarowym <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparer` jest `null`, każdy element z określonego zakresu elementów w `array` musi implementować <xref:System.IComparable> interfejsu, aby być w stanie porównania z wartością każdy inny element w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Program .NET Framework zawiera wstępnie zdefiniowane <xref:System.Collections.IComparer> implementacje wymienione w poniższej tabeli.  
  
|Implementacja|Opis|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty, ale wykonuje porównania bez uwzględniania ciągów.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty za pomocą konwencji sortowania bieżącej kultury.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty za pomocą konwencji sortowania niezmiennej kultury.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Porównuje dwa obiekty typu `T` przy użyciu sortowania domyślnego typu.|  
  
 Może również obsługiwać niestandardowe porównań, podając własne wystąpienie <xref:System.Collections.IComparer> implementacji `comparer` parametru. Przykład robi to definiując `ReverseComparer` klasy, która powoduje odwrócenie kolejności sortowania domyślnego wystąpienia typu i wykonuje porównania bez uwzględniania wielkości liter ciągu.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji wynosi mniej niż 16 elementów, używa [sortowania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * Dziennik<sup>N</sup>, gdzie *N* to zakres tablicy wejściowej, używa [sortowania przez Kopcowanie](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [sortowania](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane za pomocą algorytmów sortowania przez Kopcowanie i, w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operacji, gdzie `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób sortowania wartości w <xref:System.Array> przy użyciu domyślnego modułu porównującego i niestandardowego modułu porównującego, który odwraca porządek sortowania. Należy zauważyć, że wynik może się różnić w zależności od bieżącego <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ma charakter wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.  
  
—lub— 
 <paramref name="length" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="length" /> nie określono prawidłowego zakresu <paramref name="array" />.  
  
—lub— 
Implementacja <paramref name="comparer" /> spowodowane błędem podczas sortowania. Na przykład <paramref name="comparer" /> mogą nie zwracać na 0, podczas porównywania elementów z samym sobą.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> to <see langword="null" />, a jeden lub więcej elementów w <paramref name="array" /> nie implementuje <see cref="T:System.IComparable" /> interfejsu.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 i starszych wersji należy używać algorytmu sortowania. Sortowania określa nieprawidłowy porównywanie w niektórych sytuacjach, w których zgłasza operacji <see cref="T:System.IndexOutOfRangeException" /> wyjątek i zgłasza <see cref="T:System.ArgumentException" /> wyjątek do obiektu wywołującego. Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], istnieje możliwość, że sortowanie operations w poprzednio zgłosił <see cref="T:System.ArgumentException" /> nie zgłosi wyjątku, ponieważ algorytmów sortowania i sortowania przez kopcowanie wstawiania nie wykrywaj nieprawidłowe porównania. W większości przypadków to dotyczy tablic z mniej niż 16 elementów.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">Jednowymiarowy <see cref="T:System.Array" /> zawierającą klucze ze słownika do sortowania.</param>
        <param name="items">Jednowymiarowy <see cref="T:System.Array" /> zawiera elementy, które odnoszą się do każdego z kluczy w <paramref name="keys" /><see cref="T:System.Array" />.  
  
—lub— 
 <see langword="null" /> Aby posortować tylko <paramref name="keys" /><see cref="T:System.Array" />.</param>
        <param name="index">Indeks początkowy zakresu do sortowania.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <param name="comparer">
          <see cref="T:System.Collections.IComparer" /> Wdrożenia do użycia podczas porównywania elementów.  
  
—lub— 
 <see langword="null" /> Aby użyć <see cref="T:System.IComparable" /> wykonania każdego elementu.</param>
        <summary>Sortuje zakres elementów w parze jednowymiarowa <see cref="T:System.Array" /> obiektów (jedna z nich zawiera klucze, a drugi zawiera elementy odpowiednich) oparte na kluczach, w pierwszym <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w `keys` <xref:System.Array> ma odpowiadający mu element w `items` <xref:System.Array>. Gdy ponownie klucza podczas sortowania, odpowiadający mu element w `items` <xref:System.Array> podobnie zmiany położenia. W związku z tym `items` <xref:System.Array> są sortowane zgodnie z ustaleniami odpowiadających im kluczy w `keys` <xref:System.Array>.  
  
 Jeśli `comparer` jest `null`, każdy klucz z określonego zakresu elementów w `keys` <xref:System.Array> musi implementować <xref:System.IComparable> interfejsu, aby być w stanie porównania z wartością co drugi klucz.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale nie będą sortowane elementy, które mają nie odpowiednich kluczy. Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <xref:System.ArgumentException>.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Program .NET Framework zawiera wstępnie zdefiniowane <xref:System.Collections.IComparer> implementacje wymienione w poniższej tabeli.  
  
|Implementacja|Opis|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty, ale wykonuje porównania bez uwzględniania ciągów.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty za pomocą konwencji sortowania bieżącej kultury.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Porównuje wszystkie dwa obiekty za pomocą konwencji sortowania niezmiennej kultury.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Porównuje dwa obiekty typu `T` przy użyciu sortowania domyślnego typu.|  
  
 Może również obsługiwać niestandardowe porównań, podając własne wystąpienie <xref:System.Collections.IComparer> implementacji `comparer` parametru. Przykład robi to przez zdefiniowanie niestandardowego <xref:System.Collections.IComparer> wdrożenia, który odwraca porządek sortowania domyślnego i wykonuje porównania bez uwzględniania wielkości liter ciągu.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji wynosi mniej niż 16 elementów, używa [sortowania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * Dziennik<sup>N</sup>, gdzie *N* to zakres tablicy wejściowej, używa [sortowania przez Kopcowanie](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [sortowania](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane za pomocą algorytmów sortowania przez Kopcowanie i, w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operacji, gdzie `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób sortowania dwie tablice skojarzone, której pierwsza tablica zawiera klucze, a druga tablica zawiera wartości. Sortuje są wykonywane przy użyciu domyślnego modułu porównującego i niestandardowego modułu porównującego, który odwraca porządek sortowania. Należy zauważyć, że wynik może się różnić w zależności od bieżącego <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> Jest wielowymiarowy.  
  
—lub— 
<paramref name="items" /><see cref="T:System.Array" /> Jest wielowymiarowy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="keys" />.  
  
—lub— 
 <paramref name="length" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> nie jest <see langword="null" />, a dolna granica <paramref name="keys" /> jest niezgodna z dolną granicę <paramref name="items" />.  
  
—lub— 
 <paramref name="items" /> nie jest <see langword="null" />, a długość <paramref name="keys" /> jest większa niż długość <paramref name="items" />.  
  
—lub— 
 <paramref name="index" /> i <paramref name="length" /> nie określono prawidłowego zakresu <paramref name="keys" /><see cref="T:System.Array" />.  
  
—lub— 
 <paramref name="items" /> nie jest <see langword="null" />, i <paramref name="index" /> i <paramref name="length" /> nie określono prawidłowego zakresu <paramref name="items" /><see cref="T:System.Array" />.  
  
—lub— 
Implementacja <paramref name="comparer" /> spowodowane błędem podczas sortowania. Na przykład <paramref name="comparer" /> mogą nie zwracać na 0, podczas porównywania elementów z samym sobą.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />i co najmniej jeden element w <paramref name="keys" /><see cref="T:System.Array" /> nie należy implementować <see cref="T:System.IComparable" /> interfejsu.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 i starszych wersji należy używać algorytmu sortowania. Sortowania określa nieprawidłowy porównywanie w niektórych sytuacjach, w których zgłasza operacji <see cref="T:System.IndexOutOfRangeException" /> wyjątek i zgłasza <see cref="T:System.ArgumentException" /> wyjątek do obiektu wywołującego. Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], istnieje możliwość, że sortowanie operations w poprzednio zgłosił <see cref="T:System.ArgumentException" /> nie zgłosi wyjątku, ponieważ algorytmów sortowania i sortowania przez kopcowanie wstawiania nie wykrywaj nieprawidłowe porównania. W większości przypadków to dotyczy tablic z mniej niż 16 elementów.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> do sortowania.</param>
        <summary>Sortuje elementów w całej <see cref="T:System.Array" /> przy użyciu <see cref="T:System.IComparable`1" /> implementacji interfejsu ogólnego każdego elementu <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element obiektu `array` musi implementować <xref:System.IComparable%601> ogólny interfejs być zdolny do porównania z wartością każdy inny element w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji wynosi mniej niż 16 elementów, używa [sortowania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * Dziennik<sup>N</sup>, gdzie *N* to zakres tablicy wejściowej, używa [sortowania przez Kopcowanie](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [sortowania](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane za pomocą algorytmów sortowania przez Kopcowanie i, w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> przeciążenie metody rodzajowe i <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> przeciążenia metody rodzajowej. Tworzona jest tablica ciągów, w losowej kolejności.  
  
 Tablica jest wyświetlana, sortowana i ponownie wyświetlana.  
  
> [!NOTE]
>  Wywołania <xref:System.Array.Sort%2A> i <xref:System.Array.BinarySearch%2A> metody ogólne nie wyglądają inaczej niż wywołania ich odpowiedników nierodzajowych, ponieważ wywnioskować typu parametru typu ogólnego z typu pierwszego argumentu, Visual Basic, C# i C++. Jeśli używasz [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do zbadania języka Microsoft intermediate language (MSIL), możesz zobaczyć, że wywoływane są metody rodzajowe.  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> Przeciążenia metody ogólnej jest następnie używany do dwóch ciągów wyszukiwania, taki, który nie znajduje się w tablicy, a drugi, jest. Tablica i wartość zwracana przez <xref:System.Array.BinarySearch%2A> metody są przekazywane do `ShowWhere` metody rodzajowej, który zawiera wartość indeksu, jeśli ciąg zostanie znaleziony, a w przeciwnym razie elementy ciągu wyszukiwania spadnie między gdyby w tablicy. Indeks jest ujemny, jeśli ciąg nie jest n tablicy, więc `ShowWhere` metoda pobiera bitowe uzupełnienie (~ operatora w języku C# i Visual C++ `Xor` -1 w języku Visual Basic) w celu uzyskania indeksu pierwszego elementu na liście, który jest większy niż ściśle wyszukiwania NG.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jeden lub więcej elementów w <paramref name="array" /> nie należy implementować <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowy, zero-base <see cref="T:System.Array" /> sortowania</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> Implementacji interfejsu ogólnego do użycia podczas porównywania elementów, lub <see langword="null" /> używać <see cref="T:System.IComparable`1" /> implementacji interfejsu ogólnego każdego elementu.</param>
        <summary>Sortuje elementów w <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.Generic.IComparer`1" /> interfejs generyczny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparer` jest `null`, każdy element obiektu `array` musi implementować <xref:System.IComparable%601> ogólny interfejs być zdolny do porównania z wartością każdy inny element w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji wynosi mniej niż 16 elementów, używa [sortowania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * Dziennik<sup>N</sup>, gdzie *N* to zakres tablicy wejściowej, używa [sortowania przez Kopcowanie](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [sortowania](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane za pomocą algorytmów sortowania przez Kopcowanie i, w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> przeciążenie metody rodzajowe i <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> przeciążenia metody rodzajowej.  
  
 Kodu przykładowy definiuje alternatywny moduł porównujący dla ciągów o nazwie `ReverseCompare`, który implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Moduł porównujący wywołuje <xref:System.String.CompareTo%28System.String%29> metody, odwracając kolejność argumentów porównawczych, tak aby posortować ciągi wysokiej do minimum zamiast niska wysoka.  
  
 Tablica jest wyświetlana, sortowana i ponownie wyświetlana. Tablice muszą być sortowane, aby można było używać <xref:System.Array.BinarySearch%2A> metody.  
  
> [!NOTE]
>  Wywołania <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> i <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metody ogólne nie wyglądają inaczej niż wywołania ich odpowiedników nierodzajowych, ponieważ wywnioskować typu parametru typu ogólnego z typu pierwszego argumentu, Visual Basic, C# i C++. Jeśli używasz [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do zbadania języka Microsoft intermediate language (MSIL), możesz zobaczyć, że wywoływane są metody rodzajowe.  
  
 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenia metody ogólnej jest następnie używany do dwóch ciągów wyszukiwania, taki, który nie znajduje się w tablicy, a drugi, jest. Tablica i wartość zwracana przez <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metody są przekazywane do `ShowWhere` metody rodzajowej, który zawiera wartość indeksu, jeśli ciąg zostanie znaleziony, a w przeciwnym razie elementy ciągu wyszukiwania spadnie między gdyby w tablicy. Indeks jest ujemny, jeśli ciąg nie jest n tablicy, więc `ShowWhere` metoda pobiera bitowe uzupełnienie (~ operatora w języku C# i Visual C++ `Xor` -1 w języku Visual Basic) w celu uzyskania indeksu pierwszego elementu na liście, który jest większy niż ściśle wyszukiwania NG.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />i co najmniej jeden element w <paramref name="array" /> nie należy implementować <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <exception cref="T:System.ArgumentException">Implementacja <paramref name="comparer" /> spowodowane błędem podczas sortowania. Na przykład <paramref name="comparer" /> mogą nie zwracać na 0, podczas porównywania elementów z samym sobą.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 i starszych wersji należy używać algorytmu sortowania. Sortowania określa nieprawidłowy porównywanie w niektórych sytuacjach, w których zgłasza operacji <see cref="T:System.IndexOutOfRangeException" /> wyjątek i zgłasza <see cref="T:System.ArgumentException" /> wyjątek do obiektu wywołującego. Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], istnieje możliwość, że sortowanie operations w poprzednio zgłosił <see cref="T:System.ArgumentException" /> nie zgłosi wyjątku, ponieważ algorytmów sortowania i sortowania przez kopcowanie wstawiania nie wykrywaj nieprawidłowe porównania. W większości przypadków to dotyczy tablic z mniej niż 16 elementów.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * Comparison&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> sortowania</param>
        <param name="comparison">
          <see cref="T:System.Comparison`1" /> Do użycia podczas porównywania elementów.</param>
        <summary>Sortuje elementów w <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Comparison`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu introspective sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji wynosi mniej niż 16 elementów, używa [sortowania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * Dziennik<sup>N</sup>, gdzie *N* to zakres tablicy wejściowej, używa [sortowania przez Kopcowanie](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [sortowania](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane za pomocą algorytmów sortowania przez Kopcowanie i, w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> przeciążenie metody.  
  
 Przykładowy kod definiuje metodę alternatywnych porównania ciągów o nazwie `CompareDinosByLength`. Ta metoda działa w następujący sposób: po pierwsze, comparandsare sprawdzane pod kątem`null`, odwołanie o wartości null jest traktowany jako mniejsza niż inna niż null. Po drugie długości ciągów są porównywane i dłuższego ciągu jest uznawany za większy. Po trzecie Jeśli długości są równe, porównywania ciągów znaków zwykłych jest używany.  
  
 Tablica ciągów jest tworzone i wypełniane przy użyciu czterech ciągów, w losowej kolejności. Lista zawiera również ciąg pusty i odwołanie o wartości null. Zostanie wyświetlona lista sortowane przy użyciu <xref:System.Comparison%601> Delegat ogólny reprezentujący `CompareDinosByLength` metody i ponownie wyświetlone.  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="comparison" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Implementacja <paramref name="comparison" /> spowodowane błędem podczas sortowania. Na przykład <paramref name="comparison" /> mogą nie zwracać na 0, podczas porównywania elementów z samym sobą.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 i starszych wersji należy używać algorytmu sortowania. Sortowania określa nieprawidłowy porównywanie w niektórych sytuacjach, w których zgłasza operacji <see cref="T:System.IndexOutOfRangeException" /> wyjątek i zgłasza <see cref="T:System.ArgumentException" /> wyjątek do obiektu wywołującego. Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], istnieje możliwość, że sortowanie operations w poprzednio zgłosił <see cref="T:System.ArgumentException" /> nie zgłosi wyjątku, ponieważ algorytmów sortowania i sortowania przez kopcowanie wstawiania nie wykrywaj nieprawidłowe porównania. W większości przypadków to dotyczy tablic z mniej niż 16 elementów.</para>
        </block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> sortowania</param>
        <param name="index">Indeks początkowy zakresu do sortowania.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <summary>Sortuje elementy w zakresie elementów w <see cref="T:System.Array" /> przy użyciu <see cref="T:System.IComparable`1" /> implementacji interfejsu ogólnego każdego elementu <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element z określonego zakresu elementów w `array` musi implementować <xref:System.IComparable%601> ogólny interfejs być zdolny do porównania z wartością każdy inny element w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji wynosi mniej niż 16 elementów, używa [sortowania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * Dziennik<sup>N</sup>, gdzie *N* to zakres tablicy wejściowej, używa [sortowania przez Kopcowanie](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [sortowania](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane za pomocą algorytmów sortowania przez Kopcowanie i, w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operacji, gdzie `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> przeciążenie metody rodzajowe i <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> przeciążenia metody ogólnej sortowanie zakresu w tablicy.  
  
 Kodu przykładowy definiuje alternatywny moduł porównujący dla ciągów o nazwie `ReverseCompare`, który implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Moduł porównujący wywołuje <xref:System.String.CompareTo%28System.String%29> metody, odwracając kolejność argumentów porównawczych, tak aby posortować ciągi wysokiej do minimum zamiast niska wysoka.  
  
 Przykład kodu tworzy i wyświetla tablicę nazw dinozaurów, składający się z trzech zwierząt roślinożernych następują trzy mięsożerców (tyrannosaurids, aby była precyzyjna). <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Przeciążenia metody ogólnej jest używana do sortowania ostatnie trzy elementy tablicy, która zostanie wyświetlona. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenia metody ogólnej jest używana z `ReverseCompare` w odwrotnej kolejności sortowania ostatnie trzy elementy. Dokładnie mylić dinozaurów wyświetlane są ponownie.  
  
> [!NOTE]
>  Wywołania <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> i <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metody ogólne nie wyglądają inaczej niż wywołania ich odpowiedników nierodzajowych, ponieważ wywnioskować typu parametru typu ogólnego z typu pierwszego argumentu, Visual Basic, C# i C++. Jeśli używasz [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do zbadania języka Microsoft intermediate language (MSIL), możesz zobaczyć, że wywoływane są metody rodzajowe.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.  
  
—lub— 
 <paramref name="length" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="length" /> nie określono prawidłowego zakresu <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jeden lub więcej elementów w <paramref name="array" /> nie należy implementować <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> do sortowania.</param>
        <param name="index">Indeks początkowy zakresu do sortowania.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> Implementacji interfejsu ogólnego do użycia podczas porównywania elementów, lub <see langword="null" /> używać <see cref="T:System.IComparable`1" /> implementacji interfejsu ogólnego każdego elementu.</param>
        <summary>Sortuje elementy w zakresie elementów w <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.Generic.IComparer`1" /> interfejs generyczny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparer` jest `null`, każdy element z określonego zakresu elementów w `array` musi implementować <xref:System.IComparable%601> ogólny interfejs być zdolny do porównania z wartością każdy inny element w `array`.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji wynosi mniej niż 16 elementów, używa [sortowania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * Dziennik<sup>N</sup>, gdzie *N* to zakres tablicy wejściowej, używa [sortowania przez Kopcowanie](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [sortowania](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane za pomocą algorytmów sortowania przez Kopcowanie i, w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operacji, gdzie `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> przeciążenie metody rodzajowe i <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> przeciążenia metody ogólnej sortowanie zakresu w tablicy.  
  
 Kodu przykładowy definiuje alternatywny moduł porównujący dla ciągów o nazwie `ReverseCompare`, który implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Moduł porównujący wywołuje <xref:System.String.CompareTo%28System.String%29> metody, odwracając kolejność argumentów porównawczych, tak aby posortować ciągi wysokiej do minimum zamiast niska wysoka.  
  
 Przykład kodu tworzy i wyświetla tablicę nazw dinozaurów, składający się z trzech zwierząt roślinożernych następują trzy mięsożerców (tyrannosaurids, aby była precyzyjna). <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Przeciążenia metody ogólnej jest używana do sortowania ostatnie trzy elementy tablicy, która zostanie wyświetlona. <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenia metody ogólnej jest używana z `ReverseCompare` w odwrotnej kolejności sortowania ostatnie trzy elementy. Dokładnie mylić dinozaurów wyświetlane są ponownie.  
  
> [!NOTE]
>  Wywołania <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> i <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> metody ogólne nie wyglądają inaczej niż wywołania ich odpowiedników nierodzajowych, ponieważ wywnioskować typu parametru typu ogólnego z typu pierwszego argumentu, Visual Basic, C# i C++. Jeśli używasz [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do zbadania języka Microsoft intermediate language (MSIL), możesz zobaczyć, że wywoływane są metody rodzajowe.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="array" />.  
  
—lub— 
 <paramref name="length" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="length" /> nie określono prawidłowego zakresu <paramref name="array" />.  
  
—lub— 
Implementacja <paramref name="comparer" /> spowodowane błędem podczas sortowania. Na przykład <paramref name="comparer" /> mogą nie zwracać na 0, podczas porównywania elementów z samym sobą.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />i co najmniej jeden element w <paramref name="array" /> nie należy implementować <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 i starszych wersji należy używać algorytmu sortowania. Sortowania określa nieprawidłowy porównywanie w niektórych sytuacjach, w których zgłasza operacji <see cref="T:System.IndexOutOfRangeException" /> wyjątek i zgłasza <see cref="T:System.ArgumentException" /> wyjątek do obiektu wywołującego. Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], istnieje możliwość, że sortowanie operations w poprzednio zgłosił <see cref="T:System.ArgumentException" /> nie zgłosi wyjątku, ponieważ algorytmów sortowania i sortowania przez kopcowanie wstawiania nie wykrywaj nieprawidłowe porównania. W większości przypadków to dotyczy tablic z mniej niż 16 elementów.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Typ elementów tablicy klucza.</typeparam>
        <typeparam name="TValue">Typ elementów tablicy elementów.</typeparam>
        <param name="keys">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> zawierającą klucze ze słownika do sortowania.</param>
        <param name="items">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> zawiera elementy, które odpowiadają klucze ze słownika <paramref name="keys" />, lub <see langword="null" /> sortowania tylko <paramref name="keys" />.</param>
        <summary>Sortuje parę <see cref="T:System.Array" /> obiektów (jedna z nich zawiera klucze, a drugi zawiera elementy odpowiednich) oparte na kluczach, w pierwszym <see cref="T:System.Array" /> przy użyciu <see cref="T:System.IComparable`1" /> implementacji interfejsu ogólnego każdego klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w `keys` <xref:System.Array> ma odpowiadający mu element w `items` <xref:System.Array>. Gdy ponownie klucza podczas sortowania, odpowiadający mu element w `items` <xref:System.Array> podobnie zmiany położenia. W związku z tym `items` <xref:System.Array> są sortowane zgodnie z ustaleniami odpowiadających im kluczy w `keys` <xref:System.Array>.  
  
 Każdy klucz w `keys` <xref:System.Array> musi implementować <xref:System.IComparable%601> ogólny interfejs być zdolny do porównania z wartością co drugi klucz.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale nie będą sortowane elementy, które mają nie odpowiednich kluczy. Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <xref:System.ArgumentException>.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji wynosi mniej niż 16 elementów, używa [sortowania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * Dziennik<sup>N</sup>, gdzie *N* to zakres tablicy wejściowej, używa [sortowania przez Kopcowanie](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [sortowania](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane za pomocą algorytmów sortowania przez Kopcowanie i, w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, i <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> przeciążeń metody rodzajowej, do sortowania par tablicami reprezentującymi kluczy i wartości.  
  
 Kodu przykładowy definiuje alternatywny moduł porównujący dla ciągów o nazwie `ReverseCompare`, który implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Moduł porównujący wywołuje <xref:System.String.CompareTo%28System.String%29> metody, odwracając kolejność argumentów porównawczych, tak aby posortować ciągi wysokiej do minimum zamiast niska wysoka.  
  
 Przykład kodu tworzy i wyświetla tablicę nazw dinozaurów (klucze) i tablicy liczb całkowitych reprezentujących maksymalną długość każdego dinozaurów w metrach (wartości). Tablice są następnie sortowane i wyświetlane kilka razy:  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Przeciążenie jest wykorzystywane do sortowania obu tablicach w kolejności według nazw dinozaurów w pierwszej tablicy.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenia i wystąpienie `ReverseCompare` są używane, aby odwrócić porządek sortowania sparowane tablic.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Przeciążenie jest wykorzystywane do sortowania ostatnie trzy elementy obu tablicach.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenie jest wykorzystywane w odwrotnej kolejności sortowania ostatnie trzy elementy obu tablicach.  
  
> [!NOTE]
>  Wywołania metod ogólnych wyglądają inaczej niż wywołania ich odpowiedników nierodzajowych, ponieważ Visual Basic, C# i C++ wywnioskować typu parametru typu ogólnego z typu pierwszych dwóch argumentów. Jeśli używasz [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do zbadania języka Microsoft intermediate language (MSIL), możesz zobaczyć, że wywoływane są metody rodzajowe.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> nie jest <see langword="null" />, a dolna granica <paramref name="keys" /> jest niezgodna z dolną granicę <paramref name="items" />.  
  
—lub— 
 <paramref name="items" /> nie jest <see langword="null" />, a długość <paramref name="keys" /> jest większa niż długość <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jeden lub więcej elementów w <paramref name="keys" /><see cref="T:System.Array" /> nie należy implementować <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Typ elementów tablicy klucza.</typeparam>
        <typeparam name="TValue">Typ elementów tablicy elementów.</typeparam>
        <param name="keys">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> zawierającą klucze ze słownika do sortowania.</param>
        <param name="items">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> zawiera elementy, które odpowiadają klucze ze słownika <paramref name="keys" />, lub <see langword="null" /> sortowania tylko <paramref name="keys" />.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> Implementacji interfejsu ogólnego do użycia podczas porównywania elementów, lub <see langword="null" /> używać <see cref="T:System.IComparable`1" /> implementacji interfejsu ogólnego każdego elementu.</param>
        <summary>Sortuje parę <see cref="T:System.Array" /> obiektów (jedna z nich zawiera klucze, a drugi zawiera elementy odpowiednich) oparte na kluczach, w pierwszym <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.Generic.IComparer`1" /> interfejs generyczny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w `keys` <xref:System.Array> ma odpowiadający mu element w `items` <xref:System.Array>. Gdy ponownie klucza podczas sortowania, odpowiadający mu element w `items` <xref:System.Array> podobnie zmiany położenia. W związku z tym `items` <xref:System.Array> są sortowane zgodnie z ustaleniami odpowiadających im kluczy w `keys` <xref:System.Array>.  
  
 Jeśli `comparer` jest `null`, każdy klucz w `keys` <xref:System.Array> musi implementować <xref:System.IComparable%601> ogólny interfejs być zdolny do porównania z wartością co drugi klucz.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale nie będą sortowane elementy, które mają nie odpowiednich kluczy. Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <xref:System.ArgumentException>.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji wynosi mniej niż 16 elementów, używa [sortowania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * Dziennik<sup>N</sup>, gdzie *N* to zakres tablicy wejściowej, używa [sortowania przez Kopcowanie](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [sortowania](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane za pomocą algorytmów sortowania przez Kopcowanie i, w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 >,<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, i <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> przeciążeń metody rodzajowej, do sortowania par tablicami reprezentującymi kluczy i wartości.  
  
 Kodu przykładowy definiuje alternatywny moduł porównujący dla ciągów o nazwie `ReverseCompare`, który implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Moduł porównujący wywołuje <xref:System.String.CompareTo%28System.String%29> metody, odwracając kolejność argumentów porównawczych, tak aby posortować ciągi wysokiej do minimum zamiast niska wysoka.  
  
 Przykład kodu tworzy i wyświetla tablicę nazw dinozaurów (klucze) i tablicy liczb całkowitych reprezentujących maksymalną długość każdego dinozaurów w metrach (wartości). Tablice są następnie sortowane i wyświetlane kilka razy:  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Przeciążenie jest wykorzystywane do sortowania obu tablicach w kolejności według nazw dinozaurów w pierwszej tablicy.  
  
-   [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > przeciążenia i wystąpienie `ReverseCompare` służą do odwrócić kolejność sortowania sparowane tablic.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Przeciążenie jest wykorzystywane do sortowania ostatnie trzy elementy obu tablicach.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenie jest wykorzystywane w odwrotnej kolejności sortowania ostatnie trzy elementy obu tablicach.  
  
> [!NOTE]
>  Wywołania metod ogólnych wyglądają inaczej niż wywołania ich odpowiedników nierodzajowych, ponieważ Visual Basic, C# i C++ wywnioskować typu parametru typu ogólnego z typu pierwszych dwóch argumentów. Jeśli używasz [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do zbadania języka Microsoft intermediate language (MSIL), możesz zobaczyć, że wywoływane są metody rodzajowe.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> nie jest <see langword="null" />, a dolna granica <paramref name="keys" /> jest niezgodna z dolną granicę <paramref name="items" />.  
  
—lub— 
 <paramref name="items" /> nie jest <see langword="null" />, a długość <paramref name="keys" /> jest większa niż długość <paramref name="items" />.  
  
—lub— 
Implementacja <paramref name="comparer" /> spowodowane błędem podczas sortowania. Na przykład <paramref name="comparer" /> mogą nie zwracać na 0, podczas porównywania elementów z samym sobą.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />i co najmniej jeden element w <paramref name="keys" /><see cref="T:System.Array" /> nie należy implementować <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 i starszych wersji należy używać algorytmu sortowania. Sortowania określa nieprawidłowy porównywanie w niektórych sytuacjach, w których zgłasza operacji <see cref="T:System.IndexOutOfRangeException" /> wyjątek i zgłasza <see cref="T:System.ArgumentException" /> wyjątek do obiektu wywołującego. Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], istnieje możliwość, że sortowanie operations w poprzednio zgłosił <see cref="T:System.ArgumentException" /> nie zgłosi wyjątku, ponieważ algorytmów sortowania i sortowania przez kopcowanie wstawiania nie wykrywaj nieprawidłowe porównania. W większości przypadków to dotyczy tablic z mniej niż 16 elementów.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Typ elementów tablicy klucza.</typeparam>
        <typeparam name="TValue">Typ elementów tablicy elementów.</typeparam>
        <param name="keys">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> zawierającą klucze ze słownika do sortowania.</param>
        <param name="items">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> zawiera elementy, które odpowiadają klucze ze słownika <paramref name="keys" />, lub <see langword="null" /> sortowania tylko <paramref name="keys" />.</param>
        <param name="index">Indeks początkowy zakresu do sortowania.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <summary>Sortuje zakres elementów w parze <see cref="T:System.Array" /> obiektów (jedna z nich zawiera klucze, a drugi zawiera elementy odpowiednich) oparte na kluczach, w pierwszym <see cref="T:System.Array" /> przy użyciu <see cref="T:System.IComparable`1" /> implementacji interfejsu ogólnego każdego klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w `keys` <xref:System.Array> ma odpowiadający mu element w `items` <xref:System.Array>. Gdy ponownie klucza podczas sortowania, odpowiadający mu element w `items` <xref:System.Array> podobnie zmiany położenia. W związku z tym `items` <xref:System.Array> są sortowane zgodnie z ustaleniami odpowiadających im kluczy w `keys` <xref:System.Array>.  
  
 Każdy klucz z określonego zakresu elementów w `keys` <xref:System.Array> musi implementować <xref:System.IComparable%601> ogólny interfejs być zdolny do porównania z wartością co drugi klucz.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale nie będą sortowane elementy, które mają nie odpowiednich kluczy. Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <xref:System.ArgumentException>.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji wynosi mniej niż 16 elementów, używa [sortowania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * Dziennik<sup>N</sup>, gdzie *N* to zakres tablicy wejściowej, używa [sortowania przez Kopcowanie](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [sortowania](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane za pomocą algorytmów sortowania przez Kopcowanie i, w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operacji, gdzie `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 >, a <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> przeciążenia metody ogólnej do sortowania par tablicami reprezentującymi kluczy i wartości.  
  
 Kodu przykładowy definiuje alternatywny moduł porównujący dla ciągów o nazwie `ReverseCompare`, który implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Moduł porównujący wywołuje <xref:System.String.CompareTo%28System.String%29> metody, odwracając kolejność argumentów porównawczych, tak aby posortować ciągi wysokiej do minimum zamiast niska wysoka.  
  
 Przykład kodu tworzy i wyświetla tablicę nazw dinozaurów (klucze) i tablicy liczb całkowitych reprezentujących maksymalną długość każdego dinozaurów w metrach (wartości). Tablice są następnie sortowane i wyświetlane kilka razy:  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Przeciążenie jest wykorzystywane do sortowania obu tablicach w kolejności według nazw dinozaurów w pierwszej tablicy.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenia i wystąpienie `ReverseCompare` są używane, aby odwrócić porządek sortowania sparowane tablic.  
  
-   [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 > przeciążenie jest wykorzystywane do sortowania ostatnie trzy elementy obu tablicach.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenie jest wykorzystywane w odwrotnej kolejności sortowania ostatnie trzy elementy obu tablicach.  
  
> [!NOTE]
>  Wywołania metod ogólnych wyglądają inaczej niż wywołania ich odpowiedników nierodzajowych, ponieważ Visual Basic, C# i C++ wywnioskować typu parametru typu ogólnego z typu pierwszych dwóch argumentów. Jeśli używasz [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do zbadania języka Microsoft intermediate language (MSIL), możesz zobaczyć, że wywoływane są metody rodzajowe.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="keys" />.  
  
—lub— 
 <paramref name="length" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> nie jest <see langword="null" />, a dolna granica <paramref name="keys" /> jest niezgodna z dolną granicę <paramref name="items" />.  
  
—lub— 
 <paramref name="items" /> nie jest <see langword="null" />, a długość <paramref name="keys" /> jest większa niż długość <paramref name="items" />.  
  
—lub— 
 <paramref name="index" /> i <paramref name="length" /> nie określono prawidłowego zakresu <paramref name="keys" /><see cref="T:System.Array" />.  
  
—lub— 
 <paramref name="items" /> nie jest <see langword="null" />, i <paramref name="index" /> i <paramref name="length" /> nie określono prawidłowego zakresu <paramref name="items" /><see cref="T:System.Array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Jeden lub więcej elementów w <paramref name="keys" /><see cref="T:System.Array" /> nie należy implementować <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Typ elementów tablicy klucza.</typeparam>
        <typeparam name="TValue">Typ elementów tablicy elementów.</typeparam>
        <param name="keys">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> zawierającą klucze ze słownika do sortowania.</param>
        <param name="items">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> zawiera elementy, które odpowiadają klucze ze słownika <paramref name="keys" />, lub <see langword="null" /> sortowania tylko <paramref name="keys" />.</param>
        <param name="index">Indeks początkowy zakresu do sortowania.</param>
        <param name="length">Liczba elementów w zakresie do sortowania.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> Implementacji interfejsu ogólnego do użycia podczas porównywania elementów, lub <see langword="null" /> używać <see cref="T:System.IComparable`1" /> implementacji interfejsu ogólnego każdego elementu.</param>
        <summary>Sortuje zakres elementów w parze <see cref="T:System.Array" /> obiektów (jedna z nich zawiera klucze, a drugi zawiera elementy odpowiednich) oparte na kluczach, w pierwszym <see cref="T:System.Array" /> przy użyciu określonego <see cref="T:System.Collections.Generic.IComparer`1" /> interfejs generyczny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w `keys` <xref:System.Array> ma odpowiadający mu element w `items` <xref:System.Array>. Gdy ponownie klucza podczas sortowania, odpowiadający mu element w `items` <xref:System.Array> podobnie zmiany położenia. W związku z tym `items` <xref:System.Array> są sortowane zgodnie z ustaleniami odpowiadających im kluczy w `keys` <xref:System.Array>.  
  
 Jeśli `comparer` jest `null`, każdy klucz z określonego zakresu elementów w `keys` <xref:System.Array> musi implementować <xref:System.IComparable%601> ogólny interfejs być zdolny do porównania z wartością co drugi klucz.  
  
 Można sortować, jeśli istnieje więcej elementów niż klucze, ale nie będą sortowane elementy, które mają nie odpowiednich kluczy. Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <xref:System.ArgumentException>.  
  
 Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.  
  
 Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:  
  
-   Jeśli rozmiar partycji wynosi mniej niż 16 elementów, używa [sortowania](https://en.wikipedia.org/wiki/Insertion_sort) algorytmu.  
  
-   Jeśli liczba partycji przekracza 2 * Dziennik<sup>N</sup>, gdzie *N* to zakres tablicy wejściowej, używa [sortowania przez Kopcowanie](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa [sortowania](https://en.wikipedia.org/wiki/Quicksort) algorytmu.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Dla tablic, które są sortowane za pomocą algorytmów sortowania przez Kopcowanie i, w najgorszym przypadku ta metoda jest O (`n` dziennika `n`) operacji, gdzie `n` jest `length`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, a [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32% 2CSystem.Collections.Generic.IComparer%7b%60%600%7D%29 > przeciążeń metody rodzajowej, do sortowania par tablicami reprezentującymi kluczy i wartości.  
  
 Kodu przykładowy definiuje alternatywny moduł porównujący dla ciągów o nazwie `ReverseCompare`, który implementuje `IComparer<string>`(`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Moduł porównujący wywołuje <xref:System.String.CompareTo%28System.String%29> metody, odwracając kolejność argumentów porównawczych, tak aby posortować ciągi wysokiej do minimum zamiast niska wysoka.  
  
 Przykład kodu tworzy i wyświetla tablicę nazw dinozaurów (klucze) i tablicy liczb całkowitych reprezentujących maksymalną długość każdego dinozaurów w metrach (wartości). Tablice są następnie sortowane i wyświetlane kilka razy:  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Przeciążenie jest wykorzystywane do sortowania obu tablicach w kolejności według nazw dinozaurów w pierwszej tablicy.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Przeciążenia i wystąpienie `ReverseCompare` są używane, aby odwrócić porządek sortowania sparowane tablic.  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Przeciążenie jest wykorzystywane do sortowania ostatnie trzy elementy obu tablicach.  
  
-   [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > przeciążenie jest wykorzystywane do sortowania ostatnich trzech oba elementy tablic w odwrotnej kolejności.  
  
> [!NOTE]
>  Wywołania metod ogólnych wyglądają inaczej niż wywołania ich odpowiedników nierodzajowych, ponieważ Visual Basic, C# i C++ wywnioskować typu parametru typu ogólnego z typu pierwszych dwóch argumentów. Jeśli używasz [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) do zbadania języka Microsoft intermediate language (MSIL), możesz zobaczyć, że wywoływane są metody rodzajowe.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż dolna granica <paramref name="keys" />.  
  
—lub— 
 <paramref name="length" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> nie jest <see langword="null" />, a dolna granica <paramref name="keys" /> jest niezgodna z dolną granicę <paramref name="items" />.  
  
—lub— 
 <paramref name="items" /> nie jest <see langword="null" />, a długość <paramref name="keys" /> jest większa niż długość <paramref name="items" />.  
  
—lub— 
 <paramref name="index" /> i <paramref name="length" /> nie określono prawidłowego zakresu <paramref name="keys" /><see cref="T:System.Array" />.  
  
—lub— 
 <paramref name="items" /> nie jest <see langword="null" />, i <paramref name="index" /> i <paramref name="length" /> nie określono prawidłowego zakresu <paramref name="items" /><see cref="T:System.Array" />.  
  
—lub— 
Implementacja <paramref name="comparer" /> spowodowane błędem podczas sortowania. Na przykład <paramref name="comparer" /> mogą nie zwracać na 0, podczas porównywania elementów z samym sobą.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />i co najmniej jeden element w <paramref name="keys" /><see cref="T:System.Array" /> nie należy implementować <see cref="T:System.IComparable`1" /> interfejs generyczny.</exception>
        <block subset="none" type="usage">
          <para>.NET Framework 4 i starszych wersji należy używać algorytmu sortowania. Sortowania określa nieprawidłowy porównywanie w niektórych sytuacjach, w których zgłasza operacji <see cref="T:System.IndexOutOfRangeException" /> wyjątek i zgłasza <see cref="T:System.ArgumentException" /> wyjątek do obiektu wywołującego. Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], istnieje możliwość, że sortowanie operations w poprzednio zgłosił <see cref="T:System.ArgumentException" /> nie zgłosi wyjątku, ponieważ algorytmów sortowania i sortowania przez kopcowanie wstawiania nie wykrywaj nieprawidłowe porównania. W większości przypadków to dotyczy tablic z mniej niż 16 elementów.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Wykonywanie niezależnych od kultury operacji na ciągach w tablicach</related>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Array.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Array" />.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość implementuje <xref:System.Collections.ICollection?displayProperty=nameWithType> interfejsu.  
  
 Na podstawie klas .NET framework <xref:System.Array> Podaj swoją własną wersję zsynchronizowane za pomocą kolekcji <xref:System.Array.SyncRoot%2A> właściwości.  
  
 Klasy korzystające z tablicami, mogą także implementować własne synchronizacji przy użyciu <xref:System.Array.SyncRoot%2A> właściwości. Synchronizowanie kodu należy wykonywać operacje na `SyncRoot` kolekcji, a nie bezpośrednio w kolekcji. Gwarantuje to prawidłowe funkcjonowanie kolekcji, które są uzyskiwane z innych obiektów. W szczególności zachowuje właściwe synchronizacji z innych wątków, które mogą być jednocześnie modyfikowania kolekcji. Należy pamiętać, że niektóre implementacje <xref:System.Array.SyncRoot%2A> może zwrócić <xref:System.Array> sam.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie bezpieczne procedury wątku. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zablokować tablicy podczas całego procesu wyliczania, przy użyciu <xref:System.Array.SyncRoot%2A> właściwości.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów znajdujących się w <see cref="T:System.Array" />.</summary>
        <value>Liczba elementów znajdujących się w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowany na <xref:System.Collections.ICollection> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt, który ma zostać dodany do <see cref="T:System.Collections.IList" />.</param>
        <summary>Wywołanie tej metody zawsze zgłasza <see cref="T:System.NotSupportedException" /> wyjątku.</summary>
        <returns>Dodanie wartości do tablicy nie jest obsługiwana. Nie jest zwracana żadna wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType> implementacji dodanie członka do kolekcji. Jednak ponieważ tablice o stałym rozmiarze ( <xref:System.Array.IsFixedSize%2A> właściwość zawsze zwraca `true`), ta metoda zawsze wyrzuca <xref:System.NotSupportedException> wyjątku.  
  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowany na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> Ma stały rozmiar.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy z <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowany na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> Jest tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do zlokalizowania w bieżącej listy. Element do zlokalizowania może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Określa, czy element jest <see cref="T:System.Collections.IList" />.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> znajduje się w <see cref="T:System.Collections.IList" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowany na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do zlokalizowania w bieżącej listy.</param>
        <summary>Określa indeks konkretny element w <see cref="T:System.Collections.IList" />.</summary>
        <returns>Indeks wartości Jeśli znalezione na liście; w przeciwnym razie, wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowany na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Indeks, w którym <paramref name="value" /> powinien zostać wstawiony.</param>
        <param name="value">Obiekt do wstawienia.</param>
        <summary>Wstawia element do <see cref="T:System.Collections.IList" /> pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowany na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> nie jest prawidłowym indeksem w <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> Jest tylko do odczytu.  
  
—lub— 
<see cref="T:System.Collections.IList" /> Ma stały rozmiar.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> to odwołanie o wartości null w <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks elementu do pobrania lub ustawienia.</param>
        <summary>Pobieranie lub konfigurowanie elementów pod określonym indeksem.</summary>
        <value>Element pod określonym indeksem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowany na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="index" /> jest równa lub większa niż <see cref="P:System.Collections.ICollection.Count" />.</exception>
        <exception cref="T:System.ArgumentException">Bieżący <see cref="T:System.Array" /> nie ma dokładnie jednego wymiaru.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do usunięcia z <see cref="T:System.Collections.IList" />.</param>
        <summary>Usuwa pierwsze wystąpienie określonego obiektu z <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowany na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> Jest tylko do odczytu.  
  
—lub— 
<see cref="T:System.Collections.IList" /> Ma stały rozmiar.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks elementu do usunięcia.</param>
        <summary>Usuwa <see cref="T:System.Collections.IList" /> element pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowany na <xref:System.Collections.IList> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks nie jest prawidłowym indeksem w <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> Jest tylko do odczytu.  
  
—lub— 
<see cref="T:System.Collections.IList" /> Ma stały rozmiar.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania z bieżącym wystąpieniem.</param>
        <param name="comparer">Obiekt, który porównuje bieżący obiekt i <paramref name="other" />.</param>
        <summary>Określa, czy bieżący obiekt kolekcji poprzedza, odbywa się w tym samym miejscu lub następuje inny obiekt w porządku sortowania.</summary>
        <returns>Liczba całkowita wskazująca relację bieżącego obiektu kolekcji z innymi, jak pokazano w poniższej tabeli.  
  
 <list type="table"><listheader><term> Wartość zwracana 
 </term><description> Opis 
 </description></listheader><item><term> -1 
 </term><description> Bieżące wystąpienie poprzedza <paramref name="other" />.  
  
 </description></item><item><term> 0 
 </term><description> Bieżące wystąpienie i <paramref name="other" /> są takie same.  
  
 </description></item><item><term> 1 
 </term><description> Bieżące wystąpienie następuje po <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowany na <xref:System.Collections.IStructuralComparable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania z bieżącym wystąpieniem.</param>
        <param name="comparer">Obiekt, który określa, czy bieżące wystąpienie i <paramref name="other" /> są takie same.</param>
        <summary>Określa, czy obiekt jest taki sam jak bieżące wystąpienie.</summary>
        <returns>
          <see langword="true" /> Jeśli dwa obiekty są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowany na <xref:System.Collections.IStructuralEquatable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">Obiekt, który oblicza wartość skrótu bieżącego obiektu.</param>
        <summary>Zwraca wartość skrótu dla bieżącego wystąpienia.</summary>
        <returns>Wartość skrótu dla bieżącego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Array> wystąpienia jest rzutowany na <xref:System.Collections.IStructuralEquatable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member TrueForAll : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.TrueForAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Typ elementów tablicy.</typeparam>
        <param name="array">Jednowymiarowy, zaczynający się od zera <see cref="T:System.Array" /> sprawdzania warunków.</param>
        <param name="match">Predykat, który definiuje warunki sprawdzania elementów.</param>
        <summary>Określa, czy każdy element w tablicy jest zgodna z warunkami zdefiniowanymi przez określony predykat.</summary>
        <returns>
          <see langword="true" /> Jeśli każdy element w kolekcji <paramref name="array" /> pasuje do warunków zdefiniowanych przez określony predykat; w przeciwnym razie <see langword="false" />. Jeśli nie ma elementów w tablicy, wartość zwracana jest <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca`true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy `array` są indywidualnie przekazywane do <xref:System.Predicate%601>, a przetwarzanie jest zatrzymywany, gdy zwraca delegata `false` dla każdego elementu.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Array.Length%2A> z `array`.  
  
   
  
## Examples  
 Poniższy przykład określa, czy ostatni znak każdego elementu w tablicy ciągów jest liczbą. Tworzy dwie tablice parametrów. Pierwszy arrayincludes ciągi, które kończą się znaki alfabetu i ciągi, które kończą się znaki numeryczne. Druga tablica zawiera tylko ciągi, które kończą się znaki numeryczne. Przykładzie zdefiniowano też `EndWithANumber` metody, którego podpis pasuje do <xref:System.Predicate%601> delegować. Przykład przekazuje macierzy w celu <xref:System.Array.TrueForAll%2A> metoda wraz z delegatem, który reprezentuje `EndsWithANumber` metody.  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 Poniższy przykład jest podobny do pierwszego, z tą różnicą, że przekazuje tablicę ciągów, aby <xref:System.Array.TrueForAll%2A> metoda wraz z wyrażenia lambda, która określa, czy element określonej tablicy kończy ciąg reprezentujący liczbę.  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 W obu przypadkach <xref:System.Array.TrueForAll%2A> metoda zwraca `false` zaraz po napotkaniu pierwszego elementu tablicy, który nie kończy się liczbą. W przeciwnym razie zwraca `true` po wykonaniu wszystkich elementów w tablicy.  
  
> [!NOTE]
>  Jak obu przykładach w języku C# i Visual Basic nie jest niezbędne do utworzenia `Predicate<string>` delegowanie (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>
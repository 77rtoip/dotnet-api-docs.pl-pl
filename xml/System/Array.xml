<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Array.xml" source-language="en-US" target-language="pl-PL">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5b335c7a4c2bf211f02463ddce0008b2f15f2e6b0.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b335c7a4c2bf211f02463ddce0008b2f15f2e6b0</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the base class for all arrays in the common language runtime.</source>
          <target state="translated">Udostępnia metody tworzenia, modyfikowania, wyszukiwania i sortowania tablic, w tym samym służy jako klasa podstawowa dla wszystkich tablic w środowisko uruchomieniowe języka wspólnego.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> class is not part of the <ph id="ph2">&lt;xref:System.Collections&gt;</ph> namespaces.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> Klasa nie jest częścią <ph id="ph2">&lt;xref:System.Collections&gt;</ph> przestrzeni nazw.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>However, it is still considered a collection because it is based on the <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Jednak nadal uważa się kolekcji, ponieważ jest on oparty na <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> class is the base class for language implementations that support arrays.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> Klasa jest klasą podstawową dla implementacji języka, które obsługują tablic.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>However, only the system and compilers can derive explicitly from the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated">Jednak tylko systemu i kompilatory można jawnie pochodzi od <ph id="ph1">&lt;xref:System.Array&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Users should employ the array constructs provided by the language.</source>
          <target state="translated">Użytkownicy powinny zostać konstrukcje tablicy udostępniane przez język.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>An element is a value in an <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Element ma wartość <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The length of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is the total number of elements it can contain.</source>
          <target state="translated">Długość <ph id="ph1">&lt;xref:System.Array&gt;</ph> jest to całkowita liczba elementów może zawierać.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The lower bound of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is the index of its first element.</source>
          <target state="translated">Dolna granica <ph id="ph1">&lt;xref:System.Array&gt;</ph> jest indeks pierwszego elementu.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>An <ph id="ph1">&lt;xref:System.Array&gt;</ph> can have any lower bound, but it has a lower bound of zero by default.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> Może mieć żadnych dolna granica, ale ma dolna granica zero domyślnie.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>A different lower bound can be defined when creating an instance of the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class using <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>.A multidimensional <ph id="ph3">&lt;xref:System.Array&gt;</ph> can have different bounds for each dimension.</source>
          <target state="translated">Podczas tworzenia wystąpienia można zdefiniować dolną granicą inną <ph id="ph1">&lt;xref:System.Array&gt;</ph> przy użyciu <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>. Wielowymiarowe <ph id="ph3">&lt;xref:System.Array&gt;</ph> może mieć różne granic dla każdego wymiaru.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>An array can have a maximum of 32 dimensions.</source>
          <target state="translated">Tablica może mieć maksymalnie 32 wymiarów.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Unlike the classes in the <ph id="ph1">&lt;xref:System.Collections&gt;</ph> namespaces, <ph id="ph2">&lt;xref:System.Array&gt;</ph> has a fixed capacity.</source>
          <target state="translated">W odróżnieniu od klasy w <ph id="ph1">&lt;xref:System.Collections&gt;</ph> przestrzeni nazw, <ph id="ph2">&lt;xref:System.Array&gt;</ph> ma stały pojemność.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>To increase the capacity, you must create a new <ph id="ph1">&lt;xref:System.Array&gt;</ph> object with the required capacity, copy the elements from the old <ph id="ph2">&lt;xref:System.Array&gt;</ph> object to the new one, and delete the old <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Aby zwiększyć pojemność, należy utworzyć nowy <ph id="ph1">&lt;xref:System.Array&gt;</ph> obiektów z wymaganą pojemnością, skopiować elementy ze starego <ph id="ph2">&lt;xref:System.Array&gt;</ph> do nowego obiektu, a następnie usuń stare <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>By default, the maximum size of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is 2 gigabytes (GB).</source>
          <target state="translated">Domyślnie maksymalny rozmiar <ph id="ph1">&lt;xref:System.Array&gt;</ph> 2 gigabajty (GB).</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>In a 64-bit environment, you can avoid the size restriction by setting the <ph id="ph1">`enabled`</ph> attribute of the <bpt id="p1">[</bpt>gcAllowVeryLargeObjects<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)</ept> configuration element to <ph id="ph2">`true`</ph> in the run-time environment.</source>
          <target state="translated">W środowisku 64-bitowym ograniczenie rozmiaru można uniknąć, ustawiając <ph id="ph1">`enabled`</ph> atrybutu <bpt id="p1">[</bpt>gcallowverylargeobjects —<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)</ept> element konfiguracji do <ph id="ph2">`true`</ph> w środowisku czasu wykonywania.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>However, the array will still be limited to a total of 4 billion elements, and to a maximum index of 0X7FEFFFFF in any given dimension (0X7FFFFFC7 for byte arrays and arrays of single-byte structures).</source>
          <target state="translated">Jednak tablicy nadal będzie ograniczona, łączną liczbę elementów 4 miliardy oraz maksymalny indeks 0X7FEFFFFF w dowolnym danym wymiarze (0X7FFFFFC7 tablice typu byte i tablice struktur jednobajtowe).</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Single-dimensional arrays implement the <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType&gt;</ph> generic interfaces.</source>
          <target state="translated">Tablice jednowymiarowe zaimplementować <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType&gt;</ph> i <ph id="ph5">&lt;xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType&gt;</ph> interfejsach.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The implementations are provided to arrays at run time, and as a result, the generic interfaces do not appear in the declaration syntax for the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated">Implementacje są dostarczane do tablic w czasie wykonywania, a w związku z tym interfejsy ogólne nie są wyświetlane w Składnia deklaracji <ph id="ph1">&lt;xref:System.Array&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>In addition,  there are no reference topics for interface members that are accessible only by casting an array to the generic interface type (explicit interface implementations).</source>
          <target state="translated">Ponadto nie ma żadnych tematy dokumentacji dla członków interfejsu, które są dostępne tylko przez rzutowanie tablicy typu ogólnego interfejsu (jawne implementacje interfejsu).</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The key thing to be aware of when you cast an array to one of these interfaces is that members which add, insert, or remove elements throw <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Klucza jest, aby mieć świadomość podczas rzutowania tablicy do jednej z tych interfejsów jest elementów członkowskich, które dodają, Wstaw lub usuń elementy throw <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source><ph id="ph1">&lt;xref:System.Type&gt;</ph> objects provide information about array type declarations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type&gt;</ph> obiekty zawierają informacje dotyczące deklaracje typu tablicy.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> objects with the same array type share the same <ph id="ph2">&lt;xref:System.Type&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> obiekty z tym samym typem tablicy współużytkują takie same <ph id="ph2">&lt;xref:System.Type&gt;</ph> obiektu.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source><ph id="ph1">&lt;xref:System.Type.IsArray%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetElementType%2A?displayProperty=nameWithType&gt;</ph> might not return the expected results with <ph id="ph3">&lt;xref:System.Array&gt;</ph> because if an array is cast to the type <ph id="ph4">&lt;xref:System.Array&gt;</ph>, the result is an object, not an array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsArray%2A?displayProperty=nameWithType&gt;</ph> i <ph id="ph2">&lt;xref:System.Type.GetElementType%2A?displayProperty=nameWithType&gt;</ph> nie może zwrócić oczekiwanych rezultatów przy <ph id="ph3">&lt;xref:System.Array&gt;</ph> ponieważ jeśli tablica jest rzutowany na typ <ph id="ph4">&lt;xref:System.Array&gt;</ph>, wynikiem jest obiekt nie tablicy.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>That is, <ph id="ph1">`typeof(System.Array).IsArray`</ph> returns <ph id="ph2">`false`</ph>, and <ph id="ph3">`typeof(System.Array).GetElementType`</ph> returns <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Oznacza to <ph id="ph1">`typeof(System.Array).IsArray`</ph> zwraca <ph id="ph2">`false`</ph>, i <ph id="ph3">`typeof(System.Array).GetElementType`</ph> zwraca <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> method copies elements not only between arrays of the same type but also between standard arrays of different types; it handles type casting automatically.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> Metoda kopiuje elementy nie tylko między macierzami z tego samego typu, ale również między standardowe tablice o różnych typach; obsługiwane są automatycznie rzutowanie typów.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Some methods, such as <ph id="ph1">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.CopyTo%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Array.GetValue%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Array.SetValue%2A&gt;</ph>, provide overloads that accept 64-bit integers as parameters to accommodate large capacity arrays.</source>
          <target state="translated">Niektóre metody, takie jak <ph id="ph1">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.CopyTo%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Array.GetValue%2A&gt;</ph>, i <ph id="ph5">&lt;xref:System.Array.SetValue%2A&gt;</ph>, podaj przeciążenia, które akceptują 64-bitowych liczb całkowitych jako parametry, aby pomieścić tablice dużej pojemności.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source><ph id="ph1">&lt;xref:System.Array.LongLength%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> return 64-bit integers indicating the length of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.LongLength%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> zwraca 64-bitowych liczb całkowitych wskazującą długości tablicy.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is not guaranteed to be sorted.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> Nie jest gwarantowana ma zostać posortowana.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>You must sort the <ph id="ph1">&lt;xref:System.Array&gt;</ph> prior to performing operations (such as <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph>) that require the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to be sorted.</source>
          <target state="translated">Należy sortować <ph id="ph1">&lt;xref:System.Array&gt;</ph> przed wykonaniem operacji (takich jak <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph>), które wymagają <ph id="ph3">&lt;xref:System.Array&gt;</ph> ma zostać posortowana.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Using an <ph id="ph1">&lt;xref:System.Array&gt;</ph> object of pointers in native code is not supported and will throw a <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> for several methods.</source>
          <target state="translated">Przy użyciu <ph id="ph1">&lt;xref:System.Array&gt;</ph> obiektu wskaźniki w kodzie natywnym nie jest obsługiwana i zgłosi <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> dla kilku metod.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The following code example shows how <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> copies elements between an array of type integer and an array of type <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">Poniższy kod przedstawia przykład sposobu <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> kopiuje elementy między tablicą typu integer i tablicy typu <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The following code example creates and initializes an <ph id="ph1">&lt;xref:System.Array&gt;</ph> and displays its properties and its elements.</source>
          <target state="translated">Poniższy przykład kodu tworzy i inicjuje <ph id="ph1">&lt;xref:System.Array&gt;</ph> i wyświetla jego właściwości i jej elementów.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Public static (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) members of this type are thread safe.</source>
          <target state="translated">Publiczne statyczne (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> w języku Visual Basic) elementy członkowskie tego typu są bezpieczne dla wątków.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Any instance members are not guaranteed to be thread safe.</source>
          <target state="translated">Wystąpienia elementów członkowskich nie dają gwarancji bezpieczeństwa wątków.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>This implementation does not provide a synchronized (thread safe) wrapper for an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>; however, .NET Framework classes based on <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> provide their own synchronized version of the collection using the <ph id="ph3">&lt;see cref="P:System.Array.SyncRoot" /&gt;</ph> property.</source>
          <target state="translated">Ta implementacja nie zapewnia zsynchronizowany otoki (wielowątkowość) dla <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>, jednak na podstawie klasy .NET Framework <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> Udostępnij własnych zsynchronizowaną wersję w kolekcji przy użyciu <ph id="ph3">&lt;see cref="P:System.Array.SyncRoot" /&gt;</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>The one-dimensional, zero-based array to wrap in a read-only <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph> wrapper.</source>
          <target state="translated">Tablica jednowymiarowa, liczony od zera do zakodowania w tylko do odczytu <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph> otoki.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>Returns a read-only wrapper for the specified array.</source>
          <target state="translated">Zwraca tylko do odczytu otoki dla określonej tablicy.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>A read-only <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph> wrapper for the specified array.</source>
          <target state="translated">Tylko do odczytu <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph> otoki dla określonej tablicy.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>To prevent any modifications to the array, expose the array only through this wrapper.</source>
          <target state="translated">Aby zapobiec wszelkie zmiany w tablicy, ujawnia tablicy tylko za pośrednictwem tej otoki.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">Kolekcja, która jest tylko do odczytu, jest po prostu zbiorem z otoką uniemożliwiającą zmianę kolekcji; w związku z tym, jeśli zmiany zostaną wprowadzone do podstawowej kolekcji, kolekcja tylko do odczytu uwzględni te zmiany.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>The following example wraps an array in a read-only <ph id="ph1">&lt;xref:System.Collections.ObjectModel.ReadOnlyCollection%601&gt;</ph>.</source>
          <target state="translated">Poniższy przykład otacza tablicy tylko do odczytu <ph id="ph1">&lt;xref:System.Collections.ObjectModel.ReadOnlyCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Searches a one-dimensional sorted <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> for a value, using a binary search algorithm.</source>
          <target state="translated">Wyszukuje jednowymiarowa sortowane <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> wartości, przy użyciu algorytmu wyszukiwania binarnego.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The sorted one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Sortowanych jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The object to search for.</source>
          <target state="translated">Obiekt, który trzeba wyszukać.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>Searches an entire one-dimensional sorted array for a specific element, using the <ph id="ph1">&lt;see cref="T:System.IComparable" /&gt;</ph> interface implemented by each element of the array and by the specified object.</source>
          <target state="translated">Wyszukiwanie jako całą jednowymiarowa sortowane tablicy dla określonego elementu, za pomocą <ph id="ph1">&lt;see cref="T:System.IComparable" /&gt;</ph> interfejsu zaimplementowanego przez każdy element tablicy i określonego obiektu.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Określony indeks <ph id="ph1">&lt;paramref name="value" /&gt;</ph> w określonym <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, jeśli <ph id="ph3">&lt;paramref name="value" /&gt;</ph> zostanie odnaleziony; w przeciwnym razie wartość ujemną.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nie można odnaleźć i <ph id="ph2">&lt;paramref name="value" /&gt;</ph> jest mniejszy niż jeden lub więcej elementów w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, liczbami ujemnymi zwrócony dopełnienia bitowego indeksu pierwszego elementu, który jest większy niż <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nie można odnaleźć i <ph id="ph2">&lt;paramref name="value" /&gt;</ph> jest większa niż wszystkie elementy w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, liczbami ujemnymi zwrócony dopełnienia bitowego (indeksu ostatnim elementem plus 1).</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Jeśli ta metoda jest wywoływana z innych niż — sortowane <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <ph id="ph2">&lt;paramref name="value" /&gt;</ph> znajduje się w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Ta metoda nie obsługuje tablic wyszukiwanie, zawierające ujemne indeksy.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> muszą być posortowane przed wywołaniem tej metody.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array&gt;</ph> nie zawiera określonej wartości, metoda zwraca całkowitą liczbą ujemną.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">Operator dopełnienia bitowego można zastosować (~ w języku C# <ph id="ph1">`Not`</ph> w języku Visual Basic) do negatywny wynik do tworzenia indeksu.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Jeśli ten indeks jest większa niż górna granica tablicy, istnieją żadnych elementów, które są większe niż <ph id="ph1">`value`</ph> w tablicy.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>Either <ph id="ph1">`value`</ph> or every element of <ph id="ph2">`array`</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface, which is used for comparisons.</source>
          <target state="translated">Albo <ph id="ph1">`value`</ph> lub każdy element <ph id="ph2">`array`</ph> musi implementować <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interfejs, który jest używany do porównania.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementacji; w przeciwnym razie wynik może być nieprawidłowy.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If<ph id="ph1">`value`</ph> does not implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph3">`array`</ph> are not tested for <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
          <target state="translated">Jeśli<ph id="ph1">`value`</ph> nie implementuje <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interfejsu elementy <ph id="ph3">`array`</ph> nie są sprawdzane pod kątem <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> przed rozpoczęciem wyszukiwania.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Jest zwracany wyjątek, jeśli wyszukiwanie napotkał element, który nie implementuje <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Dozwolone są zduplikowane elementy.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array&gt;</ph> zawiera więcej niż jeden element równa <ph id="ph2">`value`</ph>, metoda zwraca indeks tylko jedno z wystąpień i niekoniecznie pierwsza z nich.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> zawsze można porównać z żadnym innym typem odwołania; w związku z tym porównania z <ph id="ph2">`null`</ph> nie generują wyjątek.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Dla każdego elementu przetestowane <ph id="ph1">`value`</ph> jest przekazywany do odpowiedniego <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> wdrożenia, nawet jeśli <ph id="ph3">`value`</ph> jest <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Oznacza to <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> wdrożenia Określa jak porównuje danego elementu <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Ta metoda jest O (dziennika <ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The following code example shows how to use <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> to locate a specific object in an <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Poniższy przykładowy kod przedstawia sposób użycia <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> można znaleźć określonego obiektu w <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The array is created with its elements in ascending sort order.</source>
          <target state="translated">Tablica jest tworzony z jego elementów w kolejności rosnącej.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method requires the array to be sorted in ascending order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> Metoda wymaga tablicy mają być sortowane w kolejności rosnącej.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> Typ nie jest zgodny z elementami <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> does not implement the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> nie implementuje <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interfejsu i wyszukiwanie napotkał element, który nie implementuje <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The sorted one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Sortowanych jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The object to search for.</source>
          <target state="translated">Obiekt, który trzeba wyszukać.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> Wdrożenia do użycia podczas porównywania elementów.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> stosowania dla każdego elementu.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>Searches an entire one-dimensional sorted array for a value using the specified <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> interface.</source>
          <target state="translated">Wyszukiwanie jako całą jednowymiarowa sortowane tablicy wartości przy użyciu określonego <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Określony indeks <ph id="ph1">&lt;paramref name="value" /&gt;</ph> w określonym <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, jeśli <ph id="ph3">&lt;paramref name="value" /&gt;</ph> zostanie odnaleziony; w przeciwnym razie wartość ujemną.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nie można odnaleźć i <ph id="ph2">&lt;paramref name="value" /&gt;</ph> jest mniejszy niż jeden lub więcej elementów w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, liczbami ujemnymi zwrócony dopełnienia bitowego indeksu pierwszego elementu, który jest większy niż <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nie można odnaleźć i <ph id="ph2">&lt;paramref name="value" /&gt;</ph> jest większa niż wszystkie elementy w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, liczbami ujemnymi zwrócony dopełnienia bitowego (indeksu ostatnim elementem plus 1).</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Jeśli ta metoda jest wywoływana z innych niż — sortowane <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <ph id="ph2">&lt;paramref name="value" /&gt;</ph> znajduje się w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Ta metoda nie obsługuje tablic wyszukiwanie, zawierające ujemne indeksy.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> muszą być posortowane przed wywołaniem tej metody.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array&gt;</ph> nie zawiera określonej wartości, metoda zwraca całkowitą liczbą ujemną.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">Operator dopełnienia bitowego można zastosować (~ w języku C# <ph id="ph1">`Not`</ph> w języku Visual Basic) do negatywny wynik do tworzenia indeksu.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Jeśli ten indeks jest większa niż górna granica tablicy, istnieją żadnych elementów, które są większe niż <ph id="ph1">`value`</ph> w tablicy.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">Moduł porównujący dostosowuje sposób porównywania elementów.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Na przykład można użyć <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> jako modułu porównującego do wyszukiwania ciągów bez uwzględniania wielkości liter.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> implementation.</source>
          <target state="translated">Jeśli <ph id="ph1">`comparer`</ph> nie jest <ph id="ph2">`null`</ph>, elementy <ph id="ph3">`array`</ph> są porównywane z podaną wartością przy użyciu określonego <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> implementacji.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez <ph id="ph2">`comparer`</ph>; w przeciwnym razie wynik może być nieprawidłowy.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If<ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation provided by the element itself or by the specified value.</source>
          <target state="translated">Jeśli<ph id="ph1">`comparer`</ph> jest <ph id="ph2">`null`</ph>, porównanie wykonuje się za pomocą <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementacja elementu lub określonej wartości.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementacji; w przeciwnym razie wynik może być nieprawidłowy.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph> and <ph id="ph3">`value`</ph> does not implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph5">`array`</ph> are not tested for <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
          <target state="translated">Jeśli <ph id="ph1">`comparer`</ph> jest <ph id="ph2">`null`</ph> i <ph id="ph3">`value`</ph> nie implementuje <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interfejsu elementy <ph id="ph5">`array`</ph> nie są sprawdzane pod kątem <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> przed rozpoczęciem wyszukiwania.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Jest zwracany wyjątek, jeśli wyszukiwanie napotkał element, który nie implementuje <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Dozwolone są zduplikowane elementy.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array&gt;</ph> zawiera więcej niż jeden element równa <ph id="ph2">`value`</ph>, metoda zwraca indeks tylko jedno z wystąpień i niekoniecznie pierwsza z nich.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> zawsze można porównać z żadnym innym typem odwołania; w związku z tym porównania z <ph id="ph2">`null`</ph> nie generują wyjątek.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Dla każdego elementu przetestowane <ph id="ph1">`value`</ph> jest przekazywany do odpowiedniego <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> wdrożenia, nawet jeśli <ph id="ph3">`value`</ph> jest <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Oznacza to <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> wdrożenia Określa jak porównuje danego elementu <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Ta metoda jest O (dziennika <ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, i <ph id="ph3">&lt;paramref name="value" /&gt;</ph> jest typu, który nie jest zgodny z elementami <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> does not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> nie implementuje <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interfejsu i wyszukiwanie napotkał element, który nie implementuje <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The sorted one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Sortowanych jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The starting index of the range to search.</source>
          <target state="translated">Indeks początkowy zakresu wyszukiwania.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The length of the range to search.</source>
          <target state="translated">Długość zakresu wyszukiwania.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The object to search for.</source>
          <target state="translated">Obiekt, który trzeba wyszukać.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the <ph id="ph1">&lt;see cref="T:System.IComparable" /&gt;</ph> interface implemented by each element of the array and by the specified value.</source>
          <target state="translated">Przeszukuje zakresu elementów tablicą jednowymiarową posortowane wartości, przy użyciu <ph id="ph1">&lt;see cref="T:System.IComparable" /&gt;</ph> interfejsu zaimplementowanego przez każdy element tablicy i określonej wartości.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Określony indeks <ph id="ph1">&lt;paramref name="value" /&gt;</ph> w określonym <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, jeśli <ph id="ph3">&lt;paramref name="value" /&gt;</ph> zostanie odnaleziony; w przeciwnym razie wartość ujemną.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nie można odnaleźć i <ph id="ph2">&lt;paramref name="value" /&gt;</ph> jest mniejszy niż jeden lub więcej elementów w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, liczbami ujemnymi zwrócony dopełnienia bitowego indeksu pierwszego elementu, który jest większy niż <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nie można odnaleźć i <ph id="ph2">&lt;paramref name="value" /&gt;</ph> jest większa niż wszystkie elementy w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, liczbami ujemnymi zwrócony dopełnienia bitowego (indeksu ostatnim elementem plus 1).</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Jeśli ta metoda jest wywoływana z innych niż — sortowane <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <ph id="ph2">&lt;paramref name="value" /&gt;</ph> znajduje się w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Ta metoda nie obsługuje tablic wyszukiwanie, zawierające ujemne indeksy.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> muszą być posortowane przed wywołaniem tej metody.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array&gt;</ph> nie zawiera określonej wartości, metoda zwraca całkowitą liczbą ujemną.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result to produce an index.</source>
          <target state="translated">Operator dopełnienia bitowego można zastosować (~ w języku C# <ph id="ph1">`Not`</ph> w języku Visual Basic) do negatywny wynik do tworzenia indeksu.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Jeśli ten indeks jest większa niż górna granica tablicy, istnieją żadnych elementów, które są większe niż <ph id="ph1">`value`</ph> w tablicy.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>Either <ph id="ph1">`value`</ph> or every element of <ph id="ph2">`array`</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface, which is used for comparisons.</source>
          <target state="translated">Albo <ph id="ph1">`value`</ph> lub każdy element <ph id="ph2">`array`</ph> musi implementować <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interfejs, który jest używany do porównania.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementacji; w przeciwnym razie wynik może być nieprawidłowy.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If <ph id="ph1">`value`</ph> does not implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph3">`array`</ph> are not tested for <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
          <target state="translated">Jeśli <ph id="ph1">`value`</ph> nie implementuje <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interfejsu elementy <ph id="ph3">`array`</ph> nie są sprawdzane pod kątem <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> przed rozpoczęciem wyszukiwania.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Jest zwracany wyjątek, jeśli wyszukiwanie napotkał element, który nie implementuje <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Dozwolone są zduplikowane elementy.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array&gt;</ph> zawiera więcej niż jeden element równa <ph id="ph2">`value`</ph>, metoda zwraca indeks tylko jedno z wystąpień i niekoniecznie pierwsza z nich.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> zawsze można porównać z żadnym innym typem odwołania; w związku z tym porównania z <ph id="ph2">`null`</ph> nie generują wyjątek.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Dla każdego elementu przetestowane <ph id="ph1">`value`</ph> jest przekazywany do odpowiedniego <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> wdrożenia, nawet jeśli <ph id="ph3">`value`</ph> jest <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Oznacza to <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> wdrożenia Określa jak porównuje danego elementu <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Ta metoda jest O (dziennika <ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> jest mniejsza niż dolna granica <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> i <ph id="ph2">&lt;paramref name="length" /&gt;</ph> nie zostanie określony prawidłowy zakres w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> Typ nie jest zgodny z elementami <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> does not implement the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> nie implementuje <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interfejsu i wyszukiwanie napotkał element, który nie implementuje <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The sorted one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Sortowanych jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The starting index of the range to search.</source>
          <target state="translated">Indeks początkowy zakresu wyszukiwania.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The length of the range to search.</source>
          <target state="translated">Długość zakresu wyszukiwania.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The object to search for.</source>
          <target state="translated">Obiekt, który trzeba wyszukać.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> Wdrożenia do użycia podczas porównywania elementów.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> stosowania dla każdego elementu.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the specified <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> interface.</source>
          <target state="translated">Przeszukuje tablicą jednowymiarową posortowane wartości, korzystając z określonego zakresu elementów <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Określony indeks <ph id="ph1">&lt;paramref name="value" /&gt;</ph> w określonym <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, jeśli <ph id="ph3">&lt;paramref name="value" /&gt;</ph> zostanie odnaleziony; w przeciwnym razie wartość ujemną.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nie można odnaleźć i <ph id="ph2">&lt;paramref name="value" /&gt;</ph> jest mniejszy niż jeden lub więcej elementów w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, liczbami ujemnymi zwrócony dopełnienia bitowego indeksu pierwszego elementu, który jest większy niż <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nie można odnaleźć i <ph id="ph2">&lt;paramref name="value" /&gt;</ph> jest większa niż wszystkie elementy w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, liczbami ujemnymi zwrócony dopełnienia bitowego (indeksu ostatnim elementem plus 1).</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Jeśli ta metoda jest wywoływana z innych niż — sortowane <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <ph id="ph2">&lt;paramref name="value" /&gt;</ph> znajduje się w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Ta metoda nie obsługuje tablic wyszukiwanie, zawierające ujemne indeksy.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> muszą być posortowane przed wywołaniem tej metody.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array&gt;</ph> nie zawiera określonej wartości, metoda zwraca całkowitą liczbą ujemną.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">Operator dopełnienia bitowego można zastosować (~ w języku C# <ph id="ph1">`Not`</ph> w języku Visual Basic) do negatywny wynik do tworzenia indeksu.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Jeśli ten indeks jest większa niż górna granica tablicy, istnieją żadnych elementów, które są większe niż <ph id="ph1">`value`</ph> w tablicy.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">Moduł porównujący dostosowuje sposób porównywania elementów.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Na przykład można użyć <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> jako modułu porównującego do wyszukiwania ciągów bez uwzględniania wielkości liter.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> implementation.</source>
          <target state="translated">Jeśli <ph id="ph1">`comparer`</ph> nie jest <ph id="ph2">`null`</ph>, elementy <ph id="ph3">`array`</ph> są porównywane z podaną wartością przy użyciu określonego <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> implementacji.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez <ph id="ph2">`comparer`</ph>; w przeciwnym razie wynik może być nieprawidłowy.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation provided by the element itself or by the specified value.</source>
          <target state="translated">Jeśli <ph id="ph1">`comparer`</ph> jest <ph id="ph2">`null`</ph>, porównanie wykonuje się za pomocą <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementacja elementu lub określonej wartości.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementacji; w przeciwnym razie wynik może być nieprawidłowy.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph> and <ph id="ph3">`value`</ph> does not implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph5">`array`</ph> are not tested for <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
          <target state="translated">Jeśli <ph id="ph1">`comparer`</ph> jest <ph id="ph2">`null`</ph> i <ph id="ph3">`value`</ph> nie implementuje <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interfejsu elementy <ph id="ph5">`array`</ph> nie są sprawdzane pod kątem <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> przed rozpoczęciem wyszukiwania.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Jest zwracany wyjątek, jeśli wyszukiwanie napotkał element, który nie implementuje <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Dozwolone są zduplikowane elementy.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array&gt;</ph> zawiera więcej niż jeden element równa <ph id="ph2">`value`</ph>, metoda zwraca indeks tylko jedno z wystąpień i niekoniecznie pierwsza z nich.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception when using <ph id="ph3">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`null`</ph> zawsze można porównać z żadnym innym typem odwołania; w związku z tym porównania z <ph id="ph2">`null`</ph> nie generują wyjątek, korzystając z <ph id="ph3">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Dla każdego elementu przetestowane <ph id="ph1">`value`</ph> jest przekazywany do odpowiedniego <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> wdrożenia, nawet jeśli <ph id="ph3">`value`</ph> jest <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Oznacza to <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> wdrożenia Określa jak porównuje danego elementu <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Ta metoda jest O (dziennika <ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> jest mniejsza niż dolna granica <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> i <ph id="ph2">&lt;paramref name="length" /&gt;</ph> nie zostanie określony prawidłowy zakres w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, i <ph id="ph3">&lt;paramref name="value" /&gt;</ph> jest typu, który nie jest zgodny z elementami <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> does not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> nie implementuje <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interfejsu i wyszukiwanie napotkał element, który nie implementuje <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Sortowanych jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The object to search for.</source>
          <target state="translated">Obiekt, który trzeba wyszukać.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>Searches an entire one-dimensional sorted array for a specific element, using the <ph id="ph1">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implemented by each element of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> and by the specified object.</source>
          <target state="translated">Wyszukiwanie jako całą jednowymiarowa sortowane tablicy dla określonego elementu, za pomocą <ph id="ph1">&lt;see cref="T:System.IComparable`1" /&gt;</ph> ogólny interfejs implementowany przez każdy element <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> i określonego obiektu.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Określony indeks <ph id="ph1">&lt;paramref name="value" /&gt;</ph> w określonym <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, jeśli <ph id="ph3">&lt;paramref name="value" /&gt;</ph> zostanie odnaleziony; w przeciwnym razie wartość ujemną.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nie można odnaleźć i <ph id="ph2">&lt;paramref name="value" /&gt;</ph> jest mniejszy niż jeden lub więcej elementów w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, liczbami ujemnymi zwrócony dopełnienia bitowego indeksu pierwszego elementu, który jest większy niż <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nie można odnaleźć i <ph id="ph2">&lt;paramref name="value" /&gt;</ph> jest większa niż wszystkie elementy w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, liczbami ujemnymi zwrócony dopełnienia bitowego (indeksu ostatnim elementem plus 1).</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Jeśli ta metoda jest wywoływana z innych niż — sortowane <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <ph id="ph2">&lt;paramref name="value" /&gt;</ph> znajduje się w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Ta metoda nie obsługuje tablic wyszukiwanie, zawierające ujemne indeksy.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> muszą być posortowane przed wywołaniem tej metody.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If <ph id="ph1">`array`</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Jeśli <ph id="ph1">`array`</ph> nie zawiera określonej wartości, metoda zwraca całkowitą liczbą ujemną.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">Operator dopełnienia bitowego można zastosować (~ w języku C# <ph id="ph1">`Not`</ph> w języku Visual Basic) do negatywny wynik do tworzenia indeksu.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Jeśli ten indeks jest równy rozmiarowi tablicy, są żadnych elementów większe niż <ph id="ph1">`value`</ph> w tablicy.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">`T`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface, which is used for comparisons.</source>
          <target state="translated"><ph id="ph1">`T`</ph> musi implementować <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> interfejs ogólny, który służy do porównania.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementacji; w przeciwnym razie wynik może być nieprawidłowy.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Dozwolone są zduplikowane elementy.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array&gt;</ph> zawiera więcej niż jeden element równa <ph id="ph2">`value`</ph>, metoda zwraca indeks tylko jedno z wystąpień i niekoniecznie pierwsza z nich.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> zawsze można porównać z żadnym innym typem odwołania; w związku z tym porównania z <ph id="ph2">`null`</ph> nie generują wyjątek.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Dla każdego elementu przetestowane <ph id="ph1">`value`</ph> jest przekazywany do odpowiedniego <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> wdrożenia, nawet jeśli <ph id="ph3">`value`</ph> jest <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Oznacza to <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> wdrożenia Określa jak porównuje danego elementu <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Ta metoda jest O (dziennika <ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generic method overload.</source>
          <target state="translated">Poniższy przykład kodu pokazuje <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%29&gt;</ph> przeciążenia metody rodzajowej i <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> przeciążenia metody rodzajowej.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>An array of strings is created, in no particular order.</source>
          <target state="translated">Tablica ciągów jest tworzony w określonej kolejności.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The array is displayed, sorted, and displayed again.</source>
          <target state="translated">Tablica jest wyświetlana, sortowana i ponownie wyświetlana.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>Arrays must be sorted in order to use the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method.</source>
          <target state="translated">Tablice muszą być posortowane w celu użycia <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Wywołania <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> metody rodzajowe nie wygląda inaczej z wywołań, aby ich odpowiedniki nierodzajowe, ponieważ Visual Basic, C# i C++ wnioskować o typie parametru typu ogólnego z typem pierwszego argumentu.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Jeśli używasz <bpt id="p1">[</bpt>Ildasm.exe (dezasembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> zbadać język pośredni firmy Microsoft (MSIL), widoczny wywoływane metody ogólne.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generic method overload is then used to search for two strings, one that is not in the array and one that is.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> Przeciążenia metody rodzajowej jest następnie używany do wyszukiwania dwa ciągi, jest taki, który nie znajduje się w tablicy i jeden który.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The array and the return value of the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method are passed to the <ph id="ph2">`ShowWhere`</ph> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</source>
          <target state="translated">Tablica i wartość zwracaną <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> metody są przekazywane do <ph id="ph2">`ShowWhere`</ph> ogólnego metodę, która zawiera wartość indeksu, jeśli ciąg zostanie znaleziony, a w przeciwnym razie elementy ciąg wyszukiwania spadnie między gdyby w tablicy.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The index is negative if the string is not in the array, so the <ph id="ph1">`ShowWhere`</ph> method takes the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph>-1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</source>
          <target state="translated">Indeks jest liczbą ujemną, jeśli ciąg nie jest w tablicy, więc <ph id="ph1">`ShowWhere`</ph> metoda przyjmuje dopełnienia bitowego (~ operatora w języku C# i Visual C++ <ph id="ph2">`Xor`</ph>-1 w języku Visual Basic) Aby uzyskać indeks pierwszego elementu na liście, który jest większy niż wyszukiwanie str w toku.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">&lt;paramref name="T" /&gt;</ph> does not implement the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="T" /&gt;</ph> nie implementuje <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Sortowanych jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The object to search for.</source>
          <target state="translated">Obiekt, który trzeba wyszukać.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> Wdrożenia do użycia podczas porównywania elementów.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> stosowania dla każdego elementu.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>Searches an entire one-dimensional sorted array for a value using the specified <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Wyszukiwanie jako całą jednowymiarowa sortowane tablicy wartości przy użyciu określonego <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Określony indeks <ph id="ph1">&lt;paramref name="value" /&gt;</ph> w określonym <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, jeśli <ph id="ph3">&lt;paramref name="value" /&gt;</ph> zostanie odnaleziony; w przeciwnym razie wartość ujemną.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nie można odnaleźć i <ph id="ph2">&lt;paramref name="value" /&gt;</ph> jest mniejszy niż jeden lub więcej elementów w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, liczbami ujemnymi zwrócony dopełnienia bitowego indeksu pierwszego elementu, który jest większy niż <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nie można odnaleźć i <ph id="ph2">&lt;paramref name="value" /&gt;</ph> jest większa niż wszystkie elementy w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, liczbami ujemnymi zwrócony dopełnienia bitowego (indeksu ostatnim elementem plus 1).</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Jeśli ta metoda jest wywoływana z innych niż — sortowane <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <ph id="ph2">&lt;paramref name="value" /&gt;</ph> znajduje się w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Ta metoda nie obsługuje tablic wyszukiwanie, zawierające ujemne indeksy.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> muszą być posortowane przed wywołaniem tej metody.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array&gt;</ph> nie zawiera określonej wartości, metoda zwraca całkowitą liczbą ujemną.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result to produce an index.</source>
          <target state="translated">Operator dopełnienia bitowego można zastosować (~ w języku C# <ph id="ph1">`Not`</ph> w języku Visual Basic) do negatywny wynik do tworzenia indeksu.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Jeśli ten indeks jest równy rozmiarowi tablicy, są żadnych elementów większe niż <ph id="ph1">`value`</ph> w tablicy.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">Moduł porównujący dostosowuje sposób porównywania elementów.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Na przykład można użyć <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> jako modułu porównującego do wyszukiwania ciągów bez uwzględniania wielkości liter.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> generic interface implementation.</source>
          <target state="translated">Jeśli <ph id="ph1">`comparer`</ph> nie jest <ph id="ph2">`null`</ph>, elementy <ph id="ph3">`array`</ph> są porównywane z podaną wartością przy użyciu określonego <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> implementacją ogólnego interfejsu.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez <ph id="ph2">`comparer`</ph>; w przeciwnym razie wynik może być nieprawidłowy.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface implementation provided by <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">`comparer`</ph> jest <ph id="ph2">`null`</ph>, porównanie wykonuje się za pomocą <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> implementacji interfejsu ogólnego pochodzącymi <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementacji; w przeciwnym razie wynik może być nieprawidłowy.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph> and <ph id="ph3">`value`</ph> does not implement the <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> generic interface, the elements of <ph id="ph5">`array`</ph> are not tested for <ph id="ph6">&lt;xref:System.IComparable%601&gt;</ph> before the search begins.</source>
          <target state="translated">Jeśli <ph id="ph1">`comparer`</ph> jest <ph id="ph2">`null`</ph> i <ph id="ph3">`value`</ph> nie implementuje <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> interfejs ogólny, elementy <ph id="ph5">`array`</ph> nie są sprawdzane pod kątem <ph id="ph6">&lt;xref:System.IComparable%601&gt;</ph> przed rozpoczęciem wyszukiwania.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph>.</source>
          <target state="translated">Jest zwracany wyjątek, jeśli wyszukiwanie napotkał element, który nie implementuje <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Dozwolone są zduplikowane elementy.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array&gt;</ph> zawiera więcej niż jeden element równa <ph id="ph2">`value`</ph>, metoda zwraca indeks tylko jedno z wystąpień i niekoniecznie pierwsza z nich.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> zawsze można porównać z żadnym innym typem odwołania; w związku z tym porównania z <ph id="ph2">`null`</ph> nie generują wyjątek.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Dla każdego elementu przetestowane <ph id="ph1">`value`</ph> jest przekazywany do odpowiedniego <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> wdrożenia, nawet jeśli <ph id="ph3">`value`</ph> jest <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Oznacza to <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> wdrożenia Określa jak porównuje danego elementu <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Ta metoda jest O (dziennika <ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload.</source>
          <target state="translated">W poniższym przykładzie pokazano <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> przeciążenia metody rodzajowej i <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> przeciążenia metody rodzajowej.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">Przykładowy kod definiuje alternatywny porównania ciągów o nazwie <ph id="ph1">`ReverseCompare`</ph>, który implementuje <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> w języku Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> w programie Visual C++) interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Moduł porównujący wywołania <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> metody odwracanie kolejności comparands, dzięki czemu ciągi sortowania dużej do minimum zamiast niskiego na wysoki.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The array is displayed, sorted, and displayed again.</source>
          <target state="translated">Tablica jest wyświetlana, sortowana i ponownie wyświetlana.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>Arrays must be sorted in order to use the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method.</source>
          <target state="translated">Tablice muszą być posortowane w celu użycia <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Wywołania <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> metody rodzajowe nie wygląda inaczej z wywołań, aby ich odpowiedniki nierodzajowe, ponieważ Visual Basic, C# i C++ wnioskować o typie parametru typu ogólnego z typem pierwszego argumentu.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Jeśli używasz <bpt id="p1">[</bpt>Ildasm.exe (dezasembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> zbadać język pośredni firmy Microsoft (MSIL), widoczny wywoływane metody ogólne.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload is then used to search for two strings, one that is not in the array and one that is.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Przeciążenia metody rodzajowej jest następnie używany do wyszukiwania dwa ciągi, jest taki, który nie znajduje się w tablicy i jeden który.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The array and the return value of the <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> method are passed to the <ph id="ph2">`ShowWhere`</ph> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</source>
          <target state="translated">Tablica i wartość zwracaną <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> metody są przekazywane do <ph id="ph2">`ShowWhere`</ph> ogólnego metodę, która zawiera wartość indeksu, jeśli ciąg zostanie znaleziony, a w przeciwnym razie elementy ciąg wyszukiwania spadnie między gdyby w tablicy.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The index is negative if the string is not n the array, so the <ph id="ph1">`ShowWhere`</ph> method takes the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph> -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</source>
          <target state="translated">Indeks jest liczbą ujemną, jeśli ciąg nie jest n tablicy, więc <ph id="ph1">`ShowWhere`</ph> metoda przyjmuje dopełnienia bitowego (~ operatora w języku C# i Visual C++ <ph id="ph2">`Xor`</ph> -1 w języku Visual Basic) Aby uzyskać indeks pierwszego elementu na liście, który jest większy niż ściśle wyszukiwania NG.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, i <ph id="ph3">&lt;paramref name="value" /&gt;</ph> jest typu, który nie jest zgodny z elementami <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="T" /&gt;</ph> does not implement the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, i <ph id="ph3">&lt;paramref name="T" /&gt;</ph> nie implementuje <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> interfejs ogólny</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Sortowanych jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The starting index of the range to search.</source>
          <target state="translated">Indeks początkowy zakresu wyszukiwania.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The length of the range to search.</source>
          <target state="translated">Długość zakresu wyszukiwania.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The object to search for.</source>
          <target state="translated">Obiekt, który trzeba wyszukać.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the <ph id="ph1">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implemented by each element of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> and by the specified value.</source>
          <target state="translated">Przeszukuje zakresu elementów tablicą jednowymiarową posortowane wartości, przy użyciu <ph id="ph1">&lt;see cref="T:System.IComparable`1" /&gt;</ph> ogólny interfejs implementowany przez każdy element <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> i podaną wartość.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Określony indeks <ph id="ph1">&lt;paramref name="value" /&gt;</ph> w określonym <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, jeśli <ph id="ph3">&lt;paramref name="value" /&gt;</ph> zostanie odnaleziony; w przeciwnym razie wartość ujemną.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nie można odnaleźć i <ph id="ph2">&lt;paramref name="value" /&gt;</ph> jest mniejszy niż jeden lub więcej elementów w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, liczbami ujemnymi zwrócony dopełnienia bitowego indeksu pierwszego elementu, który jest większy niż <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nie można odnaleźć i <ph id="ph2">&lt;paramref name="value" /&gt;</ph> jest większa niż wszystkie elementy w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, liczbami ujemnymi zwrócony dopełnienia bitowego (indeksu ostatnim elementem plus 1).</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Jeśli ta metoda jest wywoływana z innych niż — sortowane <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <ph id="ph2">&lt;paramref name="value" /&gt;</ph> znajduje się w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Ta metoda nie obsługuje tablic wyszukiwanie, zawierające ujemne indeksy.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> muszą być posortowane przed wywołaniem tej metody.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If the array does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Jeśli macierz nie zawiera określonej wartości, metoda zwraca całkowitą liczbą ujemną.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">Operator dopełnienia bitowego można zastosować (~ w języku C# <ph id="ph1">`Not`</ph> w języku Visual Basic) do negatywny wynik do tworzenia indeksu.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Jeśli ten indeks jest równy rozmiarowi tablicy, są żadnych elementów większe niż <ph id="ph1">`value`</ph> w tablicy.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">`T`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface, which is used for comparisons.</source>
          <target state="translated"><ph id="ph1">`T`</ph> musi implementować <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> interfejs ogólny, który służy do porównania.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementacji; w przeciwnym razie wynik może być nieprawidłowy.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Dozwolone są zduplikowane elementy.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array&gt;</ph> zawiera więcej niż jeden element równa <ph id="ph2">`value`</ph>, metoda zwraca indeks tylko jedno z wystąpień i niekoniecznie pierwsza z nich.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> zawsze można porównać z żadnym innym typem odwołania; w związku z tym porównania z <ph id="ph2">`null`</ph> nie generują wyjątek.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Dla każdego elementu przetestowane <ph id="ph1">`value`</ph> jest przekazywany do odpowiedniego <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> wdrożenia, nawet jeśli <ph id="ph3">`value`</ph> jest <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Oznacza to <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> wdrożenia Określa jak porównuje danego elementu <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Ta metoda jest O (dziennika <ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> jest mniejsza niż dolna granica <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> i <ph id="ph2">&lt;paramref name="length" /&gt;</ph> nie zostanie określony prawidłowy zakres w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> Typ nie jest zgodny z elementami <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="T" /&gt;</ph> does not implement the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="T" /&gt;</ph> nie implementuje <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Sortowanych jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The starting index of the range to search.</source>
          <target state="translated">Indeks początkowy zakresu wyszukiwania.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The length of the range to search.</source>
          <target state="translated">Długość zakresu wyszukiwania.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The object to search for.</source>
          <target state="translated">Obiekt, który trzeba wyszukać.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> Wdrożenia do użycia podczas porównywania elementów.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> stosowania dla każdego elementu.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the specified <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Przeszukuje tablicą jednowymiarową posortowane wartości, korzystając z określonego zakresu elementów <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Określony indeks <ph id="ph1">&lt;paramref name="value" /&gt;</ph> w określonym <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, jeśli <ph id="ph3">&lt;paramref name="value" /&gt;</ph> zostanie odnaleziony; w przeciwnym razie wartość ujemną.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nie można odnaleźć i <ph id="ph2">&lt;paramref name="value" /&gt;</ph> jest mniejszy niż jeden lub więcej elementów w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, liczbami ujemnymi zwrócony dopełnienia bitowego indeksu pierwszego elementu, który jest większy niż <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nie można odnaleźć i <ph id="ph2">&lt;paramref name="value" /&gt;</ph> jest większa niż wszystkie elementy w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, liczbami ujemnymi zwrócony dopełnienia bitowego (indeksu ostatnim elementem plus 1).</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Jeśli ta metoda jest wywoływana z innych niż — sortowane <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, zwracana wartość może być nieprawidłowy i może zostać zwrócona wartość ujemną, nawet jeśli <ph id="ph2">&lt;paramref name="value" /&gt;</ph> znajduje się w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Ta metoda nie obsługuje tablic wyszukiwanie, zawierające ujemne indeksy.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> muszą być posortowane przed wywołaniem tej metody.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If the array does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Jeśli macierz nie zawiera określonej wartości, metoda zwraca całkowitą liczbą ujemną.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">Operator dopełnienia bitowego można zastosować (~ w języku C# <ph id="ph1">`Not`</ph> w języku Visual Basic) do negatywny wynik do tworzenia indeksu.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Jeśli ten indeks jest równy rozmiarowi tablicy, są żadnych elementów większe niż <ph id="ph1">`value`</ph> w tablicy.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">W przeciwnym razie jest to indeks pierwszego elementu, który jest większy niż <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">Moduł porównujący dostosowuje sposób porównywania elementów.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Na przykład można użyć <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> jako modułu porównującego do wyszukiwania ciągów bez uwzględniania wielkości liter.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> generic interface implementation.</source>
          <target state="translated">Jeśli <ph id="ph1">`comparer`</ph> nie jest <ph id="ph2">`null`</ph>, elementy <ph id="ph3">`array`</ph> są porównywane z podaną wartością przy użyciu określonego <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> implementacją ogólnego interfejsu.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez <ph id="ph2">`comparer`</ph>; w przeciwnym razie wynik może być nieprawidłowy.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface implementation provided for type <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">`comparer`</ph> jest <ph id="ph2">`null`</ph>, porównanie wykonuje się za pomocą <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> implementacji ogólny interfejs dostarczony dla typu <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> już muszą być posortowane w zwiększenie wartości w kolejności sortowania zdefiniowane przez <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementacji; w przeciwnym razie wynik może być nieprawidłowy.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Dozwolone są zduplikowane elementy.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array&gt;</ph> zawiera więcej niż jeden element równa <ph id="ph2">`value`</ph>, metoda zwraca indeks tylko jedno z wystąpień i niekoniecznie pierwsza z nich.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception when using <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`null`</ph> zawsze można porównać z żadnym innym typem odwołania; w związku z tym porównania z <ph id="ph2">`null`</ph> nie generują wyjątek, korzystając z <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Dla każdego elementu przetestowane <ph id="ph1">`value`</ph> jest przekazywany do odpowiedniego <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> wdrożenia, nawet jeśli <ph id="ph3">`value`</ph> jest <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Oznacza to <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> wdrożenia Określa jak porównuje danego elementu <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Ta metoda jest O (dziennika <ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> jest mniejsza niż dolna granica <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> i <ph id="ph2">&lt;paramref name="length" /&gt;</ph> nie zostanie określony prawidłowy zakres w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, i <ph id="ph3">&lt;paramref name="value" /&gt;</ph> jest typu, który nie jest zgodny z elementami <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="T" /&gt;</ph> does not implement the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, i <ph id="ph3">&lt;paramref name="T" /&gt;</ph> nie implementuje <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The array whose elements need to be cleared.</source>
          <target state="translated">Tablica której elementy muszą zostać wyczyszczone.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The starting index of the range of elements to clear.</source>
          <target state="translated">Indeks początkowy zakresu elementów, aby wyczyścić.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The number of elements to clear.</source>
          <target state="translated">Liczba elementów, aby wyczyścić.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Sets a range of elements in an array to the default value of each element type.</source>
          <target state="translated">Określa zakres elementów w tablicy na wartość domyślną każdego typu elementu.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>This method resets each element in an array to the element type's default value.</source>
          <target state="translated">Ta metoda powoduje zresetowanie każdego elementu w tablicy, wartość domyślna typu elementu.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>It sets elements of reference types (including <ph id="ph1">&lt;xref:System.String&gt;</ph> elements) to <ph id="ph2">`null`</ph>, and sets elements of value types to the default values shown in the following table.</source>
          <target state="translated">Ustawia elementy Typy odwołań (łącznie z <ph id="ph1">&lt;xref:System.String&gt;</ph> elementy) do <ph id="ph2">`null`</ph>i ustawia elementy typów wartości do wartości domyślnych, które przedstawiono w poniższej tabeli.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Type</source>
          <target state="translated">Typ</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Value</source>
          <target state="translated">Wartość</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>All integral and floating point numeric types</source>
          <target state="translated">Wszystkie typy liczbowe punktu całkowitych i zmiennoprzecinkowych</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>0 (zero)</source>
          <target state="translated">0 (zero)</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Other value types</source>
          <target state="translated">Inne typy wartości</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Default value of the type's fields</source>
          <target state="translated">Domyślna wartość pola typu</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The range of cleared elements wrap from row to row in a multi-dimensional array.</source>
          <target state="translated">Zakres wyczyszczone zawijania elementy wiersz po wierszu w tablicy wielowymiarowej.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>This method only clears the values of the elements; it does not delete the elements themselves.</source>
          <target state="translated">Ta metoda usuwa tylko wartości elementów; nie są usuwane ze sobą elementy.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>An array has a fixed size; therefore, elements cannot be added or removed.</source>
          <target state="translated">Tablica ma stały rozmiar; w związku z tym elementów nie można dodać ani usunąć.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Array.Clear%2A&gt;</ph> method to reset integer values in a one-dimensional, two-dimensional, and three-dimensional array.</source>
          <target state="translated">W poniższym przykładzie użyto <ph id="ph1">&lt;xref:System.Array.Clear%2A&gt;</ph> metodę, aby zresetować wartości całkowite w tablicy jednowymiarowa dwuwymiarowa i trójwymiarowych.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The following example defines a <ph id="ph1">`TimeZoneTime`</ph> structure that includes a <ph id="ph2">&lt;xref:System.TimeZoneInfo&gt;</ph> field and a <ph id="ph3">&lt;xref:System.DateTimeOffset&gt;</ph> field.</source>
          <target state="translated">W poniższym przykładzie zdefiniowano <ph id="ph1">`TimeZoneTime`</ph> struktury zawierającej <ph id="ph2">&lt;xref:System.TimeZoneInfo&gt;</ph> pola i <ph id="ph3">&lt;xref:System.DateTimeOffset&gt;</ph> pola.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Array.Clear%2A&gt;</ph> method to clear one element in a two-element array of <ph id="ph2">`TimeZoneTime`</ph> values.</source>
          <target state="translated">Następnie wywołuje <ph id="ph1">&lt;xref:System.Array.Clear%2A&gt;</ph> metodę, aby wyczyścić jeden element w tablicy dwuelementową <ph id="ph2">`TimeZoneTime`</ph> wartości.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The method sets the value of the cleared element to the default value of a <ph id="ph1">&lt;xref:System.TimeZoneInfo&gt;</ph> object, which is <ph id="ph2">`null`</ph>, and the default value of a <ph id="ph3">&lt;xref:System.DateTimeOffset&gt;</ph> object, which is <ph id="ph4">&lt;xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Metoda ustawia wartość elementu wyczyszczone, wartość domyślna wynosząca <ph id="ph1">&lt;xref:System.TimeZoneInfo&gt;</ph> obiektu, który jest <ph id="ph2">`null`</ph>i wartość domyślną <ph id="ph3">&lt;xref:System.DateTimeOffset&gt;</ph> obiektu, który jest <ph id="ph4">&lt;xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> jest mniejsza niż dolna granica <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The sum of <ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is greater than the size of <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Suma <ph id="ph1">&lt;paramref name="index" /&gt;</ph> i <ph id="ph2">&lt;paramref name="length" /&gt;</ph> jest większy niż rozmiar <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Array.Clone">
          <source>Creates a shallow copy of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Tworzy kopię pobieżną <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Array.Clone">
          <source>A shallow copy of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Kopia pobieżna <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies only the elements of the <ph id="ph2">&lt;xref:System.Array&gt;</ph>, whether they are reference types or value types, but it does not copy the objects that the references refer to.</source>
          <target state="translated">Kopia pobieżna <ph id="ph1">&lt;xref:System.Array&gt;</ph> kopiuje elementy ze <ph id="ph2">&lt;xref:System.Array&gt;</ph>, czy znajdują się odwołania typy lub wartości, ale nie kopiuje obiektów, które dotyczą odwołania.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>The references in the new <ph id="ph1">&lt;xref:System.Array&gt;</ph> point to the same objects that the references in the original <ph id="ph2">&lt;xref:System.Array&gt;</ph> point to.</source>
          <target state="translated">Odwołań w nowym <ph id="ph1">&lt;xref:System.Array&gt;</ph> wskazują ten sam obiekty, które odwołań w oryginalnym <ph id="ph2">&lt;xref:System.Array&gt;</ph> wskaż.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Z kolei bezpośrednich kopię <ph id="ph1">&lt;xref:System.Array&gt;</ph> kopiuje elementy i wszystkich bezpośrednio lub pośrednio odwołuje się elementów.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>The clone is of the same <ph id="ph1">&lt;xref:System.Type&gt;</ph> as the original <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Klon jest taka sama <ph id="ph1">&lt;xref:System.Type&gt;</ph> jak oryginał <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>The following code example clones a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo?displayProperty=nameWithType&gt;</ph> array and demonstrates the behavior of a shallow copy.</source>
          <target state="translated">Poniższy kod przykładowy klony <ph id="ph1">&lt;xref:System.Globalization.CultureInfo?displayProperty=nameWithType&gt;</ph> tablicy i prezentuje działanie kopia pobieżna.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> Zawierający dane do skopiowania.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">32-bitową liczbę całkowitą, która reprezentuje indeks w <bpt id="p1">&lt;c&gt;</bpt>Tablica_źródłowa<ept id="p1">&lt;/c&gt;</ept> od rozpoczyna się kopiowanie które.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> Odbierająca danych.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> at which storing begins.</source>
          <target state="translated">32-bitową liczbę całkowitą, która reprezentuje indeks w <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> od przechowywania, która rozpoczyna się.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the number of elements to copy.</source>
          <target state="translated">32-bitową liczbę całkowitą reprezentującą liczbę elementów do skopiowania.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified source index and pastes them to another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified destination index.</source>
          <target state="translated">Kopiuje elementy z zakresu <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> począwszy od indeksu określone źródło i wkleja je do innego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> począwszy od indeksu do określonej lokalizacji docelowej.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Guarantees that all changes are undone if the copy does not succeed completely.</source>
          <target state="translated">Gwarantuje, że wszystkie zmiany zostaną cofnięte, jeśli kopiowanie nie powiedzie się całkowicie.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated"><ph id="ph1">`sourceArray`</ph> i <ph id="ph2">`destinationArray`</ph> parametry muszą mieć taką samą liczbę wymiarów.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`sourceArray`</ph> type must be the same as or derived from the <ph id="ph2">`destinationArray`</ph> type; otherwise, an <ph id="ph3">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown.</source>
          <target state="translated"><ph id="ph1">`sourceArray`</ph> Typu musi być taka sama jak lub pochodny <ph id="ph2">`destinationArray`</ph> typu; w przeciwnym razie <ph id="ph3">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> jest generowany.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Unlike <ph id="ph1">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> verifies the compatibility of the array types before performing any operation.</source>
          <target state="translated">W odróżnieniu od <ph id="ph1">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> sprawdza zgodność typy tablic, przed wykonaniem każdej operacji.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</source>
          <target state="translated">Jeśli kopiowanie odbywa się między tablice wielowymiarowe, tablicy zachowuje się jak długo Jednowymiarowa tablica, gdzie wierszy (lub kolumny) koncepcyjnie ustanowienia end-to-end.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">Jeśli na przykład tablica ma trzy wiersze (lub kolumny) z czterema elementami, skopiowanie sześciu elementów od początku tablicy może spowodować skopiowanie wszystkich czterech elementów pierwszego wiersza (lub kolumny) i pierwszych dwóch elementów drugiego wiersza (lub kolumny).</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>To start copying from the second element of the third row (or column), <ph id="ph1">`sourceIndex`</ph> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</source>
          <target state="translated">Aby rozpocząć kopiowanie z drugiego elementu trzeciego wiersza (lub kolumny), <ph id="ph1">`sourceIndex`</ph> musi być górna granica pierwszego wiersza (lub kolumny) oraz długość wiersza drugi (lub kolumny) oraz dwa.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">Jeśli <ph id="ph1">`sourceArray`</ph> i <ph id="ph2">`destinationArray`</ph> nakładają się na siebie, ta metoda działa tak, jakby oryginalnej wartości <ph id="ph3">`sourceArray`</ph> zostały zachowane w tymczasowej lokalizacji przed <ph id="ph4">`destinationArray`</ph> zostanie zastąpiony.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">Ta metoda jest odpowiednikiem standardowego funkcji C/C++ <ph id="ph1">`memmove`</ph>, a nie <ph id="ph2">`memcpy`</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">Tablice mogą być tablicami typu odwołania lub tablicami typu wartości.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">Jeśli <ph id="ph1">`sourceArray`</ph> i <ph id="ph2">`destinationArray`</ph> są obie tablic typu odwołania lub obu tablic typu <ph id="ph3">&lt;xref:System.Object&gt;</ph>, jest wykonywana kopia pobieżna.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Kopia pobieżna <ph id="ph1">&lt;xref:System.Array&gt;</ph> to nowa <ph id="ph2">&lt;xref:System.Array&gt;</ph> zawierające odwołania do tych samych elementów jak oryginał <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">Nie są kopiowane same elementy ani to, co odwołuje się do elementów.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Z kolei bezpośrednich kopię <ph id="ph1">&lt;xref:System.Array&gt;</ph> kopiuje elementy i wszystkich bezpośrednio lub pośrednio odwołuje się elementów.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If this method throws an exception while copying, the <ph id="ph1">`destinationArray`</ph> remains unchanged; therefore, <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> can be used within a constrained execution region (<ph id="ph3">&lt;xref:System.Runtime.ConstrainedExecution.Cer&gt;</ph>).</source>
          <target state="translated">Jeśli ta metoda zgłasza wyjątek podczas kopiowania, <ph id="ph1">`destinationArray`</ph> pozostaje niezmieniona; w związku z tym <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> znajdują się w regionie ograniczonego wykonania (<ph id="ph3">&lt;xref:System.Runtime.ConstrainedExecution.Cer&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> i <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> ma różnym stopniu.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> type is neither the same as nor derived from the <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> Typu nie jest ani taka sama jak ani nie pochodzi od <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> typu.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated">Co najmniej jeden element w <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> nie można rzutować na typ <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> jest mniejsza niż dolna granica pierwszym wymiarze <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> jest mniejsza niż dolna granica pierwszym wymiarze <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest większa niż liczba elementów od <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> na końcu <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest większa niż liczba elementów od <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> na końcu <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The type of the elements of the source array.</source>
          <target state="translated">Typ elementów tablicy źródłowej.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The type of the elements of the target array.</source>
          <target state="translated">Typ elementów tablicy docelowej.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to convert to a target type.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> można przekonwertować na typ docelowy.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>A <ph id="ph1">&lt;see cref="T:System.Converter`2" /&gt;</ph> that converts each element from one type to another type.</source>
          <target state="translated">A <ph id="ph1">&lt;see cref="T:System.Converter`2" /&gt;</ph> konwertująca każdy element z jednego typu do innego typu.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>Converts an array of one type to an array of another type.</source>
          <target state="translated">Konwertuje tablicę jednego typu na tablicę innego typu.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>An array of the target type containing the converted elements from the source array.</source>
          <target state="translated">Tablica zawierająca elementy przekonwertowany z tablicy źródłowej na typ docelowy.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The <ph id="ph1">&lt;xref:System.Converter%602&gt;</ph> is a delegate to a method that converts an object to the target type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Converter%602&gt;</ph> Jest delegowany do metody, która konwertuje obiektu na typ docelowy.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Converter%602&gt;</ph>, and the converted elements are saved in the new array.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> indywidualnie są przekazywane do <ph id="ph2">&lt;xref:System.Converter%602&gt;</ph>, i przekonwertowane elementy są zapisywane w nowej tablicy.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The source <ph id="ph1">`array`</ph> remains unchanged.</source>
          <target state="translated">Źródło <ph id="ph1">`array`</ph> pozostaje niezmieniona.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The following code example defines a method named <ph id="ph1">`PointFToPoint`</ph> that converts a <ph id="ph2">&lt;xref:System.Drawing.PointF&gt;</ph> structure to a <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> structure.</source>
          <target state="translated">Poniższy przykładowy kod definiuje metodę o nazwie <ph id="ph1">`PointFToPoint`</ph> konwertująca <ph id="ph2">&lt;xref:System.Drawing.PointF&gt;</ph> struktury do <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> struktury.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The example then creates an array of <ph id="ph1">&lt;xref:System.Drawing.PointF&gt;</ph> structures, creates a <ph id="ph2">`Converter&lt;PointF, Point&gt;`</ph> delegate (<ph id="ph3">`Converter(Of PointF, Point)`</ph> in Visual Basic) to represent the <ph id="ph4">`PointFToPoint`</ph> method, and passes the delegate to the <ph id="ph5">&lt;xref:System.Array.ConvertAll%2A&gt;</ph> method.</source>
          <target state="translated">Następnie tworzony tablicę <ph id="ph1">&lt;xref:System.Drawing.PointF&gt;</ph> struktury, tworzy <ph id="ph2">`Converter&lt;PointF, Point&gt;`</ph> delegować (<ph id="ph3">`Converter(Of PointF, Point)`</ph> w języku Visual Basic) do reprezentowania <ph id="ph4">`PointFToPoint`</ph> metody i przekazuje delegata do <ph id="ph5">&lt;xref:System.Array.ConvertAll%2A&gt;</ph> — metoda.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The <ph id="ph1">&lt;xref:System.Array.ConvertAll%2A&gt;</ph> method passes each element of the input list to the <ph id="ph2">`PointFToPoint`</ph> method and puts the converted elements into a new list of <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> structures.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.ConvertAll%2A&gt;</ph> Metoda przekazuje każdy element na liście wejściowej, aby <ph id="ph2">`PointFToPoint`</ph> — metoda i umieszcza przekonwertowanego elementy do nowej listy <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> struktury.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>Both lists are displayed.</source>
          <target state="translated">Zarówno listy są wyświetlane.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source><ph id="ph1">&lt;paramref name="converter" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="converter" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Copies a range of elements in one <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> and performs type casting and boxing as required.</source>
          <target state="translated">Kopiuje zakresu elementów w jednym <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do innego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> i wykonuje typu rzutowania i konwersja boxing zgodnie z wymaganiami.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> Zawierający dane do skopiowania.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> Odbierająca danych.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A 32-bit integer that represents the number of elements to copy.</source>
          <target state="translated">32-bitową liczbę całkowitą reprezentującą liczbę elementów do skopiowania.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the first element and pastes them into another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the first element.</source>
          <target state="translated">Kopiuje elementy z zakresu <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zaczynając od pierwszego elementu i wkleja je do innego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> zaczynając od pierwszego elementu.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The length is specified as a 32-bit integer.</source>
          <target state="translated">Długość jest określony jako 32-bitową liczbę całkowitą.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated"><ph id="ph1">`sourceArray`</ph> i <ph id="ph2">`destinationArray`</ph> parametry muszą mieć taką samą liczbę wymiarów.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data.</source>
          <target state="translated">Ponadto <ph id="ph1">`destinationArray`</ph> musi już mieć wymiarów i musi mieć wystarczającą liczbę elementów do uwzględnienia skopiowanych danych.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end.</source>
          <target state="translated">Jeśli kopiowanie odbywa się między tablice wielowymiarowe, tablicy zachowuje się jak długo Jednowymiarowa tablica, gdzie wierszy (lub kolumny) koncepcyjnie określone są pełne.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">Jeśli na przykład tablica ma trzy wiersze (lub kolumny) z czterema elementami, skopiowanie sześciu elementów od początku tablicy może spowodować skopiowanie wszystkich czterech elementów pierwszego wiersza (lub kolumny) i pierwszych dwóch elementów drugiego wiersza (lub kolumny).</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">Jeśli <ph id="ph1">`sourceArray`</ph> i <ph id="ph2">`destinationArray`</ph> nakładają się na siebie, ta metoda działa tak, jakby oryginalnej wartości <ph id="ph3">`sourceArray`</ph> zostały zachowane w tymczasowej lokalizacji przed <ph id="ph4">`destinationArray`</ph> zostanie zastąpiony.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">Ta metoda jest odpowiednikiem standardowego funkcji C/C++ <ph id="ph1">`memmove`</ph>, a nie <ph id="ph2">`memcpy`</ph>.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">Tablice mogą być tablicami typu odwołania lub tablicami typu wartości.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Type downcasting is performed, as required.</source>
          <target state="translated">Rzutowanie typu w dół jest wykonywane odpowiednio do potrzeb.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
          <target state="translated">Podczas kopiowania z tablicy typu odwołania do tablicy typu wartości każdy element jest rozpakowywany, a następnie kopiowany.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
          <target state="translated">Podczas kopiowania z tablicy wartości typu do tablicy typu odwołania każdy element jest pakowany, a następnie kopiowany.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
          <target state="translated">Podczas kopiowania z tablicą typu odwołanie lub typ wartości do <ph id="ph1">&lt;xref:System.Object&gt;</ph> tablicy, <ph id="ph2">&lt;xref:System.Object&gt;</ph> jest utworzony w celu przechowywania każdej wartości lub odwołania, a następnie skopiowana.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Podczas kopiowania z <ph id="ph1">&lt;xref:System.Object&gt;</ph> tablicy do tablicy typu odwołanie lub typ wartości i przypisanie nie jest możliwe, <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> jest generowany.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">Jeśli <ph id="ph1">`sourceArray`</ph> i <ph id="ph2">`destinationArray`</ph> są obie tablic typu odwołania lub obu tablic typu <ph id="ph3">&lt;xref:System.Object&gt;</ph>, jest wykonywana kopia pobieżna.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Kopia pobieżna <ph id="ph1">&lt;xref:System.Array&gt;</ph> to nowa <ph id="ph2">&lt;xref:System.Array&gt;</ph> zawierające odwołania do tych samych elementów jak oryginał <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">Nie są kopiowane same elementy ani to, co odwołuje się do elementów.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Z kolei bezpośrednich kopię <ph id="ph1">&lt;xref:System.Array&gt;</ph> kopiuje elementy i wszystkich bezpośrednio lub pośrednio odwołuje się elementów.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> Jest generowany, jeśli tablice mają niezgodne typy.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Type compatibility is defined as follows:</source>
          <target state="translated">Zgodność z typem jest zdefiniowana w następujący sposób:</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A type is compatible with itself.</source>
          <target state="translated">Typ jest zgodny z samym sobą.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
          <target state="translated">Typ wartości jest niezgodny z <ph id="ph1">&lt;xref:System.Object&gt;</ph> i typu interfejsu implementowanych przez ten typ wartości.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
          <target state="translated">Typ wartości jest uważany za podłączony do interfejsu tylko wtedy, gdy bezpośrednio implementuje ten interfejs.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Disconnected types are not compatible.</source>
          <target state="translated">Odłączony typy nie są zgodne.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
          <target state="translated">Dwa typy rzeczywistej wartości wewnętrznej (wstępnie zdefiniowane) są zgodne w przypadku kopiowania z typu źródłowego na typ docelowy w konwersji rozszerzającej.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
          <target state="translated">Konwersja rozszerzająca nigdy nie traci informacji, podczas gdy konwersja zawężająca może utracić informacje.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
          <target state="translated">Na przykład konwersja 32-bitowej oznaczonej liczby całkowitej na 64-bitową jest konwersją rozszerzającą, a 64-bitowej oznaczonej liczby całkowitej na 32-bitową jest konwersją zawężającą.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji na temat konwersji, zobacz <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
          <target state="translated">Typ wartości niewewnętrznej (zdefiniowanej przez użytkownika) jest zgodny tylko z samym sobą.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
          <target state="translated">Wyliczenia mają niejawnej konwersji <ph id="ph1">&lt;xref:System.Enum&gt;</ph> i ich typ podstawowy.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Jeśli wartość każdego elementu w <ph id="ph1">`sourceArray`</ph> wymaga przypisanie elementu podrzędnego (na przykład z klasy podstawowej w klasie pochodnej lub interfejs do obiektu) i jeden lub więcej elementów nie można rzutować typu odpowiadającego w <ph id="ph2">`destinationArray`</ph>, <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> jest generowany.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
          <target state="translated">Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan <ph id="ph1">`destinationArray`</ph> jest niezdefiniowana.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> i <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> ma różnym stopniu.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> i <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> mają niezgodne typy.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated">Co najmniej jeden element w <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> nie można rzutować na typ <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest większa niż liczba elementów w <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest większa niż liczba elementów w <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> Zawierający dane do skopiowania.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> Odbierająca danych.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A 64-bit integer that represents the number of elements to copy.</source>
          <target state="translated">64-bitową liczbę całkowitą reprezentującą liczbę elementów do skopiowania.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The integer must be between zero and <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>, inclusive.</source>
          <target state="translated">Liczba całkowita należy do zakresu od zera i <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>włącznie.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the first element and pastes them into another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the first element.</source>
          <target state="translated">Kopiuje elementy z zakresu <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zaczynając od pierwszego elementu i wkleja je do innego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> zaczynając od pierwszego elementu.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The length is specified as a 64-bit integer.</source>
          <target state="translated">Długość jest określony jako 64-bitową liczbę całkowitą.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated"><ph id="ph1">`sourceArray`</ph> i <ph id="ph2">`destinationArray`</ph> parametry muszą mieć taką samą liczbę wymiarów.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data.</source>
          <target state="translated">Ponadto <ph id="ph1">`destinationArray`</ph> musi już mieć wymiarów i musi mieć wystarczającą liczbę elementów do uwzględnienia skopiowanych danych.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end.</source>
          <target state="translated">Jeśli kopiowanie odbywa się między tablice wielowymiarowe, tablicy zachowuje się jak długo Jednowymiarowa tablica, gdzie wierszy (lub kolumny) koncepcyjnie określone są pełne.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">Jeśli na przykład tablica ma trzy wiersze (lub kolumny) z czterema elementami, skopiowanie sześciu elementów od początku tablicy może spowodować skopiowanie wszystkich czterech elementów pierwszego wiersza (lub kolumny) i pierwszych dwóch elementów drugiego wiersza (lub kolumny).</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">Jeśli <ph id="ph1">`sourceArray`</ph> i <ph id="ph2">`destinationArray`</ph> nakładają się na siebie, ta metoda działa tak, jakby oryginalnej wartości <ph id="ph3">`sourceArray`</ph> zostały zachowane w tymczasowej lokalizacji przed <ph id="ph4">`destinationArray`</ph> zostanie zastąpiony.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">Ta metoda jest odpowiednikiem standardowego funkcji C/C++ <ph id="ph1">`memmove`</ph>, a nie <ph id="ph2">`memcpy`</ph>.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">Tablice mogą być tablicami typu odwołania lub tablicami typu wartości.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Type downcasting is performed, as required.</source>
          <target state="translated">Rzutowanie typu w dół jest wykonywane odpowiednio do potrzeb.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
          <target state="translated">Podczas kopiowania z tablicy typu odwołania do tablicy typu wartości każdy element jest rozpakowywany, a następnie kopiowany.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
          <target state="translated">Podczas kopiowania z tablicy wartości typu do tablicy typu odwołania każdy element jest pakowany, a następnie kopiowany.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
          <target state="translated">Podczas kopiowania z tablicą typu odwołanie lub typ wartości do <ph id="ph1">&lt;xref:System.Object&gt;</ph> tablicy, <ph id="ph2">&lt;xref:System.Object&gt;</ph> jest utworzony w celu przechowywania każdej wartości lub odwołania, a następnie skopiowana.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Podczas kopiowania z <ph id="ph1">&lt;xref:System.Object&gt;</ph> tablicy do tablicy typu odwołanie lub typ wartości i przypisanie nie jest możliwe, <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> jest generowany.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">Jeśli <ph id="ph1">`sourceArray`</ph> i <ph id="ph2">`destinationArray`</ph> są obie tablic typu odwołania lub obu tablic typu <ph id="ph3">&lt;xref:System.Object&gt;</ph>, jest wykonywana kopia pobieżna.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Kopia pobieżna <ph id="ph1">&lt;xref:System.Array&gt;</ph> to nowa <ph id="ph2">&lt;xref:System.Array&gt;</ph> zawierające odwołania do tych samych elementów jak oryginał <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">Nie są kopiowane same elementy ani to, co odwołuje się do elementów.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Z kolei bezpośrednich kopię <ph id="ph1">&lt;xref:System.Array&gt;</ph> kopiuje elementy i wszystkich bezpośrednio lub pośrednio odwołuje się elementów.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> Jest generowany, jeśli tablice mają niezgodne typy.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Type compatibility is defined as follows:</source>
          <target state="translated">Zgodność z typem jest zdefiniowana w następujący sposób:</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A type is compatible with itself.</source>
          <target state="translated">Typ jest zgodny z samym sobą.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
          <target state="translated">Typ wartości jest niezgodny z <ph id="ph1">&lt;xref:System.Object&gt;</ph> i typu interfejsu implementowanych przez ten typ wartości.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
          <target state="translated">Typ wartości jest uważany za podłączony do interfejsu tylko wtedy, gdy bezpośrednio implementuje ten interfejs.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Disconnected types are not compatible.</source>
          <target state="translated">Odłączony typy nie są zgodne.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
          <target state="translated">Dwa typy rzeczywistej wartości wewnętrznej (wstępnie zdefiniowane) są zgodne w przypadku kopiowania z typu źródłowego na typ docelowy w konwersji rozszerzającej.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
          <target state="translated">Konwersja rozszerzająca nigdy nie traci informacji, podczas gdy konwersja zawężająca może utracić informacje.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
          <target state="translated">Na przykład konwersja 32-bitowej oznaczonej liczby całkowitej na 64-bitową jest konwersją rozszerzającą, a 64-bitowej oznaczonej liczby całkowitej na 32-bitową jest konwersją zawężającą.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji na temat konwersji, zobacz <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
          <target state="translated">Typ wartości niewewnętrznej (zdefiniowanej przez użytkownika) jest zgodny tylko z samym sobą.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
          <target state="translated">Wyliczenia mają niejawnej konwersji <ph id="ph1">&lt;xref:System.Enum&gt;</ph> i ich typ podstawowy.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Jeśli wartość każdego elementu w <ph id="ph1">`sourceArray`</ph> wymaga przypisanie elementu podrzędnego (na przykład z klasy podstawowej w klasie pochodnej lub interfejs do obiektu) i jeden lub więcej elementów nie można rzutować typu odpowiadającego w <ph id="ph2">`destinationArray`</ph>, <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> jest generowany.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
          <target state="translated">Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan <ph id="ph1">`destinationArray`</ph> jest niezdefiniowana.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> i <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> ma różnym stopniu.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> i <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> mają niezgodne typy.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated">Co najmniej jeden element w <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> nie można rzutować na typ <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than 0 or greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest mniejsza niż 0 lub większą niż <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest większa niż liczba elementów w <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest większa niż liczba elementów w <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> Zawierający dane do skopiowania.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">32-bitową liczbę całkowitą, która reprezentuje indeks w <bpt id="p1">&lt;c&gt;</bpt>Tablica_źródłowa<ept id="p1">&lt;/c&gt;</ept> od rozpoczyna się kopiowanie które.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> Odbierająca danych.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> at which storing begins.</source>
          <target state="translated">32-bitową liczbę całkowitą, która reprezentuje indeks w <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> od przechowywania, która rozpoczyna się.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the number of elements to copy.</source>
          <target state="translated">32-bitową liczbę całkowitą reprezentującą liczbę elementów do skopiowania.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified source index and pastes them to another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified destination index.</source>
          <target state="translated">Kopiuje elementy z zakresu <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> począwszy od indeksu określone źródło i wkleja je do innego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> począwszy od indeksu do określonej lokalizacji docelowej.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The length and the indexes are specified as 32-bit integers.</source>
          <target state="translated">Długość i indeksy są określone jako 32-bitowych liczb całkowitych.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated"><ph id="ph1">`sourceArray`</ph> i <ph id="ph2">`destinationArray`</ph> parametry muszą mieć taką samą liczbę wymiarów.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements starting from the <ph id="ph2">`destinationIndex`</ph> position to accommodate the copied data.</source>
          <target state="translated">Ponadto <ph id="ph1">`destinationArray`</ph> musi już mieć wymiarów i musi mieć wystarczającą liczbę elementów od <ph id="ph2">`destinationIndex`</ph> pozycji, aby pomieścić skopiowanych danych.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</source>
          <target state="translated">Jeśli kopiowanie odbywa się między tablice wielowymiarowe, tablicy zachowuje się jak długo Jednowymiarowa tablica, gdzie wierszy (lub kolumny) koncepcyjnie ustanowienia end-to-end.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">Jeśli na przykład tablica ma trzy wiersze (lub kolumny) z czterema elementami, skopiowanie sześciu elementów od początku tablicy może spowodować skopiowanie wszystkich czterech elementów pierwszego wiersza (lub kolumny) i pierwszych dwóch elementów drugiego wiersza (lub kolumny).</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>To start copying from the second element of the third row (or column), <ph id="ph1">`sourceIndex`</ph> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</source>
          <target state="translated">Aby rozpocząć kopiowanie z drugiego elementu trzeciego wiersza (lub kolumny), <ph id="ph1">`sourceIndex`</ph> musi być górna granica pierwszego wiersza (lub kolumny) oraz długość wiersza drugi (lub kolumny) oraz dwa.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">Jeśli <ph id="ph1">`sourceArray`</ph> i <ph id="ph2">`destinationArray`</ph> nakładają się na siebie, ta metoda działa tak, jakby oryginalnej wartości <ph id="ph3">`sourceArray`</ph> zostały zachowane w tymczasowej lokalizacji przed <ph id="ph4">`destinationArray`</ph> zostanie zastąpiony.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">Ta metoda jest odpowiednikiem standardowego funkcji C/C++ <ph id="ph1">`memmove`</ph>, a nie <ph id="ph2">`memcpy`</ph>.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">Tablice mogą być tablicami typu odwołania lub tablicami typu wartości.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Type downcasting is performed, as required.</source>
          <target state="translated">Rzutowanie typu w dół jest wykonywane odpowiednio do potrzeb.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
          <target state="translated">Podczas kopiowania z tablicy typu odwołania do tablicy typu wartości każdy element jest rozpakowywany, a następnie kopiowany.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
          <target state="translated">Podczas kopiowania z tablicy wartości typu do tablicy typu odwołania każdy element jest pakowany, a następnie kopiowany.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
          <target state="translated">Podczas kopiowania z tablicą typu odwołanie lub typ wartości do <ph id="ph1">&lt;xref:System.Object&gt;</ph> tablicy, <ph id="ph2">&lt;xref:System.Object&gt;</ph> jest utworzony w celu przechowywania każdej wartości lub odwołania, a następnie skopiowana.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Podczas kopiowania z <ph id="ph1">&lt;xref:System.Object&gt;</ph> tablicy do tablicy typu odwołanie lub typ wartości i przypisanie nie jest możliwe, <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> jest generowany.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">Jeśli <ph id="ph1">`sourceArray`</ph> i <ph id="ph2">`destinationArray`</ph> są obie tablic typu odwołania lub obu tablic typu <ph id="ph3">&lt;xref:System.Object&gt;</ph>, jest wykonywana kopia pobieżna.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Kopia pobieżna <ph id="ph1">&lt;xref:System.Array&gt;</ph> to nowa <ph id="ph2">&lt;xref:System.Array&gt;</ph> zawierające odwołania do tych samych elementów jak oryginał <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">Nie są kopiowane same elementy ani to, co odwołuje się do elementów.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Z kolei bezpośrednich kopię <ph id="ph1">&lt;xref:System.Array&gt;</ph> kopiuje elementy i wszystkich bezpośrednio lub pośrednio odwołuje się elementów.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> Jest generowany, jeśli tablice mają niezgodne typy.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Type compatibility is defined as follows:</source>
          <target state="translated">Zgodność z typem jest zdefiniowana w następujący sposób:</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A type is compatible with itself.</source>
          <target state="translated">Typ jest zgodny z samym sobą.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
          <target state="translated">Typ wartości jest niezgodny z <ph id="ph1">&lt;xref:System.Object&gt;</ph> i typu interfejsu implementowanych przez ten typ wartości.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
          <target state="translated">Typ wartości jest uważany za podłączony do interfejsu tylko wtedy, gdy bezpośrednio implementuje ten interfejs.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Disconnected types are not compatible.</source>
          <target state="translated">Odłączony typy nie są zgodne.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
          <target state="translated">Dwa typy rzeczywistej wartości wewnętrznej (wstępnie zdefiniowane) są zgodne w przypadku kopiowania z typu źródłowego na typ docelowy w konwersji rozszerzającej.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
          <target state="translated">Konwersja rozszerzająca nigdy nie traci informacji, podczas gdy konwersja zawężająca może utracić informacje.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
          <target state="translated">Na przykład konwersja 32-bitowej oznaczonej liczby całkowitej na 64-bitową jest konwersją rozszerzającą, a 64-bitowej oznaczonej liczby całkowitej na 32-bitową jest konwersją zawężającą.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji na temat konwersji, zobacz <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
          <target state="translated">Typ wartości niewewnętrznej (zdefiniowanej przez użytkownika) jest zgodny tylko z samym sobą.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
          <target state="translated">Wyliczenia mają niejawnej konwersji <ph id="ph1">&lt;xref:System.Enum&gt;</ph> i ich typ podstawowy.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Jeśli wartość każdego elementu w <ph id="ph1">`sourceArray`</ph> wymaga przypisanie elementu podrzędnego (na przykład z klasy podstawowej w klasie pochodnej lub interfejs do obiektu) i jeden lub więcej elementów nie można rzutować typu odpowiadającego w <ph id="ph2">`destinationArray`</ph>, <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> jest generowany.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
          <target state="translated">Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan <ph id="ph1">`destinationArray`</ph> jest niezdefiniowana.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to copy from one <ph id="ph1">&lt;xref:System.Array&gt;</ph> of type <ph id="ph2">&lt;xref:System.Object&gt;</ph> to another <ph id="ph3">&lt;xref:System.Array&gt;</ph> of type integer.</source>
          <target state="translated">Poniższy przykład kodu pokazuje sposób kopiowania z jednego <ph id="ph1">&lt;xref:System.Array&gt;</ph> typu <ph id="ph2">&lt;xref:System.Object&gt;</ph> do innego <ph id="ph3">&lt;xref:System.Array&gt;</ph> typu integer.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> i <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> ma różnym stopniu.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> i <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> mają niezgodne typy.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated">Co najmniej jeden element w <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> nie można rzutować na typ <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> jest mniejsza niż dolna granica pierwszym wymiarze <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> jest mniejsza niż dolna granica pierwszym wymiarze <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest większa niż liczba elementów od <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> na końcu <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest większa niż liczba elementów od <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> na końcu <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> Zawierający dane do skopiowania.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">64-bitową liczbę całkowitą, która reprezentuje indeks w <bpt id="p1">&lt;c&gt;</bpt>Tablica_źródłowa<ept id="p1">&lt;/c&gt;</ept> od rozpoczyna się kopiowanie które.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> Odbierająca danych.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> at which storing begins.</source>
          <target state="translated">64-bitową liczbę całkowitą, która reprezentuje indeks w <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> od przechowywania, która rozpoczyna się.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the number of elements to copy.</source>
          <target state="translated">64-bitową liczbę całkowitą reprezentującą liczbę elementów do skopiowania.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The integer must be between zero and <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>, inclusive.</source>
          <target state="translated">Liczba całkowita należy do zakresu od zera i <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>włącznie.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified source index and pastes them to another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified destination index.</source>
          <target state="translated">Kopiuje elementy z zakresu <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> począwszy od indeksu określone źródło i wkleja je do innego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> począwszy od indeksu do określonej lokalizacji docelowej.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The length and the indexes are specified as 64-bit integers.</source>
          <target state="translated">Długość i indeksy są określone jako 64-bitowych liczb całkowitych.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated"><ph id="ph1">`sourceArray`</ph> i <ph id="ph2">`destinationArray`</ph> parametry muszą mieć taką samą liczbę wymiarów.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements starting from the <ph id="ph2">`destinationIndex`</ph> position to accommodate the copied data.</source>
          <target state="translated">Ponadto <ph id="ph1">`destinationArray`</ph> musi już mieć wymiarów i musi mieć wystarczającą liczbę elementów od <ph id="ph2">`destinationIndex`</ph> pozycji, aby pomieścić skopiowanych danych.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</source>
          <target state="translated">Jeśli kopiowanie odbywa się między tablice wielowymiarowe, tablicy zachowuje się jak długo Jednowymiarowa tablica, gdzie wierszy (lub kolumny) koncepcyjnie ustanowienia end-to-end.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">Jeśli na przykład tablica ma trzy wiersze (lub kolumny) z czterema elementami, skopiowanie sześciu elementów od początku tablicy może spowodować skopiowanie wszystkich czterech elementów pierwszego wiersza (lub kolumny) i pierwszych dwóch elementów drugiego wiersza (lub kolumny).</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>To start copying from the second element of the third row (or column), <ph id="ph1">`sourceIndex`</ph> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</source>
          <target state="translated">Aby rozpocząć kopiowanie z drugiego elementu trzeciego wiersza (lub kolumny), <ph id="ph1">`sourceIndex`</ph> musi być górna granica pierwszego wiersza (lub kolumny) oraz długość wiersza drugi (lub kolumny) oraz dwa.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">Jeśli <ph id="ph1">`sourceArray`</ph> i <ph id="ph2">`destinationArray`</ph> nakładają się na siebie, ta metoda działa tak, jakby oryginalnej wartości <ph id="ph3">`sourceArray`</ph> zostały zachowane w tymczasowej lokalizacji przed <ph id="ph4">`destinationArray`</ph> zostanie zastąpiony.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">Ta metoda jest odpowiednikiem standardowego funkcji C/C++ <ph id="ph1">`memmove`</ph>, a nie <ph id="ph2">`memcpy`</ph>.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">Tablice mogą być tablicami typu odwołania lub tablicami typu wartości.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Type downcasting is performed, as required.</source>
          <target state="translated">Rzutowanie typu w dół jest wykonywane odpowiednio do potrzeb.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
          <target state="translated">Podczas kopiowania z tablicy typu odwołania do tablicy typu wartości każdy element jest rozpakowywany, a następnie kopiowany.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
          <target state="translated">Podczas kopiowania z tablicy wartości typu do tablicy typu odwołania każdy element jest pakowany, a następnie kopiowany.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
          <target state="translated">Podczas kopiowania z tablicą typu odwołanie lub typ wartości do <ph id="ph1">&lt;xref:System.Object&gt;</ph> tablicy, <ph id="ph2">&lt;xref:System.Object&gt;</ph> jest utworzony w celu przechowywania każdej wartości lub odwołania, a następnie skopiowana.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Podczas kopiowania z <ph id="ph1">&lt;xref:System.Object&gt;</ph> tablicy do tablicy typu odwołanie lub typ wartości i przypisanie nie jest możliwe, <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> jest generowany.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">Jeśli <ph id="ph1">`sourceArray`</ph> i <ph id="ph2">`destinationArray`</ph> są obie tablic typu odwołania lub obu tablic typu <ph id="ph3">&lt;xref:System.Object&gt;</ph>, jest wykonywana kopia pobieżna.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Kopia pobieżna <ph id="ph1">&lt;xref:System.Array&gt;</ph> to nowa <ph id="ph2">&lt;xref:System.Array&gt;</ph> zawierające odwołania do tych samych elementów jak oryginał <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">Nie są kopiowane same elementy ani to, co odwołuje się do elementów.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Z kolei bezpośrednich kopię <ph id="ph1">&lt;xref:System.Array&gt;</ph> kopiuje elementy i wszystkich bezpośrednio lub pośrednio odwołuje się elementów.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> Jest generowany, jeśli tablice mają niezgodne typy.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Type compatibility is defined as follows:</source>
          <target state="translated">Zgodność z typem jest zdefiniowana w następujący sposób:</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A type is compatible with itself.</source>
          <target state="translated">Typ jest zgodny z samym sobą.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
          <target state="translated">Typ wartości jest niezgodny z <ph id="ph1">&lt;xref:System.Object&gt;</ph> i typu interfejsu implementowanych przez ten typ wartości.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
          <target state="translated">Typ wartości jest uważany za podłączony do interfejsu tylko wtedy, gdy bezpośrednio implementuje ten interfejs.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Disconnected types are not compatible.</source>
          <target state="translated">Odłączony typy nie są zgodne.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
          <target state="translated">Dwa typy rzeczywistej wartości wewnętrznej (wstępnie zdefiniowane) są zgodne w przypadku kopiowania z typu źródłowego na typ docelowy w konwersji rozszerzającej.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
          <target state="translated">Konwersja rozszerzająca nigdy nie traci informacji, podczas gdy konwersja zawężająca może utracić informacje.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
          <target state="translated">Na przykład konwersja 32-bitowej oznaczonej liczby całkowitej na 64-bitową jest konwersją rozszerzającą, a 64-bitowej oznaczonej liczby całkowitej na 32-bitową jest konwersją zawężającą.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji na temat konwersji, zobacz <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
          <target state="translated">Typ wartości niewewnętrznej (zdefiniowanej przez użytkownika) jest zgodny tylko z samym sobą.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
          <target state="translated">Wyliczenia mają niejawnej konwersji <ph id="ph1">&lt;xref:System.Enum&gt;</ph> i ich typ podstawowy.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Jeśli wartość każdego elementu w <ph id="ph1">`sourceArray`</ph> wymaga przypisanie elementu podrzędnego (na przykład z klasy podstawowej w klasie pochodnej lub interfejs do obiektu) i jeden lub więcej elementów nie można rzutować typu odpowiadającego w <ph id="ph2">`destinationArray`</ph>, <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> jest generowany.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
          <target state="translated">Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan <ph id="ph1">`destinationArray`</ph> jest niezdefiniowana.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The following code example shows how to copy from one <ph id="ph1">&lt;xref:System.Array&gt;</ph> of type <ph id="ph2">&lt;xref:System.Object&gt;</ph> to another <ph id="ph3">&lt;xref:System.Array&gt;</ph> of type integer.</source>
          <target state="translated">Poniższy przykład kodu pokazuje sposób kopiowania z jednego <ph id="ph1">&lt;xref:System.Array&gt;</ph> typu <ph id="ph2">&lt;xref:System.Object&gt;</ph> do innego <ph id="ph3">&lt;xref:System.Array&gt;</ph> typu integer.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> i <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> ma różnym stopniu.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> i <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> mają niezgodne typy.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated">Co najmniej jeden element w <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> nie można rzutować na typ <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than 0 or greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest mniejsza niż 0 lub większą niż <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest większa niż liczba elementów od <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> na końcu <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest większa niż liczba elementów od <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> na końcu <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Copies all the elements of the current one-dimensional array to the specified one-dimensional array.</source>
          <target state="translated">Kopiuje wszystkie elementy tablicy jednowymiarowej bieżącej do określonej tablicy jednowymiarowej tablicy.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The one-dimensional array that is the destination of the elements copied from the current array.</source>
          <target state="translated">Jednowymiarowa tablica, która jest miejscem docelowym elementów kopiowanych z bieżącej tablicy.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>A 32-bit integer that represents the index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">32-bitową liczbę całkowitą, która reprezentuje indeks w <bpt id="p1">&lt;c&gt;</bpt>tablicy<ept id="p1">&lt;/c&gt;</ept> od rozpoczyna się kopiowanie które.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</source>
          <target state="translated">Kopiuje wszystkie elementy bieżącego tablicy jednowymiarowej do określonej tablicy jednowymiarowej tablicy, zaczynając od indeksu tablicy w określonej lokalizacji docelowej.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The index is specified as a 32-bit integer.</source>
          <target state="translated">Indeks jest określony jako 32-bitową liczbę całkowitą.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>This method copies all the elements of the current array instance to the <ph id="ph1">`array`</ph> destination array, starting at index <ph id="ph2">`index`</ph>.</source>
          <target state="translated">Ta metoda kopiuje wszystkie elementy do bieżącego wystąpienia tablicy <ph id="ph1">`array`</ph> docelowej tablicy, zaczynając od indeksu <ph id="ph2">`index`</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">`array`</ph> destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements.</source>
          <target state="translated"><ph id="ph1">`array`</ph> Tablicy docelowej musi już mieć wymiarów i musi mieć wystarczającą liczbę elementów do uwzględnienia skopiowane elementy.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>Otherwise, the method throws an exception.</source>
          <target state="translated">W przeciwnym razie metoda zgłasza wyjątek.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>This method supports the <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated">Ta metoda obsługuje <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>If implementing <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> is not explicitly required, use <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> to avoid an extra indirection.</source>
          <target state="translated">W przypadku implementowania <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> jest jawnie nie jest to wymagane, użyj <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> Aby uniknąć dodatkowych pośrednie.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`array`</ph> is undefined.</source>
          <target state="translated">Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan <ph id="ph1">`array`</ph> jest niezdefiniowana.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.It performs a shallow copy only.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>. Wykonuje kopię pobieżną tylko.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Array&gt;</ph> to another <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Poniższy przykład kodu pokazuje sposób kopiowania <ph id="ph1">&lt;xref:System.Array&gt;</ph> do innego <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Array&gt;</ph> to another <ph id="ph2">&lt;xref:System.Array&gt;</ph> with a nonzero lower bound.</source>
          <target state="translated">Poniższy przykład kodu pokazuje sposób kopiowania <ph id="ph1">&lt;xref:System.Array&gt;</ph> do innego <ph id="ph2">&lt;xref:System.Array&gt;</ph> z dolną granicą różną od zera.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>Note that the entire source <ph id="ph1">&lt;xref:System.Array&gt;</ph> is copied, including empty elements that overwrite existing elements in the target <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Należy pamiętać, że cały źródła <ph id="ph1">&lt;xref:System.Array&gt;</ph> jest kopiowana, włączając puste elementy, które zastąpić istniejące elementy w celu <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> jest mniejsza niż dolna granica <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The number of elements in the source array is greater than the available number of elements from <ph id="ph1">&lt;paramref name="index" /&gt;</ph> to the end of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Liczba elementów w tablicy źródłowej jest większa niż liczba dostępnych elementów z <ph id="ph1">&lt;paramref name="index" /&gt;</ph> do końca tablicy docelowej <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Typ źródła <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> nie można automatycznie rzutować na typ docelowy <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The source array is multidimensional.</source>
          <target state="translated">Źródłowa tablica jest wielowymiarowa.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>At least one element in the source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> cannot be cast to the type of destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Co najmniej jeden element w źródle <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> nie można rzutować na typ docelowy <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The one-dimensional array that is the destination of the elements copied from the current array.</source>
          <target state="translated">Jednowymiarowa tablica, która jest miejscem docelowym elementów kopiowanych z bieżącej tablicy.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>A 64-bit integer that represents the index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">64-bitową liczbę całkowitą, która reprezentuje indeks w <bpt id="p1">&lt;c&gt;</bpt>tablicy<ept id="p1">&lt;/c&gt;</ept> od rozpoczyna się kopiowanie które.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</source>
          <target state="translated">Kopiuje wszystkie elementy bieżącego tablicy jednowymiarowej do określonej tablicy jednowymiarowej tablicy, zaczynając od indeksu tablicy w określonej lokalizacji docelowej.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The index is specified as a 64-bit integer.</source>
          <target state="translated">Indeks jest określony jako 64-bitową liczbę całkowitą.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>This method copies all the elements of the current array instance to the <ph id="ph1">`array`</ph> destination array, starting at index <ph id="ph2">`index`</ph>.</source>
          <target state="translated">Ta metoda kopiuje wszystkie elementy do bieżącego wystąpienia tablicy <ph id="ph1">`array`</ph> docelowej tablicy, zaczynając od indeksu <ph id="ph2">`index`</ph>.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The <ph id="ph1">`array`</ph> destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements.</source>
          <target state="translated"><ph id="ph1">`array`</ph> Tablicy docelowej musi już mieć wymiarów i musi mieć wystarczającą liczbę elementów do uwzględnienia skopiowane elementy.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>Otherwise, the method throws an exception.</source>
          <target state="translated">W przeciwnym razie metoda zgłasza wyjątek.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>This method supports the <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated">Ta metoda obsługuje <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>If implementing <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> is not explicitly required, use <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> to avoid an extra indirection.</source>
          <target state="translated">W przypadku implementowania <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> jest jawnie nie jest to wymagane, użyj <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> Aby uniknąć dodatkowych pośrednie.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`array`</ph> is undefined.</source>
          <target state="translated">Jeśli ta metoda zgłasza wyjątek podczas kopiowania, stan <ph id="ph1">`array`</ph> jest niezdefiniowana.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.It performs a shallow copy only.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>. Wykonuje kopię pobieżną tylko.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Array&gt;</ph> to another <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Poniższy przykład kodu pokazuje sposób kopiowania <ph id="ph1">&lt;xref:System.Array&gt;</ph> do innego <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Array&gt;</ph> to another <ph id="ph2">&lt;xref:System.Array&gt;</ph> with a nonzero lower bound.</source>
          <target state="translated">Poniższy przykład kodu pokazuje sposób kopiowania <ph id="ph1">&lt;xref:System.Array&gt;</ph> do innego <ph id="ph2">&lt;xref:System.Array&gt;</ph> z dolną granicą różną od zera.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>Note that the entire source <ph id="ph1">&lt;xref:System.Array&gt;</ph> is copied, including empty elements that overwrite existing elements in the target <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Należy pamiętać, że cały źródła <ph id="ph1">&lt;xref:System.Array&gt;</ph> jest kopiowana, włączając puste elementy, które zastąpić istniejące elementy w celu <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The number of elements in the source array is greater than the available number of elements from <ph id="ph1">&lt;paramref name="index" /&gt;</ph> to the end of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Liczba elementów w tablicy źródłowej jest większa niż liczba dostępnych elementów z <ph id="ph1">&lt;paramref name="index" /&gt;</ph> do końca tablicy docelowej <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Typ źródła <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> nie można automatycznie rzutować na typ docelowy <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Źródło <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>At least one element in the source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> cannot be cast to the type of destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Co najmniej jeden element w źródle <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> nie można rzutować na typ docelowy <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> class.</source>
          <target state="translated">Inicjuje nowe wystąpienie klasy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> z <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do utworzenia.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>The size of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Rozmiar <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do utworzenia.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>Creates a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and length, with zero-based indexing.</source>
          <target state="translated">Tworzy jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> określonego <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> i długości z indeksowania liczony od zera.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>A new one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length, using zero-based indexing.</source>
          <target state="translated">Nowy jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> określonego <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> o określonej długości, przy użyciu indeksowania liczony od zera.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">W przeciwieństwie do większości klasy <ph id="ph1">&lt;xref:System.Array&gt;</ph> zapewnia <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> metody, zamiast konstruktorów publicznych, aby umożliwić późne powiązania dostępu.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Elementy typu odwołania są zainicjowane do <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Elementy typu wartości są inicjowane od zera.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>The following code example shows how to create and initialize a one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Poniższy przykładowy kod przedstawia sposób tworzenia i inicjowania jednowymiarowa <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> nie jest prawidłową <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> nie jest obsługiwane.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Na przykład <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> nie jest obsługiwane.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> jest to otwarty typ ogólny.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> z <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do utworzenia.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>An array of 32-bit integers that represent the size of each dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">32-bitowych liczb całkowitych, które reprezentują rozmiar każdego wymiaru tablicy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do utworzenia.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Creates a multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with zero-based indexing.</source>
          <target state="translated">Tworzy wielowymiarowe <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> określonego <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> i wymiarów długości z indeksowania liczony od zera.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The dimension lengths are specified in an array of 32-bit integers.</source>
          <target state="translated">Długości wymiaru są określone w tablicy 32-bitowych liczb całkowitych.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>A new multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
          <target state="translated">Nowy wielowymiarowe <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> określonego <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> o określonej długości dla każdego wymiaru przy użyciu indeksowania liczony od zera.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">W przeciwieństwie do większości klasy <ph id="ph1">&lt;xref:System.Array&gt;</ph> zapewnia <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> metody, zamiast konstruktorów publicznych, aby umożliwić późne powiązania dostępu.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The number of elements in the <ph id="ph1">`lengths`</ph> array must equal the number of dimensions in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Liczba elementów w <ph id="ph1">`lengths`</ph> tablicy musi być równa liczby wymiarów w nowym <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Each element of the <ph id="ph1">`lengths`</ph> array must specify the length of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Każdy element <ph id="ph1">`lengths`</ph> określić długości odpowiedniego wymiaru tablicy w nowym <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Elementy typu odwołania są zainicjowane do <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Elementy typu wartości są inicjowane od zera.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of all values in <ph id="ph3">`lengths`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest produktem wszystkich wartości w <ph id="ph3">`lengths`</ph>.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The following code example shows how to create and initialize a multidimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Poniższy przykładowy kod przedstawia sposób tworzenia i inicjowania wielowymiarowe <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> nie jest prawidłową <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> array contains less than one element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> Tablica zawiera mniej niż jeden element.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> nie jest obsługiwane.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Na przykład <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> nie jest obsługiwane.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> jest to otwarty typ ogólny.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Any value in <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is less than zero.</source>
          <target state="translated">Dowolna wartość <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> z <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do utworzenia.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>An array of 64-bit integers that represent the size of each dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">64-bitowych liczb całkowitych, które reprezentują rozmiar każdego wymiaru tablicy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do utworzenia.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Each integer in the array must be between zero and <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>, inclusive.</source>
          <target state="translated">Każdy całkowitą w tablicy musi wynosić od zera i <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>włącznie.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Creates a multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with zero-based indexing.</source>
          <target state="translated">Tworzy wielowymiarowe <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> określonego <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> i wymiarów długości z indeksowania liczony od zera.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The dimension lengths are specified in an array of 64-bit integers.</source>
          <target state="translated">Długości wymiaru są określone w tablicy 64-bitowych liczb całkowitych.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>A new multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
          <target state="translated">Nowy wielowymiarowe <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> określonego <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> o określonej długości dla każdego wymiaru przy użyciu indeksowania liczony od zera.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">W przeciwieństwie do większości klasy <ph id="ph1">&lt;xref:System.Array&gt;</ph> zapewnia <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> metody, zamiast konstruktorów publicznych, aby umożliwić późne powiązania dostępu.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The number of elements in the <ph id="ph1">`lengths`</ph> array must equal the number of dimensions in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Liczba elementów w <ph id="ph1">`lengths`</ph> tablicy musi być równa liczby wymiarów w nowym <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Each element of the <ph id="ph1">`lengths`</ph> array must specify the length of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Każdy element <ph id="ph1">`lengths`</ph> określić długości odpowiedniego wymiaru tablicy w nowym <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Elementy typu odwołania są zainicjowane do <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Elementy typu wartości są inicjowane od zera.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of all values in <ph id="ph3">`lengths`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest produktem wszystkich wartości w <ph id="ph3">`lengths`</ph>.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The following code example shows how to create and initialize a multidimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Poniższy przykładowy kod przedstawia sposób tworzenia i inicjowania wielowymiarowe <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> nie jest prawidłową <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> array contains less than one element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> Tablica zawiera mniej niż jeden element.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> nie jest obsługiwane.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Na przykład <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> nie jest obsługiwane.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> jest to otwarty typ ogólny.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Any value in <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is less than zero or greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Dowolna wartość <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> jest mniejsza niż zero lub większa niż <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> z <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do utworzenia.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>The size of the first dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Rozmiar pierwszym wymiarze <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do utworzenia.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>The size of the second dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Rozmiar drugiego wymiaru <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do utworzenia.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>Creates a two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with zero-based indexing.</source>
          <target state="translated">Tworzy dwuwymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> określonego <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> i wymiarów długości z indeksowania liczony od zera.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>A new two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
          <target state="translated">Nowy dwuwymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> określonego <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> o określonej długości dla każdego wymiaru przy użyciu indeksowania liczony od zera.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">W przeciwieństwie do większości klasy <ph id="ph1">&lt;xref:System.Array&gt;</ph> zapewnia <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> metody, zamiast konstruktorów publicznych, aby umożliwić późne powiązania dostępu.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Elementy typu odwołania są zainicjowane do <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Elementy typu wartości są inicjowane od zera.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of <ph id="ph3">`length1`</ph> and <ph id="ph4">`length2`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest produktem <ph id="ph3">`length1`</ph> i <ph id="ph4">`length2`</ph>.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>The following code example shows how to create and initialize a two-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Poniższy przykładowy kod przedstawia sposób tworzenia i inicjowania dwuwymiarowa <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> nie jest prawidłową <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> nie jest obsługiwane.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Na przykład <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> nie jest obsługiwane.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> jest to otwarty typ ogólny.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length1" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length1" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length2" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length2" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> z <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do utworzenia.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>A one-dimensional array that contains the size of each dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Jednowymiarowa tablica, która zawiera rozmiar każdego wymiaru <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do utworzenia.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>A one-dimensional array that contains the lower bound (starting index) of each dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Jednowymiarowa tablica, która zawiera dolna granica (indeks początkowy) każdego wymiaru <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do utworzenia.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Creates a multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with the specified lower bounds.</source>
          <target state="translated">Tworzy wielowymiarowe <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> określonego <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> i wymiarów długości z określonym dolne granice tablicy.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>A new multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length and lower bound for each dimension.</source>
          <target state="translated">Nowy wielowymiarowe <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> określonego <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> z określoną długość i dolną granicę każdego wymiaru.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">W przeciwieństwie do większości klasy <ph id="ph1">&lt;xref:System.Array&gt;</ph> zapewnia <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> metody, zamiast konstruktorów publicznych, aby umożliwić późne powiązania dostępu.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The <ph id="ph1">`lengths`</ph> and <ph id="ph2">`lowerBounds`</ph> arrays must have the same number of elements.</source>
          <target state="translated"><ph id="ph1">`lengths`</ph> i <ph id="ph2">`lowerBounds`</ph> tablice muszą mieć taką samą liczbę elementów.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The number of elements in the <ph id="ph1">`lengths`</ph> array must equal the number of dimensions in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Liczba elementów w <ph id="ph1">`lengths`</ph> tablicy musi być równa liczby wymiarów w nowym <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Each element of the <ph id="ph1">`lengths`</ph> array must specify the length of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Każdy element <ph id="ph1">`lengths`</ph> określić długości odpowiedniego wymiaru tablicy w nowym <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Each element of the <ph id="ph1">`lowerBounds`</ph> array must specify the lower bound of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Każdy element <ph id="ph1">`lowerBounds`</ph> określić dolna granica odpowiedniego wymiaru tablicy w nowym <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Generally, the .NET Framework class library and many programming languages do not handle nonzero lower bounds.</source>
          <target state="translated">Ogólnie rzecz biorąc Biblioteka klas programu .NET Framework i wielu języków programowania nie obsługują niezerową dolne granice tablicy.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Elementy typu odwołania są zainicjowane do <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Elementy typu wartości są inicjowane od zera.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of all values in <ph id="ph3">`lengths`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest produktem wszystkich wartości w <ph id="ph3">`lengths`</ph>.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The following code example shows how to create and initialize a multidimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> with specified lower bounds.</source>
          <target state="translated">Poniższy przykładowy kod przedstawia sposób tworzenia i inicjowania wielowymiarowe <ph id="ph1">&lt;xref:System.Array&gt;</ph> z określonym dolne granice tablicy.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="lowerBounds" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lowerBounds" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> nie jest prawidłową <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> array contains less than one element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> Tablica zawiera mniej niż jeden element.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> and <ph id="ph2">&lt;paramref name="lowerBounds" /&gt;</ph> arrays do not contain the same number of elements.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> i <ph id="ph2">&lt;paramref name="lowerBounds" /&gt;</ph> tablice nie zawierają tę samą liczbę elementów.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> nie jest obsługiwane.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Na przykład <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> nie jest obsługiwane.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> jest to otwarty typ ogólny.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Any value in <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is less than zero.</source>
          <target state="translated">Dowolna wartość <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Any value in <ph id="ph1">&lt;paramref name="lowerBounds" /&gt;</ph> is very large, such that the sum of a dimension's lower bound and length is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Dowolna wartość <ph id="ph1">&lt;paramref name="lowerBounds" /&gt;</ph> jest bardzo duży, w taki sposób, że suma dolna granica wymiaru i jego długość jest większa niż <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> z <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do utworzenia.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The size of the first dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Rozmiar pierwszym wymiarze <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do utworzenia.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The size of the second dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Rozmiar drugiego wymiaru <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do utworzenia.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The size of the third dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Rozmiar wymiaru innych <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do utworzenia.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>Creates a three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with zero-based indexing.</source>
          <target state="translated">Tworzy trójwymiarowy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> określonego <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> i wymiarów długości z indeksowania liczony od zera.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>A new three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
          <target state="translated">Nowy trójwymiarowy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> określonego <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> o określonej długości dla każdego wymiaru przy użyciu indeksowania liczony od zera.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">W przeciwieństwie do większości klasy <ph id="ph1">&lt;xref:System.Array&gt;</ph> zapewnia <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> metody, zamiast konstruktorów publicznych, aby umożliwić późne powiązania dostępu.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Elementy typu odwołania są zainicjowane do <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Elementy typu wartości są inicjowane od zera.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of <ph id="ph3">`length1`</ph>, <ph id="ph4">`length2`</ph>, and <ph id="ph5">`length3`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest produktem <ph id="ph3">`length1`</ph>, <ph id="ph4">`length2`</ph>, i <ph id="ph5">`length3`</ph>.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The following code example shows how to create and initialize a three-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Poniższy przykładowy kod przedstawia sposób tworzenia i inicjowania trójwymiarowy <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> nie jest prawidłową <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> nie jest obsługiwane.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Na przykład <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> nie jest obsługiwane.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> jest to otwarty typ ogólny.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length1" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length1" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length2" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length2" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length3" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length3" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Empty``1">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Array.Empty``1">
          <source>Returns an empty array.</source>
          <target state="translated">Zwraca pustą tablicę.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Array.Empty``1">
          <source>Returns an empty <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Zwraca pustą <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the elements to search for.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> Definiujący warunki elementu do wyszukania.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>Determines whether the specified array contains elements that match the conditions defined by the specified predicate.</source>
          <target state="translated">Określa, czy określona tablica zawiera elementy odpowiadające warunkom zdefiniowanym przez określony predykat.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="array" /&gt;</ph> contains one or more elements that match the conditions defined by the specified predicate; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli <ph id="ph2">&lt;paramref name="array" /&gt;</ph> zawiera jeden lub więcej elementów, które pasują do warunków zdefiniowanych przez określony predykat; w przeciwnym razie <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> Jest delegowany do metody, która zwraca <ph id="ph2">`true`</ph> obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, and processing is stopped when a match is found.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> indywidualnie są przekazywane do <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, i przetwarzania jest zatrzymana po znalezieniu dopasowania.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegate explicitly.</source>
          <target state="translated">W języku C# i Visual Basic, nie jest konieczne tworzenie <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> jawnie delegowanie.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The following example specifies the match conditions for the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> method usinglambda expressions to check whether a planet starts with a given letter or whether the planet is found on the given array.</source>
          <target state="translated">W poniższym przykładzie warunki dopasowania <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> wyrażenia usinglambda metody do sprawdzenia, czy planety zaczynał się literą danego lub czy świecie znajduje się w podanej tablicy.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> method to indicate whether any names in a string array begin with a specified character.</source>
          <target state="translated">W poniższym przykładzie użyto <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> metodę, aby wskazać, czy wszystkie nazwy w tablicy ciągów zaczynają się od określonego znaku.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The example instantiates a <ph id="ph1">`StringSearcher`</ph> object by passing the string to search for to its class constructor.</source>
          <target state="translated">Przykład tworzy <ph id="ph1">`StringSearcher`</ph> obiektu przez przekazywanie ciągu wyszukiwania dla jego konstruktora klasy.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">`StringSearcher.StartsWith`</ph> method has same signature as the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
          <target state="translated"><ph id="ph1">`StringSearcher.StartsWith`</ph> Metoda ma takiego samego podpisu jak <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegowanie.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>When the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> method is called, each member of the array is passed to the delegate until it returns <ph id="ph2">`true`</ph> or iterates all the elements in the array.</source>
          <target state="translated">Gdy <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> metoda jest wywoływana, każdy element członkowski tablicy jest przekazywana do delegata, dopóki zwróci <ph id="ph2">`true`</ph> lub iteracji wszystkich elementów w tablicy.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>You can also use a lambda expression rather than explicitly define a method whose signature corresponds to that of the delegate.</source>
          <target state="translated">Można również użyć wyrażenia lambda zamiast jawnie definiować metody, której sygnatura odpowiada do tego delegata.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The following example replaces the <ph id="ph1">`StringSearcher`</ph> class and its <ph id="ph2">`StartsWith`</ph> method with a lambda expression.</source>
          <target state="translated">W poniższym przykładzie <ph id="ph1">`StringSearcher`</ph> klasy i jej <ph id="ph2">`StartsWith`</ph> metody za pomocą wyrażenia lambda.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based array to search.</source>
          <target state="translated">Tablica jednowymiarowa, liczony od zera do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The predicate that defines the conditions of the element to search for.</source>
          <target state="translated">Predykat definiujący warunki elementu do wyszukania.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca pierwsze wystąpienie w ramach całego <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated">Pierwszy element, który pasuje do warunków zdefiniowanych przez określony predykat, gdy znaleziono; w przeciwnym razie wartość domyślna dla typu <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method or a lambda expression that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate or lambda expression.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> Jest delegowany do metody lub wyrażenie lambda, które zwraca <ph id="ph2">`true`</ph> obiekt przekazywany do jest zgodne z warunkami określonymi w delegat lub wyrażenie lambda.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, starting with the first element and ending with the last element.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> indywidualnie są przekazywane do <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, rozpoczynając od pierwszego elementu i kończąc ostatnim elemencie.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>Processing is stopped when a match is found.</source>
          <target state="translated">Przetwarzanie zostało zatrzymane po znalezieniu dopasowania.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The following example uses a <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegate with the <ph id="ph2">&lt;xref:System.Array.Find%2A&gt;</ph> generic method to search an array of <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> structures.</source>
          <target state="translated">W poniższym przykładzie użyto <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegat <ph id="ph2">&lt;xref:System.Array.Find%2A&gt;</ph> metody ogólnej wyszukiwania tablicę <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> struktury.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The method the delegate represents, <ph id="ph1">`ProductGT10`</ph>, returns <ph id="ph2">`true`</ph> if the product of the X and Y fields is greater than 100,000.</source>
          <target state="translated">Reprezentuje delegata, Metoda <ph id="ph1">`ProductGT10`</ph>, zwraca <ph id="ph2">`true`</ph> Jeśli produkt pola X i Y jest większa niż 100 000.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> method calls the delegate for each element of the array, returning the first point that meets the test condition.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> Metoda wywołuje delegata dla każdego elementu w tablicy, zwracając pierwszego punktu, który spełnia warunek testu.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>Visual Basic and C# users do not have to create the delegate explicitly or specify the type argument of the generic method.</source>
          <target state="translated">Visual Basic i C# użytkowników ma utworzyć delegat jawnie lub określić argument typu metody ogólnej.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The compilers determine the necessary types from the method arguments you supply.</source>
          <target state="translated">Kompilatory ustalić wymagane typy z podane argumenty metody.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>Rather than explicitly defining a method with the necessary signature, instantiating a <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegate, and passing the delegate to the <ph id="ph2">&lt;xref:System.Array.Find%2A&gt;</ph> method, it is customary to use a lambda expression.</source>
          <target state="translated">Zamiast jawnie definiowanie metody podpisem konieczne utworzenie wystąpienia <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegować i przekazywanie delegata do <ph id="ph2">&lt;xref:System.Array.Find%2A&gt;</ph> metody jest zwyczajowe można użyć wyrażenia lambda.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The following example is identical to the previous one, except that it uses a lambda expression as the <ph id="ph1">`match`</ph> argument.</source>
          <target state="translated">Poniższy przykład jest taki sam jak poprzedni, z wyjątkiem tego, że używa wyrażenia lambda jako <ph id="ph1">`match`</ph> argumentu.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the elements to search for.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> Definiujący warunki elementu do wyszukania.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>Retrieves all the elements that match the conditions defined by the specified predicate.</source>
          <target state="translated">Pobiera wszystkie elementy odpowiadające warunkom zdefiniowanym przez określony predykat.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>An <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> containing all the elements that match the conditions defined by the specified predicate, if found; otherwise, an empty <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> Zawierający wszystkie elementy zgodnych warunki zdefiniowane przez określony predykat, jeśli je znaleziono; w przeciwnym razie, pustą <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> Jest delegowany do metody, która zwraca <ph id="ph2">`true`</ph> obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, and the elements that match the conditions are saved in the returned array.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> indywidualnie są przekazywane do <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, i elementy, które spełniają podane są zapisywane w zwróconej tablicy.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The following example creates an array of 50 random numbers with values that can range from 0 to 1,000.</source>
          <target state="translated">Poniższy przykład tworzy tablicę 50 liczb losowych wartości, które mogą należeć do zakresu od 0 do 1000.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> method with a lambda expression that returns the values that range from 300 to 600.</source>
          <target state="translated">Następnie wywołuje <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> metody za pomocą wyrażenia lambda, która zwraca wartości zakresu od 300 do 600.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>Note that the lambda expression is passed a parameter named <ph id="ph1">`x`</ph>;  this represents the individual array member that is passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Należy pamiętać, że wyrażenie lambda jest przekazywany parametr o nazwie <ph id="ph1">`x`</ph>;  Ta pozycja reprezentuje poszczególnych element członkowski, który jest przekazywany do <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>Also note that the local <ph id="ph1">`lBound`</ph> and <ph id="ph2">`uBound`</ph> variables are accessible within the lambda expression.</source>
          <target state="translated">Należy również zauważyć, że lokalna <ph id="ph1">`lBound`</ph> i <ph id="ph2">`uBound`</ph> zmienne są dostępne w wyrażeniu lambda.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.FindLast%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Array.FindAll%2A&gt;</ph> generic methods.</source>
          <target state="translated">Poniższy przykład kodu pokazuje <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.FindLast%2A&gt;</ph>, i <ph id="ph3">&lt;xref:System.Array.FindAll%2A&gt;</ph> metody ogólne.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">Przykładowy kod definiuje również metody predykatu wyszukiwania o nazwie <ph id="ph1">`EndsWithSaurus`</ph>, który akceptuje parametr typu string i zwraca wartość typu Boolean wartość wskazującą, czy ciąg wejściowy kończy się na "saurus".</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> generic method traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> Metoda rodzajowa jest przesyłany tablicy od początku, przekazywanie kolejno do każdego elementu <ph id="ph2">`EndsWithSaurus`</ph> metody.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element "Amargasaurus".</source>
          <target state="translated">Zatrzymuje wyszukiwania, kiedy <ph id="ph1">`EndsWithSaurus`</ph> metoda zwraca <ph id="ph2">`true`</ph> dla elementu "Amargasaurus".</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">W języku C# i Visual Basic, nie jest konieczne tworzenie <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegować (<ph id="ph2">`Predicate(Of String)`</ph> w języku Visual Basic) jawnie.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLast%2A&gt;</ph> generic method is used to search the array backward from the end.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindLast%2A&gt;</ph> Metoda ogólna służy do wyszukiwania do tyłu na końcu tablicy.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>It finds the element "Dilophosaurus" at position 5.</source>
          <target state="translated">Znajduje element „Dilophosaurus” w pozycji 5.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> generic method is used to return an array containing all the elements that end in "saurus".</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> Metoda ogólna służy do zwracania tablica zawierająca wszystkie elementy, które kończą się "saurus".</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The elements are displayed.</source>
          <target state="translated">Elementy są wyświetlane.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The code example also demonstrates the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> generic methods.</source>
          <target state="translated">Przykład kodu pokazuje, również <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> metody ogólne.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the first occurrence within an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks pierwszego wystąpienia w <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> lub jego część.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> Definiujący warunki elementu do wyszukania.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks pierwszego wystąpienia w obrębie całej <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">Liczony od zera indeks pierwszego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, jeśli je znaleziono; w przeciwnym razie wartość -1.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched forward starting at the first element and ending at the last element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> Przeszukiwany jest do przodu zaczynając od pierwszego elementu i końcowy z ostatniego elementu.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> Jest delegowany do metody, która zwraca <ph id="ph2">`true`</ph> obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> indywidualnie są przekazywane do <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">Poniższy przykład kodu pokazuje wszystkich trzech przeciążeń <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> metody rodzajowej.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">Przykładowy kod definiuje również metody predykatu wyszukiwania o nazwie <ph id="ph1">`EndsWithSaurus`</ph>, który akceptuje parametr typu string i zwraca wartość typu Boolean wartość wskazującą, czy ciąg wejściowy kończy się na "saurus".</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> Przeciążenie metody są przesyłane za pośrednictwem tablicy od początku, przekazywanie kolejno do każdego elementu <ph id="ph2">`EndsWithSaurus`</ph> metody.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 1.</source>
          <target state="translated">Zatrzymuje wyszukiwania, kiedy <ph id="ph1">`EndsWithSaurus`</ph> metoda zwraca <ph id="ph2">`true`</ph> dla elementu na pozycji 1.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">W języku C# i Visual Basic, nie jest konieczne tworzenie <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegować (<ph id="ph2">`Predicate(Of String)`</ph> w języku Visual Basic) jawnie.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> Przeciążenie metody używane do przeszukiwania tablicy, zaczynając od pozycji 2 i przejściem do końca tablicy.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>It finds the element at position 5.</source>
          <target state="translated">Wyszukiwany element na pozycji 5.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 2.</source>
          <target state="translated">Na koniec <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> przeciążenie metody używane do przeszukiwania zakres trzy elementy, zaczynając od pozycji 2.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Ponieważ nie ma nazw dinozaurów w tym zakresie kończących się ciągiem „saurus”, zwraca wartość –1.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> Definiujący warunki elementu do wyszukania.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that extends from the specified index to the last element.</source>
          <target state="translated">Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks pierwszego wystąpienia w zakresie elementów w <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> który rozciąga się od określonego indeksu do ostatniego elementu.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">Liczony od zera indeks pierwszego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, jeśli je znaleziono; w przeciwnym razie wartość -1.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at the last element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> Przeszukiwany jest do przodu zaczynając od <ph id="ph2">`startIndex`</ph> i kończąc na ostatnim elemencie.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> Jest delegowany do metody, która zwraca <ph id="ph2">`true`</ph> obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> indywidualnie są przekazywane do <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest liczba elementów od <ph id="ph3">`startIndex`</ph> na końcu <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">Poniższy przykład kodu pokazuje wszystkich trzech przeciążeń <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> metody rodzajowej.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">Przykładowy kod definiuje również metody predykatu wyszukiwania o nazwie <ph id="ph1">`EndsWithSaurus`</ph>, który akceptuje parametr typu string i zwraca wartość typu Boolean wartość wskazującą, czy ciąg wejściowy kończy się na "saurus".</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> Przeciążenie metody są przesyłane za pośrednictwem tablicy od początku, przekazywanie kolejno do każdego elementu <ph id="ph2">`EndsWithSaurus`</ph> metody.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 1.</source>
          <target state="translated">Zatrzymuje wyszukiwania, kiedy <ph id="ph1">`EndsWithSaurus`</ph> metoda zwraca <ph id="ph2">`true`</ph> dla elementu na pozycji 1.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">W języku C# i Visual Basic, nie jest konieczne tworzenie <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegować (<ph id="ph2">`Predicate(Of String)`</ph> w języku Visual Basic) jawnie.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> Przeciążenie metody używane do przeszukiwania tablicy, zaczynając od pozycji 2 i przejściem do końca tablicy.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>It finds the element at position 5.</source>
          <target state="translated">Wyszukiwany element na pozycji 5.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 2.</source>
          <target state="translated">Na koniec <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> przeciążenie metody używane do przeszukiwania zakres trzy elementy, zaczynając od pozycji 2.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Ponieważ nie ma nazw dinozaurów w tym zakresie kończących się ciągiem „saurus”, zwraca wartość –1.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Liczba elementów w sekcji do wyszukania.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> Definiujący warunki elementu do wyszukania.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that starts at the specified index and contains the specified number of elements.</source>
          <target state="translated">Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks pierwszego wystąpienia w zakresie elementów w <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> rozpoczyna się od określonego indeksu i zawiera określonej liczby elementów.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">Liczony od zera indeks pierwszego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, jeśli je znaleziono; w przeciwnym razie wartość -1.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> plus <ph id="ph4">`count`</ph> minus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> Przeszukiwany jest do przodu zaczynając od <ph id="ph2">`startIndex`</ph> i kończący się na <ph id="ph3">`startIndex`</ph> plus <ph id="ph4">`count`</ph> pomniejszonej o 1, jeśli <ph id="ph5">`count`</ph> jest większa niż 0.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> Jest delegowany do metody, która zwraca <ph id="ph2">`true`</ph> obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> indywidualnie są przekazywane do <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">Poniższy przykład kodu pokazuje wszystkich trzech przeciążeń <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> metody rodzajowej.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">Przykładowy kod definiuje również metody predykatu wyszukiwania o nazwie <ph id="ph1">`EndsWithSaurus`</ph>, który akceptuje parametr typu string i zwraca wartość typu Boolean wartość wskazującą, czy ciąg wejściowy kończy się na "saurus".</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> Przeciążenie metody są przesyłane za pośrednictwem tablicy od początku, przekazywanie kolejno do każdego elementu <ph id="ph2">`EndsWithSaurus`</ph> metody.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 1.</source>
          <target state="translated">Zatrzymuje wyszukiwania, kiedy <ph id="ph1">`EndsWithSaurus`</ph> metoda zwraca <ph id="ph2">`true`</ph> dla elementu na pozycji 1.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">W języku C# i Visual Basic, nie jest konieczne tworzenie <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegować (<ph id="ph2">`Predicate(Of String)`</ph> w języku Visual Basic) jawnie.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> Przeciążenie metody używane do przeszukiwania tablicy, zaczynając od pozycji 2 i przejściem do końca tablicy.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>It finds the element at position 5.</source>
          <target state="translated">Wyszukiwany element na pozycji 5.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 2.</source>
          <target state="translated">Na koniec <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> przeciążenie metody używane do przeszukiwania zakres trzy elementy, zaczynając od pozycji 2.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Ponieważ nie ma nazw dinozaurów w tym zakresie kończących się ciągiem „saurus”, zwraca wartość –1.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> i <ph id="ph2">&lt;paramref name="count" /&gt;</ph> nie zostanie określony prawidłowy części <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> Definiujący warunki elementu do wyszukania.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca ostatnie wystąpienie w ramach całego <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The last element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated">Ostatni element, który pasuje do warunków zdefiniowanych przez określony predykat, gdy znaleziono; w przeciwnym razie wartość domyślna dla typu <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> Jest delegowany do metody, która zwraca <ph id="ph2">`true`</ph> obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, moving backward in the <ph id="ph3">&lt;xref:System.Array&gt;</ph>, starting with the last element and ending with the first element.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> indywidualnie są przekazywane do <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, przenoszenie z poprzednimi wersjami w <ph id="ph3">&lt;xref:System.Array&gt;</ph>, zaczynając od ostatniego elementu i kończąc pierwszego elementu.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>Processing is stopped when a match is found.</source>
          <target state="translated">Przetwarzanie zostało zatrzymane po znalezieniu dopasowania.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.FindLast%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Array.FindAll%2A&gt;</ph> generic methods.</source>
          <target state="translated">Poniższy przykład kodu pokazuje <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.FindLast%2A&gt;</ph>, i <ph id="ph3">&lt;xref:System.Array.FindAll%2A&gt;</ph> metody ogólne.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">Przykładowy kod definiuje również metody predykatu wyszukiwania o nazwie <ph id="ph1">`EndsWithSaurus`</ph>, który akceptuje parametr typu string i zwraca wartość typu Boolean wartość wskazującą, czy ciąg wejściowy kończy się na "saurus".</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> generic method traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> Metoda rodzajowa jest przesyłany tablicy od początku, przekazywanie kolejno do każdego elementu <ph id="ph2">`EndsWithSaurus`</ph> metody.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element "Amargasaurus".</source>
          <target state="translated">Zatrzymuje wyszukiwania, kiedy <ph id="ph1">`EndsWithSaurus`</ph> metoda zwraca <ph id="ph2">`true`</ph> dla elementu "Amargasaurus".</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the<ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">W języku C# i Visual Basic, nie jest konieczne tworzenie<ph id="ph1">`Predicate&lt;string&gt;`</ph> delegować (<ph id="ph2">`Predicate(Of String)`</ph> w języku Visual Basic) jawnie.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLast%2A&gt;</ph> generic method is used to search the array backward from the end.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindLast%2A&gt;</ph> Metoda ogólna służy do wyszukiwania do tyłu na końcu tablicy.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>It finds the element "Dilophosaurus" at position 5.</source>
          <target state="translated">Znajduje element „Dilophosaurus” w pozycji 5.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> generic method is used to return an array containing all the elements that end in "saurus".</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> Metoda ogólna służy do zwracania tablica zawierająca wszystkie elementy, które kończą się "saurus".</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The elements are displayed.</source>
          <target state="translated">Elementy są wyświetlane.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The code example also demonstrates the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> generic methods.</source>
          <target state="translated">Przykład kodu pokazuje, również <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> metody ogólne.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the last occurrence within an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks w ciągu ostatniego wystąpienia <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> lub jego część.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> Definiujący warunki elementu do wyszukania.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks ostatniego wystąpienia w obrębie całej <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Liczony od zera indeks ostatniego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, jeśli je znaleziono; w przeciwnym razie wartość -1.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> Przeszukiwany jest wstecz od ostatniego elementu i kończącego się na pierwszym elementem.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> Jest delegowany do metody, która zwraca <ph id="ph2">`true`</ph> obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> indywidualnie są przekazywane do <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">Poniższy przykład kodu pokazuje wszystkich trzech przeciążeń <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> metody rodzajowej.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">Przykładowy kod definiuje również metody predykatu wyszukiwania o nazwie <ph id="ph1">`EndsWithSaurus`</ph>, który akceptuje parametr typu string i zwraca wartość typu Boolean wartość wskazującą, czy ciąg wejściowy kończy się na "saurus".</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array backward from the end, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> Przeciążenie metody jest przesyłany z poprzednimi wersjami tablicy po zakończeniu przekazywania kolejno do każdego elementu <ph id="ph2">`EndsWithSaurus`</ph> metody.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 5.</source>
          <target state="translated">Zatrzymuje wyszukiwania, kiedy <ph id="ph1">`EndsWithSaurus`</ph> metoda zwraca <ph id="ph2">`true`</ph> dla elementu na pozycji 5.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">W języku C# i Visual Basic, nie jest konieczne tworzenie <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegować (<ph id="ph2">`Predicate(Of String)`</ph> w języku Visual Basic) jawnie.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> Przeciążenie metody używane do przeszukiwania tablicy, zaczynając od pozycji 4 i kontynuowanie wstecz na początku tablicy.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>It finds the element at position 1.</source>
          <target state="translated">Wyszukiwany element na pozycji 1.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</source>
          <target state="translated">Na koniec <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> przeciążenie metody używane do przeszukiwania zakres trzy elementy zaczynając od pozycji 4 i Praca Wstecz (to znaczy elementy 4, 3 i 2).</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Ponieważ nie ma nazw dinozaurów w tym zakresie kończących się ciągiem „saurus”, zwraca wartość –1.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> Definiujący warunki elementu do wyszukania.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that extends from the first element to the specified index.</source>
          <target state="translated">Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks ostatniego wystąpienia w zakresie elementów w <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> który rozciąga się od pierwszego elementu zgodnie z określonym indeksem.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Liczony od zera indeks ostatniego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, jeśli je znaleziono; w przeciwnym razie wartość -1.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> Jest przeszukane z poprzednimi wersjami zaczynając od <ph id="ph2">`startIndex`</ph> i kończącego się na pierwszym elementem.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> Jest delegowany do metody, która zwraca <ph id="ph2">`true`</ph> obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> indywidualnie są przekazywane do <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from the beginning of <ph id="ph3">`array`</ph> to <ph id="ph4">`startIndex`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest liczba elementów od początku <ph id="ph3">`array`</ph> do <ph id="ph4">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">Poniższy przykład kodu pokazuje wszystkich trzech przeciążeń <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> metody rodzajowej.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">Przykładowy kod definiuje również metody predykatu wyszukiwania o nazwie <ph id="ph1">`EndsWithSaurus`</ph>, który akceptuje parametr typu string i zwraca wartość typu Boolean wartość wskazującą, czy ciąg wejściowy kończy się na "saurus".</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array backward from the end, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> Przeciążenie metody jest przesyłany z poprzednimi wersjami tablicy po zakończeniu przekazywania kolejno do każdego elementu <ph id="ph2">`EndsWithSaurus`</ph> metody.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 5.</source>
          <target state="translated">Zatrzymuje wyszukiwania, kiedy <ph id="ph1">`EndsWithSaurus`</ph> metoda zwraca <ph id="ph2">`true`</ph> dla elementu na pozycji 5.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">W języku C# i Visual Basic, nie jest konieczne tworzenie <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegować (<ph id="ph2">`Predicate(Of String)`</ph> w języku Visual Basic) jawnie.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> Przeciążenie metody używane do przeszukiwania tablicy, zaczynając od pozycji 4 i kontynuowanie wstecz na początku tablicy.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>It finds the element at position 1.</source>
          <target state="translated">Wyszukiwany element na pozycji 1.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</source>
          <target state="translated">Na koniec <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> przeciążenie metody używane do przeszukiwania zakres trzy elementy zaczynając od pozycji 4 i Praca Wstecz (to znaczy elementy 4, 3 i 2).</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Ponieważ nie ma nazw dinozaurów w tym zakresie kończących się ciągiem „saurus”, zwraca wartość –1.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Liczba elementów w sekcji do wyszukania.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> Definiujący warunki elementu do wyszukania.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
          <target state="translated">Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks ostatniego wystąpienia w zakresie elementów w <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> czy zawiera określoną liczbę elementów i kończy się na określony indeks.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Liczony od zera indeks ostatniego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, jeśli je znaleziono; w przeciwnym razie wartość -1.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> Jest przeszukane z poprzednimi wersjami zaczynając od <ph id="ph2">`startIndex`</ph> i kończący się na <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, jeśli <ph id="ph5">`count`</ph> jest większa niż 0.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> Jest delegowany do metody, która zwraca <ph id="ph2">`true`</ph> obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> indywidualnie są przekazywane do <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">Poniższy przykład kodu pokazuje wszystkich trzech przeciążeń <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> metody rodzajowej.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Tworzona jest tablica ciągów zawierająca 8 nazw dinozaurów, przy czym dwie z nich (w pozycjach 1 i 5) kończą się na „saurus”.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">Przykładowy kod definiuje również metody predykatu wyszukiwania o nazwie <ph id="ph1">`EndsWithSaurus`</ph>, który akceptuje parametr typu string i zwraca wartość typu Boolean wartość wskazującą, czy ciąg wejściowy kończy się na "saurus".</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array backward from the end, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> Przeciążenie metody jest przesyłany z poprzednimi wersjami tablicy po zakończeniu przekazywania kolejno do każdego elementu <ph id="ph2">`EndsWithSaurus`</ph> metody.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 5.</source>
          <target state="translated">Zatrzymuje wyszukiwania, kiedy <ph id="ph1">`EndsWithSaurus`</ph> metoda zwraca <ph id="ph2">`true`</ph> dla elementu na pozycji 5.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">W języku C# i Visual Basic, nie jest konieczne tworzenie <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegować (<ph id="ph2">`Predicate(Of String)`</ph> w języku Visual Basic) jawnie.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> Przeciążenie metody używane do przeszukiwania tablicy, zaczynając od pozycji 4 i kontynuowanie wstecz na początku tablicy.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>It finds the element at position 1.</source>
          <target state="translated">Wyszukiwany element na pozycji 1.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</source>
          <target state="translated">Na koniec <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> przeciążenie metody używane do przeszukiwania zakres trzy elementy zaczynając od pozycji 4 i Praca Wstecz (to znaczy elementy 4, 3 i 2).</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Ponieważ nie ma nazw dinozaurów w tym zakresie kończących się ciągiem „saurus”, zwraca wartość –1.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> i <ph id="ph2">&lt;paramref name="count" /&gt;</ph> nie zostanie określony prawidłowy części <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> on whose elements the action is to be performed.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> dla elementów, których ma być wykonywane działania.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Action`1" /&gt;</ph> to perform on each element of <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Action`1" /&gt;</ph> Do wykonania na każdym elemencie <bpt id="p1">&lt;c&gt;</bpt>tablicy<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>Performs the specified action on each element of the specified array.</source>
          <target state="translated">Wykonuje określoną akcję na każdym elemencie określonej tablicy.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> is a delegate to a method that performs an action on the object passed to it.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Action%601&gt;</ph> Delegowany do metody, która wykonuje akcję na obiekcie przekazywanych do niej.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Action%601&gt;</ph>.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> indywidualnie są przekazywane do <ph id="ph2">&lt;xref:System.Action%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The following example shows how to use <ph id="ph1">&lt;xref:System.Array.ForEach%2A&gt;</ph> to display the squares of each element in an integer array.</source>
          <target state="translated">Poniższy przykład przedstawia użycie <ph id="ph1">&lt;xref:System.Array.ForEach%2A&gt;</ph> do wyświetlenia kwadratów każdego elementu w tablicy liczby całkowitej.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source><ph id="ph1">&lt;paramref name="action" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Array.GetEnumerator">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Zwraca <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> dla <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Array.GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> Dla <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>[Visual Basic, C#]</source>
          <target state="translated">[Visual Basic, C#]</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in C++, <ph id="ph3">`For Each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated"><ph id="ph1">`foreach`</ph> Instrukcji języka C# (<ph id="ph2">`for each`</ph> w języku C++ <ph id="ph3">`For Each`</ph> w języku Visual Basic) ukrywa złożoność wyliczenia.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">W związku z tym przy użyciu <ph id="ph1">`foreach`</ph> jest zalecane, zamiast bezpośrednie manipulowanie modułu wyliczającego.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> również wprowadzono moduł wyliczający wróć do tej pozycji.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>At this position, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">W tym miejscu <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> jest niezdefiniowana.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">W związku z tym należy wywołać <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> można poprawić modułu wyliczającego pierwszy element do kolekcji przed odczytywania wartości <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> zwraca ten sam obiekt do momentu <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> lub <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> jest wywoływana.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> Ustawia <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> do następnego elementu.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> przekazuje końcem kolekcji, moduł wyliczający jest umieszczony za ostatnim elementem w kolekcji i <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> zwraca <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Gdy moduł wyliczający jest w tym miejscu kolejnych wywołań <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> zwracają również <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Jeśli przez ostatnie wywołanie <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> zwrócił <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> jest niezdefiniowana.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">Aby ustawić <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> aby pierwszym elementem kolekcji ponownie, należy wywołać <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> następuje <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie czy usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniany, a jego zachowanie staje się niezdefiniowane.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">Moduł wyliczający nie ma wyłączny dostęp do kolekcji; w związku z tym wyliczania kolekcji leżą nie jest bezpieczne procedury wątku.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>The following code example shows how to use <ph id="ph1">&lt;xref:System.Array.GetEnumerator%2A&gt;</ph> to list the elements of an array.</source>
          <target state="translated">Poniższy przykładowy kod przedstawia sposób użycia <ph id="ph1">&lt;xref:System.Array.GetEnumerator%2A&gt;</ph> do listy elementów tablicy.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source>A zero-based dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> whose length needs to be determined.</source>
          <target state="translated">Liczony od zera wymiaru <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> którego długość musi można określić.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source>Gets a 32-bit integer that represents the number of elements in the specified dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Pobiera 32-bitową liczbę całkowitą reprezentującą liczbę elementów w określonym wymiarze <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source>A 32-bit integer that represents the number of elements in the specified dimension.</source>
          <target state="translated">32-bitową liczbę całkowitą reprezentującą liczbę elementów w określonym wymiarze.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLength(System.Int32)">
          <source>An example of <ph id="ph1">&lt;xref:System.Array.GetLength%2A&gt;</ph> is <ph id="ph2">`GetLength(0)`</ph>, which returns the number of elements in the first dimension of the <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Przykład <ph id="ph1">&lt;xref:System.Array.GetLength%2A&gt;</ph> jest <ph id="ph2">`GetLength(0)`</ph>, która zwraca liczbę elementów w pierwszym wymiarze <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLength(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLength(System.Int32)">
          <source>The following example shows how to use <ph id="ph1">&lt;xref:System.Array.GetLength%2A&gt;</ph> to display the dimensions of two arrays with different ranks.</source>
          <target state="translated">Poniższy przykład przedstawia użycie <ph id="ph1">&lt;xref:System.Array.GetLength%2A&gt;</ph> do wyświetlenia wymiary dwie tablice o różnym stopniu.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> jest równa lub większa niż <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>A zero-based dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> whose length needs to be determined.</source>
          <target state="translated">Liczony od zera wymiaru <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> którego długość musi można określić.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>Gets a 64-bit integer that represents the number of elements in the specified dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Pobiera 64-bitową liczbę całkowitą reprezentującą liczbę elementów w określonym wymiarze <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>A 64-bit integer that represents the number of elements in the specified dimension.</source>
          <target state="translated">64-bitową liczbę całkowitą reprezentującą liczbę elementów w określonym wymiarze.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>An example of <ph id="ph1">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> is <ph id="ph2">`GetLongLength(0)`</ph>, which returns the number of elements in the first dimension of the <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Przykład <ph id="ph1">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> jest <ph id="ph2">`GetLongLength(0)`</ph>, która zwraca liczbę elementów w pierwszym wymiarze <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> jest równa lub większa niż <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>A zero-based dimension of the array whose starting index needs to be determined.</source>
          <target state="translated">Liczony od zera wymiar tablicy, którego indeks początkowy trzeba określić.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>Gets the index of the first element of the specified dimension in the array.</source>
          <target state="translated">Pobiera indeks pierwszego elementu określonego wymiaru tablicy.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>The index of the first element of the specified dimension in the array.</source>
          <target state="translated">Indeks pierwszego elementu obiektu określonego wymiaru tablicy.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source><ph id="ph1">`GetLowerBound(0)`</ph> returns the starting index of the first dimension of the array, and <ph id="ph2">`GetLowerBound(Rank - 1)`</ph> returns the starting index of the last dimension of the array.</source>
          <target state="translated"><ph id="ph1">`GetLowerBound(0)`</ph> Zwraca indeks początkowy pierwszego wymiaru tablicy, i <ph id="ph2">`GetLowerBound(Rank - 1)`</ph> zwraca indeks początkowy ostatniego wymiaru tablicy.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> method always returns a value that indicates the index of the lower bound of the array, even if the array is empty.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> Metoda zawsze zwraca wartość wskazującą, indeks dolna granica tablicy, nawet jeśli tablica jest pusta.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>Note that, although most arrays in the .NET Framework are zero-based (that is, the <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> method returns zero for each dimension of an array), the .NET Framework does support arrays that are not zero-based.</source>
          <target state="translated">Należy zauważyć, że chociaż większość tablic w programie .NET Framework jest liczony od zera (to znaczy <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> metoda zwraca zero dla każdego wymiaru tablicy), programu .NET Framework obsługuje tablic, które nie są liczony od zera.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>Such arrays can be created with the <ph id="ph1">&lt;xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29&gt;</ph> method, and can also be returned from unmanaged code.</source>
          <target state="translated">Takie tablice można tworzyć za pomocą <ph id="ph1">&lt;xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29&gt;</ph> metody, a także mogą być zwracane z kodem niezarządzanym.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods to display the bounds of a one-dimensional and two-dimensional array and to display the values of their array elements.</source>
          <target state="translated">W poniższym przykładzie użyto <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metody do wyświetlania granice tablicy jednowymiarowej tablicy i dwuwymiarowa i wyświetlanie ich elementów tablicy wartości.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> jest równa lub większa niż <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>A zero-based dimension of the array whose upper bound needs to be determined.</source>
          <target state="translated">Liczony od zera wymiar tablicy, w których górna granica trzeba określić.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>Gets the index of the last element of the specified dimension in the array.</source>
          <target state="translated">Pobiera indeks ostatnim elementem określonego wymiaru tablicy.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>The index of the last element of the specified dimension in the array, or -1 if the specified dimension is empty.</source>
          <target state="translated">Indeks ostatniego elementu określonego wymiaru tablicy lub -1, jeśli określony wymiar jest pusta.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source><ph id="ph1">`GetUpperBound(0)`</ph> returns the last index in the first dimension of the array, and <ph id="ph2">`GetUpperBound(Rank - 1)`</ph> returns the last index of the last dimension of the array.</source>
          <target state="translated"><ph id="ph1">`GetUpperBound(0)`</ph> Zwraca ostatni indeks w pierwszym wymiarze tablicy i <ph id="ph2">`GetUpperBound(Rank - 1)`</ph> zwraca ostatni indeks ostatniego wymiaru tablicy.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods to display the bounds of a one-dimensional and two-dimensional array and to display the values of their array elements.</source>
          <target state="translated">W poniższym przykładzie użyto <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metody do wyświetlania granice tablicy jednowymiarowej tablicy i dwuwymiarowa i wyświetlanie ich elementów tablicy wartości.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> jest równa lub większa niż <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Gets the value of the specified element in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Pobiera wartość określonego elementu w bieżącym <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>A 32-bit integer that represents the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">32-bitową liczbę całkowitą, która reprezentuje pozycję <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> elementu do pobrania.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>Gets the value at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Pobiera wartość w określonej pozycji w jednowymiarowej tablicy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>The index is specified as a 32-bit integer.</source>
          <target state="translated">Indeks jest określony jako 32-bitową liczbę całkowitą.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>The value at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Wartość w określonej pozycji w jednowymiarowej tablicy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metod można określić, czy wartość <ph id="ph3">`index`</ph> jest poza zakresem.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">Bieżące <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> nie ma dokładnie jednego wymiaru.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla bieżącego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Jednowymiarowa tablica 32-bitowych liczb całkowitych reprezentujących indeksów określający pozycję <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> elementu do pobrania.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>Gets the value at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Pobiera wartość w określonej pozycji w wielowymiarowe <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The indexes are specified as an array of 32-bit integers.</source>
          <target state="translated">Indeksy są określone jako tablicę 32-bitowych liczb całkowitych.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The value at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Wartość w określonej pozycji w wielowymiarowe <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Liczba elementów w <ph id="ph1">`indices`</ph> musi być równa liczbie wymiarów w <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Wszystkie elementy w <ph id="ph1">`indices`</ph> tablicy wspólnie określić położenie żądanego elementu w wielowymiarowe <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metod można ustalić, czy dowolny z indeksów jest poza zakresem.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The number of dimensions in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is not equal to the number of elements in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</source>
          <target state="translated">Liczba wymiarów w bieżącym <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> nie jest równa liczbie elementów w <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>Any element in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Dowolny element w <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>A 64-bit integer that represents the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">64-bitową liczbę całkowitą, która reprezentuje pozycję <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> elementu do pobrania.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>Gets the value at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Pobiera wartość w określonej pozycji w jednowymiarowej tablicy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>The index is specified as a 64-bit integer.</source>
          <target state="translated">Indeks jest określony jako 64-bitową liczbę całkowitą.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>The value at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Wartość w określonej pozycji w jednowymiarowej tablicy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metod można określić, czy wartość <ph id="ph3">`index`</ph> jest poza zakresem.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">Bieżące <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> nie ma dokładnie jednego wymiaru.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla bieżącego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Jednowymiarowa tablica 64-bitowych liczb całkowitych reprezentujących indeksów określający pozycję <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> elementu do pobrania.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>Gets the value at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Pobiera wartość w określonej pozycji w wielowymiarowe <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The indexes are specified as an array of 64-bit integers.</source>
          <target state="translated">Indeksy są określone jako tablicę 64-bitowych liczb całkowitych.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The value at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Wartość w określonej pozycji w wielowymiarowe <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Liczba elementów w <ph id="ph1">`indices`</ph> musi być równa liczbie wymiarów w <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Wszystkie elementy w <ph id="ph1">`indices`</ph> tablicy wspólnie określić położenie żądanego elementu w wielowymiarowe <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metod można ustalić, czy dowolny z indeksów jest poza zakresem.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The number of dimensions in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is not equal to the number of elements in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</source>
          <target state="translated">Liczba wymiarów w bieżącym <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> nie jest równa liczbie elementów w <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>Any element in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Dowolny element w <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">32-bitową liczbę całkowitą, który reprezentuje indeks pierwszego wymiaru <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> elementu do pobrania.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">32-bitową liczbę całkowitą, reprezentującą sekundę wymiaru indeks <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> elementu do pobrania.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>Gets the value at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Pobiera wartość w określonej pozycji w dwuwymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The indexes are specified as 32-bit integers.</source>
          <target state="translated">Indeksy są określane jako 32-bitowe liczby całkowite.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The value at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Wartość w określonej pozycji w dwuwymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metod można ustalić, czy dowolny z indeksów jest poza zakresem.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly two dimensions.</source>
          <target state="translated">Bieżące <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> nie ma dokładnie dwóch wymiarów.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>Either <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Albo <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> lub <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">64-bitową liczbę całkowitą, który reprezentuje indeks pierwszego wymiaru <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> elementu do pobrania.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">64-bitową liczbę całkowitą reprezentującą sekundę wymiaru indeks <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> elementu do pobrania.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>Gets the value at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Pobiera wartość w określonej pozycji w dwuwymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The indexes are specified as 64-bit integers.</source>
          <target state="translated">Indeksy są określone jako 64-bitowych liczb całkowitych.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The value at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Wartość w określonej pozycji w dwuwymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metod można ustalić, czy dowolny z indeksów jest poza zakresem.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly two dimensions.</source>
          <target state="translated">Bieżące <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> nie ma dokładnie dwóch wymiarów.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>Either <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Albo <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> lub <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">32-bitową liczbę całkowitą, który reprezentuje indeks pierwszego wymiaru <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> elementu do pobrania.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">32-bitową liczbę całkowitą, reprezentującą sekundę wymiaru indeks <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> elementu do pobrania.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">32-bitową liczbę całkowitą, reprezentujący indeks trzeci wymiar <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> elementu do pobrania.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>Gets the value at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Pobiera wartość w określonej pozycji w trójwymiarowy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The indexes are specified as 32-bit integers.</source>
          <target state="translated">Indeksy są określane jako 32-bitowe liczby całkowite.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The value at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Wartość w określonej pozycji w trójwymiarowy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metod można ustalić, czy dowolny z indeksów jest poza zakresem.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly three dimensions.</source>
          <target state="translated">Bieżące <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> nie ma dokładnie trzy wymiarów.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> or <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> lub <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> lub <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">64-bitową liczbę całkowitą, który reprezentuje indeks pierwszego wymiaru <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> elementu do pobrania.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">64-bitową liczbę całkowitą reprezentującą sekundę wymiaru indeks <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> elementu do pobrania.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">64-bitową liczbę całkowitą, reprezentujący indeks trzeci wymiar <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> elementu do pobrania.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>Gets the value at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Pobiera wartość w określonej pozycji w trójwymiarowy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The indexes are specified as 64-bit integers.</source>
          <target state="translated">Indeksy są określone jako 64-bitowych liczb całkowitych.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The value at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Wartość w określonej pozycji w trójwymiarowy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metod można ustalić, czy dowolny z indeksów jest poza zakresem.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly three dimensions.</source>
          <target state="translated">Bieżące <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> nie ma dokładnie trzy wymiarów.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> or <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> lub <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> lub <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array or in a range of elements in the array.</source>
          <target state="translated">Wyszukuje określony obiekt i zwraca indeks jego pierwszego wystąpienia w tablicy jednowymiarowej tablicy lub zakresu elementów w tablicy.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>The one-dimensional array to search.</source>
          <target state="translated">Jednowymiarowa tablica, która do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Obiekt do zlokalizowania w <bpt id="p1">&lt;c&gt;</bpt>tablicy<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</source>
          <target state="translated">Wyszukuje określony obiekt i zwraca indeks jego pierwszego wystąpienia w tablicą jednowymiarową.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>The index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if found; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Indeks pierwszego wystąpienia <ph id="ph1">&lt;paramref name="value" /&gt;</ph> w <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, jeśli je znaleziono; w przeciwnym razie wartość dolna granica tablicy pomniejszonej o 1.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>This method searches all the elements of a one-dimensional arrayfor <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Ta metoda przeszukuje wszystkie elementy jednowymiarowa arrayfor <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling each element's <ph id="ph3">`Equals`</ph> method until it finds a match.</source>
          <target state="translated">Aby określić, czy <ph id="ph1">`value`</ph> istnieje w <ph id="ph2">`array`</ph>, metoda przeprowadza porównanie równości, wywołując każdy element <ph id="ph3">`Equals`</ph> metody do momentu znalezienia dopasowania.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>This means that if the element overrides the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method, that override is called.</source>
          <target state="translated">Oznacza to, że jeśli zastępuje element <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> wywoływana jest metoda, tego zastąpienia.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>Because most arrays have a lower bound of zero, this method generally returns –1 if<ph id="ph1">`value`</ph> isn’t found.</source>
          <target state="translated">Ponieważ większość tablice dolna granica zero, tej metody zwykle zwraca -1, jeśli<ph id="ph1">`value`</ph> nie zostanie odnaleziony.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>(0x80000000) and <ph id="ph2">`value`</ph> isn’t found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</source>
          <target state="translated">W rzadkich przypadkach, że dolna granica tablicy wynosi <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>(0x80000000) i <ph id="ph2">`value`</ph> nie zostanie odnaleziony, ta metoda zwraca <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>The example calls the following three overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method to find the index of a string in a string array:</source>
          <target state="translated">Przykład wywołuje następujących trzech przeciążeń <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> metody do znalezienia w tablicy ciągów indeksu ciągu:</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, aby określić pierwsze wystąpienie ciągu "" w tablicy ciągów.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, aby określić pierwsze wystąpienie ciągu "" w czwartym do ostatnich elementów tablicy ciągów.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, aby określić pierwsze wystąpienie ciągu "" w ciągu tablicy z elementu, który następuje ostatniego pomyślnego dopasowania do końca tablicy.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The one-dimensional array to search.</source>
          <target state="translated">Jednowymiarowa tablica, która do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Obiekt do zlokalizowania w <bpt id="p1">&lt;c&gt;</bpt>tablicy<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The starting index of the search.</source>
          <target state="translated">Indeks początkowy wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>0 (zero) is valid in an empty array.</source>
          <target state="translated">0 (zero) jest prawidłową wartością w pustej tablicy.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence.</source>
          <target state="translated">Wyszukuje określony obiekt w zakresie elementów tablicy jednowymiarowej i zwraca indeks jego pierwszego wystąpienia.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The range extends from a specified index to the end of the array.</source>
          <target state="translated">Z zakresu od określonego indeksu do końca tablicy.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, if it’s found, within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that extends from <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> to the last element; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Indeks pierwszego wystąpienia <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, jeśli został znaleziony, w ramach zakresu elementów <ph id="ph2">&lt;paramref name="array" /&gt;</ph> rozciąga się od <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> do ostatniego elementu; w przeciwnym razie wartość dolnej granicy tablicy pomniejszonej o 1.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>This method searches a one-dimensional array from the element at index <ph id="ph1">`startIndex`</ph> to the last element.</source>
          <target state="translated">Ta metoda wyszukuje tablicą jednowymiarową z elementu o indeksie <ph id="ph1">`startIndex`</ph> do ostatniego elementu.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`Equals`</ph> method of every element until it finds a match.</source>
          <target state="translated">Aby określić, czy <ph id="ph1">`value`</ph> istnieje w <ph id="ph2">`array`</ph>, metoda przeprowadza porównanie równości, wywołując <ph id="ph3">`Equals`</ph> metody każdego elementu, aż do znalezienia dopasowania.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>This means that if the element overrides the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method, that override is called.</source>
          <target state="translated">Oznacza to, że jeśli zastępuje element <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> wywoływana jest metoda, tego zastąpienia.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>Because most arrays have a lower bound of zero, this method generally returns –1 if <ph id="ph1">`value`</ph> isn’t found.</source>
          <target state="translated">Ponieważ większość tablice dolna granica zero, tej metody zwykle zwraca -1, jeśli <ph id="ph1">`value`</ph> nie zostanie odnaleziony.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>(0x80000000) and <ph id="ph2">`value`</ph> isn’t found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</source>
          <target state="translated">W rzadkich przypadkach, że dolna granica tablicy wynosi <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>(0x80000000) i <ph id="ph2">`value`</ph> nie zostanie odnaleziony, ta metoda zwraca <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>,the method returns -1.</source>
          <target state="translated">Jeśli <ph id="ph1">`startIndex`</ph> jest równe <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, metoda zwraca wartość -1.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is greater than <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">`startIndex`</ph> jest większa niż <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, metoda wygeneruje <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest liczba elementów od <ph id="ph3">`startIndex`</ph> na końcu <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The example calls the following three overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method to find the index of a string in a string array:</source>
          <target state="translated">Przykład wywołuje następujących trzech przeciążeń <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> metody do znalezienia w tablicy ciągów indeksu ciągu:</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, aby określić pierwsze wystąpienie ciągu "" w tablicy ciągów.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, aby określić pierwsze wystąpienie ciągu "" w czwartym do ostatnich elementów tablicy ciągów.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, aby określić pierwsze wystąpienie ciągu "" w ciągu tablicy z elementu, który następuje ostatniego pomyślnego dopasowania do końca tablicy.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The one-dimensional array to search.</source>
          <target state="translated">Jednowymiarowa tablica, która do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Obiekt do zlokalizowania w <bpt id="p1">&lt;c&gt;</bpt>tablicy<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The starting index of the search.</source>
          <target state="translated">Indeks początkowy wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>0 (zero) is valid in an empty array.</source>
          <target state="translated">0 (zero) jest prawidłową wartością w pustej tablicy.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The number of elements to search.</source>
          <target state="translated">Liczba elementów do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of ifs first occurrence.</source>
          <target state="translated">Wyszukuje określony obiekt w zakresie elementów tablicy jednowymiarowej i zwraca indeks ifs pierwszego wystąpienia.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The range extends from a specified index for a specified number of elements.</source>
          <target state="translated">Z zakresu od określonego indeksu dla określonej liczby elementów.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, if it’s found in the <ph id="ph2">&lt;paramref name="array" /&gt;</ph> from index <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> to <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph5"> + </ph><ph id="ph6">&lt;paramref name="count" /&gt;</ph> - 1; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Indeks pierwszego wystąpienia <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, jeśli został znaleziony w <ph id="ph2">&lt;paramref name="array" /&gt;</ph> z indeksu <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> do <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph> <ph id="ph5"> + </ph> <ph id="ph6">&lt;paramref name="count" /&gt;</ph> - 1, a w przeciwnym razie dolna granica tablicy pomniejszonej o 1.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>This method searches the elements of a one-dimensional arrayfrom <ph id="ph1">`startIndex`</ph> to <ph id="ph2">`startIndex`</ph> plus <ph id="ph3">`count`</ph> minus 1, if <ph id="ph4">`count`</ph> is greater than 0.</source>
          <target state="translated">Ta metoda przeszukuje elementy jednowymiarowa arrayfrom <ph id="ph1">`startIndex`</ph> do <ph id="ph2">`startIndex`</ph> plus <ph id="ph3">`count`</ph> pomniejszonej o 1, jeśli <ph id="ph4">`count`</ph> jest większa niż 0.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`Equals`</ph> method of every element until it finds a match.</source>
          <target state="translated">Aby określić, czy <ph id="ph1">`value`</ph> istnieje w <ph id="ph2">`array`</ph>, metoda przeprowadza porównanie równości, wywołując <ph id="ph3">`Equals`</ph> metody każdego elementu, aż do znalezienia dopasowania.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>This means that if the element overrides the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method, that override is called.</source>
          <target state="translated">Oznacza to, że jeśli zastępuje element <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> wywoływana jest metoda, tego zastąpienia.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Becausemost arrays have a lower bound of zero, this method generally returns –1 when <ph id="ph1">`value`</ph> isn’t found.</source>
          <target state="translated">Tablice Becausemost ma dolna granica zero, ta metoda zwraca wartość-1 w przypadku <ph id="ph1">`value`</ph> nie zostanie odnaleziony.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> (0x80000000) and <ph id="ph2">`value`</ph> isn’t found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</source>
          <target state="translated">W rzadkich przypadkach, że dolna granica tablicy wynosi <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> (0x80000000) i <ph id="ph2">`value`</ph> nie zostanie odnaleziony, ta metoda zwraca <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startindex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method returns -1.</source>
          <target state="translated">Jeśli <ph id="ph1">`startindex`</ph> jest równe <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, metoda zwraca wartość -1.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is greater than <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">`startIndex`</ph> jest większa niż <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, metoda wygeneruje <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The example calls the following three overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method to find the index of a string in a string array:</source>
          <target state="translated">Przykład wywołuje następujących trzech przeciążeń <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> metody do znalezienia w tablicy ciągów indeksu ciągu:</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, aby określić pierwsze wystąpienie ciągu "" w tablicy ciągów.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, aby określić pierwsze wystąpienie ciągu "" w czwartym do ostatnich elementów tablicy ciągów.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, aby określić pierwsze wystąpienie ciągu "" w ciągu tablicy z elementu, który następuje ostatniego pomyślnego dopasowania do końca tablicy.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>To determine the value of the <ph id="ph1">`count`</ph> argument, it subtracts the upper bound of the array from the starting index and adds one.</source>
          <target state="translated">Aby określić wartość <ph id="ph1">`count`</ph> argumentu, odejmuje górna granica tablicy z indeks początkowy i dodaje jeden.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> i <ph id="ph2">&lt;paramref name="count" /&gt;</ph> nie zostanie określony prawidłowy części <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The one-dimensional, zero-based array to search.</source>
          <target state="translated">Tablica jednowymiarowa, liczony od zera do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Obiekt do zlokalizowania w <bpt id="p1">&lt;c&gt;</bpt>tablicy<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</source>
          <target state="translated">Wyszukuje określony obiekt i zwraca indeks jego pierwszego wystąpienia w tablicą jednowymiarową.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the entire <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Liczony od zera indeks pierwszego wystąpienia <ph id="ph1">&lt;paramref name="value" /&gt;</ph> w całej <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, jeśli je znaleziono; w przeciwnym razie wartość -1.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>This method searches all the elements of a one-dimensional array for <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Ta metoda przeszukuje wszystkie elementy tablicy jednowymiarowej dla <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`T.Equals`</ph> method on every element.</source>
          <target state="translated">Aby określić, czy <ph id="ph1">`value`</ph> istnieje w <ph id="ph2">`array`</ph>, metoda przeprowadza porównanie równości, wywołując <ph id="ph3">`T.Equals`</ph> metody dla każdego elementu.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>This means that if <ph id="ph1">`T`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method, that override is called.</source>
          <target state="translated">Oznacza to, że jeśli <ph id="ph1">`T`</ph> zastępuje <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> wywoływana jest metoda, tego zastąpienia.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The following example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">W poniższym przykładzie pokazano wszystkie trzy ogólnego przeciążeń <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the array from the beginning, and finds the first occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> Przeciążenie metody wyszukuje tablicy od początku i znajduje pierwsze wystąpienie ciągu.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> Przeciążenie metody używane do przeszukiwania tablicy, począwszy od lokalizacji indeksu 3 i dalej koniec tablicy i wyszukuje drugie wystąpienie ciągu.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Na koniec <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> przeciążenie metody używane do przeszukiwania zakres dwóch wpisów, rozpoczynając od lokalizacji indeksu dwa; zwraca -1, ponieważ nie bez wystąpień ciągu wyszukiwania w tym zakresie.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The one-dimensional, zero-based array to search.</source>
          <target state="translated">Tablica jednowymiarowa, liczony od zera do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Obiekt do zlokalizowania w <bpt id="p1">&lt;c&gt;</bpt>tablicy<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>0 (zero) is valid in an empty array.</source>
          <target state="translated">0 (zero) jest prawidłową wartością w pustej tablicy.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>Searches for the specified object in a range of elements of a one dimensional array, and returns the index of its first occurrence.</source>
          <target state="translated">Wyszukuje określony obiekt w zakresie elementów Jednowymiarowa tablica i zwraca indeks jego pierwszego wystąpienia.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The range extends from a specified index to the end of the array.</source>
          <target state="translated">Z zakresu od określonego indeksu do końca tablicy.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that extends from <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> to the last element, if found; otherwise, –1.</source>
          <target state="translated">Liczony od zera indeks pierwszego wystąpienia <ph id="ph1">&lt;paramref name="value" /&gt;</ph> w zakresie elementów w <ph id="ph2">&lt;paramref name="array" /&gt;</ph> rozciąga się od <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> do ostatniego elementu, jeśli je znaleziono; w przeciwnym razie wartość -1.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>This method searches a one-dimensional array from the element at <ph id="ph1">`startIndex`</ph> to the end of the array.</source>
          <target state="translated">Ta metoda wyszukuje tablicą jednowymiarową z elementu <ph id="ph1">`startIndex`</ph> do końca tablicy.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`T.Equals`</ph> method on every element.</source>
          <target state="translated">Aby określić, czy <ph id="ph1">`value`</ph> istnieje w <ph id="ph2">`array`</ph>, metoda przeprowadza porównanie równości, wywołując <ph id="ph3">`T.Equals`</ph> metody dla każdego elementu.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>This means that if <ph id="ph1">`T`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method, that override is called.</source>
          <target state="translated">Oznacza to, że jeśli <ph id="ph1">`T`</ph> zastępuje <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> wywoływana jest metoda, tego zastąpienia.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph>,the method returns -1.If <ph id="ph3">`startIndex`</ph> is greater than <ph id="ph4">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method throws an <ph id="ph5">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">`startIndex`</ph> jest równe <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph>, metoda zwraca - 1.If <ph id="ph3">`startIndex`</ph> jest większa niż <ph id="ph4">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, metoda wygeneruje <ph id="ph5">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest liczba elementów od <ph id="ph3">`startIndex`</ph> na końcu <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The following example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">W poniższym przykładzie pokazano wszystkie trzy ogólnego przeciążeń <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the array from the beginning, and finds the first occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> Przeciążenie metody wyszukuje tablicy od początku i znajduje pierwsze wystąpienie ciągu.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> Przeciążenie metody używane do przeszukiwania tablicy, począwszy od lokalizacji indeksu 3 i dalej koniec tablicy i wyszukuje drugie wystąpienie ciągu.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Na koniec <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> przeciążenie metody używane do przeszukiwania zakres dwóch wpisów, rozpoczynając od lokalizacji indeksu dwa; zwraca -1, ponieważ nie bez wystąpień ciągu wyszukiwania w tym zakresie.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based array to search.</source>
          <target state="translated">Tablica jednowymiarowa, liczony od zera do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Obiekt do zlokalizowania w <bpt id="p1">&lt;c&gt;</bpt>tablicy<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>0 (zero) is valid in an empty array.</source>
          <target state="translated">0 (zero) jest prawidłową wartością w pustej tablicy.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Liczba elementów w sekcji do wyszukania.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence.</source>
          <target state="translated">Wyszukuje określony obiekt w zakresie elementów tablicy jednowymiarowej i zwraca indeks jego pierwszego wystąpienia.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The range extends from a specified index for a specified number of elements.</source>
          <target state="translated">Z zakresu od określonego indeksu dla określonej liczby elementów.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that starts at <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and contains the number of elements specified in <ph id="ph4">&lt;paramref name="count" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Liczony od zera indeks pierwszego wystąpienia <ph id="ph1">&lt;paramref name="value" /&gt;</ph> w zakresie elementów w <ph id="ph2">&lt;paramref name="array" /&gt;</ph> który rozpoczyna się od <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> i zawiera liczbę elementów określonych w <ph id="ph4">&lt;paramref name="count" /&gt;</ph>, jeśli je znaleziono; w przeciwnym razie wartość -1.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>This method searchesthe elements of a one-dimensional array from <ph id="ph1">`startIndex`</ph> to <ph id="ph2">`startIndex`</ph> plus <ph id="ph3">`count`</ph> minus 1, if <ph id="ph4">`count`</ph> is greater than 0.</source>
          <target state="translated">Tej metody elementy searchesthe tablicy jednowymiarowej z <ph id="ph1">`startIndex`</ph> do <ph id="ph2">`startIndex`</ph> plus <ph id="ph3">`count`</ph> pomniejszonej o 1, jeśli <ph id="ph4">`count`</ph> jest większa niż 0.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`T.Equals`</ph> method on every element.</source>
          <target state="translated">Aby określić, czy <ph id="ph1">`value`</ph> istnieje w <ph id="ph2">`array`</ph>, metoda przeprowadza porównanie równości, wywołując <ph id="ph3">`T.Equals`</ph> metody dla każdego elementu.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>This means that if <ph id="ph1">`T`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method, that override is called.</source>
          <target state="translated">Oznacza to, że jeśli <ph id="ph1">`T`</ph> zastępuje <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> wywoływana jest metoda, tego zastąpienia.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method returns -1.</source>
          <target state="translated">Jeśli <ph id="ph1">`startIndex`</ph> jest równe <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, metoda zwraca wartość -1.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is greater than <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">`startIndex`</ph> jest większa niż <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, metoda wygeneruje <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The following example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">W poniższym przykładzie pokazano wszystkie trzy ogólnego przeciążeń <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the array from the beginning, and finds the first occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> Przeciążenie metody wyszukuje tablicy od początku i znajduje pierwsze wystąpienie ciągu.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> Przeciążenie metody używane do przeszukiwania tablicy, począwszy od lokalizacji indeksu 3 i dalej koniec tablicy i wyszukuje drugie wystąpienie ciągu.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Na koniec <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> przeciążenie metody używane do przeszukiwania zakres dwóch wpisów, rozpoczynając od lokalizacji indeksu dwa; zwraca -1, ponieważ nie bez wystąpień ciągu wyszukiwania w tym zakresie.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> i <ph id="ph2">&lt;paramref name="count" /&gt;</ph> nie zostanie określony prawidłowy części <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Array.Initialize">
          <source>Initializes every element of the value-type <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> by calling the default constructor of the value type.</source>
          <target state="translated">Inicjuje każdy element na wartość typu <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> przez wywołanie konstruktora domyślnego typu wartości.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>This method is designed to help compilers support value-type arrays; most users do not need this method.</source>
          <target state="translated">Ta metoda ma na celu kompilatory obsługuje tablic typu wartość; Większość użytkowników nie muszą tej metody.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>It must not be used on reference-type arrays.</source>
          <target state="translated">Nie należy go w tablicach Typ odwołania.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> is not a value-type <ph id="ph2">&lt;xref:System.Array&gt;</ph> or if the value type does not have a default constructor, the <ph id="ph3">&lt;xref:System.Array&gt;</ph> is not modified.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array&gt;</ph> nie jest typem wartości <ph id="ph2">&lt;xref:System.Array&gt;</ph> lub jeśli typ wartości nie ma konstruktora domyślnego <ph id="ph3">&lt;xref:System.Array&gt;</ph> nie jest modyfikowany.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>The value-type <ph id="ph1">&lt;xref:System.Array&gt;</ph> can have any lower bound and any number of dimensions.</source>
          <target state="translated">Typ wartości <ph id="ph1">&lt;xref:System.Array&gt;</ph> może mieć żadnych dolna granica i dowolną liczbę wymiarów.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>You can use this method only on value types that have constructors; however, value types that are native to C# do not have constructors.</source>
          <target state="translated">Tej metody można użyć tylko dla typów wartości, które mają konstruktorów; typy wartości, które są natywne dla C# nie mają jednak konstruktorów.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" uid="P:System.Array.IsFixedSize">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Pobiera wartość wskazującą czy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ma stały rozmiar.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsFixedSize">
          <source>This property is always <ph id="ph1">&lt;see langword="true" /&gt;</ph> for all arrays.</source>
          <target state="translated">Ta właściwość jest zawsze <ph id="ph1">&lt;see langword="true" /&gt;</ph> dla wszystkich tablic.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsFixedSize">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> property because it is required by the <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> implementuje <ph id="ph2">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> właściwości, ponieważ jest to wymagane przez <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsFixedSize">
          <source>An array with a fixed size does not allow the addition or removal of elements after the array is created, but it allows the modification of existing elements.</source>
          <target state="translated">Tablicy o ustalonym rozmiarze nie zezwala na dodawanie i usuwanie elementów po utworzeniu tablicy, ale umożliwia modyfikowanie istniejących elementów.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsFixedSize">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Pobieranie wartości tej właściwości jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" uid="P:System.Array.IsReadOnly">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is read-only.</source>
          <target state="translated">Pobiera wartość wskazującą czy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> jest tylko do odczytu.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>This property is always <ph id="ph1">&lt;see langword="false" /&gt;</ph> for all arrays.</source>
          <target state="translated">Ta właściwość jest zawsze <ph id="ph1">&lt;see langword="false" /&gt;</ph> dla wszystkich tablic.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Array.IsReadOnly%2A&gt;</ph> property because it is required by the <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> implementuje <ph id="ph2">&lt;xref:System.Array.IsReadOnly%2A&gt;</ph> właściwości, ponieważ jest to wymagane przez <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>An array that is read-only does not allow the addition, removal, or modification of elements after the array is created.</source>
          <target state="translated">Tablica, która jest tylko do odczytu nie zezwala na dodanie, usunięcie lub modyfikowania elementów po utworzeniu tablicy.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>If you require a read-only collection, use a <ph id="ph1">&lt;xref:System.Collections&gt;</ph> class that implements the <ph id="ph2">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated">Jeśli potrzebujesz kolekcji tylko do odczytu, użyj <ph id="ph1">&lt;xref:System.Collections&gt;</ph> klasa implementująca <ph id="ph2">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>If you cast or convert an array to an <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> interface object, the <ph id="ph2">&lt;xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType&gt;</ph> property returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Jeśli rzutowania lub konwersji tablicy do <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> obiektu interfejsu <ph id="ph2">&lt;xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType&gt;</ph> zwraca właściwość <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>However, if you cast or convert an array to a <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> interface, the <ph id="ph2">`IsReadOnly`</ph> property returns <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Jednak jeśli rzutowania lub konwersji tablicy do <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> interfejsu <ph id="ph2">`IsReadOnly`</ph> zwraca właściwość <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Pobieranie wartości tej właściwości jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="P:System.Array.IsSynchronized">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is synchronized (thread safe).</source>
          <target state="translated">Pobiera wartość wskazującą czy uzyskują dostęp do <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> jest synchronizowane (wielowątkowość).</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>This property is always <ph id="ph1">&lt;see langword="false" /&gt;</ph> for all arrays.</source>
          <target state="translated">Ta właściwość jest zawsze <ph id="ph1">&lt;see langword="false" /&gt;</ph> dla wszystkich tablic.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Array.IsSynchronized%2A&gt;</ph> property because it is required by the <ph id="ph3">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> implementuje <ph id="ph2">&lt;xref:System.Array.IsSynchronized%2A&gt;</ph> właściwości, ponieważ jest to wymagane przez <ph id="ph3">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>.NET Framework classes based on <ph id="ph1">&lt;xref:System.Array&gt;</ph> provide their own synchronized version of the collection using the <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Na podstawie klasy .NET framework <ph id="ph1">&lt;xref:System.Array&gt;</ph> Udostępnij własnych zsynchronizowaną wersję w kolekcji przy użyciu <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Classes that use arrays can also implement their own synchronization using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Klasy korzystające tablice można też wdrożyć za pomocą ich własnych synchronizacji <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>The synchronizing code must perform operations on the <ph id="ph1">`SyncRoot`</ph> of the collection, not directly on the collection.</source>
          <target state="translated">Synchronizowanie kodu musi wykonywać operacje <ph id="ph1">`SyncRoot`</ph> kolekcji, a nie bezpośrednio w kolekcji.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">Gwarantuje to prawidłowe funkcjonowanie kolekcji, które są uzyskiwane z innych obiektów.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.</source>
          <target state="translated">W szczególności przechowuje prawidłowego synchronizacji z innych wątków, które mogą być jednocześnie modyfikowania kolekcji.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Note that some implementations of <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> might return the <ph id="ph2">&lt;xref:System.Array&gt;</ph> itself.</source>
          <target state="translated">Należy pamiętać, że niektóre implementacje <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> może zwrócić <ph id="ph2">&lt;xref:System.Array&gt;</ph> samej siebie.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">Wyliczanie za pomocą kolekcji leżą nie jest procedurą bezpieczne wątku.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Pobieranie wartości tej właściwości jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>The following code example shows how to lock an array during the entire enumeration by using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak można zablokować tablicy podczas wyliczania całego przy użyciu <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Returns the index of the last occurrence of a value in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> or in a portion of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Zwraca indeks ostatniego wystąpienia wartości w jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> lub w części <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Obiekt do zlokalizowania w <bpt id="p1">&lt;c&gt;</bpt>tablicy<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>Searches for the specified object and returns the index of the last occurrence within the entire one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Wyszukuje określony obiekt i zwraca indeks ostatniego wystąpienia w obrębie całej jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the entire <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if found; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Indeks ostatniego wystąpienia <ph id="ph1">&lt;paramref name="value" /&gt;</ph> w obrębie całej <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, jeśli je znaleziono; w przeciwnym razie wartość dolna granica tablicy pomniejszonej o 1.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
          <target state="translated">Jednowymiarowa <ph id="ph1">&lt;xref:System.Array&gt;</ph> przeszukiwany jest wstecz od ostatniego elementu i kończącego się na pierwszym elementem.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Elementy są porównywane przy użyciu określonej wartości <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Jeśli typ elementu jest nonintrinsic typem (zdefiniowane przez użytkownika), <ph id="ph1">`Equals`</ph> implementacji tego typu jest używana.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>Since most arrays will have a lower bound of zero, this method would generally return –1 when <ph id="ph1">`value`</ph> is not found.</source>
          <target state="translated">Ponieważ większość tablice mają dolna granica zero, ta metoda zwróci zazwyczaj-1 w przypadku <ph id="ph1">`value`</ph> nie znaleziono.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">`value`</ph> is not found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, which is <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</source>
          <target state="translated">W rzadkich przypadkach, że dolna granica tablicy wynosi <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> i <ph id="ph2">`value`</ph> nie zostanie znaleziony, ta metoda zwraca <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, która jest <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>In the .NET Framework version 2.0, this method uses the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to determine whether the <ph id="ph4">&lt;xref:System.Object&gt;</ph> specified by the <ph id="ph5">`value`</ph> parameter exists.</source>
          <target state="translated">W programie .NET Framework w wersji 2.0, ta metoda używa <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metody <ph id="ph3">&lt;xref:System.Array&gt;</ph> ustalenie, czy <ph id="ph4">&lt;xref:System.Object&gt;</ph> określonego przez <ph id="ph5">`value`</ph> parametr istnieje.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`value`</ph><ph id="ph4">&lt;xref:System.Object&gt;</ph> itself.</source>
          <target state="translated">We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metody <ph id="ph3">`value`</ph> <ph id="ph4">&lt;xref:System.Object&gt;</ph> samej siebie.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph2">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metody <ph id="ph2">`item`</ph> parametrów dla obiektów w kolekcji.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element in an array.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak można określić indeksu ostatniego wystąpienia określony element w tablicy.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Obiekt do zlokalizowania w <bpt id="p1">&lt;c&gt;</bpt>tablicy<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The starting index of the backward search.</source>
          <target state="translated">Indeks początkowy wyszukiwania do tyłu.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that extends from the first element to the specified index.</source>
          <target state="translated">Wyszukuje określony obiekt i zwraca indeks ostatniego wystąpienia w zakresie elementów w jednowymiarowej tablicy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> który rozciąga się od pierwszego elementu zgodnie z określonym indeksem.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that extends from the first element to <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Indeks ostatniego wystąpienia <ph id="ph1">&lt;paramref name="value" /&gt;</ph> w zakresie elementów w <ph id="ph2">&lt;paramref name="array" /&gt;</ph> który rozciąga się od pierwszego elementu <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, jeśli je znaleziono; w przeciwnym razie wartość dolna granica tablicy pomniejszonej o 1.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
          <target state="translated">Jednowymiarowa <ph id="ph1">&lt;xref:System.Array&gt;</ph> jest przeszukane z poprzednimi wersjami zaczynając od <ph id="ph2">`startIndex`</ph> i kończącego się na pierwszym elementem.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Elementy są porównywane przy użyciu określonej wartości <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Jeśli typ elementu jest nonintrinsic typem (zdefiniowane przez użytkownika), <ph id="ph1">`Equals`</ph> implementacji tego typu jest używana.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>Since most arrays will have a lower bound of zero, this method would generally return –1 when <ph id="ph1">`value`</ph> is not found.</source>
          <target state="translated">Ponieważ większość tablice mają dolna granica zero, ta metoda zwróci zazwyczaj-1 w przypadku <ph id="ph1">`value`</ph> nie znaleziono.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">`value`</ph> is not found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, which is <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</source>
          <target state="translated">W rzadkich przypadkach, że dolna granica tablicy wynosi <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> i <ph id="ph2">`value`</ph> nie zostanie znaleziony, ta metoda zwraca <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, która jest <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from the beginning of <ph id="ph3">`array`</ph> to <ph id="ph4">`startIndex`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest liczba elementów od początku <ph id="ph3">`array`</ph> do <ph id="ph4">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>In the .NET Framework version 2.0, this method uses the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to determine whether the <ph id="ph4">&lt;xref:System.Object&gt;</ph> specified by the <ph id="ph5">`value`</ph> parameter exists.</source>
          <target state="translated">W programie .NET Framework w wersji 2.0, ta metoda używa <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metody <ph id="ph3">&lt;xref:System.Array&gt;</ph> ustalenie, czy <ph id="ph4">&lt;xref:System.Object&gt;</ph> określonego przez <ph id="ph5">`value`</ph> parametr istnieje.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`value`</ph><ph id="ph4">&lt;xref:System.Object&gt;</ph> itself.</source>
          <target state="translated">We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metody <ph id="ph3">`value`</ph> <ph id="ph4">&lt;xref:System.Object&gt;</ph> samej siebie.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element in an array.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak można określić indeksu ostatniego wystąpienia określony element w tablicy.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Obiekt do zlokalizowania w <bpt id="p1">&lt;c&gt;</bpt>tablicy<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The starting index of the backward search.</source>
          <target state="translated">Indeks początkowy wyszukiwania do tyłu.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Liczba elementów w sekcji do wyszukania.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
          <target state="translated">Wyszukuje określony obiekt i zwraca indeks ostatniego wystąpienia w zakresie elementów w jednowymiarowej tablicy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zawierający określoną liczbę elementów i kończy się w określonym indeksie.</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that contains the number of elements specified in <ph id="ph3">&lt;paramref name="count" /&gt;</ph> and ends at <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Indeks ostatniego wystąpienia <ph id="ph1">&lt;paramref name="value" /&gt;</ph> w zakresie elementów w <ph id="ph2">&lt;paramref name="array" /&gt;</ph> zawiera liczbę elementów określonych w <ph id="ph3">&lt;paramref name="count" /&gt;</ph> i kończy się na <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, jeśli je znaleziono; w przeciwnym razie wartość dolna granica tablicy pomniejszonej o 1.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">Jednowymiarowa <ph id="ph1">&lt;xref:System.Array&gt;</ph> jest przeszukane z poprzednimi wersjami zaczynając od <ph id="ph2">`startIndex`</ph> i kończący się na <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, jeśli <ph id="ph5">`count`</ph> jest większa niż 0.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Elementy są porównywane przy użyciu określonej wartości <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>If the element type is a nonintrinsic (user-defined) type, the<ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Jeśli typ elementu jest nonintrinsic typem (zdefiniowane przez użytkownika),<ph id="ph1">`Equals`</ph> implementacji tego typu jest używana.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Since most arrays will have a lower bound of zero, this method would generally return –1 when <ph id="ph1">`value`</ph> is not found.</source>
          <target state="translated">Ponieważ większość tablice mają dolna granica zero, ta metoda zwróci zazwyczaj-1 w przypadku <ph id="ph1">`value`</ph> nie znaleziono.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">`value`</ph> is not found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, which is <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</source>
          <target state="translated">W rzadkich przypadkach, że dolna granica tablicy wynosi <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> i <ph id="ph2">`value`</ph> nie zostanie znaleziony, ta metoda zwraca <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, która jest <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>In the .NET Framework version 2.0, this method uses the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to determine whether the <ph id="ph4">&lt;xref:System.Object&gt;</ph> specified by the <ph id="ph5">`value`</ph> parameter exists.</source>
          <target state="translated">W programie .NET Framework w wersji 2.0, ta metoda używa <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metody <ph id="ph3">&lt;xref:System.Array&gt;</ph> ustalenie, czy <ph id="ph4">&lt;xref:System.Object&gt;</ph> określonego przez <ph id="ph5">`value`</ph> parametr istnieje.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`value`</ph><ph id="ph4">&lt;xref:System.Object&gt;</ph> itself.</source>
          <target state="translated">We wcześniejszych wersjach programu .NET Framework, oznaczanie został utworzony przy użyciu <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> metody <ph id="ph3">`value`</ph> <ph id="ph4">&lt;xref:System.Object&gt;</ph> samej siebie.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element in an array.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak można określić indeksu ostatniego wystąpienia określony element w tablicy.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Note that the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> method is a backward search; therefore, <ph id="ph2">`count`</ph> must be less than or equal to (<ph id="ph3">`startIndex`</ph> minus the lower bound of the array plus 1).</source>
          <target state="translated">Należy pamiętać, że <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> metoda jest wyszukiwania do tyłu; w związku z tym <ph id="ph2">`count`</ph> musi być mniejsze niż lub równe (<ph id="ph3">`startIndex`</ph> minus dolna granica tablicy plus 1).</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> i <ph id="ph2">&lt;paramref name="count" /&gt;</ph> nie zostanie określony prawidłowy części <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Obiekt do zlokalizowania w <bpt id="p1">&lt;c&gt;</bpt>tablicy<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>Searches for the specified object and returns the index of the last occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Wyszukuje określony obiekt i zwraca indeks ostatniego wystąpienia w obrębie całej <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the entire <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Liczony od zera indeks ostatniego wystąpienia <ph id="ph1">&lt;paramref name="value" /&gt;</ph> w obrębie całej <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, jeśli je znaleziono; w przeciwnym razie wartość -1.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> Przeszukiwany jest wstecz od ostatniego elementu i kończącego się na pierwszym elementem.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Elementy są porównywane przy użyciu określonej wartości <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Jeśli typ elementu jest nonintrinsic typem (zdefiniowane przez użytkownika), <ph id="ph1">`Equals`</ph> implementacji tego typu jest używana.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The following code example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Poniższy przykład kodu pokazuje wszystkie trzy ogólnego przeciążeń <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the entire array from the end, and finds the second occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> Przeciążenie metody wyszukuje całą macierz od jej końca i wyszukuje drugie wystąpienie ciągu.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> Przeciążenie metody używane do przeszukiwania tablicy z poprzednimi wersjami, począwszy od lokalizacji indeksu 3 i dalej na początku tablicy i znajduje pierwsze wystąpienie ciągu.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Na koniec <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> przeciążenie metody używane do przeszukiwania zakres cztery wpisy, zaczynając od lokalizacji indeksu 4 i rozszerzanie Wstecz (to znaczy przeszukuje elementy w lokalizacjach, 4, 3, 2 i 1); to wyszukiwanie zwraca -1, ponieważ nie żadnych wystąpień wyszukiwania ciąg w tym zakresie.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Obiekt do zlokalizowania w <bpt id="p1">&lt;c&gt;</bpt>tablicy<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that extends from the first element to the specified index.</source>
          <target state="translated">Wyszukuje określony obiekt i zwraca indeks ostatniego wystąpienia w zakresie elementów w <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> który rozciąga się od pierwszego elementu zgodnie z określonym indeksem.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that extends from the first element to <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Liczony od zera indeks ostatniego wystąpienia <ph id="ph1">&lt;paramref name="value" /&gt;</ph> w zakresie elementów w <ph id="ph2">&lt;paramref name="array" /&gt;</ph> który rozciąga się od pierwszego elementu <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, jeśli je znaleziono; w przeciwnym razie wartość -1.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> Jest przeszukane z poprzednimi wersjami zaczynając od <ph id="ph2">`startIndex`</ph> i kończącego się na pierwszym elementem.</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Elementy są porównywane przy użyciu określonej wartości <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Jeśli typ elementu jest nonintrinsic typem (zdefiniowane przez użytkownika), <ph id="ph1">`Equals`</ph> implementacji tego typu jest używana.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from the beginning of <ph id="ph3">`array`</ph> to <ph id="ph4">`startIndex`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest liczba elementów od początku <ph id="ph3">`array`</ph> do <ph id="ph4">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The following code example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Poniższy przykład kodu pokazuje wszystkie trzy ogólnego przeciążeń <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the entire array from the end, and finds the second occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> Przeciążenie metody wyszukuje całą macierz od jej końca i wyszukuje drugie wystąpienie ciągu.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> Przeciążenie metody używane do przeszukiwania tablicy z poprzednimi wersjami, począwszy od lokalizacji indeksu 3 i dalej na początku tablicy i znajduje pierwsze wystąpienie ciągu.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Na koniec <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> przeciążenie metody używane do przeszukiwania zakres cztery wpisy, zaczynając od lokalizacji indeksu 4 i rozszerzanie Wstecz (to znaczy przeszukuje elementy w lokalizacjach, 4, 3, 2 i 1); to wyszukiwanie zwraca -1, ponieważ nie żadnych wystąpień wyszukiwania ciąg w tym zakresie.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do wyszukiwania.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Obiekt do zlokalizowania w <bpt id="p1">&lt;c&gt;</bpt>tablicy<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Liczba elementów w sekcji do wyszukania.</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
          <target state="translated">Wyszukuje określony obiekt i zwraca indeks ostatniego wystąpienia w zakresie elementów w <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zawierający określoną liczbę elementów i kończy się w określonym indeksie.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that contains the number of elements specified in <ph id="ph3">&lt;paramref name="count" /&gt;</ph> and ends at <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Liczony od zera indeks ostatniego wystąpienia <ph id="ph1">&lt;paramref name="value" /&gt;</ph> w zakresie elementów w <ph id="ph2">&lt;paramref name="array" /&gt;</ph> zawiera liczbę elementów określonych w <ph id="ph3">&lt;paramref name="count" /&gt;</ph> i kończy się na <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, jeśli je znaleziono; w przeciwnym razie wartość -1.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> Jest przeszukane z poprzednimi wersjami zaczynając od <ph id="ph2">`startIndex`</ph> i kończący się na <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, jeśli <ph id="ph5">`count`</ph> jest większa niż 0.</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Elementy są porównywane przy użyciu określonej wartości <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Jeśli typ elementu jest nonintrinsic typem (zdefiniowane przez użytkownika), <ph id="ph1">`Equals`</ph> implementacji tego typu jest używana.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The following code example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Poniższy przykład kodu pokazuje wszystkie trzy ogólnego przeciążeń <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Tablica ciągów jest tworzona, gdy jeden wpis, to pojawia się dwukrotnie, z lokalizacją indeksu 0 i lokalizacją indeksu 5.</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the entire array from the end, and finds the second occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> Przeciążenie metody wyszukuje całą macierz od jej końca i wyszukuje drugie wystąpienie ciągu.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> Przeciążenie metody używane do przeszukiwania tablicy z poprzednimi wersjami, począwszy od lokalizacji indeksu 3 i dalej na początku tablicy i znajduje pierwsze wystąpienie ciągu.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Na koniec <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> przeciążenie metody używane do przeszukiwania zakres cztery wpisy, zaczynając od lokalizacji indeksu 4 i rozszerzanie Wstecz (to znaczy przeszukuje elementy w lokalizacjach, 4, 3, 2 i 1); to wyszukiwanie zwraca -1, ponieważ nie żadnych wystąpień wyszukiwania ciąg w tym zakresie.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> i <ph id="ph2">&lt;paramref name="count" /&gt;</ph> nie zostanie określony prawidłowy części <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" uid="P:System.Array.Length">
          <source>Gets the total number of elements in all the dimensions of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Pobiera całkowitą liczbę elementów w wszystkie wymiary <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Length">
          <source>The total number of elements in all the dimensions of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>; zero if there are no elements in the array.</source>
          <target state="translated">Całkowita liczba elementów w wszystkie wymiary <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>; zero, jeśli w tablicy nie ma elementów.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Length">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Pobieranie wartości tej właściwości jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Length">
          <source>The following example uses the                                 <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> property to get the total number of elements in an array.</source>
          <target state="translated">W poniższym przykładzie użyto <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> właściwości do pobrania łączna liczba elementów w tablicy.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Length">
          <source>It also uses the                                 <ph id="ph1">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> method to determine the number of elements in each dimension of a multidimensional array.</source>
          <target state="translated">Ponadto użyto <ph id="ph1">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metodę, aby określić liczbę elementów w każdego wymiaru tablicy wielowymiarowej.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" uid="P:System.Array.Length">
          <source>The array is multidimensional and contains more than <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> elements.</source>
          <target state="translated">Tablica jest wielowymiarowa i zawiera więcej niż <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> elementów.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="P:System.Array.LongLength">
          <source>Gets a 64-bit integer that represents the total number of elements in all the dimensions of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Pobiera 64-bitową liczbę całkowitą, reprezentujący łączna liczba elementów w wszystkie wymiary <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.LongLength">
          <source>A 64-bit integer that represents the total number of elements in all the dimensions of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">64-bitową liczbę całkowitą, reprezentujący łączna liczba elementów w wszystkie wymiary <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.LongLength">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Pobieranie wartości tej właściwości jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="P:System.Array.Rank">
          <source>Gets the rank (number of dimensions) of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Pobiera pozycję (liczba wymiarów) <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="P:System.Array.Rank">
          <source>For example, a one-dimensional array returns 1, a two-dimensional array returns 2, and so on.</source>
          <target state="translated">Na przykład tablicą jednowymiarową zwraca wartość 1, jest tablicą dwuwymiarową zwraca 2 i tak dalej.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>The rank (number of dimensions) of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Rangę (liczba wymiarów) <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>For example, the Visual Basic code</source>
          <target state="translated">Na przykład kod Visual Basic</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>and the C# code</source>
          <target state="translated">i kodu C#</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>create an array of three dimensions with a <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> property whose value is 3.</source>
          <target state="translated">Utwórz tablicę trzech wymiarów z <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> właściwości, którego wartość to 3.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>A jagged array (an array of arrays) is a one-dimensional array; the value of its <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> property is 1.</source>
          <target state="translated">Tablicy nieregularnej (tablicy tablic) jest tablicą jednowymiarową; wartość jego <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> właściwość jest 1.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Pobieranie wartości tej właściwości jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>The following example initializes a one-dimensional array, a two-dimensional array, and a jagged array, and retrieves the <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> property of each.</source>
          <target state="translated">W poniższym przykładzie inicjuje tablicą jednowymiarową tablicą dwuwymiarową i tablicy nieregularnej i pobiera <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> właściwości każdego z nich.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The one-dimensional, zero-based array to resize, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> to create a new array with the specified size.</source>
          <target state="translated">Tablica jednowymiarowa, liczony od zera do zmiany rozmiaru, lub <ph id="ph1">&lt;see langword="null" /&gt;</ph> do utworzenia nowej tablicy o określonym rozmiarze.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The size of the new array.</source>
          <target state="translated">Rozmiar nowej tablicy.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>Changes the number of elements of a one-dimensional array to the specified new size.</source>
          <target state="translated">Zmiany liczby elementów tablicy jednowymiarowej z określonym rozmiarem nowe.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>This method allocates a new array with the specified size, copies elements from the old array to the new one, and then replaces the old array with the new one.</source>
          <target state="translated">Ta metoda przydziela nowej tablicy o określonym rozmiarze, kopiuje elementy z tablicy starego do nowego i zastąpi stare tablicy nowym.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source><ph id="ph1">`array`</ph> must be a one-dimensional array.</source>
          <target state="translated"><ph id="ph1">`array`</ph> musi być tablicą jednowymiarową.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>If <ph id="ph1">`array`</ph> is <ph id="ph2">`null`</ph>, this method creates a new array with the specified size.</source>
          <target state="translated">Jeśli <ph id="ph1">`array`</ph> jest <ph id="ph2">`null`</ph>, ta metoda tworzy nowy tablicy o określonym rozmiarze.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>If <ph id="ph1">`newSize`</ph> is greater than the <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> of the old array, a new array is allocated and all the elements are copied from the old array to the new one.</source>
          <target state="translated">Jeśli <ph id="ph1">`newSize`</ph> jest większa niż <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> starego tablicy jest przydzielany nowej tablicy i wszystkie elementy są kopiowane z tablicy starego do nowego.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>If <ph id="ph1">`newSize`</ph> is less than the <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> of the old array, a new array is allocated and elements are copied from the old array to the new one until the new one is filled; the rest of the elements in the old array are ignored.</source>
          <target state="translated">Jeśli <ph id="ph1">`newSize`</ph> jest mniejsza niż <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> starego tablicy jest przydzielany nowej tablicy i są kopiowane elementy z tablicy starego do nowego dopóki nowym jest wypełniony; pozostałe elementy w tablicy stare są ignorowane.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>If <ph id="ph1">`newSize`</ph> is equal to the <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> of the old array, this method does nothing.</source>
          <target state="translated">Jeśli <ph id="ph1">`newSize`</ph> jest równa <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> starego tablicy, ta metoda nie działa.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`newSize`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`newSize`</ph>.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Resize%2A&gt;</ph> method resizes a one-dimensional array only.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Resize%2A&gt;</ph> Metody zmienia rozmiar tylko tablicą jednowymiarową.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> class does not include a method for resizing multi-dimensional arrays.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> Klasa nie ma metody do zmiany rozmiaru tablic wielowymiarowych.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>To do this, you must either provide your own code or call a special-purpose method in a third-party library.</source>
          <target state="translated">Aby to zrobić, należy zapewnić swoim własnym kodem lub wywołanie metody specjalnych w bibliotece innych firm.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The following code illustrates one possible implementation for a method that resizes an array of <bpt id="p1">*</bpt>n<ept id="p1">*</ept> dimensions.</source>
          <target state="translated">Poniższy kod przedstawia możliwe jedna implementacja metody, która zmienia rozmiar tablicy <bpt id="p1">*</bpt>n<ept id="p1">*</ept> wymiarów.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The following example shows how resizing affects the array.</source>
          <target state="translated">W poniższym przykładzie pokazano, jak zmiana rozmiaru wpływa na tablicy.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="newSize" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newSize" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Reverses the order of the elements in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> or in a portion of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Odwraca kolejność elementów w jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> lub w części <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to reverse.</source>
          <target state="translated">Jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> Aby odwrócić.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array)">
          <source>Reverses the sequence of the elements in the entire one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Odwraca kolejność elementów w całej jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>After a call to this method, the element at <ph id="ph1">`myArray[i]`</ph>, where <ph id="ph2">`i`</ph> is any index in the array, moves to <ph id="ph3">`myArray[j]`</ph>, where <ph id="ph4">`j`</ph> equals <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>.</source>
          <target state="translated">Po wywołaniu tej metody elementu <ph id="ph1">`myArray[i]`</ph>, gdzie <ph id="ph2">`i`</ph> żadnych indeks w tablicy, przenosi do <ph id="ph3">`myArray[j]`</ph>, gdzie <ph id="ph4">`j`</ph> jest równe <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>As the following example shows, the <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> method can be used to reverse a jagged array.</source>
          <target state="translated">Jak pokazano na poniższym przykładzie, <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> metody można użyć do odwracania tablicą nieregularną.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>It initializes a jagged array with one element for each month of the current year in the current culture's calendar.</source>
          <target state="translated">Tablicy nieregularnej o jeden element jest inicjowana w każdym miesiącu w bieżącym roku w kalendarzu bieżącej kultury.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>Each element contains an array with as many elements as that month has days.</source>
          <target state="translated">Każdy element zawiera tablicę z dowolną liczbę elementów, ponieważ dni miesiąca.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>The example displays the contents of the array, calls the <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> method, and then displays the contents of the reversed array.</source>
          <target state="translated">W przykładzie przedstawiono zawartości tablicy, wywołania <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> metody, a następnie wyświetla zawartość tablicę wycofane.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>The following code example shows how to reverse the sort of the values in an <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Poniższy przykładowy kod przedstawia sposób sortowania wartości w odwrotnej <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to reverse.</source>
          <target state="translated">Jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> Aby odwrócić.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The starting index of the section to reverse.</source>
          <target state="translated">Indeks początkowy sekcji, aby odwrócić.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The number of elements in the section to reverse.</source>
          <target state="translated">Liczba elementów w sekcji, aby odwrócić.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>Reverses the sequence of the elements in a range of elements in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Odwraca kolejność elementów w zakresie elementów w jednowymiarowej tablicy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>After a call to this method, the element at <ph id="ph1">`myArray[i]`</ph>, where <ph id="ph2">`i`</ph> is any index in the array, moves to <ph id="ph3">`myArray[j]`</ph>, where <ph id="ph4">`j`</ph> equals <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>.</source>
          <target state="translated">Po wywołaniu tej metody elementu <ph id="ph1">`myArray[i]`</ph>, gdzie <ph id="ph2">`i`</ph> żadnych indeks w tablicy, przenosi do <ph id="ph3">`myArray[j]`</ph>, gdzie <ph id="ph4">`j`</ph> jest równe <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> method can be used to reverse a jagged array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> Metody można użyć do odwracania tablicą nieregularną.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to reverse the sort of the values in a range of elements in an <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Poniższy przykładowy kod przedstawia sposób Odwróć kolejność sortowania wartości zakresu elementów w <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> jest mniejsza niż dolna granica <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> i <ph id="ph2">&lt;paramref name="length" /&gt;</ph> nie zostanie określony prawidłowy zakres w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Sets the specified element in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to the specified value.</source>
          <target state="translated">Ustawia określony element w bieżącym <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> z podaną wartością.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The new value for the specified element.</source>
          <target state="translated">Nowa wartość dla określonego elementu.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>A 32-bit integer that represents the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">32-bitową liczbę całkowitą, która reprezentuje pozycję <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element, aby ustawić.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>Sets a value to the element at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ustawia wartość do elementu w określonej pozycji w jednowymiarowej tablicy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The index is specified as a 32-bit integer.</source>
          <target state="translated">Indeks jest określony jako 32-bitową liczbę całkowitą.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metod można określić, czy wartość <ph id="ph3">`index`</ph> jest poza zakresem.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji na temat konwersji, zobacz <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> jest używana do przypisywania <ph id="ph2">`null`</ph> do elementu tablicy typów wartości zainicjowaniem wszystkich pól elementu od zera.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">Bieżące <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> nie ma dokładnie jednego wymiaru.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> Nie można rzutować na typ elementu bieżącego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla bieżącego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The new value for the specified element.</source>
          <target state="translated">Nowa wartość dla określonego elementu.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the element to set.</source>
          <target state="translated">Jednowymiarowa tablica 32-bitowych liczb całkowitych reprezentujących indeksów, określając położenie elementu można ustawić.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>Sets a value to the element at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ustawia wartość do elementu w określonej pozycji w wielowymiarowe <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The indexes are specified as an array of 32-bit integers.</source>
          <target state="translated">Indeksy są określone jako tablicę 32-bitowych liczb całkowitych.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Liczba elementów w <ph id="ph1">`indices`</ph> musi być równa liczbie wymiarów w <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Wszystkie elementy w <ph id="ph1">`indices`</ph> tablicy wspólnie określić położenie żądanego elementu w wielowymiarowe <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the values in the <ph id="ph3">`indices`</ph> array is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metod można określić, czy dowolna z wartości w <ph id="ph3">`indices`</ph> tablicy jest poza zakresem.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji na temat konwersji, zobacz <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> jest używana do przypisywania <ph id="ph2">`null`</ph> do elementu tablicy typów wartości zainicjowaniem wszystkich pól elementu od zera.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The number of dimensions in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is not equal to the number of elements in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</source>
          <target state="translated">Liczba wymiarów w bieżącym <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> nie jest równa liczbie elementów w <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> Nie można rzutować na typ elementu bieżącego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>Any element in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Dowolny element w <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The new value for the specified element.</source>
          <target state="translated">Nowa wartość dla określonego elementu.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>A 64-bit integer that represents the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">64-bitową liczbę całkowitą, która reprezentuje pozycję <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element, aby ustawić.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>Sets a value to the element at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ustawia wartość do elementu w określonej pozycji w jednowymiarowej tablicy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The index is specified as a 64-bit integer.</source>
          <target state="translated">Indeks jest określony jako 64-bitową liczbę całkowitą.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metod można określić, czy wartość <ph id="ph3">`index`</ph> jest poza zakresem.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji na temat konwersji, zobacz <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> jest używana do przypisywania <ph id="ph2">`null`</ph> do elementu tablicy typów wartości zainicjowaniem wszystkich pól elementu od zera.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">Bieżące <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> nie ma dokładnie jednego wymiaru.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> Nie można rzutować na typ elementu bieżącego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla bieżącego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The new value for the specified element.</source>
          <target state="translated">Nowa wartość dla określonego elementu.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the element to set.</source>
          <target state="translated">Jednowymiarowa tablica 64-bitowych liczb całkowitych reprezentujących indeksów, określając położenie elementu można ustawić.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>Sets a value to the element at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ustawia wartość do elementu w określonej pozycji w wielowymiarowe <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The indexes are specified as an array of 64-bit integers.</source>
          <target state="translated">Indeksy są określone jako tablicę 64-bitowych liczb całkowitych.</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Liczba elementów w <ph id="ph1">`indices`</ph> musi być równa liczbie wymiarów w <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Wszystkie elementy w <ph id="ph1">`indices`</ph> tablicy wspólnie określić położenie żądanego elementu w wielowymiarowe <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the values in the <ph id="ph3">`indices`</ph> array is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metod można określić, czy dowolna z wartości w <ph id="ph3">`indices`</ph> tablicy jest poza zakresem.</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji na temat konwersji, zobacz <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> jest używana do przypisywania <ph id="ph2">`null`</ph> do elementu tablicy typów wartości zainicjowaniem wszystkich pól elementu od zera.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The number of dimensions in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is not equal to the number of elements in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</source>
          <target state="translated">Liczba wymiarów w bieżącym <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> nie jest równa liczbie elementów w <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> Nie można rzutować na typ elementu bieżącego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>Any element in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Dowolny element w <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The new value for the specified element.</source>
          <target state="translated">Nowa wartość dla określonego elementu.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">32-bitową liczbę całkowitą, który reprezentuje indeks pierwszego wymiaru <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element, aby ustawić.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">32-bitową liczbę całkowitą, reprezentującą sekundę wymiaru indeks <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element, aby ustawić.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>Sets a value to the element at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ustawia wartość do elementu w określonej pozycji w dwuwymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The indexes are specified as 32-bit integers.</source>
          <target state="translated">Indeksy są określane jako 32-bitowe liczby całkowite.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metod można ustalić, czy dowolny z indeksów jest poza zakresem.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji na temat konwersji, zobacz <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> jest używana do przypisywania <ph id="ph2">`null`</ph> do elementu tablicy typów wartości zainicjowaniem wszystkich pól elementu od zera.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly two dimensions.</source>
          <target state="translated">Bieżące <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> nie ma dokładnie dwóch wymiarów.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> Nie można rzutować na typ elementu bieżącego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>Either <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Albo <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> lub <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The new value for the specified element.</source>
          <target state="translated">Nowa wartość dla określonego elementu.</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">64-bitową liczbę całkowitą, który reprezentuje indeks pierwszego wymiaru <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element, aby ustawić.</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">64-bitową liczbę całkowitą reprezentującą sekundę wymiaru indeks <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element, aby ustawić.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>Sets a value to the element at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ustawia wartość do elementu w określonej pozycji w dwuwymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The indexes are specified as 64-bit integers.</source>
          <target state="translated">Indeksy są określone jako 64-bitowych liczb całkowitych.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metod można ustalić, czy dowolny z indeksów jest poza zakresem.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji na temat konwersji, zobacz <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> jest używana do przypisywania <ph id="ph2">`null`</ph> do elementu tablicy typów wartości zainicjowaniem wszystkich pól elementu od zera.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly two dimensions.</source>
          <target state="translated">Bieżące <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> nie ma dokładnie dwóch wymiarów.</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> Nie można rzutować na typ elementu bieżącego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>Either <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Albo <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> lub <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The new value for the specified element.</source>
          <target state="translated">Nowa wartość dla określonego elementu.</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">32-bitową liczbę całkowitą, który reprezentuje indeks pierwszego wymiaru <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element, aby ustawić.</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">32-bitową liczbę całkowitą, reprezentującą sekundę wymiaru indeks <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element, aby ustawić.</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">32-bitową liczbę całkowitą, reprezentujący indeks trzeci wymiar <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element, aby ustawić.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>Sets a value to the element at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ustawia wartość do elementu w określonej pozycji w trójwymiarowy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The indexes are specified as 32-bit integers.</source>
          <target state="translated">Indeksy są określane jako 32-bitowe liczby całkowite.</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metod można ustalić, czy dowolny z indeksów jest poza zakresem.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji na temat konwersji, zobacz <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> jest używana do przypisywania <ph id="ph2">`null`</ph> do elementu tablicy typów wartości zainicjowaniem wszystkich pól elementu od zera.</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly three dimensions.</source>
          <target state="translated">Bieżące <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> nie ma dokładnie trzy wymiarów.</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> Nie można rzutować na typ elementu bieżącego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> or <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> lub <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> lub <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The new value for the specified element.</source>
          <target state="translated">Nowa wartość dla określonego elementu.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">64-bitową liczbę całkowitą, który reprezentuje indeks pierwszego wymiaru <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element, aby ustawić.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">64-bitową liczbę całkowitą reprezentującą sekundę wymiaru indeks <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element, aby ustawić.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">64-bitową liczbę całkowitą, reprezentujący indeks trzeci wymiar <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element, aby ustawić.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>Sets a value to the element at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ustawia wartość do elementu w określonej pozycji w trójwymiarowy <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The indexes are specified as 64-bit integers.</source>
          <target state="translated">Indeksy są określone jako 64-bitowych liczb całkowitych.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> metod można ustalić, czy dowolny z indeksów jest poza zakresem.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Aby uzyskać więcej informacji na temat konwersji, zobacz <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Ta metoda jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> jest używana do przypisywania <ph id="ph2">`null`</ph> do elementu tablicy typów wartości zainicjowaniem wszystkich pól elementu od zera.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Wartość elementu nie jest odwołaniem zerowym i nie można jej znaleźć przez wyszukiwanie odwołania zerowego.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak ustawiać i pobierać określoną wartość w tablicy jednowymiarowej lub wielowymiarowej.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly three dimensions.</source>
          <target state="translated">Bieżące <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> nie ma dokładnie trzy wymiarów.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> Nie można rzutować na typ elementu bieżącego <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> or <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> lub <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> lub <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> znajduje się poza zakresem indeksów prawidłowy dla odpowiedniego wymiaru bieżącego <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Sorts the elements in a one-dimensional array.</source>
          <target state="translated">Sortuje elementy z tablicą jednowymiarową.</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated">Jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do sortowania.</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source>Sorts the elements in an entire one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element of the <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Sortuje elementów w całej jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> przy użyciu <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> stosowania dla każdego elementu <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>Each element of <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
          <target state="translated">Każdy element <ph id="ph1">`array`</ph> musi implementować <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interfejsu, aby umożliwiać porównania z każdego innego elementu w <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>If the partition size is fewer than 16 elements, it uses an<bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Jeśli rozmiar partycji jest mniej niż 16 elementów, używa<bpt id="p1">[</bpt>sortowania wstawiania<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Jeśli liczba partycji przekracza 2 * dziennika<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, gdzie <bpt id="p2">*</bpt>N<ept id="p2">*</ept> jest zakresu wartości tablicy wejściowej używa <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">W przeciwnym razie używa <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana.</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (<ph id="ph1">`n`</ph> dziennika <ph id="ph2">`n`</ph>) operację, której <ph id="ph3">`n`</ph> jest <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>The following code example shows how to sort the values in an <ph id="ph1">&lt;xref:System.Array&gt;</ph> using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Poniższy przykład kodu pokazuje sposób posortować wartości w <ph id="ph1">&lt;xref:System.Array&gt;</ph> przy użyciu domyślna funkcja porównująca i niestandardowej funkcji porównującej Odwraca kolejność sortowania.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Należy pamiętać, że wynik mogą się różnić w zależności od bieżącej <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source>One or more elements in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated">Co najmniej jeden element w <ph id="ph1">&lt;paramref name="array" /&gt;</ph> nie implementują <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">Jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zawierającą klucze ze słownika do sortowania.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zawiera elementy, które odpowiadają każdej z kluczy w <bpt id="p1">&lt;c&gt;</bpt>klucze<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to sort only the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby posortować tylko <bpt id="p1">&lt;c&gt;</bpt>klucze<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Sorts a pair of one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each key.</source>
          <target state="translated">Sortuje pary jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> obiektów (jeden zawiera klucze, a drugi zawiera odpowiednie elementy) oparte na klucze w pierwszym <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> przy użyciu <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> stosowania dla każdego klucza.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> ma odpowiadający mu element w <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Po klucz zostaje przeniesiony podczas sortowania, odpowiadający mu element w <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> podobnie ponownie.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">W związku z tym <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> jest sortowana według rozmieszczenia odpowiadające im klucze w <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> musi implementować <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interfejsu, aby umożliwiać porównania z każdym innym kluczem.</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które mają nie odpowiadające im klucze nie będą sortowane.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Jeśli rozmiar partycji jest mniej niż 16 elementów, używa <bpt id="p1">[</bpt>sortowania wstawiania<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Jeśli liczba partycji przekracza 2 * dziennika<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, gdzie <bpt id="p2">*</bpt>N<ept id="p2">*</ept> jest zakresu wartości tablicy wejściowej używa <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">W przeciwnym razie używa <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`keys`</ph>.</source>
          <target state="translated">Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (<ph id="ph1">`n`</ph> dziennika <ph id="ph2">`n`</ph>) operację, której <ph id="ph3">`n`</ph> jest <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph5">`keys`</ph>.</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The following example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</source>
          <target state="translated">Poniższy przykład przedstawia sposób sortowania dwie tablice skojarzony, gdzie pierwszy tablica zawiera klucze, a druga tablica zawiera wartości.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Sorts are done using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Sortuje są wykonywane przy użyciu domyślna funkcja porównująca i niestandardowej funkcji porównującej Odwraca kolejność sortowania.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Należy pamiętać, że wynik mogą się różnić w zależności od bieżącej <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> Jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> Jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> nie jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, a długość <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> jest większa niż długość <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>One or more elements in the <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated">Co najmniej jeden element w <ph id="ph1">&lt;paramref name="keys" /&gt;</ph> <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> nie implementują <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The one-dimensional array to sort.</source>
          <target state="translated">Jednowymiarowa tablica, aby posortować.</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The implementation to use when comparing elements.</source>
          <target state="translated">Implementacja do użycia podczas porównywania elementów.</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> stosowania dla każdego elementu.</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Sorts the elements in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">Sortuje elementy w jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> przy użyciu określonego <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element of <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">`comparer`</ph> jest <ph id="ph2">`null`</ph>, każdy element <ph id="ph3">`array`</ph> musi implementować <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interfejsu, aby umożliwiać porównania z każdego innego elementu w <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Jeśli rozmiar partycji jest mniej niż 16 elementów, używa <bpt id="p1">[</bpt>sortowania wstawiania<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Jeśli liczba partycji przekracza 2 * dziennika<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, gdzie <bpt id="p2">*</bpt>N<ept id="p2">*</ept> jest zakresu wartości tablicy wejściowej używa <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">W przeciwnym razie używa <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (<ph id="ph1">`n`</ph> dziennika <ph id="ph2">`n`</ph>) operację, której <ph id="ph3">`n`</ph> jest <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
          <target state="translated">.NET Framework zawiera wstępnie zdefiniowane <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementacje wymienione w poniższej tabeli.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Implementation</source>
          <target state="translated">Implementacja</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Description</source>
          <target state="translated">Opis</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
          <target state="translated">Porównuje dowolnymi dwoma obiektami, ale wykonuje bez uwzględniania wielkości liter porównania ciągów.</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
          <target state="translated">Porównuje dowolnymi dwoma obiektami przy użyciu konwencji sortowania bieżącej kultury.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
          <target state="translated">Porównuje dowolnymi dwoma obiektami za pomocą sortowania konwencjach Niezmienna kultura.</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
          <target state="translated">Porównuje dwa obiekty typu <ph id="ph1">`T`</ph> przy użyciu sortowania domyślnego typu.</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
          <target state="translated">Może również obsługiwać niestandardowe porównania, podając własne wystąpienie <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> wykonania <ph id="ph2">`comparer`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The example does this by defining a <ph id="ph1">`ReverseComparer`</ph> class that reverses the default sort order for instances of a type and performs case-insensitive string comparison.</source>
          <target state="translated">Przykład robi to poprzez definiowanie <ph id="ph1">`ReverseComparer`</ph> klasy, która Odwraca kolejność sortowania domyślnego wystąpienia typu i wykonuje porównania ciągów bez uwzględniania wielkości liter.</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The following example sorts the values in a string arrayby using the default comparer.</source>
          <target state="translated">Poniższy przykład sortuje wartości arrayby ciągu, przy użyciu domyślna funkcja porównująca.</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>It also defines a custom <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation named <ph id="ph2">`ReverseComparer`</ph> that reverses an object's default sort order while performing a case-insensitive string comparison.</source>
          <target state="translated">Definiuje również niestandardowego <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> wdrożenia o nazwie <ph id="ph2">`ReverseComparer`</ph> który Odwraca kolejność sortowania domyślnego obiektu podczas wykonywania porównania ciągów bez uwzględniania wielkości liter.</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Note that the output might vary depending on the current culture.</source>
          <target state="translated">Należy pamiętać, że dane wyjściowe mogą się różnić w zależności od bieżącej kultury.</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>i co najmniej jeden element w <ph id="ph3">&lt;paramref name="array" /&gt;</ph> nie implementują <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">Implementacja <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> spowodował błąd podczas sortowania.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Na przykład <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> nie mogą zwracać 0, podczas porównywania elementu z samym sobą.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">.NET Framework 4 i starszych wersji należy używać tylko algorytm Quicksort.</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Quicksort określa nieprawidłowy comparers w niektórych sytuacjach, w których zgłasza operacji <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> wyjątku i zgłasza <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> wyjątek do obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">Począwszy od <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, istnieje możliwość, że sortowanie operacji poprzednio zwrócił <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> nie spowoduje zgłoszenie wyjątku, ponieważ algorytmy sortowania i heapsort wstawiania nie wykrywaj nieprawidłowe porównania.</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">W większości przypadków dotyczy tablic o mniej niż 16 elementów.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">Jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zawierającą klucze ze słownika do sortowania.</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zawiera elementy, które odpowiadają każdej z kluczy w <bpt id="p1">&lt;c&gt;</bpt>klucze<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to sort only the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby posortować tylko <bpt id="p1">&lt;c&gt;</bpt>klucze<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> Wdrożenia do użycia podczas porównywania elementów.</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> stosowania dla każdego elementu.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Sorts a pair of one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph3">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">Sortuje pary jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> obiektów (jeden zawiera klucze, a drugi zawiera odpowiednie elementy) oparte na klucze w pierwszym <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> przy użyciu określonego <ph id="ph3">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> ma odpowiadający mu element w <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Po klucz zostaje przeniesiony podczas sortowania, odpowiadający mu element w <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> podobnie ponownie.</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">W związku z tym <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> jest sortowana według rozmieszczenia odpowiadające im klucze w <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
          <target state="translated">Jeśli <ph id="ph1">`comparer`</ph> jest <ph id="ph2">`null`</ph>, każdy klucz w <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph> musi implementować <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> interfejsu, aby umożliwiać porównania z każdym innym kluczem.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które mają nie odpowiadające im klucze nie będą sortowane.</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
          <target state="translated">.NET Framework zawiera wstępnie zdefiniowane <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementacje wymienione w poniższej tabeli.</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Implementation</source>
          <target state="translated">Implementacja</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Description</source>
          <target state="translated">Opis</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
          <target state="translated">Porównuje dowolnymi dwoma obiektami, ale wykonuje bez uwzględniania wielkości liter porównania ciągów.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
          <target state="translated">Porównuje dowolnymi dwoma obiektami przy użyciu konwencji sortowania bieżącej kultury.</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
          <target state="translated">Porównuje dowolnymi dwoma obiektami za pomocą sortowania konwencjach Niezmienna kultura.</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
          <target state="translated">Porównuje dwa obiekty typu <ph id="ph1">`T`</ph> przy użyciu sortowania domyślnego typu.</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
          <target state="translated">Może również obsługiwać niestandardowe porównania, podając własne wystąpienie <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> wykonania <ph id="ph2">`comparer`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The example does this by defining an <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation that reverses the default sort order and performs case-insensitive string comparison.</source>
          <target state="translated">Przykład robi to poprzez definiowanie <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementacji Odwraca kolejność sortowania domyślnego, który wykonuje porównania ciągów bez uwzględniania wielkości liter.</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Jeśli rozmiar partycji jest mniej niż 16 elementów, używa <bpt id="p1">[</bpt>sortowania wstawiania<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Jeśli liczba partycji przekracza 2 * dziennika<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, gdzie <bpt id="p2">*</bpt>N<ept id="p2">*</ept> jest zakresu wartości tablicy wejściowej używa <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">W przeciwnym razie używa <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana.</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`keys`</ph>.</source>
          <target state="translated">Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (<ph id="ph1">`n`</ph> dziennika <ph id="ph2">`n`</ph>) operację, której <ph id="ph3">`n`</ph> jest <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph5">`keys`</ph>.</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The following example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</source>
          <target state="translated">Poniższy przykład przedstawia sposób sortowania dwie tablice skojarzony, gdzie pierwszy tablica zawiera klucze, a druga tablica zawiera wartości.</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Sorts are done using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Sortuje są wykonywane przy użyciu domyślna funkcja porównująca i niestandardowej funkcji porównującej Odwraca kolejność sortowania.</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Należy pamiętać, że wynik mogą się różnić w zależności od bieżącej <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> Jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> Jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> nie jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, a długość <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> jest większa niż długość <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">Implementacja <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> spowodował błąd podczas sortowania.</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Na przykład <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> nie mogą zwracać 0, podczas porównywania elementu z samym sobą.</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>i co najmniej jeden element w <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> nie implementują <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">.NET Framework 4 i starszych wersji należy używać tylko algorytm Quicksort.</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Quicksort określa nieprawidłowy comparers w niektórych sytuacjach, w których zgłasza operacji <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> wyjątku i zgłasza <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> wyjątek do obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previouslythrew <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, becausethe insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">Począwszy od <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, istnieje możliwość, który sortowanie previouslythrew tej operacji <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> nie spowoduje zgłoszenie wyjątku, ponieważ algorytmy sortowania i heapsort wstawiania nie wykrywaj nieprawidłowe porównania.</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">W większości przypadków dotyczy tablic o mniej niż 16 elementów.</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated">Jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do sortowania.</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Indeks początkowy zakresu do sortowania.</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Liczba elementów w zakresie do sortowania.</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>Sorts the elements in a range of elements in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element of the <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Sortuje elementy w zakresie elementów w jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> przy użyciu <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> stosowania dla każdego elementu <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>Each element within the specified range of elements in <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
          <target state="translated">Każdy element określonego zakresu elementów w <ph id="ph1">`array`</ph> musi implementować <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interfejsu, aby umożliwiać porównania z każdego innego elementu w <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Jeśli rozmiar partycji jest mniej niż 16 elementów, używa <bpt id="p1">[</bpt>sortowania wstawiania<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Jeśli liczba partycji przekracza 2 * dziennika<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, gdzie <bpt id="p2">*</bpt>N<ept id="p2">*</ept> jest zakresu wartości tablicy wejściowej używa <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">W przeciwnym razie używa <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana.</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (<ph id="ph1">`n`</ph> dziennika <ph id="ph2">`n`</ph>) operację, której <ph id="ph3">`n`</ph> jest <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to sort the values in an <ph id="ph1">&lt;xref:System.Array&gt;</ph> using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Poniższy przykład kodu pokazuje sposób posortować wartości w <ph id="ph1">&lt;xref:System.Array&gt;</ph> przy użyciu domyślna funkcja porównująca i niestandardowej funkcji porównującej Odwraca kolejność sortowania.</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Należy pamiętać, że wynik mogą się różnić w zależności od bieżącej <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> jest mniejsza niż dolna granica <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> i <ph id="ph2">&lt;paramref name="length" /&gt;</ph> nie zostanie określony prawidłowy zakres w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>One or more elements in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated">Co najmniej jeden element w <ph id="ph1">&lt;paramref name="array" /&gt;</ph> nie implementują <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">Jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zawierającą klucze ze słownika do sortowania.</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zawiera elementy, które odpowiadają każdej z kluczy w <bpt id="p1">&lt;c&gt;</bpt>klucze<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to sort only the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby posortować tylko <bpt id="p1">&lt;c&gt;</bpt>klucze<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Indeks początkowy zakresu do sortowania.</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Liczba elementów w zakresie do sortowania.</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Sorts a range of elements in a pair of one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each key.</source>
          <target state="translated">Zakres elementów w parze jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> obiektów (jeden zawiera klucze, a drugi zawiera odpowiednie elementy) oparte na klucze w pierwszym <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> przy użyciu <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> stosowania dla każdego klucza.</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> ma odpowiadający mu element w <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Po klucz zostaje przeniesiony podczas sortowania, odpowiadający mu element w <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> podobnie ponownie.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">W związku z tym <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> jest sortowana według rozmieszczenia odpowiadające im klucze w <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Each key within the specified range of elements in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
          <target state="translated">Każdy klucz określonego zakresu elementów w <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> musi implementować <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interfejsu, aby umożliwiać porównania z każdym innym kluczem.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które mają nie odpowiadające im klucze nie będą sortowane.</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Jeśli rozmiar partycji jest mniej niż 16 elementów, używa <bpt id="p1">[</bpt>sortowania wstawiania<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Jeśli liczba partycji przekracza 2 * dziennika<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, gdzie <bpt id="p2">*</bpt>N<ept id="p2">*</ept> jest zakresu wartości tablicy wejściowej używa <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">W przeciwnym razie używa <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana.</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (<ph id="ph1">`n`</ph> dziennika <ph id="ph2">`n`</ph>) operację, której <ph id="ph3">`n`</ph> jest <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</source>
          <target state="translated">Poniższy przykład kodu pokazuje sposób sortowania dwie tablice skojarzony, gdzie pierwszy tablica zawiera klucze, a druga tablica zawiera wartości.</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Sorts are done using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Sortuje są wykonywane przy użyciu domyślna funkcja porównująca i niestandardowej funkcji porównującej Odwraca kolejność sortowania.</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Należy pamiętać, że wynik mogą się różnić w zależności od bieżącej <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> Jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> Jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> jest mniejsza niż dolna granica <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> nie jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, a długość <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> jest większa niż długość <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> i <ph id="ph2">&lt;paramref name="length" /&gt;</ph> nie zostanie określony prawidłowy zakres w <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="index" /&gt;</ph> and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> nie jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, i <ph id="ph3">&lt;paramref name="index" /&gt;</ph> i <ph id="ph4">&lt;paramref name="length" /&gt;</ph> nie zostanie określony prawidłowy zakres w <ph id="ph5">&lt;paramref name="items" /&gt;</ph> <ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>One or more elements in the <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated">Co najmniej jeden element w <ph id="ph1">&lt;paramref name="keys" /&gt;</ph> <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> nie implementują <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated">Jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do sortowania.</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Indeks początkowy zakresu do sortowania.</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Liczba elementów w zakresie do sortowania.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> Wdrożenia do użycia podczas porównywania elementów.</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> stosowania dla każdego elementu.</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Sorts the elements in a range of elements in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">Sortuje elementy w zakresie elementów w jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> przy użyciu określonego <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element within the specified range of elements in <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">`comparer`</ph> jest <ph id="ph2">`null`</ph>, każdy element określonego zakresu elementów w <ph id="ph3">`array`</ph> musi implementować <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interfejsu, aby umożliwiać porównania z każdego innego elementu w <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
          <target state="translated">.NET Framework zawiera wstępnie zdefiniowane <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementacje wymienione w poniższej tabeli.</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Implementation</source>
          <target state="translated">Implementacja</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Description</source>
          <target state="translated">Opis</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
          <target state="translated">Porównuje dowolnymi dwoma obiektami, ale wykonuje bez uwzględniania wielkości liter porównania ciągów.</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
          <target state="translated">Porównuje dowolnymi dwoma obiektami przy użyciu konwencji sortowania bieżącej kultury.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
          <target state="translated">Porównuje dowolnymi dwoma obiektami za pomocą sortowania konwencjach Niezmienna kultura.</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
          <target state="translated">Porównuje dwa obiekty typu <ph id="ph1">`T`</ph> przy użyciu sortowania domyślnego typu.</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
          <target state="translated">Może również obsługiwać niestandardowe porównania, podając własne wystąpienie <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> wykonania <ph id="ph2">`comparer`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The example does this by defining a <ph id="ph1">`ReverseComparer`</ph> class that reverses the default sort order for instances of a type and performs case-insensitive string comparison.</source>
          <target state="translated">Przykład robi to poprzez definiowanie <ph id="ph1">`ReverseComparer`</ph> klasy, która Odwraca kolejność sortowania domyślnego wystąpienia typu i wykonuje porównania ciągów bez uwzględniania wielkości liter.</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Jeśli rozmiar partycji jest mniej niż 16 elementów, używa <bpt id="p1">[</bpt>sortowania wstawiania<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Jeśli liczba partycji przekracza 2 * dziennika<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, gdzie <bpt id="p2">*</bpt>N<ept id="p2">*</ept> jest zakresu wartości tablicy wejściowej używa <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">W przeciwnym razie używa <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana.</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (<ph id="ph1">`n`</ph> dziennika <ph id="ph2">`n`</ph>) operację, której <ph id="ph3">`n`</ph> jest <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The following code example shows how to sort the values in an <ph id="ph1">&lt;xref:System.Array&gt;</ph> using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Poniższy przykład kodu pokazuje sposób posortować wartości w <ph id="ph1">&lt;xref:System.Array&gt;</ph> przy użyciu domyślna funkcja porównująca i niestandardowej funkcji porównującej Odwraca kolejność sortowania.</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Należy pamiętać, że wynik mogą się różnić w zależności od bieżącej <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> jest mniejsza niż dolna granica <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> i <ph id="ph2">&lt;paramref name="length" /&gt;</ph> nie zostanie określony prawidłowy zakres w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">Implementacja <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> spowodował błąd podczas sortowania.</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Na przykład <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> nie mogą zwracać 0, podczas porównywania elementu z samym sobą.</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>i co najmniej jeden element w <ph id="ph3">&lt;paramref name="array" /&gt;</ph> nie implementują <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">.NET Framework 4 i starszych wersji należy używać tylko algorytm Quicksort.</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Quicksort określa nieprawidłowy comparers w niektórych sytuacjach, w których zgłasza operacji <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> wyjątku i zgłasza <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> wyjątek do obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">Począwszy od <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, istnieje możliwość, że sortowanie operacji poprzednio zwrócił <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> nie spowoduje zgłoszenie wyjątku, ponieważ algorytmy sortowania i heapsort wstawiania nie wykrywaj nieprawidłowe porównania.</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">W większości przypadków dotyczy tablic o mniej niż 16 elementów.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">Jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zawierającą klucze ze słownika do sortowania.</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zawiera elementy, które odpowiadają każdej z kluczy w <bpt id="p1">&lt;c&gt;</bpt>klucze<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to sort only the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby posortować tylko <bpt id="p1">&lt;c&gt;</bpt>klucze<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Indeks początkowy zakresu do sortowania.</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Liczba elementów w zakresie do sortowania.</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> Wdrożenia do użycia podczas porównywania elementów.</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Aby użyć <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> stosowania dla każdego elementu.</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Sorts a range of elements in a pair of one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph3">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">Zakres elementów w parze jednowymiarowa <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> obiektów (jeden zawiera klucze, a drugi zawiera odpowiednie elementy) oparte na klucze w pierwszym <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> przy użyciu określonego <ph id="ph3">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> ma odpowiadający mu element w <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Po klucz zostaje przeniesiony podczas sortowania, odpowiadający mu element w <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> podobnie ponownie.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">W związku z tym <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> jest sortowana według rozmieszczenia odpowiadające im klucze w <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key within the specified range of elements in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
          <target state="translated">Jeśli <ph id="ph1">`comparer`</ph> jest <ph id="ph2">`null`</ph>, każdy klucz określonego zakresu elementów w <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph> musi implementować <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> interfejsu, aby umożliwiać porównania z każdym innym kluczem.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które mają nie odpowiadające im klucze nie będą sortowane.</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
          <target state="translated">.NET Framework zawiera wstępnie zdefiniowane <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementacje wymienione w poniższej tabeli.</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Implementation</source>
          <target state="translated">Implementacja</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Description</source>
          <target state="translated">Opis</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
          <target state="translated">Porównuje dowolnymi dwoma obiektami, ale wykonuje bez uwzględniania wielkości liter porównania ciągów.</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
          <target state="translated">Porównuje dowolnymi dwoma obiektami przy użyciu konwencji sortowania bieżącej kultury.</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
          <target state="translated">Porównuje dowolnymi dwoma obiektami za pomocą sortowania konwencjach Niezmienna kultura.</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
          <target state="translated">Porównuje dwa obiekty typu <ph id="ph1">`T`</ph> przy użyciu sortowania domyślnego typu.</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
          <target state="translated">Może również obsługiwać niestandardowe porównania, podając własne wystąpienie <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> wykonania <ph id="ph2">`comparer`</ph> parametru.</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The example does this by defining a custom <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation that reverses the default sort order and performs case-insensitive string comparison.</source>
          <target state="translated">Przykład robi to poprzez Definiowanie niestandardowego <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementacji Odwraca kolejność sortowania domyślnego, który wykonuje porównania ciągów bez uwzględniania wielkości liter.</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Jeśli rozmiar partycji jest mniej niż 16 elementów, używa <bpt id="p1">[</bpt>sortowania wstawiania<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Jeśli liczba partycji przekracza 2 * dziennika<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, gdzie <bpt id="p2">*</bpt>N<ept id="p2">*</ept> jest zakresu wartości tablicy wejściowej używa <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">W przeciwnym razie używa <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana.</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (<ph id="ph1">`n`</ph> dziennika <ph id="ph2">`n`</ph>) operację, której <ph id="ph3">`n`</ph> jest <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The following code example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</source>
          <target state="translated">Poniższy przykład kodu pokazuje sposób sortowania dwie tablice skojarzony, gdzie pierwszy tablica zawiera klucze, a druga tablica zawiera wartości.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Sorts are done using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Sortuje są wykonywane przy użyciu domyślna funkcja porównująca i niestandardowej funkcji porównującej Odwraca kolejność sortowania.</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Należy pamiętać, że wynik mogą się różnić w zależności od bieżącej <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> Jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> Jest wielowymiarowy.</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> jest mniejsza niż dolna granica <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> nie jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>oraz dolną granicę <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> jest niezgodny z dolną granicę <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> nie jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, a długość <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> jest większa niż długość <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> i <ph id="ph2">&lt;paramref name="length" /&gt;</ph> nie zostanie określony prawidłowy zakres w <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="index" /&gt;</ph> and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> nie jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, i <ph id="ph3">&lt;paramref name="index" /&gt;</ph> i <ph id="ph4">&lt;paramref name="length" /&gt;</ph> nie zostanie określony prawidłowy zakres w <ph id="ph5">&lt;paramref name="items" /&gt;</ph> <ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">Implementacja <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> spowodował błąd podczas sortowania.</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Na przykład <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> nie mogą zwracać 0, podczas porównywania elementu z samym sobą.</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>i co najmniej jeden element w <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> nie implementują <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">.NET Framework 4 i starszych wersji należy używać tylko algorytm Quicksort.</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Quicksort określa nieprawidłowy comparers w niektórych sytuacjach, w których zgłasza operacji <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> wyjątku i zgłasza <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> wyjątek do obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">Począwszy od <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, istnieje możliwość, że sortowanie operacji poprzednio zwrócił <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> nie spowoduje zgłoszenie wyjątku, ponieważ algorytmy sortowania i heapsort wstawiania nie wykrywaj nieprawidłowe porównania.</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">W większości przypadków dotyczy tablic o mniej niż 16 elementów.</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[])">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do sortowania.</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[])">
          <source>Sorts the elements in an entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element of the <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Sortuje elementów w całej <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> przy użyciu <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implementacji interfejsu ogólnego każdy element <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>Each element of <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
          <target state="translated">Każdy element <ph id="ph1">`array`</ph> musi implementować <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> ogólny interfejs umożliwiać porównania z każdego innego elementu w <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Jeśli rozmiar partycji jest mniej niż 16 elementów, używa <bpt id="p1">[</bpt>sortowania wstawiania<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Jeśli liczba partycji przekracza 2 * dziennika<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, gdzie <bpt id="p2">*</bpt>N<ept id="p2">*</ept> jest zakresu wartości tablicy wejściowej używa <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">W przeciwnym razie używa <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (<ph id="ph1">`n`</ph> dziennika <ph id="ph2">`n`</ph>) operację, której <ph id="ph3">`n`</ph> jest <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generic method overload.</source>
          <target state="translated">Poniższy przykład kodu pokazuje <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%29&gt;</ph> przeciążenia metody rodzajowej i <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> przeciążenia metody rodzajowej.</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>An array of strings is created, in no particular order.</source>
          <target state="translated">Tablica ciągów jest tworzony w określonej kolejności.</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The array is displayed, sorted, and displayed again.</source>
          <target state="translated">Tablica jest wyświetlana, sortowana i ponownie wyświetlana.</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Wywołania <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> metody rodzajowe nie wygląda inaczej z wywołań, aby ich odpowiedniki nierodzajowe, ponieważ Visual Basic, C# i C++ wnioskować o typie parametru typu ogólnego z typem pierwszego argumentu.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Jeśli używasz <bpt id="p1">[</bpt>Ildasm.exe (dezasembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> zbadać język pośredni firmy Microsoft (MSIL), widoczny wywoływane metody ogólne.</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generic method overload is then used to search for two strings, one that is not in the array and one that is.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> Przeciążenia metody rodzajowej jest następnie używany do wyszukiwania dwa ciągi, jest taki, który nie znajduje się w tablicy i jeden który.</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The array and the return value of the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method are passed to the <ph id="ph2">`ShowWhere`</ph> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</source>
          <target state="translated">Tablica i wartość zwracaną <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> metody są przekazywane do <ph id="ph2">`ShowWhere`</ph> ogólnego metodę, która zawiera wartość indeksu, jeśli ciąg zostanie znaleziony, a w przeciwnym razie elementy ciąg wyszukiwania spadnie między gdyby w tablicy.</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The index is negative if the string is not n the array, so the <ph id="ph1">`ShowWhere`</ph> method takes the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph> -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</source>
          <target state="translated">Indeks jest liczbą ujemną, jeśli ciąg nie jest n tablicy, więc <ph id="ph1">`ShowWhere`</ph> metoda przyjmuje dopełnienia bitowego (~ operatora w języku C# i Visual C++ <ph id="ph2">`Xor`</ph> -1 w języku Visual Basic) Aby uzyskać indeks pierwszego elementu na liście, który jest większy niż ściśle wyszukiwania NG.</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[])">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[])">
          <source>One or more elements in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Co najmniej jeden element w <ph id="ph1">&lt;paramref name="array" /&gt;</ph> nie implementują <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-base <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort</source>
          <target state="translated">Jednowymiarowa, zero-base <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do sortowania</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> Implementacji interfejsu ogólnego w celu używania przy porównywaniu elementy, lub <ph id="ph2">&lt;see langword="null" /&gt;</ph> do używania <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implementacji interfejsu ogólnego każdego elementu.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Sorts the elements in an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Sortuje elementów w <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> przy użyciu określonego <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element of <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">`comparer`</ph> jest <ph id="ph2">`null`</ph>, każdy element <ph id="ph3">`array`</ph> musi implementować <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> ogólny interfejs umożliwiać porównania z każdego innego elementu w <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Jeśli rozmiar partycji jest mniej niż 16 elementów, używa <bpt id="p1">[</bpt>sortowania wstawiania<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Jeśli liczba partycji przekracza 2 * dziennika<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, gdzie <bpt id="p2">*</bpt>N<ept id="p2">*</ept> jest zakresu wartości tablicy wejściowej używa <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">W przeciwnym razie używa <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana.</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (<ph id="ph1">`n`</ph> dziennika <ph id="ph2">`n`</ph>) operację, której <ph id="ph3">`n`</ph> jest <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload.</source>
          <target state="translated">Poniższy przykład kodu pokazuje <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> przeciążenia metody rodzajowej i <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> przeciążenia metody rodzajowej.</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">Przykładowy kod definiuje alternatywny porównania ciągów o nazwie <ph id="ph1">`ReverseCompare`</ph>, który implementuje <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> w języku Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> w programie Visual C++) interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Moduł porównujący wywołania <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> metody odwracanie kolejności comparands, dzięki czemu ciągi sortowania dużej do minimum zamiast niskiego na wysoki.</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The array is displayed, sorted, and displayed again.</source>
          <target state="translated">Tablica jest wyświetlana, sortowana i ponownie wyświetlana.</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Arrays must be sorted in order to use the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method.</source>
          <target state="translated">Tablice muszą być posortowane w celu użycia <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Wywołania <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> metody rodzajowe nie wygląda inaczej z wywołań, aby ich odpowiedniki nierodzajowe, ponieważ Visual Basic, C# i C++ wnioskować o typie parametru typu ogólnego z typem pierwszego argumentu.</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Jeśli używasz <bpt id="p1">[</bpt>Ildasm.exe (dezasembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> zbadać język pośredni firmy Microsoft (MSIL), widoczny wywoływane metody ogólne.</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload is then used to search for two strings, one that is not in the array and one that is.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Przeciążenia metody rodzajowej jest następnie używany do wyszukiwania dwa ciągi, jest taki, który nie znajduje się w tablicy i jeden który.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The array and the return value of the <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> method are passed to the <ph id="ph2">`ShowWhere`</ph> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</source>
          <target state="translated">Tablica i wartość zwracaną <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> metody są przekazywane do <ph id="ph2">`ShowWhere`</ph> ogólnego metodę, która zawiera wartość indeksu, jeśli ciąg zostanie znaleziony, a w przeciwnym razie elementy ciąg wyszukiwania spadnie między gdyby w tablicy.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The index is negative if the string is not n the array, so the <ph id="ph1">`ShowWhere`</ph> method takes the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph> -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</source>
          <target state="translated">Indeks jest liczbą ujemną, jeśli ciąg nie jest n tablicy, więc <ph id="ph1">`ShowWhere`</ph> metoda przyjmuje dopełnienia bitowego (~ operatora w języku C# i Visual C++ <ph id="ph2">`Xor`</ph> -1 w języku Visual Basic) Aby uzyskać indeks pierwszego elementu na liście, który jest większy niż ściśle wyszukiwania NG.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>i co najmniej jeden element w <ph id="ph3">&lt;paramref name="array" /&gt;</ph> nie implementują <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">Implementacja <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> spowodował błąd podczas sortowania.</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Na przykład <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> nie mogą zwracać 0, podczas porównywania elementu z samym sobą.</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">.NET Framework 4 i starszych wersji należy używać tylko algorytm Quicksort.</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Quicksort określa nieprawidłowy comparers w niektórych sytuacjach, w których zgłasza operacji <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> wyjątku i zgłasza <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> wyjątek do obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">Począwszy od <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, istnieje możliwość, że sortowanie operacji poprzednio zwrócił <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> nie spowoduje zgłoszenie wyjątku, ponieważ algorytmy sortowania i heapsort wstawiania nie wykrywaj nieprawidłowe porównania.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">W większości przypadków dotyczy tablic o mniej niż 16 elementów.</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> sortowania</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Comparison`1" /&gt;</ph> to use when comparing elements.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Comparison`1" /&gt;</ph> Do użycia podczas porównywania elementów.</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Sorts the elements in an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Comparison`1" /&gt;</ph>.</source>
          <target state="translated">Sortuje elementów w <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> przy użyciu określonego <ph id="ph2">&lt;see cref="T:System.Comparison`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>This method uses introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Ta metoda używa algorytmu introspective sortowania (introsort) w następujący sposób:</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Jeśli rozmiar partycji jest mniej niż 16 elementów, używa <bpt id="p1">[</bpt>sortowania wstawiania<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Jeśli liczba partycji przekracza 2 * dziennika<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, gdzie <bpt id="p2">*</bpt>N<ept id="p2">*</ept> jest zakresu wartości tablicy wejściowej używa <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">W przeciwnym razie używa <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana.</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (<ph id="ph1">`n`</ph> dziennika <ph id="ph2">`n`</ph>) operację, której <ph id="ph3">`n`</ph> jest <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29&gt;</ph> method overload.</source>
          <target state="translated">Poniższy przykład kodu pokazuje <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29&gt;</ph> przeciążenie metody.</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The code example defines an alternative comparison method for strings, named <ph id="ph1">`CompareDinosByLength`</ph>.</source>
          <target state="translated">Przykładowy kod definiuje metodę porównywania alternatywne ciągi, o nazwie <ph id="ph1">`CompareDinosByLength`</ph>.</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>This method works as follows: First, the comparandsare tested for<ph id="ph1">`null`</ph>, and a null reference is treated as less than a non-null.</source>
          <target state="translated">Ta metoda działa w następujący sposób: najpierw comparandsare sprawdzane pod kątem<ph id="ph1">`null`</ph>, odwołanie o wartości null jest traktowany jako mniejsza niż inne niż null.</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Second, the string lengths are compared, and the longer string is deemed to be greater.</source>
          <target state="translated">Po drugie długości ciągu zostaną porównane, a ciąg dłuższy jest uważany większa.</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Third, if the lengths are equal, ordinary string comparison is used.</source>
          <target state="translated">Trzecie Jeśli długości są takie same, porównania ciągów zwykłej jest używany.</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>A array of strings is created and populated with four strings, in no particular order.</source>
          <target state="translated">Tablica ciągów jest tworzony i wypełniane przy użyciu czterech ciągów, w określonej kolejności.</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The list also includes an empty string and a null reference.</source>
          <target state="translated">Lista zawiera także pustego ciągu i odwołanie o wartości null.</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The list is displayed, sorted using a <ph id="ph1">&lt;xref:System.Comparison%601&gt;</ph> generic delegate representing the <ph id="ph2">`CompareDinosByLength`</ph> method, and displayed again.</source>
          <target state="translated">Zostanie wyświetlona lista sortowane przy użyciu <ph id="ph1">&lt;xref:System.Comparison%601&gt;</ph> Delegat ogólny reprezentujący <ph id="ph2">`CompareDinosByLength`</ph> metody i ponownie wyświetlone.</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source><ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">Implementacja <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> spowodował błąd podczas sortowania.</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Na przykład <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> nie mogą zwracać 0, podczas porównywania elementu z samym sobą.</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">.NET Framework 4 i starszych wersji należy używać tylko algorytm Quicksort.</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Quicksort określa nieprawidłowy comparers w niektórych sytuacjach, w których zgłasza operacji <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> wyjątku i zgłasza <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> wyjątek do obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">Począwszy od <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, istnieje możliwość, że sortowanie operacji poprzednio zwrócił <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> nie spowoduje zgłoszenie wyjątku, ponieważ algorytmy sortowania i heapsort wstawiania nie wykrywaj nieprawidłowe porównania.</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">W większości przypadków dotyczy tablic o mniej niż 16 elementów.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> sortowania</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Indeks początkowy zakresu do sortowania.</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Liczba elementów w zakresie do sortowania.</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>Sorts the elements in a range of elements in an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element of the <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Sortuje elementy w zakresie elementów w <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> przy użyciu <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implementacji interfejsu ogólnego każdy element <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>Each element within the specified range of elements in <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
          <target state="translated">Każdy element określonego zakresu elementów w <ph id="ph1">`array`</ph> musi implementować <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> ogólny interfejs umożliwiać porównania z każdego innego elementu w <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Jeśli rozmiar partycji jest mniej niż 16 elementów, używa <bpt id="p1">[</bpt>sortowania wstawiania<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Jeśli liczba partycji przekracza 2 * dziennika<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, gdzie <bpt id="p2">*</bpt>N<ept id="p2">*</ept> jest zakresu wartości tablicy wejściowej używa <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">W przeciwnym razie używa <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana.</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (<ph id="ph1">`n`</ph> dziennika <ph id="ph2">`n`</ph>) operację, której <ph id="ph3">`n`</ph> jest <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload for sorting a range in an array.</source>
          <target state="translated">Poniższy przykład kodu pokazuje <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> przeciążenia metody rodzajowej i <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> przeciążenia metody ogólnej sortowania zakresu w tablicy.</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">Przykładowy kod definiuje alternatywny porównania ciągów o nazwie <ph id="ph1">`ReverseCompare`</ph>, który implementuje <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> w języku Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> w programie Visual C++) interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Moduł porównujący wywołania <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> metody odwracanie kolejności comparands, dzięki czemu ciągi sortowania dużej do minimum zamiast niskiego na wysoki.</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The code example creates and displays an array of dinosaur names, consisting of three herbivores followed by three carnivores (tyrannosaurids, to be precise).</source>
          <target state="translated">Przykład kodu tworzy i wyświetla tablicę nazw kolorowanka, składające się z trzech zwierząt roślinożernych następują trzy mięsożerców (tyrannosaurids, aby była precyzyjna).</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generic method overload is used to sort the last three elements of the array, which is then displayed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Przeciążenia metody rodzajowej jest używane do sortowania ostatnie trzy elementy tablicy, która jest następnie wyświetlana.</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload is used with <ph id="ph2">`ReverseCompare`</ph> to sort the last three elements in reverse order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Przeciążenia metody rodzajowej jest używany z <ph id="ph2">`ReverseCompare`</ph> w odwrotnej kolejności sortowania ostatnie trzy elementy.</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The thoroughly confused dinosaurs are displayed again.</source>
          <target state="translated">Dokładnie mylić dinozaurów są wyświetlane ponownie.</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Wywołania <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> metody rodzajowe nie wygląda inaczej z wywołań, aby ich odpowiedniki nierodzajowe, ponieważ Visual Basic, C# i C++ wnioskować o typie parametru typu ogólnego z typem pierwszego argumentu.</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Jeśli używasz <bpt id="p1">[</bpt>Ildasm.exe (dezasembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> zbadać język pośredni firmy Microsoft (MSIL), widoczny wywoływane metody ogólne.</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> jest mniejsza niż dolna granica <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> i <ph id="ph2">&lt;paramref name="length" /&gt;</ph> nie zostanie określony prawidłowy zakres w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>One or more elements in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Co najmniej jeden element w <ph id="ph1">&lt;paramref name="array" /&gt;</ph> nie implementują <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> do sortowania.</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Indeks początkowy zakresu do sortowania.</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Liczba elementów w zakresie do sortowania.</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> Implementacji interfejsu ogólnego w celu używania przy porównywaniu elementy, lub <ph id="ph2">&lt;see langword="null" /&gt;</ph> do używania <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implementacji interfejsu ogólnego każdego elementu.</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Sorts the elements in a range of elements in an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Sortuje elementy w zakresie elementów w <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> przy użyciu określonego <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element within the specified range of elements in <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">`comparer`</ph> jest <ph id="ph2">`null`</ph>, każdy element określonego zakresu elementów w <ph id="ph3">`array`</ph> musi implementować <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> ogólny interfejs umożliwiać porównania z każdego innego elementu w <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Jeśli rozmiar partycji jest mniej niż 16 elementów, używa <bpt id="p1">[</bpt>sortowania wstawiania<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Jeśli liczba partycji przekracza 2 * dziennika<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, gdzie <bpt id="p2">*</bpt>N<ept id="p2">*</ept> jest zakresu wartości tablicy wejściowej używa <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">W przeciwnym razie używa <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana.</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (<ph id="ph1">`n`</ph> dziennika <ph id="ph2">`n`</ph>) operację, której <ph id="ph3">`n`</ph> jest <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload for sorting a range in an array.</source>
          <target state="translated">Poniższy przykład kodu pokazuje <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> przeciążenia metody rodzajowej i <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> przeciążenia metody ogólnej sortowania zakresu w tablicy.</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">Przykładowy kod definiuje alternatywny porównania ciągów o nazwie <ph id="ph1">`ReverseCompare`</ph>, który implementuje <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> w języku Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> w programie Visual C++) interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Moduł porównujący wywołania <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> metody odwracanie kolejności comparands, dzięki czemu ciągi sortowania dużej do minimum zamiast niskiego na wysoki.</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The code example creates and displays an array of dinosaur names, consisting of three herbivores followed by three carnivores (tyrannosaurids, to be precise).</source>
          <target state="translated">Przykład kodu tworzy i wyświetla tablicę nazw kolorowanka, składające się z trzech zwierząt roślinożernych następują trzy mięsożerców (tyrannosaurids, aby była precyzyjna).</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generic method overload is used to sort the last three elements of the array, which is then displayed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Przeciążenia metody rodzajowej jest używane do sortowania ostatnie trzy elementy tablicy, która jest następnie wyświetlana.</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload is used with <ph id="ph2">`ReverseCompare`</ph> to sort the last three elements in reverse order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Przeciążenia metody rodzajowej jest używany z <ph id="ph2">`ReverseCompare`</ph> w odwrotnej kolejności sortowania ostatnie trzy elementy.</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The thoroughly confused dinosaurs are displayed again.</source>
          <target state="translated">Dokładnie mylić dinozaurów są wyświetlane ponownie.</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Wywołania <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> i <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> metody rodzajowe nie wygląda inaczej z wywołań, aby ich odpowiedniki nierodzajowe, ponieważ Visual Basic, C# i C++ wnioskować o typie parametru typu ogólnego z typem pierwszego argumentu.</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Jeśli używasz <bpt id="p1">[</bpt>Ildasm.exe (dezasembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> zbadać język pośredni firmy Microsoft (MSIL), widoczny wywoływane metody ogólne.</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> jest mniejsza niż dolna granica <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> i <ph id="ph2">&lt;paramref name="length" /&gt;</ph> nie zostanie określony prawidłowy zakres w <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">Implementacja <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> spowodował błąd podczas sortowania.</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Na przykład <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> nie mogą zwracać 0, podczas porównywania elementu z samym sobą.</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>i co najmniej jeden element w <ph id="ph3">&lt;paramref name="array" /&gt;</ph> nie implementują <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">.NET Framework 4 i starszych wersji należy używać tylko algorytm Quicksort.</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Quicksort określa nieprawidłowy comparers w niektórych sytuacjach, w których zgłasza operacji <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> wyjątku i zgłasza <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> wyjątek do obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">Począwszy od <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, istnieje możliwość, że sortowanie operacji poprzednio zwrócił <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> nie spowoduje zgłoszenie wyjątku, ponieważ algorytmy sortowania i heapsort wstawiania nie wykrywaj nieprawidłowe porównania.</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">W większości przypadków dotyczy tablic o mniej niż 16 elementów.</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The type of the elements of the key array.</source>
          <target state="translated">Typ elementów tablicy klucza.</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The type of the elements of the items array.</source>
          <target state="translated">Typ elementów tablicy elementów.</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zawierającą klucze ze słownika do sortowania.</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to sort only <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zawiera elementy, które muszą być w <bpt id="p1">&lt;c&gt;</bpt>klucze<ept id="p1">&lt;/c&gt;</ept>, lub <ph id="ph2">&lt;see langword="null" /&gt;</ph> sortowania tylko <bpt id="p2">&lt;c&gt;</bpt>klucze<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Sorts a pair of <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each key.</source>
          <target state="translated">Sortuje para <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> obiektów (jeden zawiera klucze, a drugi zawiera odpowiednie elementy) oparte na klucze w pierwszym <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> przy użyciu <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implementacji interfejsu ogólnego każdego klucza.</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> ma odpowiadający mu element w <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Po klucz zostaje przeniesiony podczas sortowania, odpowiadający mu element w <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> podobnie ponownie.</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">W związku z tym <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> jest sortowana według rozmieszczenia odpowiadające im klucze w <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> musi implementować <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> ogólny interfejs umożliwiać porównania z każdym innym kluczem.</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które mają nie odpowiadające im klucze nie będą sortowane.</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Jeśli rozmiar partycji jest mniej niż 16 elementów, używa <bpt id="p1">[</bpt>sortowania wstawiania<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Jeśli liczba partycji przekracza 2 * dziennika<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, gdzie <bpt id="p2">*</bpt>N<ept id="p2">*</ept> jest zakresu wartości tablicy wejściowej używa <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">W przeciwnym razie używa <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana.</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (<ph id="ph1">`n`</ph> dziennika <ph id="ph2">`n`</ph>) operację, której <ph id="ph3">`n`</ph> jest <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, and <ph id="ph4">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overloads, for sorting pairs of arrays that represent keys and values.</source>
          <target state="translated">Poniższy przykład kodu pokazuje <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, i <ph id="ph4">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> przeciążenia metody ogólnej, do sortowania par tablicami reprezentującymi kluczy i wartości.</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">Przykładowy kod definiuje alternatywny porównania ciągów o nazwie <ph id="ph1">`ReverseCompare`</ph>, który implementuje <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> w języku Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> w programie Visual C++) interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Moduł porównujący wywołania <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> metody odwracanie kolejności comparands, dzięki czemu ciągi sortowania dużej do minimum zamiast niskiego na wysoki.</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</source>
          <target state="translated">Przykład kodu tworzy i wyświetla tablicę nazw kolorowanka (klucze) i tablica liczb całkowitych reprezentująca maksymalną długość każdej kolorowanka metry (wartości).</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The arrays are then sorted and displayed several times:</source>
          <target state="translated">Tablice są następnie wyświetlania i sortowania kilka razy:</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload is used to sort both arrays in order of the dinosaur names in the first array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> Przeciążenie umożliwia sortowanie tablic, zarówno w kolejności nazw kolorowanka w pierwszym tablicy.</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload and an instance of <ph id="ph2">`ReverseCompare`</ph> are used to reverse the sort order of the paired arrays.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Przeciążenia i wystąpienie <ph id="ph2">`ReverseCompare`</ph> służą do odwracania kolejności sortowania par tablic.</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is used to sort the last three elements of both arrays.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Przeciążenia jest używane do sortowania ostatnie trzy elementy zarówno tablic.</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload is used to sort the last three elements of both arrays in reverse order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Przeciążenia jest używane do sortowania ostatnie trzy elementy zarówno tablic w odwrotnej kolejności.</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</source>
          <target state="translated">Wywołań metody rodzajowe nie wygląda inaczej z wywołań, aby ich odpowiedniki nierodzajowe, ponieważ Visual Basic, C# i C++ wnioskować o typie parametru typu ogólnego z pierwszych dwóch argumentów typu.</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Jeśli używasz <bpt id="p1">[</bpt>Ildasm.exe (dezasembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> zbadać język pośredni firmy Microsoft (MSIL), widoczny wywoływane metody ogólne.</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> nie jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>oraz dolną granicę <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> jest niezgodny z dolną granicę <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> nie jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, a długość <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> jest większa niż długość <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>One or more elements in the <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Co najmniej jeden element w <ph id="ph1">&lt;paramref name="keys" /&gt;</ph> <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> nie implementują <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the key array.</source>
          <target state="translated">Typ elementów tablicy klucza.</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the items array.</source>
          <target state="translated">Typ elementów tablicy elementów.</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zawierającą klucze ze słownika do sortowania.</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to sort only <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zawiera elementy, które muszą być w <bpt id="p1">&lt;c&gt;</bpt>klucze<ept id="p1">&lt;/c&gt;</ept>, lub <ph id="ph2">&lt;see langword="null" /&gt;</ph> sortowania tylko <bpt id="p2">&lt;c&gt;</bpt>klucze<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> Implementacji interfejsu ogólnego w celu używania przy porównywaniu elementy, lub <ph id="ph2">&lt;see langword="null" /&gt;</ph> do używania <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implementacji interfejsu ogólnego każdego elementu.</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Sorts a pair of <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Sortuje para <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> obiektów (jeden zawiera klucze, a drugi zawiera odpowiednie elementy) oparte na klucze w pierwszym <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> przy użyciu określonego <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> ma odpowiadający mu element w <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Po klucz zostaje przeniesiony podczas sortowania, odpowiadający mu element w <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> podobnie ponownie.</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">W związku z tym <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> jest sortowana według rozmieszczenia odpowiadające im klucze w <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
          <target state="translated">Jeśli <ph id="ph1">`comparer`</ph> jest <ph id="ph2">`null`</ph>, każdy klucz w <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph> musi implementować <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> ogólny interfejs umożliwiać porównania z każdym innym kluczem.</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które mają nie odpowiadające im klucze nie będą sortowane.</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Jeśli rozmiar partycji jest mniej niż 16 elementów, używa <bpt id="p1">[</bpt>sortowania wstawiania<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Jeśli liczba partycji przekracza 2 * dziennika<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, gdzie <bpt id="p2">*</bpt>N<ept id="p2">*</ept> jest zakresu wartości tablicy wejściowej używa <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">W przeciwnym razie używa <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana.</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (<ph id="ph1">`n`</ph> dziennika <ph id="ph2">`n`</ph>) operację, której <ph id="ph3">`n`</ph> jest <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, [<ph id="ph2">\]</ph>, TValue<ph id="ph3">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;,<ph id="ph4">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, and <ph id="ph5">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overloads, for sorting pairs of arrays that represent keys and values.</source>
          <target state="translated">Poniższy przykład kodu pokazuje <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, [<ph id="ph2">\]</ph>, TValue<ph id="ph3">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 &gt;,<ph id="ph4">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, i <ph id="ph5">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> przeciążenia metody ogólnej, do sortowania par tablicami reprezentującymi kluczy i wartości.</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">Przykładowy kod definiuje alternatywny porównania ciągów o nazwie <ph id="ph1">`ReverseCompare`</ph>, który implementuje <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> w języku Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> w programie Visual C++) interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Moduł porównujący wywołania <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> metody odwracanie kolejności comparands, dzięki czemu ciągi sortowania dużej do minimum zamiast niskiego na wysoki.</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</source>
          <target state="translated">Przykład kodu tworzy i wyświetla tablicę nazw kolorowanka (klucze) i tablica liczb całkowitych reprezentująca maksymalną długość każdej kolorowanka metry (wartości).</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The arrays are then sorted and displayed several times:</source>
          <target state="translated">Tablice są następnie wyświetlania i sortowania kilka razy:</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload is used to sort both arrays in order of the dinosaur names in the first array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> Przeciążenie umożliwia sortowanie tablic, zarówno w kolejności nazw kolorowanka w pierwszym tablicy.</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt; overload and an instance of <ph id="ph3">`ReverseCompare`</ph> are used to reverse the sort order of the paired arrays.</source>
          <target state="translated">[<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 &gt; przeciążenia i wystąpienie <ph id="ph3">`ReverseCompare`</ph> służą do odwracania kolejności sortowania sparowanego tablic.</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is used to sort the last three elements of both arrays.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Przeciążenia jest używane do sortowania ostatnie trzy elementy zarówno tablic.</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload is used to sort the last three elements of both arrays in reverse order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Przeciążenia jest używane do sortowania ostatnie trzy elementy zarówno tablic w odwrotnej kolejności.</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</source>
          <target state="translated">Wywołań metody rodzajowe nie wygląda inaczej z wywołań, aby ich odpowiedniki nierodzajowe, ponieważ Visual Basic, C# i C++ wnioskować o typie parametru typu ogólnego z pierwszych dwóch argumentów typu.</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Jeśli używasz <bpt id="p1">[</bpt>Ildasm.exe (dezasembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> zbadać język pośredni firmy Microsoft (MSIL), widoczny wywoływane metody ogólne.</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> nie jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>oraz dolną granicę <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> jest niezgodny z dolną granicę <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> nie jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, a długość <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> jest większa niż długość <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">Implementacja <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> spowodował błąd podczas sortowania.</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Na przykład <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> nie mogą zwracać 0, podczas porównywania elementu z samym sobą.</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph5">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>i co najmniej jeden element w <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> nie implementują <ph id="ph5">&lt;see cref="T:System.IComparable`1" /&gt;</ph> interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">.NET Framework 4 i starszych wersji należy używać tylko algorytm Quicksort.</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Quicksort określa nieprawidłowy comparers w niektórych sytuacjach, w których zgłasza operacji <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> wyjątku i zgłasza <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> wyjątek do obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">Począwszy od <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, istnieje możliwość, że sortowanie operacji poprzednio zwrócił <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> nie spowoduje zgłoszenie wyjątku, ponieważ algorytmy sortowania i heapsort wstawiania nie wykrywaj nieprawidłowe porównania.</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">W większości przypadków dotyczy tablic o mniej niż 16 elementów.</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The type of the elements of the key array.</source>
          <target state="translated">Typ elementów tablicy klucza.</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The type of the elements of the items array.</source>
          <target state="translated">Typ elementów tablicy elementów.</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zawierającą klucze ze słownika do sortowania.</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to sort only <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zawiera elementy, które muszą być w <bpt id="p1">&lt;c&gt;</bpt>klucze<ept id="p1">&lt;/c&gt;</ept>, lub <ph id="ph2">&lt;see langword="null" /&gt;</ph> sortowania tylko <bpt id="p2">&lt;c&gt;</bpt>klucze<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Indeks początkowy zakresu do sortowania.</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Liczba elementów w zakresie do sortowania.</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Sorts a range of elements in a pair of <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each key.</source>
          <target state="translated">Zakres elementów w parze <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> obiektów (jeden zawiera klucze, a drugi zawiera odpowiednie elementy) oparte na klucze w pierwszym <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> przy użyciu <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implementacji interfejsu ogólnego każdego klucza.</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> ma odpowiadający mu element w <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Po klucz zostaje przeniesiony podczas sortowania, odpowiadający mu element w <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> podobnie ponownie.</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">W związku z tym <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> jest sortowana według rozmieszczenia odpowiadające im klucze w <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Each key within the specified range of elements in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
          <target state="translated">Każdy klucz określonego zakresu elementów w <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> musi implementować <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> ogólny interfejs umożliwiać porównania z każdym innym kluczem.</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które mają nie odpowiadające im klucze nie będą sortowane.</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Jeśli rozmiar partycji jest mniej niż 16 elementów, używa <bpt id="p1">[</bpt>sortowania wstawiania<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Jeśli liczba partycji przekracza 2 * dziennika<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, gdzie <bpt id="p2">*</bpt>N<ept id="p2">*</ept> jest zakresu wartości tablicy wejściowej używa <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">W przeciwnym razie używa <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana.</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (<ph id="ph1">`n`</ph> dziennika <ph id="ph2">`n`</ph>) operację, której <ph id="ph3">`n`</ph> jest <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, [<ph id="ph3">\]</ph>, TValue<ph id="ph4">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;, and <ph id="ph5">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overloads, for sorting pairs of arrays that represent keys and values.</source>
          <target state="translated">Poniższy przykład kodu pokazuje <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, [<ph id="ph3">\]</ph>, TValue<ph id="ph4">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 &gt;, a <ph id="ph5">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> przeciążenia metody ogólnej do sortowania par tablicami reprezentującymi kluczy i wartości.</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">Przykładowy kod definiuje alternatywny porównania ciągów o nazwie <ph id="ph1">`ReverseCompare`</ph>, który implementuje <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> w języku Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> w programie Visual C++) interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Moduł porównujący wywołania <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> metody odwracanie kolejności comparands, dzięki czemu ciągi sortowania dużej do minimum zamiast niskiego na wysoki.</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</source>
          <target state="translated">Przykład kodu tworzy i wyświetla tablicę nazw kolorowanka (klucze) i tablica liczb całkowitych reprezentująca maksymalną długość każdej kolorowanka metry (wartości).</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The arrays are then sorted and displayed several times:</source>
          <target state="translated">Tablice są następnie wyświetlania i sortowania kilka razy:</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload is used to sort both arrays in order of the dinosaur names in the first array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> Przeciążenie umożliwia sortowanie tablic, zarówno w kolejności nazw kolorowanka w pierwszym tablicy.</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload and an instance of <ph id="ph2">`ReverseCompare`</ph> are used to reverse the sort order of the paired arrays.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Przeciążenia i wystąpienie <ph id="ph2">`ReverseCompare`</ph> służą do odwracania kolejności sortowania par tablic.</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt; overload is used to sort the last three elements of both arrays.</source>
          <target state="translated">[<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 &gt; przeciążenia jest używane do sortowania ostatnie trzy elementy zarówno tablic.</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload is used to sort the last three elements of both arrays in reverse order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Przeciążenia jest używane do sortowania ostatnie trzy elementy zarówno tablic w odwrotnej kolejności.</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</source>
          <target state="translated">Wywołań metody rodzajowe nie wygląda inaczej z wywołań, aby ich odpowiedniki nierodzajowe, ponieważ Visual Basic, C# i C++ wnioskować o typie parametru typu ogólnego z pierwszych dwóch argumentów typu.</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Jeśli używasz <bpt id="p1">[</bpt>Ildasm.exe (dezasembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> zbadać język pośredni firmy Microsoft (MSIL), widoczny wywoływane metody ogólne.</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> jest mniejsza niż dolna granica <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> nie jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>oraz dolną granicę <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> jest niezgodny z dolną granicę <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> nie jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, a długość <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> jest większa niż długość <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> i <ph id="ph2">&lt;paramref name="length" /&gt;</ph> nie zostanie określony prawidłowy zakres w <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="index" /&gt;</ph> and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> nie jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, i <ph id="ph3">&lt;paramref name="index" /&gt;</ph> i <ph id="ph4">&lt;paramref name="length" /&gt;</ph> nie zostanie określony prawidłowy zakres w <ph id="ph5">&lt;paramref name="items" /&gt;</ph> <ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>One or more elements in the <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Co najmniej jeden element w <ph id="ph1">&lt;paramref name="keys" /&gt;</ph> <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> nie implementują <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the key array.</source>
          <target state="translated">Typ elementów tablicy klucza.</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the items array.</source>
          <target state="translated">Typ elementów tablicy elementów.</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zawierającą klucze ze słownika do sortowania.</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to sort only <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zawiera elementy, które muszą być w <bpt id="p1">&lt;c&gt;</bpt>klucze<ept id="p1">&lt;/c&gt;</ept>, lub <ph id="ph2">&lt;see langword="null" /&gt;</ph> sortowania tylko <bpt id="p2">&lt;c&gt;</bpt>klucze<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Indeks początkowy zakresu do sortowania.</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Liczba elementów w zakresie do sortowania.</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> Implementacji interfejsu ogólnego w celu używania przy porównywaniu elementy, lub <ph id="ph2">&lt;see langword="null" /&gt;</ph> do używania <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implementacji interfejsu ogólnego każdego elementu.</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Sorts a range of elements in a pair of <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Zakres elementów w parze <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> obiektów (jeden zawiera klucze, a drugi zawiera odpowiednie elementy) oparte na klucze w pierwszym <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> przy użyciu określonego <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Każdy klucz w <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> ma odpowiadający mu element w <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Po klucz zostaje przeniesiony podczas sortowania, odpowiadający mu element w <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> podobnie ponownie.</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">W związku z tym <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> jest sortowana według rozmieszczenia odpowiadające im klucze w <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key within the specified range of elements in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
          <target state="translated">Jeśli <ph id="ph1">`comparer`</ph> jest <ph id="ph2">`null`</ph>, każdy klucz określonego zakresu elementów w <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph> musi implementować <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> ogólny interfejs umożliwiać porównania z każdym innym kluczem.</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Można sortować, jeśli istnieje więcej elementów niż klucze, ale elementy, które mają nie odpowiadające im klucze nie będą sortowane.</target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Nie można sortować, jeśli istnieją kluczy więcej niż elementów. Spowoduje to zgłasza <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Jeśli sortowanie nie zostało ukończone pomyślnie, wyniki są niezdefiniowane.</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Ta metoda używa algorytmu sortowania introspektywnego w następujący sposób:</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Jeśli rozmiar partycji jest mniej niż 16 elementów, używa <bpt id="p1">[</bpt>sortowania wstawiania<ept id="p1">](http://en.wikipedia.org/wiki/Insertion_sort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Jeśli liczba partycji przekracza 2 * dziennika<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, gdzie <bpt id="p2">*</bpt>N<ept id="p2">*</ept> jest zakresu wartości tablicy wejściowej używa <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">W przeciwnym razie używa <bpt id="p1">[</bpt>Quicksort<ept id="p1">](http://en.wikipedia.org/wiki/Quicksort)</ept> algorytmu.</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana.</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Dla tablic, które są sortowane przy użyciu algorytmów Heapsort i Quicksort w najgorszym przypadku ta metoda jest O (<ph id="ph1">`n`</ph> dziennika <ph id="ph2">`n`</ph>) operację, której <ph id="ph3">`n`</ph> jest <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, and [<ph id="ph4">\]</ph>, TValue<ph id="ph5">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt; generic method overloads, for sorting pairs of arrays that represent keys and values.</source>
          <target state="translated">Poniższy przykład kodu pokazuje <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, a [<ph id="ph4">\]</ph>, TValue<ph id="ph5">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32% 2CSystem.Collections.Generic.IComparer%7b%60%600%7D%29 &gt; przeciążenia metody ogólnej, do sortowania par tablicami reprezentującymi kluczy i wartości.</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph>(<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">Przykładowy kod definiuje alternatywny porównania ciągów o nazwie <ph id="ph1">`ReverseCompare`</ph>, który implementuje <ph id="ph2">`IComparer&lt;string&gt;`</ph>(<ph id="ph3">`IComparer(Of String)`</ph> w języku Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> w programie Visual C++) interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Moduł porównujący wywołania <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> metody odwracanie kolejności comparands, dzięki czemu ciągi sortowania dużej do minimum zamiast niskiego na wysoki.</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</source>
          <target state="translated">Przykład kodu tworzy i wyświetla tablicę nazw kolorowanka (klucze) i tablica liczb całkowitych reprezentująca maksymalną długość każdej kolorowanka metry (wartości).</target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The arrays are then sorted and displayed several times:</source>
          <target state="translated">Tablice są następnie wyświetlania i sortowania kilka razy:</target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload is used to sort both arrays in order of the dinosaur names in the first array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> Przeciążenie umożliwia sortowanie tablic, zarówno w kolejności nazw kolorowanka w pierwszym tablicy.</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload and an instance of <ph id="ph2">`ReverseCompare`</ph> are used to reverse the sort order of the paired arrays.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Przeciążenia i wystąpienie <ph id="ph2">`ReverseCompare`</ph> służą do odwracania kolejności sortowania par tablic.</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is used to sort the last three elements of both arrays.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Przeciążenia jest używane do sortowania ostatnie trzy elementy zarówno tablic.</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt; overload is used to sort the last three elements of both arrays in reverse order.</source>
          <target state="translated">[<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 &gt; przeciążenia jest używane do sortowania ostatnich trzech oba elementy stałych w odwrotnej kolejności.</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</source>
          <target state="translated">Wywołań metody rodzajowe nie wygląda inaczej z wywołań, aby ich odpowiedniki nierodzajowe, ponieważ Visual Basic, C# i C++ wnioskować o typie parametru typu ogólnego z pierwszych dwóch argumentów typu.</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Jeśli używasz <bpt id="p1">[</bpt>Ildasm.exe (dezasembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> zbadać język pośredni firmy Microsoft (MSIL), widoczny wywoływane metody ogólne.</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> jest mniejsza niż dolna granica <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> nie jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>oraz dolną granicę <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> jest niezgodny z dolną granicę <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> nie jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, a długość <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> jest większa niż długość <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> i <ph id="ph2">&lt;paramref name="length" /&gt;</ph> nie zostanie określony prawidłowy zakres w <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="index" /&gt;</ph> and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> nie jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, i <ph id="ph3">&lt;paramref name="index" /&gt;</ph> i <ph id="ph4">&lt;paramref name="length" /&gt;</ph> nie zostanie określony prawidłowy zakres w <ph id="ph5">&lt;paramref name="items" /&gt;</ph> <ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">Implementacja <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> spowodował błąd podczas sortowania.</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Na przykład <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> nie mogą zwracać 0, podczas porównywania elementu z samym sobą.</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph5">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>i co najmniej jeden element w <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> nie implementują <ph id="ph5">&lt;see cref="T:System.IComparable`1" /&gt;</ph> interfejs generyczny.</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">.NET Framework 4 i starszych wersji należy używać tylko algorytm Quicksort.</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">Quicksort określa nieprawidłowy comparers w niektórych sytuacjach, w których zgłasza operacji <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> wyjątku i zgłasza <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> wyjątek do obiektu wywołującego.</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">Począwszy od <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, istnieje możliwość, że sortowanie operacji poprzednio zwrócił <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> nie spowoduje zgłoszenie wyjątku, ponieważ algorytmy sortowania i heapsort wstawiania nie wykrywaj nieprawidłowe porównania.</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">W większości przypadków dotyczy tablic o mniej niż 16 elementów.</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" uid="P:System.Array.SyncRoot">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Pobiera obiekt, który może służyć do synchronizujący dostęp do <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>An object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Obiekt, który może służyć do synchronizujący dostęp do <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>This property implements the <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated">Ta właściwość implementuje <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>.NET Framework classes based on <ph id="ph1">&lt;xref:System.Array&gt;</ph> provide their own synchronized version of the collection using the <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Na podstawie klasy .NET framework <ph id="ph1">&lt;xref:System.Array&gt;</ph> Udostępnij własnych zsynchronizowaną wersję w kolekcji przy użyciu <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Classes that use arrays can also implement their own synchronization using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Klasy korzystające tablice można też wdrożyć za pomocą ich własnych synchronizacji <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>The synchronizing code must perform operations on the <ph id="ph1">`SyncRoot`</ph> of the collection, not directly on the collection.</source>
          <target state="translated">Synchronizowanie kodu musi wykonywać operacje <ph id="ph1">`SyncRoot`</ph> kolekcji, a nie bezpośrednio w kolekcji.</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">Gwarantuje to prawidłowe funkcjonowanie kolekcji, które są uzyskiwane z innych obiektów.</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.</source>
          <target state="translated">W szczególności przechowuje prawidłowego synchronizacji z innych wątków, które mogą być jednocześnie modyfikowania kolekcji.</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Note that some implementations of <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> might return the <ph id="ph2">&lt;xref:System.Array&gt;</ph> itself.</source>
          <target state="translated">Należy pamiętać, że niektóre implementacje <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> może zwrócić <ph id="ph2">&lt;xref:System.Array&gt;</ph> samej siebie.</target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">Wyliczanie za pomocą kolekcji leżą nie jest procedurą bezpieczne wątku.</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający.</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Pobieranie wartości tej właściwości jest operacją O(1).</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>The following code example shows how to lock an array during the entire enumeration by using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, jak można zablokować tablicy podczas wyliczania całego przy użyciu <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#ICollection#Count">
          <source>Gets the number of elements contained in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Pobiera liczbę elementów zawartych w <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#ICollection#Count">
          <source>The number of elements contained in the collection.</source>
          <target state="translated">Liczba elementów zawartych w kolekcji.</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#ICollection#Count">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ten element jest jawną implementacją członków.</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#ICollection#Count">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> interface.</source>
          <target state="translated">Można go używać tylko wtedy, gdy <ph id="ph1">&lt;xref:System.Array&gt;</ph> wystąpienia jest rzutowane na <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>The object to be added to the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Obiekt do dodania do <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>Calling this method always throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> exception.</source>
          <target state="translated">Wywołanie tej metody zawsze zwraca <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> wyjątku.</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>Adding a value to an array is not supported.</source>
          <target state="translated">Dodanie wartości do tablicy nie jest obsługiwana.</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>No value is returned.</source>
          <target state="translated">Nie jest zwracana żadna wartość.</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>Ordinarily, an <ph id="ph1">&lt;xref:System.Collections.IList.Add%2A?displayProperty=nameWithType&gt;</ph> implementation adds a member to a collection.</source>
          <target state="translated">Zwykle <ph id="ph1">&lt;xref:System.Collections.IList.Add%2A?displayProperty=nameWithType&gt;</ph> implementacji dodaje element członkowski do kolekcji.</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>However, because arrays have a fixed size (the <ph id="ph1">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> property always returns <ph id="ph2">`true`</ph>), this method always throws a <ph id="ph3">&lt;xref:System.NotSupportedException&gt;</ph> exception.</source>
          <target state="translated">Jednak ponieważ tablice o stałym rozmiarze ( <ph id="ph1">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> właściwość zawsze zwraca <ph id="ph2">`true`</ph>), ta metoda zawsze zwraca <ph id="ph3">&lt;xref:System.NotSupportedException&gt;</ph> wyjątku.</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ten element jest jawną implementacją członków.</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Można go używać tylko wtedy, gdy <ph id="ph1">&lt;xref:System.Array&gt;</ph> wystąpienia jest rzutowane na <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> Ma stały rozmiar.</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Clear">
          <source>Removes all items from the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Usuwa wszystkie elementy z <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Clear">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ten element jest jawną implementacją członków.</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Clear">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Można go używać tylko wtedy, gdy <ph id="ph1">&lt;xref:System.Array&gt;</ph> wystąpienia jest rzutowane na <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Clear">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> Jest tylko do odczytu.</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>The object to locate in the current list.</source>
          <target state="translated">Obiekt do zlokalizowania w bieżącej listy.</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>The element to locate can be <ph id="ph1">&lt;see langword="null" /&gt;</ph> for reference types.</source>
          <target state="translated">Element, aby zlokalizować może być <ph id="ph1">&lt;see langword="null" /&gt;</ph> dla typów odwołań.</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>Determines whether an element is in the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Określa, czy element jest <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is found in the <ph id="ph3">&lt;see cref="T:System.Collections.IList" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli <ph id="ph2">&lt;paramref name="value" /&gt;</ph> znajduje się w <ph id="ph3">&lt;see cref="T:System.Collections.IList" /&gt;</ph>; w przeciwnym razie <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ten element jest jawną implementacją członków.</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Można go używać tylko wtedy, gdy <ph id="ph1">&lt;xref:System.Array&gt;</ph> wystąpienia jest rzutowane na <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>The object to locate in the current list.</source>
          <target state="translated">Obiekt do zlokalizowania w bieżącej listy.</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>Determines the index of a specific item in the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Określa indeks konkretny element w <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>The index of value if found in the list; otherwise, -1.</source>
          <target state="translated">Indeks wartości Jeśli znaleziona na liście; w przeciwnym razie wartość -1.</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ten element jest jawną implementacją członków.</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Można go używać tylko wtedy, gdy <ph id="ph1">&lt;xref:System.Array&gt;</ph> wystąpienia jest rzutowane na <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The index at which <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> should be inserted.</source>
          <target state="translated">Indeks, w którym <bpt id="p1">&lt;c&gt;</bpt>wartość<ept id="p1">&lt;/c&gt;</ept> powinien zostać wstawiony.</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The object to insert.</source>
          <target state="translated">Obiekt do wstawienia.</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>Inserts an item to the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> at the specified index.</source>
          <target state="translated">Wstawia element do <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> pod określonym indeksem.</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ten element jest jawną implementacją członków.</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Można go używać tylko wtedy, gdy <ph id="ph1">&lt;xref:System.Array&gt;</ph> wystąpienia jest rzutowane na <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is not a valid index in the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> nie jest prawidłowym indeksem w <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> Jest tylko do odczytu.</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> Ma stały rozmiar.</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is null reference in the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> to odwołanie o wartości null w <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>The index of the element to get or set.</source>
          <target state="translated">Indeks elementu do pobrania lub ustawienia.</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>Gets or sets the element at the specified index.</source>
          <target state="translated">Pobieranie lub konfigurowanie elementów pod określonym indeksem.</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>The element at the specified index.</source>
          <target state="translated">Element pod określonym indeksem.</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ten element jest jawną implementacją członków.</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Można go używać tylko wtedy, gdy <ph id="ph1">&lt;xref:System.Array&gt;</ph> wystąpienia jest rzutowane na <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> jest mniejsza od zera.</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Collections.ICollection.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> jest równa lub większa niż <ph id="ph2">&lt;see cref="P:System.Collections.ICollection.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">Bieżące <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> nie ma dokładnie jednego wymiaru.</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>The object to remove from the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Obiekt do usunięcia z <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>Removes the first occurrence of a specific object from the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Usuwa pierwsze wystąpienie określonego obiektu z <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ten element jest jawną implementacją członków.</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Można go używać tylko wtedy, gdy <ph id="ph1">&lt;xref:System.Array&gt;</ph> wystąpienia jest rzutowane na <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> Jest tylko do odczytu.</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> Ma stały rozmiar.</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>The index of the element to remove.</source>
          <target state="translated">Indeks elementu do usunięcia.</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>Removes the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> item at the specified index.</source>
          <target state="translated">Usuwa <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> element pod określonym indeksem.</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ten element jest jawną implementacją członków.</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Można go używać tylko wtedy, gdy <ph id="ph1">&lt;xref:System.Array&gt;</ph> wystąpienia jest rzutowane na <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>index is not a valid index in the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Indeks nie jest prawidłowym indeksem w <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> Jest tylko do odczytu.</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> Ma stały rozmiar.</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>The object to compare with the current instance.</source>
          <target state="translated">Obiekt do porównania z bieżącym wystąpieniem.</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>An object that compares the current object and <bpt id="p1">&lt;c&gt;</bpt>other<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Obiekt, który porównuje bieżący obiekt i <bpt id="p1">&lt;c&gt;</bpt>innych<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>Determines whether the current collection object precedes, occurs in the same position as, or follows another object in the sort order.</source>
          <target state="translated">Określa, czy bieżący obiekt kolekcji poprzedza, odbywa się w tym samym miejscu czy następuje z innym obiektem w kolejności sortowania.</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>An integer that indicates the relationship of the current collection object to other, as shown in the following table.</source>
          <target state="translated">Liczba całkowita, która wskazuje relację bieżącego obiektu kolekcji do innych, jak pokazano w poniższej tabeli.</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Return value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Wartość zwracana</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Description</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Opis elementu</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance precedes <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Bieżące wystąpienie poprzedza <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance and <ph id="ph3">&lt;paramref name="other" /&gt;</ph> are equal.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Bieżące wystąpienie i <ph id="ph3">&lt;paramref name="other" /&gt;</ph> są takie same.</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance follows <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Zgodny z bieżącym wystąpieniem <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ten element jest jawną implementacją członków.</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IStructuralComparable&gt;</ph> interface.</source>
          <target state="translated">Można go używać tylko wtedy, gdy <ph id="ph1">&lt;xref:System.Array&gt;</ph> wystąpienia jest rzutowane na <ph id="ph2">&lt;xref:System.Collections.IStructuralComparable&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>The object to compare with the current instance.</source>
          <target state="translated">Obiekt do porównania z bieżącym wystąpieniem.</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>An object that determines whether the current instance and <bpt id="p1">&lt;c&gt;</bpt>other<ept id="p1">&lt;/c&gt;</ept> are equal.</source>
          <target state="translated">Obiekt, który określa, czy bieżące wystąpienie i <bpt id="p1">&lt;c&gt;</bpt>innych<ept id="p1">&lt;/c&gt;</ept> są takie same.</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>Determines whether an object is equal to the current instance.</source>
          <target state="translated">Określa, czy obiekt jest taki sam, jak bieżące wystąpienie.</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the two objects are equal; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli dwa obiekty są równe; w przeciwnym razie <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ten element jest jawną implementacją członków.</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph> interface.</source>
          <target state="translated">Można go używać tylko wtedy, gdy <ph id="ph1">&lt;xref:System.Array&gt;</ph> wystąpienia jest rzutowane na <ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>An object that computes the hash code of the current object.</source>
          <target state="translated">Obiekt, który oblicza wartość skrótu bieżącego obiektu.</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>Returns a hash code for the current instance.</source>
          <target state="translated">Zwraca wartość skrótu dla bieżącego wystąpienia.</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>The hash code for the current instance.</source>
          <target state="translated">Wartość skrótu dla bieżącego wystąpienia.</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Ten element jest jawną implementacją członków.</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph> interface.</source>
          <target state="translated">Można go używać tylko wtedy, gdy <ph id="ph1">&lt;xref:System.Array&gt;</ph> wystąpienia jest rzutowane na <ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Typ elementów tablicy.</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to check against the conditions.</source>
          <target state="translated">Jednowymiarowa, liczony od zera <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> sprawdzania zgodności z warunkami.</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The predicate that defines the conditions to check against the elements.</source>
          <target state="translated">Predykat definiujący warunki sprawdzania zgodności elementy.</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>Determines whether every element in the array matches the conditions defined by the specified predicate.</source>
          <target state="translated">Określa, czy każdy element tablicy pasuje do warunków zdefiniowanych przez określony predykat.</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if every element in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> matches the conditions defined by the specified predicate; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli wartość każdego elementu w <ph id="ph2">&lt;paramref name="array" /&gt;</ph> pasuje do warunków zdefiniowanych przez określony predykat; w przeciwnym razie <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>If there are no elements in the array, the return value is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Jeśli w tablicy nie ma elementów, jest zwracana wartość <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns<ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> Jest delegowany do metody, która zwraca<ph id="ph2">`true`</ph> obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, and processing is stopped when the delegate returns <ph id="ph3">`false`</ph> for any element.</source>
          <target state="translated">Elementy <ph id="ph1">`array`</ph> indywidualnie są przekazywane do <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, i przetwarzania jest zatrzymana, gdy zwraca delegata <ph id="ph3">`false`</ph> dla każdego elementu.</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Ta metoda jest O (<ph id="ph1">`n`</ph>) operację, której <ph id="ph2">`n`</ph> jest <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> z <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The following example determines whether the last character of each element in a string array is a number.</source>
          <target state="translated">Poniższy przykład określa, czy ostatni znak każdego elementu w tablicy ciągów jest liczbą.</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>It creates two string arrays.</source>
          <target state="translated">Tworzy dwie tablice ciągu.</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The first arrayincludes both strings that end with alphabetic characters and strings that end with numeric characters.The second array consists only of strings that end with numeric characters.</source>
          <target state="translated">Pierwszy arrayincludes ciągi, które kończą się alfabetu i ciągi, które kończą się cyfr. Druga tablica zawiera tylko ciągi, które kończyć się znakami liczbowych.</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The example also defines an <ph id="ph1">`EndWithANumber`</ph> method whose signature matches the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
          <target state="translated">Definiuje również przykładzie <ph id="ph1">`EndWithANumber`</ph> metody, których Podpis pasuje do <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegowanie.</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The example passes each array to the <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> method along with a delegate that represents the <ph id="ph2">`EndsWithANumber`</ph> method.</source>
          <target state="translated">Przykład przekazuje każdej macierzy do <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> metody wraz z delegata, który reprezentuje <ph id="ph2">`EndsWithANumber`</ph> metody.</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The following example is similar to the first, except that it passes the string array to the <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> method along with  a lambda expression that determines whether a particular array element ends with the string representation of a number.</source>
          <target state="translated">Poniższy przykład jest podobny do pierwszej, z wyjątkiem przekazaniem do tablicy ciągów <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> metody wraz z wyrażenia lambda, określająca, czy element określonej tablicy kończy się liczbą reprezentację ciągu.</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>In both cases, the <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> method returns <ph id="ph2">`false`</ph> as soon as it encounters the first array element that does not end in a number.</source>
          <target state="translated">W obu przypadkach <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> metoda zwraca <ph id="ph2">`false`</ph> zaraz po napotkaniu pierwszy element tablicy, która nie kończy się liczbą.</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>Otherwise, it returns <ph id="ph1">`true`</ph> after iterating all the elements in the array.</source>
          <target state="translated">W przeciwnym razie zwraca <ph id="ph1">`true`</ph> po Iterowanie wszystkich elementów w tablicy.</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>As both examples show, in C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">Zgodnie z obu przykładach w C# i Visual Basic nie jest konieczne tworzenie <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegować (<ph id="ph2">`Predicate(Of String)`</ph> w języku Visual Basic) jawnie.</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>